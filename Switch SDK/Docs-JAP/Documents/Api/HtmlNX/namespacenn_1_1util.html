<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>NintendoSDK API Reference: nn::util 名前空間</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>総合概要</span></a></li>
      <li><a href="pages.html"><span>諸情報</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li class="current"><a href="namespaces.html"><span>名前空間</span></a></li>
      <li><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>名前空間一覧</span></a></li>
      <li><a href="namespacemembers.html"><span>名前空間メンバ</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1util.html">util</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">名前空間</a> &#124;
<a href="#nested-classes">クラス</a> &#124;
<a href="#typedef-members">型定義</a> &#124;
<a href="#enum-members">列挙型</a> &#124;
<a href="#func-members">関数</a> &#124;
<a href="#var-members">変数</a>  </div>
  <div class="headertitle">
<div class="title">nn::util 名前空間</div>  </div>
</div><!--header-->
<div class="contents">

<p>ユーティリティライブラリの名前空間です。  
<a href="#details">[詳解]</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
名前空間</h2></td></tr>
<tr class="memitem:namespacenn_1_1util_1_1general"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1general.html">general</a></td></tr>
<tr class="memdesc:namespacenn_1_1util_1_1general"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトル・行列計算の汎用的な実装を提供します。 アプリケーションは、この名前空間にある API を直接利用してはいけません。 アプリケーションは、nn::util 直下の API を利用してください。 <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenn_1_1util_1_1neon"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util_1_1neon.html">neon</a></td></tr>
<tr class="memdesc:namespacenn_1_1util_1_1neon"><td class="mdescLeft">&#160;</td><td class="mdescRight">ARM NEON を用いたベクトル・行列計算の実装を提供します。 アプリケーションは、この名前空間にある API を直接利用してはいけません。 アプリケーションは、nn::util 直下の API を利用してください。 <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
クラス</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_accessor_base.html">AccessorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">アクセサの基底クラスです。  <a href="classnn_1_1util_1_1_accessor_base.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1basic__string__view.html">basic_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字列参照です。  <a href="classnn_1_1util_1_1basic__string__view.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_binary_block_header.html">BinaryBlockHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">読み取り専用の機能です。構築しないでください。<br />
 バイナリブロックのヘッダです。  <a href="structnn_1_1util_1_1_binary_block_header.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_binary_file_header.html">BinaryFileHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">読み取り専用の機能です。構築しないでください。<br />
 バイナリリソースファイルのヘッダです。  <a href="structnn_1_1util_1_1_binary_file_header.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_bin_block_signature.html">BinBlockSignature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">読み取り専用の機能です。構築しないでください。<br />
 バイナリブロックヘッダのシリアライズ用シグネチャです。  <a href="structnn_1_1util_1_1_bin_block_signature.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_bin_file_signature.html">BinFileSignature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">読み取り専用の機能です。構築しないでください。<br />
 バイナリファイルヘッダのシリアライズ用シグネチャです。  <a href="structnn_1_1util_1_1_bin_file_signature.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_bin_t_ptr.html">BinTPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">読み取り専用の機能です。構築しないでください。<br />
 バイナリリソースのシリアライズ用ポインタです。  <a href="structnn_1_1util_1_1_bin_t_ptr.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_bin_t_string.html">BinTString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">読み取り専用の機能です。構築しないでください。<br />
 バイナリリソースのシリアライズ用文字列です。  <a href="structnn_1_1util_1_1_bin_t_string.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_bin_version.html">BinVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">読み取り専用の機能です。構築しないでください。<br />
 バイナリファイルヘッダのシリアライズ用バージョンです。  <a href="structnn_1_1util_1_1_bin_version.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_bit_array.html">BitArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">固定長ビット配列  <a href="classnn_1_1util_1_1_bit_array.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">BitFlagSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">POD のビットフラグ集合を扱う型です。  <a href="structnn_1_1util_1_1_bit_flag_set.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_bit_pack.html">BitPack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ビットフィールド代替型です。  <a href="structnn_1_1util_1_1_bit_pack.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_byte_ptr.html">BytePtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">バイト単位アクセス用ポインタです。<br />
 void* にバイト単位の移動機能を追加してポインタを模しています。  <a href="classnn_1_1util_1_1_byte_ptr.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_color4f.html">Color4f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD 4 要素各 32 ビットの浮動小数点数で表現されるカラーをサポートするクラスです。  <a href="classnn_1_1util_1_1_color4f.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_color4u8.html">Color4u8</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">4 要素各 8 ビットの符号なし整数で表現されるカラーをサポートするクラスです。  <a href="classnn_1_1util_1_1_color4u8.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_const_byte_ptr.html">ConstBytePtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">不変なバイト単位アクセス用ポインタです。<br />
 const void* にバイト単位の移動機能を追加してポインタを模しています。  <a href="classnn_1_1util_1_1_const_byte_ptr.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_float2.html">Float2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型の配列によって 2 次元ベクトルを表現します。  <a href="structnn_1_1util_1_1_float2.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_float3.html">Float3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型の配列によって 3 次元ベクトルを表現します。  <a href="structnn_1_1util_1_1_float3.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_float4.html">Float4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型の配列によって 4 次元ベクトルを表現します。  <a href="structnn_1_1util_1_1_float4.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_float_column_major3x2.html">FloatColumnMajor3x2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型の配列によって 3 行 2 列の行列を列優先で表現します。  <a href="structnn_1_1util_1_1_float_column_major3x2.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_float_column_major4x3.html">FloatColumnMajor4x3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型の配列によって 4 行 3 列の行列を列優先で表現します。  <a href="structnn_1_1util_1_1_float_column_major4x3.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_float_column_major4x4.html">FloatColumnMajor4x4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型の配列によって 4 行 4 列の行列を列優先で表現します。  <a href="structnn_1_1util_1_1_float_column_major4x4.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_float_format.html">FloatFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">浮動小数点数フォーマット  <a href="classnn_1_1util_1_1_float_format.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_float_row_major3x2.html">FloatRowMajor3x2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型の配列によって 3 行 2 列の行列を行優先で表現します。  <a href="structnn_1_1util_1_1_float_row_major3x2.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_float_row_major4x3.html">FloatRowMajor4x3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型の配列によって 4 行 3 列の行列を行優先で表現します。  <a href="structnn_1_1util_1_1_float_row_major4x3.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_float_row_major4x4.html">FloatRowMajor4x4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型の配列によって 4 行 4 列の行列を行優先で表現します。  <a href="structnn_1_1util_1_1_float_row_major4x4.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_dic.html">IntrusiveDic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">侵入型辞書です。  <a href="classnn_1_1util_1_1_intrusive_dic.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_dic_base_node.html">IntrusiveDicBaseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">侵入型辞書のノードです。ノードを基底クラスとして定義するスタイルです。  <a href="classnn_1_1util_1_1_intrusive_dic_base_node.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_dic_base_node_traits.html">IntrusiveDicBaseNodeTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">侵入型辞書のノードへのアクセス方法を定義するクラスです。 ノードを基底クラスとして定義した場合に使用します。  <a href="classnn_1_1util_1_1_intrusive_dic_base_node_traits.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_dic_member_node_traits.html">IntrusiveDicMemberNodeTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">侵入型辞書のノードへのアクセス方法を定義するクラスです。 ノードをメンバとして定義した場合に使用します。  <a href="classnn_1_1util_1_1_intrusive_dic_member_node_traits.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_dic_node.html">IntrusiveDicNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">侵入型辞書のノードです。  <a href="classnn_1_1util_1_1_intrusive_dic_node.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_list.html">IntrusiveList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">侵入型リストです。 要求があるまでは暫定的にTにconstが含まれないこと前提の仕様としています。  <a href="classnn_1_1util_1_1_intrusive_list.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_list_base_node.html">IntrusiveListBaseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">侵入型リストのノードです。ノードを基底クラスとして定義するスタイルです。  <a href="classnn_1_1util_1_1_intrusive_list_base_node.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_list_base_node_traits.html">IntrusiveListBaseNodeTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">侵入型リストのノードへのアクセス方法を定義するクラスです。 ノードを基底クラスとして定義した場合に使用します。  <a href="classnn_1_1util_1_1_intrusive_list_base_node_traits.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_list_member_node_traits.html">IntrusiveListMemberNodeTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">侵入型リストのノードへのアクセス方法を定義するクラスです。 ノードをメンバとして定義した場合に使用します。  <a href="classnn_1_1util_1_1_intrusive_list_member_node_traits.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_intrusive_list_node.html">IntrusiveListNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">侵入型リストのノードです。  <a href="classnn_1_1util_1_1_intrusive_list_node.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_matrix_column_major3x2f_type.html">MatrixColumnMajor3x2fType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 3 行 2 列の行列を列優先で表現します。 <a class="el" href="structnn_1_1util_1_1_matrix_row_major3x2f_type.html" title="単精度浮動小数点型による 3 行 2 列の行列を行優先で表現します。 nn::util::MatrixColumnMajor3x2fType に...">nn::util::MatrixRowMajor3x2fType</a> に対し、行と列の優先度が逆転されたメモリレイアウトを持ちます。  <a href="structnn_1_1util_1_1_matrix_column_major3x2f_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_matrix_column_major4x3f_type.html">MatrixColumnMajor4x3fType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 4 行 3 列の行列を列優先で表現します。 <a class="el" href="structnn_1_1util_1_1_matrix_row_major4x3f_type.html" title="単精度浮動小数点型による 4 行 3 列の行列を行優先で表現します。 nn::util::MatrixColumnMajor4x3fType に...">nn::util::MatrixRowMajor4x3fType</a> に対し、行と列の優先度が逆転されたメモリレイアウトを持ちます。  <a href="structnn_1_1util_1_1_matrix_column_major4x3f_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_matrix_column_major4x4f_type.html">MatrixColumnMajor4x4fType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 4 行 4 列の行列を列優先で表現します。 <a class="el" href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html" title="単精度浮動小数点型による 4 行 4 列の行列を行優先で表現します。 nn::util::MatrixColumnMajor4x4fType に...">nn::util::MatrixRowMajor4x4fType</a> に対し、行と列の優先度が逆転されたメモリレイアウトを持ちます。  <a href="structnn_1_1util_1_1_matrix_column_major4x4f_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_matrix_row_major3x2f.html">MatrixRowMajor3x2f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 3 行 2 列の行列を行優先で表現するクラスです。  <a href="classnn_1_1util_1_1_matrix_row_major3x2f.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_matrix_row_major3x2f_type.html">MatrixRowMajor3x2fType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 3 行 2 列の行列を行優先で表現します。 <a class="el" href="structnn_1_1util_1_1_matrix_column_major3x2f_type.html" title="単精度浮動小数点型による 3 行 2 列の行列を列優先で表現します。 nn::util::MatrixRowMajor3x2fType に対...">nn::util::MatrixColumnMajor3x2fType</a> に対し、行と列の優先度が逆転されたメモリレイアウトを持ちます。  <a href="structnn_1_1util_1_1_matrix_row_major3x2f_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_matrix_row_major4x3f.html">MatrixRowMajor4x3f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 4 行 3 列の行列を行優先で表現するクラスです。  <a href="classnn_1_1util_1_1_matrix_row_major4x3f.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_matrix_row_major4x3f_type.html">MatrixRowMajor4x3fType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 4 行 3 列の行列を行優先で表現します。 <a class="el" href="structnn_1_1util_1_1_matrix_column_major4x3f_type.html" title="単精度浮動小数点型による 4 行 3 列の行列を列優先で表現します。 nn::util::MatrixRowMajor4x3fType に対...">nn::util::MatrixColumnMajor4x3fType</a> に対し、行と列の優先度が逆転されたメモリレイアウトを持ちます。  <a href="structnn_1_1util_1_1_matrix_row_major4x3f_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_matrix_row_major4x4f.html">MatrixRowMajor4x4f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 4 行 4 列の行列を行優先で表現するクラスです。  <a href="classnn_1_1util_1_1_matrix_row_major4x4f.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html">MatrixRowMajor4x4fType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 4 行 4 列の行列を行優先で表現します。 <a class="el" href="structnn_1_1util_1_1_matrix_column_major4x4f_type.html" title="単精度浮動小数点型による 4 行 4 列の行列を列優先で表現します。 nn::util::MatrixRowMajor4x4fType に対...">nn::util::MatrixColumnMajor4x4fType</a> に対し、行と列の優先度が逆転されたメモリレイアウトを持ちます。  <a href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_memory_splitter.html">MemorySplitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ分配計算  <a href="classnn_1_1util_1_1_memory_splitter.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_placement_array.html">PlacementArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">固定長配列です。  <a href="classnn_1_1util_1_1_placement_array.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_ptr_placement_array.html">PtrPlacementArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">固定長ポインタ配列です。  <a href="classnn_1_1util_1_1_ptr_placement_array.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_quaternion.html">Quaternion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型によるクォータニオンを表現するクラスです。  <a href="classnn_1_1util_1_1_quaternion.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_relocation_table.html">RelocationTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">読み取り専用の機能です。構築しないでください。<br />
 リロケーションテーブルです。  <a href="structnn_1_1util_1_1_relocation_table.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_res_dic.html">ResDic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">読み取り専用の機能です。構築しないでください。<br />
 辞書構造体のアクセサクラスです。  <a href="classnn_1_1util_1_1_res_dic.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_res_dic_data.html">ResDicData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">読み取り専用の機能です。構築しないでください。<br />
 辞書構造体です。  <a href="structnn_1_1util_1_1_res_dic_data.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_res_endian.html">ResEndian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">読み取り専用の機能です。構築しないでください。<br />
 リソースクラスのエンディアン反転用ユーティリティです。  <a href="classnn_1_1util_1_1_res_endian.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html">StreamingDecompressZlibContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">zlib 形式の圧縮データのストリーミング伸長用コンテキストです。  <a href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_string_pool.html">StringPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">読み取り専用の機能です。構築しないでください。<br />
 文字列のプールです。  <a href="structnn_1_1util_1_1_string_pool.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_tiny_mt.html">TinyMt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TinyMT による乱数生成クラスです。  <a href="classnn_1_1util_1_1_tiny_mt.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_typed_storage.html">TypedStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">型の定義を隠したまま配置する領域を確保するための構造体です。  <a href="structnn_1_1util_1_1_typed_storage.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_uint8x4.html">Uint8x4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">8バイト符号なし整数型による 4 要素 1 次元配列を持つ構造体です。  <a href="structnn_1_1util_1_1_uint8x4.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_unorm8x4.html">Unorm8x4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">正規化された、8バイト符号なし整数型による 4 要素 1 次元配列を持つ構造体です。  <a href="structnn_1_1util_1_1_unorm8x4.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_uuid.html">Uuid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RFC 4122 に規定された Universally Unique Identifier (UUID) を表します。  <a href="structnn_1_1util_1_1_uuid.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_vector2f.html">Vector2f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 2 次元ベクトルを表現するクラスです。  <a href="classnn_1_1util_1_1_vector2f.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_vector2f_type.html">Vector2fType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 2 次元ベクトルを表現します。  <a href="structnn_1_1util_1_1_vector2f_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_vector3f.html">Vector3f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 3 次元ベクトルを表現するクラスです。  <a href="classnn_1_1util_1_1_vector3f.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_vector3f_type.html">Vector3fType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 3 次元ベクトルを表現します。  <a href="structnn_1_1util_1_1_vector3f_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1util_1_1_vector4f.html">Vector4f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 3 次元ベクトルを表現するクラスです。  <a href="classnn_1_1util_1_1_vector4f.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1util_1_1_vector4f_type.html">Vector4fType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 4 次元ベクトルを表現します。また、クォータニオンを表現する場合にも用いられます。  <a href="structnn_1_1util_1_1_vector4f_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
型定義</h2></td></tr>
<tr class="memitem:a9a123aed03be22d1567aeb27d70c1a56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a123aed03be22d1567aeb27d70c1a56"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a></td></tr>
<tr class="memdesc:a9a123aed03be22d1567aeb27d70c1a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 円周を 0x100000000 とするインデックスによって角度を表現します。 <br /></td></tr>
<tr class="separator:a9a123aed03be22d1567aeb27d70c1a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2311530adea3fb605362c03b3be5482a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2311530adea3fb605362c03b3be5482a"></a>
typedef <a class="el" href="structnn_1_1util_1_1_bin_t_ptr.html">BinTPtr</a>&lt; <a class="el" href="namespacenn_1_1util.html#a720977b9949f595d5e3e3a36e4afd0a1">BinString</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a2311530adea3fb605362c03b3be5482a">BinPtrToString</a></td></tr>
<tr class="memdesc:a2311530adea3fb605362c03b3be5482a"><td class="mdescLeft">&#160;</td><td class="mdescRight">BinString 型を扱う <a class="el" href="structnn_1_1util_1_1_bin_t_ptr.html" title="読み取り専用の機能です。構築しないでください。  バイナリリソースのシリアライズ用ポインタです。 ...">BinTPtr</a> です。 <br /></td></tr>
<tr class="separator:a2311530adea3fb605362c03b3be5482a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720977b9949f595d5e3e3a36e4afd0a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a720977b9949f595d5e3e3a36e4afd0a1"></a>
typedef <a class="el" href="structnn_1_1util_1_1_bin_t_string.html">BinTString</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a720977b9949f595d5e3e3a36e4afd0a1">BinString</a></td></tr>
<tr class="memdesc:a720977b9949f595d5e3e3a36e4afd0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字の型が char である <a class="el" href="structnn_1_1util_1_1_bin_t_string.html" title="読み取り専用の機能です。構築しないでください。  バイナリリソースのシリアライズ用文字列です。 ...">BinTString</a> です。 <br /></td></tr>
<tr class="separator:a720977b9949f595d5e3e3a36e4afd0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49be54197d424ea300b187b942ed824"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac49be54197d424ea300b187b942ed824"></a>
typedef <a class="el" href="structnn_1_1util_1_1_vector4f_type.html">Vector4fType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ac49be54197d424ea300b187b942ed824">Color4fType</a></td></tr>
<tr class="memdesc:ac49be54197d424ea300b187b942ed824"><td class="mdescLeft">&#160;</td><td class="mdescRight">4 要素各 32 ビットの浮動小数点数によってカラーを表現します。 <br /></td></tr>
<tr class="separator:ac49be54197d424ea300b187b942ed824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79dfd3486048d906ab2ef68bf8f9f3be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79dfd3486048d906ab2ef68bf8f9f3be"></a>
typedef <a class="el" href="structnn_1_1util_1_1_unorm8x4.html">Unorm8x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a79dfd3486048d906ab2ef68bf8f9f3be">Color4u8Type</a></td></tr>
<tr class="memdesc:a79dfd3486048d906ab2ef68bf8f9f3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">4 要素各 8 ビットの符号なし整数によってカラーを表現します。 <br /></td></tr>
<tr class="separator:a79dfd3486048d906ab2ef68bf8f9f3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a7e9c8b1f290aac20d7c882f20ab7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0a7e9c8b1f290aac20d7c882f20ab7c"></a>
typedef <a class="el" href="structnn_1_1util_1_1_float_row_major3x2.html">FloatRowMajor3x2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ab0a7e9c8b1f290aac20d7c882f20ab7c">Float3x2</a></td></tr>
<tr class="memdesc:ab0a7e9c8b1f290aac20d7c882f20ab7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型の配列によって 3 行 2 列の行列を表現します。 <br /></td></tr>
<tr class="separator:ab0a7e9c8b1f290aac20d7c882f20ab7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f45cae1843465e71962a4f18f5fdb74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f45cae1843465e71962a4f18f5fdb74"></a>
typedef <a class="el" href="structnn_1_1util_1_1_float_row_major4x3.html">FloatRowMajor4x3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a1f45cae1843465e71962a4f18f5fdb74">Float4x3</a></td></tr>
<tr class="memdesc:a1f45cae1843465e71962a4f18f5fdb74"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型の配列によって 4 行 3 列の行列を表現します。 <br /></td></tr>
<tr class="separator:a1f45cae1843465e71962a4f18f5fdb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb49f9abd5e4a507364789a6636faca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3eb49f9abd5e4a507364789a6636faca"></a>
typedef <a class="el" href="structnn_1_1util_1_1_float_row_major4x4.html">FloatRowMajor4x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a3eb49f9abd5e4a507364789a6636faca">Float4x4</a></td></tr>
<tr class="memdesc:a3eb49f9abd5e4a507364789a6636faca"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型の配列によって 4 行 4 列の行列を表現します。 <br /></td></tr>
<tr class="separator:a3eb49f9abd5e4a507364789a6636faca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02a592887cf8bd6dca55fe851f6f729"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa02a592887cf8bd6dca55fe851f6f729"></a>
typedef <a class="el" href="classnn_1_1util_1_1_float_format.html">FloatFormat</a>&lt; 1, 5, 10 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aa02a592887cf8bd6dca55fe851f6f729">FloatFormat16</a></td></tr>
<tr class="memdesc:aa02a592887cf8bd6dca55fe851f6f729"><td class="mdescLeft">&#160;</td><td class="mdescRight">16 ビット浮動小数点数を扱う浮動小数点数フォーマットの型定義です。 <br /></td></tr>
<tr class="separator:aa02a592887cf8bd6dca55fe851f6f729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ee0c4d69245441c0ee8a498925e70c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9ee0c4d69245441c0ee8a498925e70c"></a>
typedef <a class="el" href="classnn_1_1util_1_1_float_format.html">FloatFormat</a>&lt; 1, 8, 23 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aa9ee0c4d69245441c0ee8a498925e70c">FloatFormat32</a></td></tr>
<tr class="memdesc:aa9ee0c4d69245441c0ee8a498925e70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">32 ビット浮動小数点数を扱う浮動小数点数フォーマットの型定義です。 <br /></td></tr>
<tr class="separator:aa9ee0c4d69245441c0ee8a498925e70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30d0e9a77dc1b72739d270a2a4cb10b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac30d0e9a77dc1b72739d270a2a4cb10b"></a>
typedef <a class="el" href="structnn_1_1util_1_1_float_column_major3x2.html">FloatColumnMajor3x2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ac30d0e9a77dc1b72739d270a2a4cb10b">FloatT3x2</a></td></tr>
<tr class="memdesc:ac30d0e9a77dc1b72739d270a2a4cb10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型の配列によって 3 行 2 列の行列を表現します。 <a class="el" href="namespacenn_1_1util.html#ab0a7e9c8b1f290aac20d7c882f20ab7c" title="単精度浮動小数点型の配列によって 3 行 2 列の行列を表現します。 ">nn::util::Float3x2</a> に対し、行と列の優先度が逆転されたメモリレイアウトを持ちます。 <br /></td></tr>
<tr class="separator:ac30d0e9a77dc1b72739d270a2a4cb10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec387faf9cc69e9382a2a8002821f24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaec387faf9cc69e9382a2a8002821f24"></a>
typedef <a class="el" href="structnn_1_1util_1_1_float_column_major4x3.html">FloatColumnMajor4x3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aaec387faf9cc69e9382a2a8002821f24">FloatT4x3</a></td></tr>
<tr class="memdesc:aaec387faf9cc69e9382a2a8002821f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型の配列によって 4 行 3 列の行列を表現します。 <a class="el" href="namespacenn_1_1util.html#a1f45cae1843465e71962a4f18f5fdb74" title="単精度浮動小数点型の配列によって 4 行 3 列の行列を表現します。 ">nn::util::Float4x3</a> に対し、行と列の優先度が逆転されたメモリレイアウトを持ちます。 <br /></td></tr>
<tr class="separator:aaec387faf9cc69e9382a2a8002821f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11491fc1d12c8b6f393d794dc9737b46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11491fc1d12c8b6f393d794dc9737b46"></a>
typedef <a class="el" href="structnn_1_1util_1_1_float_column_major4x4.html">FloatColumnMajor4x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a11491fc1d12c8b6f393d794dc9737b46">FloatT4x4</a></td></tr>
<tr class="memdesc:a11491fc1d12c8b6f393d794dc9737b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型の配列によって 4 行 3 列の行列を表現します。 <a class="el" href="namespacenn_1_1util.html#a3eb49f9abd5e4a507364789a6636faca" title="単精度浮動小数点型の配列によって 4 行 4 列の行列を表現します。 ">nn::util::Float4x4</a> に対し、行と列の優先度が逆転されたメモリレイアウトを持ちます。 <br /></td></tr>
<tr class="separator:a11491fc1d12c8b6f393d794dc9737b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f1145aad43f345157c51d999aff9fb"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a52f1145aad43f345157c51d999aff9fb">FormatStringOutputFunction</a>) (uintptr_t arg, const char *pCharacters, int count)</td></tr>
<tr class="memdesc:a52f1145aad43f345157c51d999aff9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacenn_1_1util.html#a54f65dcb71d5cb6e32f327ccab7f796c">FormatString()</a>, <a class="el" href="namespacenn_1_1util.html#a1054c37da4a1d20fe6b0ca90a8ca351c">VFormatString()</a> が生成した文字列を受け取るコールバック関数の型です。  <a href="#a52f1145aad43f345157c51d999aff9fb">[詳解]</a><br /></td></tr>
<tr class="separator:a52f1145aad43f345157c51d999aff9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad703d4cc91629b6b26764a5d1506efd8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classnn_1_1util_1_1_matrix_row_major3x2f.html">MatrixRowMajor3x2f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ad703d4cc91629b6b26764a5d1506efd8">Matrix3x2f</a></td></tr>
<tr class="memdesc:ad703d4cc91629b6b26764a5d1506efd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 3 行 2 列の行列を行優先で表現するクラスです。  <a href="#ad703d4cc91629b6b26764a5d1506efd8">[詳解]</a><br /></td></tr>
<tr class="separator:ad703d4cc91629b6b26764a5d1506efd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57660aa7758ae3375aeffbd6b1424b24"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1util_1_1_matrix_row_major3x2f_type.html">MatrixRowMajor3x2fType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a57660aa7758ae3375aeffbd6b1424b24">Matrix3x2fType</a></td></tr>
<tr class="memdesc:a57660aa7758ae3375aeffbd6b1424b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 3 行 2 列の行列を表現します。  <a href="#a57660aa7758ae3375aeffbd6b1424b24">[詳解]</a><br /></td></tr>
<tr class="separator:a57660aa7758ae3375aeffbd6b1424b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144c36edc0c1d0762f88b59f0a754b6a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classnn_1_1util_1_1_matrix_row_major4x3f.html">MatrixRowMajor4x3f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a144c36edc0c1d0762f88b59f0a754b6a">Matrix4x3f</a></td></tr>
<tr class="memdesc:a144c36edc0c1d0762f88b59f0a754b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 4 行 3 列の行列を行優先で表現するクラスです。  <a href="#a144c36edc0c1d0762f88b59f0a754b6a">[詳解]</a><br /></td></tr>
<tr class="separator:a144c36edc0c1d0762f88b59f0a754b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb360b0e9579454c6af5804cc476c101"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1util_1_1_matrix_row_major4x3f_type.html">MatrixRowMajor4x3fType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#afb360b0e9579454c6af5804cc476c101">Matrix4x3fType</a></td></tr>
<tr class="memdesc:afb360b0e9579454c6af5804cc476c101"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 4 行 3 列の行列を表現します。  <a href="#afb360b0e9579454c6af5804cc476c101">[詳解]</a><br /></td></tr>
<tr class="separator:afb360b0e9579454c6af5804cc476c101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3916074464578212a8a939a4dbd08ae"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classnn_1_1util_1_1_matrix_row_major4x4f.html">MatrixRowMajor4x4f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ad3916074464578212a8a939a4dbd08ae">Matrix4x4f</a></td></tr>
<tr class="memdesc:ad3916074464578212a8a939a4dbd08ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 4 行 4 列の行列を行優先で表現するクラスです。  <a href="#ad3916074464578212a8a939a4dbd08ae">[詳解]</a><br /></td></tr>
<tr class="separator:ad3916074464578212a8a939a4dbd08ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb0d5db7601e1af28a6f5b90cd5fd16"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html">MatrixRowMajor4x4fType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a1bb0d5db7601e1af28a6f5b90cd5fd16">Matrix4x4fType</a></td></tr>
<tr class="memdesc:a1bb0d5db7601e1af28a6f5b90cd5fd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 4 行 4 列の行列を表現します。  <a href="#a1bb0d5db7601e1af28a6f5b90cd5fd16">[詳解]</a><br /></td></tr>
<tr class="separator:a1bb0d5db7601e1af28a6f5b90cd5fd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0393f5ea2f2d2bc1a17ff98976f4b084"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1util_1_1_matrix_column_major3x2f_type.html">MatrixColumnMajor3x2fType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a0393f5ea2f2d2bc1a17ff98976f4b084">MatrixT3x2fType</a></td></tr>
<tr class="memdesc:a0393f5ea2f2d2bc1a17ff98976f4b084"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 3 行 2 列の行列を表現します。 <a class="el" href="namespacenn_1_1util.html#a57660aa7758ae3375aeffbd6b1424b24" title="単精度浮動小数点型による 3 行 2 列の行列を表現します。 ">nn::util::Matrix3x2fType</a> に対し、行と列の優先度が逆転されたメモリレイアウトを持ちます。  <a href="#a0393f5ea2f2d2bc1a17ff98976f4b084">[詳解]</a><br /></td></tr>
<tr class="separator:a0393f5ea2f2d2bc1a17ff98976f4b084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae68b9728d824289e709226f88f4326d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1util_1_1_matrix_column_major4x3f_type.html">MatrixColumnMajor4x3fType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aae68b9728d824289e709226f88f4326d">MatrixT4x3fType</a></td></tr>
<tr class="memdesc:aae68b9728d824289e709226f88f4326d"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 4 行 3 列の行列を表現します。 <a class="el" href="namespacenn_1_1util.html#afb360b0e9579454c6af5804cc476c101" title="単精度浮動小数点型による 4 行 3 列の行列を表現します。 ">nn::util::Matrix4x3fType</a> に対し、行と列の優先度が逆転されたメモリレイアウトを持ちます。  <a href="#aae68b9728d824289e709226f88f4326d">[詳解]</a><br /></td></tr>
<tr class="separator:aae68b9728d824289e709226f88f4326d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93b34341c777e6d93d6341520acebc8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1util_1_1_matrix_column_major4x4f_type.html">MatrixColumnMajor4x4fType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aa93b34341c777e6d93d6341520acebc8">MatrixT4x4fType</a></td></tr>
<tr class="memdesc:aa93b34341c777e6d93d6341520acebc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">単精度浮動小数点型による 4 行 4 列の行列を表現します。 <a class="el" href="namespacenn_1_1util.html#a1bb0d5db7601e1af28a6f5b90cd5fd16" title="単精度浮動小数点型による 4 行 4 列の行列を表現します。 ">nn::util::Matrix4x4fType</a> に対し、行と列の優先度が逆転されたメモリレイアウトを持ちます。  <a href="#aa93b34341c777e6d93d6341520acebc8">[詳解]</a><br /></td></tr>
<tr class="separator:aa93b34341c777e6d93d6341520acebc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ed3b5d58dc0275f9c96f4d4ec7a079"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html">StreamingDecompressZlibContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#af2ed3b5d58dc0275f9c96f4d4ec7a079">StreamingDecompressDeflateContext</a></td></tr>
<tr class="memdesc:af2ed3b5d58dc0275f9c96f4d4ec7a079"><td class="mdescLeft">&#160;</td><td class="mdescRight">raw deflate 形式の圧縮データのストリーミング伸長用コンテキストです。  <a href="#af2ed3b5d58dc0275f9c96f4d4ec7a079">[詳解]</a><br /></td></tr>
<tr class="separator:af2ed3b5d58dc0275f9c96f4d4ec7a079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9beb7ac8f35cef8dd13f0416662320a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html">StreamingDecompressZlibContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ae9beb7ac8f35cef8dd13f0416662320a">StreamingDecompressGzipContext</a></td></tr>
<tr class="memdesc:ae9beb7ac8f35cef8dd13f0416662320a"><td class="mdescLeft">&#160;</td><td class="mdescRight">gzip 形式の圧縮データのストリーミング伸長用コンテキストです。  <a href="#ae9beb7ac8f35cef8dd13f0416662320a">[詳解]</a><br /></td></tr>
<tr class="separator:ae9beb7ac8f35cef8dd13f0416662320a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f6a01d93a4172e07b7c0e80a680d42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70f6a01d93a4172e07b7c0e80a680d42"></a>
typedef <a class="el" href="classnn_1_1util_1_1basic__string__view.html">basic_string_view</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a70f6a01d93a4172e07b7c0e80a680d42">string_view</a></td></tr>
<tr class="memdesc:a70f6a01d93a4172e07b7c0e80a680d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字の型が char である文字列参照です。 <br /></td></tr>
<tr class="separator:a70f6a01d93a4172e07b7c0e80a680d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
列挙型</h2></td></tr>
<tr class="memitem:a4a5a5a34319b208c9c23ac038d412a31"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a4a5a5a34319b208c9c23ac038d412a31">ByteOrderMark</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1util.html#a4a5a5a34319b208c9c23ac038d412a31af47a310dc26e97a75adae293e89fd52f">ByteOrderMark_Normal</a> = 0xFEFF, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1util.html#a4a5a5a34319b208c9c23ac038d412a31a59a43d310e2ac1c3f6a852eb5e2f789e">ByteOrderMark_Reverse</a> = 0xFFFE
<br />
 }<tr class="memdesc:a4a5a5a34319b208c9c23ac038d412a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">バイトオーダーマークを示す列挙体です。  <a href="namespacenn_1_1util.html#a4a5a5a34319b208c9c23ac038d412a31">[詳解]</a><br /></td></tr>
<tr class="separator:a4a5a5a34319b208c9c23ac038d412a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a8ab72d7227a9a1b56f78d0caf2920478"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478a7f284c7d118115284232bd26b33c2149">CharacterEncodingResult_Success</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478aba616796fb8ce72bd5f1455c621a47b2">CharacterEncodingResult_InsufficientLength</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478aae294bb0babe7737681d80af74cef4a4">CharacterEncodingResult_InvalidFormat</a>
<br />
 }<tr class="memdesc:a8ab72d7227a9a1b56f78d0caf2920478"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字エンコーディング変換の結果(エラーコード)です。  <a href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">[詳解]</a><br /></td></tr>
<tr class="separator:a8ab72d7227a9a1b56f78d0caf2920478"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
関数</h2></td></tr>
<tr class="memitem:a89fad03d3f71a12026b6dcb2365180bb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a89fad03d3f71a12026b6dcb2365180bb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a89fad03d3f71a12026b6dcb2365180bb">Exchange</a> (T *p, U value)</td></tr>
<tr class="memdesc:a89fad03d3f71a12026b6dcb2365180bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定したポインタが指す変数に対し、指定した値を代入し、古い値を返します。  <a href="#a89fad03d3f71a12026b6dcb2365180bb">[詳解]</a><br /></td></tr>
<tr class="separator:a89fad03d3f71a12026b6dcb2365180bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f65dcb71d5cb6e32f327ccab7f796c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a54f65dcb71d5cb6e32f327ccab7f796c">FormatString</a> (<a class="el" href="namespacenn_1_1util.html#a52f1145aad43f345157c51d999aff9fb">FormatStringOutputFunction</a> pOutputFunction, uintptr_t outputFunctionArg, const char *pFormat,...) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a54f65dcb71d5cb6e32f327ccab7f796c"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字列をフォーマットします。  <a href="#a54f65dcb71d5cb6e32f327ccab7f796c">[詳解]</a><br /></td></tr>
<tr class="separator:a54f65dcb71d5cb6e32f327ccab7f796c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df2ac5ca47857cc945af5421ea54aa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1util_1_1_uuid.html">Uuid</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a7df2ac5ca47857cc945af5421ea54aa5">GenerateUuid</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7df2ac5ca47857cc945af5421ea54aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">RFC 4122に規定されたUniversally Unique Identifier (UUID)を生成します。  <a href="#a7df2ac5ca47857cc945af5421ea54aa5">[詳解]</a><br /></td></tr>
<tr class="separator:a7df2ac5ca47857cc945af5421ea54aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128d9474fb20b3fa7c743c864aeb3f56"><td class="memTemplParams" colspan="2">template&lt;typename Destination , typename Source &gt; </td></tr>
<tr class="memitem:a128d9474fb20b3fa7c743c864aeb3f56"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a128d9474fb20b3fa7c743c864aeb3f56">IsIntValueRepresentable</a> (Source n) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a128d9474fb20b3fa7c743c864aeb3f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数で指定した整数値が、指定した型で表現できるかどうかを取得します。  <a href="#a128d9474fb20b3fa7c743c864aeb3f56">[詳解]</a><br /></td></tr>
<tr class="separator:a128d9474fb20b3fa7c743c864aeb3f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10095886df100ad8cf72878d35bc5977"><td class="memTemplParams" colspan="2">template&lt;int N, typename Tag &gt; </td></tr>
<tr class="memitem:a10095886df100ad8cf72878d35bc5977"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">BitFlagSet</a>&lt; N, Tag &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a10095886df100ad8cf72878d35bc5977">MakeBitFlagSet</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a10095886df100ad8cf72878d35bc5977"><td class="mdescLeft">&#160;</td><td class="mdescRight">全てのビットフラグが false に初期化された <a class="el" href="structnn_1_1util_1_1_bit_flag_set.html" title="POD のビットフラグ集合を扱う型です。 ">BitFlagSet</a> を取得します。  <a href="#a10095886df100ad8cf72878d35bc5977">[詳解]</a><br /></td></tr>
<tr class="separator:a10095886df100ad8cf72878d35bc5977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794d0154e80155ad5f358910b839f343"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a794d0154e80155ad5f358910b839f343"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">BitFlagSet</a>&lt; N, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a794d0154e80155ad5f358910b839f343">MakeBitFlagSet</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a794d0154e80155ad5f358910b839f343"><td class="mdescLeft">&#160;</td><td class="mdescRight">全てのビットフラグが false に初期化された <a class="el" href="structnn_1_1util_1_1_bit_flag_set.html" title="POD のビットフラグ集合を扱う型です。 ">BitFlagSet</a> を取得します。  <a href="#a794d0154e80155ad5f358910b839f343">[詳解]</a><br /></td></tr>
<tr class="separator:a794d0154e80155ad5f358910b839f343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cf8c9c361735e4387e4274f26660fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ad0cf8c9c361735e4387e4274f26660fb">SNPrintf</a> (char *buffer, size_t bufferLength, const char *pFormat,...) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad0cf8c9c361735e4387e4274f26660fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字列をフォーマットします。  <a href="#ad0cf8c9c361735e4387e4274f26660fb">[詳解]</a><br /></td></tr>
<tr class="separator:ad0cf8c9c361735e4387e4274f26660fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1054c37da4a1d20fe6b0ca90a8ca351c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a1054c37da4a1d20fe6b0ca90a8ca351c">VFormatString</a> (<a class="el" href="namespacenn_1_1util.html#a52f1145aad43f345157c51d999aff9fb">FormatStringOutputFunction</a> pOutputFunction, uintptr_t outputFunctionArg, const char *pFormat, std::va_list formatArg) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1054c37da4a1d20fe6b0ca90a8ca351c"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字列をフォーマットします。書式指定文字列に与える引数を std::va_list で受け取る以外は、<a class="el" href="namespacenn_1_1util.html#a54f65dcb71d5cb6e32f327ccab7f796c">FormatString()</a> と同一です。  <a href="#a1054c37da4a1d20fe6b0ca90a8ca351c">[詳解]</a><br /></td></tr>
<tr class="separator:a1054c37da4a1d20fe6b0ca90a8ca351c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb19ebf42335aea1037895832e167857"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#afb19ebf42335aea1037895832e167857">VSNPrintf</a> (char *buffer, size_t bufferLength, const char *pFormat, std::va_list formatArg) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afb19ebf42335aea1037895832e167857"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字列をフォーマットします。書式指定文字列に与える引数を std::va_list で受け取る以外は、 <a class="el" href="namespacenn_1_1util.html#ad0cf8c9c361735e4387e4274f26660fb">SNPrintf()</a> と同一です。  <a href="#afb19ebf42335aea1037895832e167857">[詳解]</a><br /></td></tr>
<tr class="separator:afb19ebf42335aea1037895832e167857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ビット演算関数</div></td></tr>
<tr class="memitem:a442cc38c3c616eee03f1b66743376fa3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a442cc38c3c616eee03f1b66743376fa3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a442cc38c3c616eee03f1b66743376fa3">reverse_bits</a> (T x, int subword_bits=1, int num_swar_words=1) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a442cc38c3c616eee03f1b66743376fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">値をビット列に見立て、ビットの並び順を反転します。  <a href="#a442cc38c3c616eee03f1b66743376fa3">[詳解]</a><br /></td></tr>
<tr class="separator:a442cc38c3c616eee03f1b66743376fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec88a4a55dad4af44a729577bb2798f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec88a4a55dad4af44a729577bb2798f9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aec88a4a55dad4af44a729577bb2798f9">reverse_bytes</a> (T x, int subword_bytes=1, int num_swar_words=1) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aec88a4a55dad4af44a729577bb2798f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">値をバイト列に見立て、バイトの並び順を反転します。  <a href="#aec88a4a55dad4af44a729577bb2798f9">[詳解]</a><br /></td></tr>
<tr class="separator:aec88a4a55dad4af44a729577bb2798f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bb961273418194ab364a658116159f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa4bb961273418194ab364a658116159f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aa4bb961273418194ab364a658116159f">is_aligned</a> (T x, size_t align) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa4bb961273418194ab364a658116159f"><td class="mdescLeft">&#160;</td><td class="mdescRight">値が指定したアライメントに揃っているかどうかを返します。  <a href="#aa4bb961273418194ab364a658116159f">[詳解]</a><br /></td></tr>
<tr class="separator:aa4bb961273418194ab364a658116159f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f6772d3ae70168e07e0f39d416d72e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20f6772d3ae70168e07e0f39d416d72e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a20f6772d3ae70168e07e0f39d416d72e">align_up</a> (T x, size_t align) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a20f6772d3ae70168e07e0f39d416d72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">値を指定したアライメントまで切り上げます。  <a href="#a20f6772d3ae70168e07e0f39d416d72e">[詳解]</a><br /></td></tr>
<tr class="separator:a20f6772d3ae70168e07e0f39d416d72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8aac07f25fdd659091e1065b8c89a5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a8aac07f25fdd659091e1065b8c89a5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a8a8aac07f25fdd659091e1065b8c89a5">align_down</a> (T x, size_t align) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8a8aac07f25fdd659091e1065b8c89a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">値を指定したアライメントまで切り下げます。  <a href="#a8a8aac07f25fdd659091e1065b8c89a5">[詳解]</a><br /></td></tr>
<tr class="separator:a8a8aac07f25fdd659091e1065b8c89a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0e8eb18b9bf7c45a0b222f08026d36"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1e0e8eb18b9bf7c45a0b222f08026d36"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a1e0e8eb18b9bf7c45a0b222f08026d36">rstls1b</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1e0e8eb18b9bf7c45a0b222f08026d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">最下位の 1 のビットをオフにします。  <a href="#a1e0e8eb18b9bf7c45a0b222f08026d36">[詳解]</a><br /></td></tr>
<tr class="separator:a1e0e8eb18b9bf7c45a0b222f08026d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801a3a648e244cdd89d9160072cc45d8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a801a3a648e244cdd89d9160072cc45d8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a801a3a648e244cdd89d9160072cc45d8">setls0b</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a801a3a648e244cdd89d9160072cc45d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">最下位の 0 のビットをオンにします。  <a href="#a801a3a648e244cdd89d9160072cc45d8">[詳解]</a><br /></td></tr>
<tr class="separator:a801a3a648e244cdd89d9160072cc45d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669332e770e1518ea78380e2d399f23d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a669332e770e1518ea78380e2d399f23d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a669332e770e1518ea78380e2d399f23d">rstt1</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a669332e770e1518ea78380e2d399f23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">末尾から連続した 1 のビットをオフにします。  <a href="#a669332e770e1518ea78380e2d399f23d">[詳解]</a><br /></td></tr>
<tr class="separator:a669332e770e1518ea78380e2d399f23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacb11a5bb14955680167c808d46cefe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeacb11a5bb14955680167c808d46cefe"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aeacb11a5bb14955680167c808d46cefe">sett0</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aeacb11a5bb14955680167c808d46cefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">末尾から連続した 0 のビットをオンにします。  <a href="#aeacb11a5bb14955680167c808d46cefe">[詳解]</a><br /></td></tr>
<tr class="separator:aeacb11a5bb14955680167c808d46cefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa000931755cf4ee96cef173d261906fb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa000931755cf4ee96cef173d261906fb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aa000931755cf4ee96cef173d261906fb">isols1b</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa000931755cf4ee96cef173d261906fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">最下位の 1 のビットを取り出します。  <a href="#aa000931755cf4ee96cef173d261906fb">[詳解]</a><br /></td></tr>
<tr class="separator:aa000931755cf4ee96cef173d261906fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce2d5521d5721a8369ab94a517a3025"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ce2d5521d5721a8369ab94a517a3025"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a0ce2d5521d5721a8369ab94a517a3025">isols0b</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0ce2d5521d5721a8369ab94a517a3025"><td class="mdescLeft">&#160;</td><td class="mdescRight">最下位の 0 のビットを取り出します。  <a href="#a0ce2d5521d5721a8369ab94a517a3025">[詳解]</a><br /></td></tr>
<tr class="separator:a0ce2d5521d5721a8369ab94a517a3025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf080f682f24fb4db8c3d4b7fc25a4d2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf080f682f24fb4db8c3d4b7fc25a4d2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#abf080f682f24fb4db8c3d4b7fc25a4d2">maskt1</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abf080f682f24fb4db8c3d4b7fc25a4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">末尾から連続した 1 のビットを取り出します。  <a href="#abf080f682f24fb4db8c3d4b7fc25a4d2">[詳解]</a><br /></td></tr>
<tr class="separator:abf080f682f24fb4db8c3d4b7fc25a4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e5c98cd030634573aa1f3501a12736"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a44e5c98cd030634573aa1f3501a12736"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a44e5c98cd030634573aa1f3501a12736">maskt0</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a44e5c98cd030634573aa1f3501a12736"><td class="mdescLeft">&#160;</td><td class="mdescRight">末尾から連続した 0 のビットを取り出します。  <a href="#a44e5c98cd030634573aa1f3501a12736">[詳解]</a><br /></td></tr>
<tr class="separator:a44e5c98cd030634573aa1f3501a12736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1602964837b0e9b8356a0542732429a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad1602964837b0e9b8356a0542732429a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ad1602964837b0e9b8356a0542732429a">maskt1ls0b</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad1602964837b0e9b8356a0542732429a"><td class="mdescLeft">&#160;</td><td class="mdescRight">末尾から連続した 1 のビットと最下位の 0 のビットを取り出します。  <a href="#ad1602964837b0e9b8356a0542732429a">[詳解]</a><br /></td></tr>
<tr class="separator:ad1602964837b0e9b8356a0542732429a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c58ebce6b25b6a63ed95fdbbd386a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a72c58ebce6b25b6a63ed95fdbbd386a8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a72c58ebce6b25b6a63ed95fdbbd386a8">maskt0ls1b</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a72c58ebce6b25b6a63ed95fdbbd386a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">末尾から連続した 0 のビットと最下位の 1 のビットを取り出します。  <a href="#a72c58ebce6b25b6a63ed95fdbbd386a8">[詳解]</a><br /></td></tr>
<tr class="separator:a72c58ebce6b25b6a63ed95fdbbd386a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa975b1fe1cbcef0ad99b6645570ab58"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afa975b1fe1cbcef0ad99b6645570ab58"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#afa975b1fe1cbcef0ad99b6645570ab58">popcount</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afa975b1fe1cbcef0ad99b6645570ab58"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 のビットを数えます。  <a href="#afa975b1fe1cbcef0ad99b6645570ab58">[詳解]</a><br /></td></tr>
<tr class="separator:afa975b1fe1cbcef0ad99b6645570ab58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91281f707e3985a66a2c928437f9fc3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af91281f707e3985a66a2c928437f9fc3"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#af91281f707e3985a66a2c928437f9fc3">cntl0</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af91281f707e3985a66a2c928437f9fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">最上位から連続する 0 のビットの数を返します。  <a href="#af91281f707e3985a66a2c928437f9fc3">[詳解]</a><br /></td></tr>
<tr class="separator:af91281f707e3985a66a2c928437f9fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14aa0f35aab537531b957aae86e34d94"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14aa0f35aab537531b957aae86e34d94"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a14aa0f35aab537531b957aae86e34d94">cntt0</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a14aa0f35aab537531b957aae86e34d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">最下位から連続する 0 のビットの数を返します。  <a href="#a14aa0f35aab537531b957aae86e34d94">[詳解]</a><br /></td></tr>
<tr class="separator:a14aa0f35aab537531b957aae86e34d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab102f7cde538f702ebfef646d607a6ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab102f7cde538f702ebfef646d607a6ec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ab102f7cde538f702ebfef646d607a6ec">ispow2</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab102f7cde538f702ebfef646d607a6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定した値が 2 のべき乗かどうかを返します。  <a href="#ab102f7cde538f702ebfef646d607a6ec">[詳解]</a><br /></td></tr>
<tr class="separator:ab102f7cde538f702ebfef646d607a6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ee8bca4a8928f620e06490c8482ceb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a88ee8bca4a8928f620e06490c8482ceb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a88ee8bca4a8928f620e06490c8482ceb">floorp2</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a88ee8bca4a8928f620e06490c8482ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定した値以下の最大の 2 のべき乗の値を返します。  <a href="#a88ee8bca4a8928f620e06490c8482ceb">[詳解]</a><br /></td></tr>
<tr class="separator:a88ee8bca4a8928f620e06490c8482ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71655747c24554cc0f2627b271e0f652"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a71655747c24554cc0f2627b271e0f652"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a71655747c24554cc0f2627b271e0f652">ceilp2</a> (T x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a71655747c24554cc0f2627b271e0f652"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定した値以上の最小の 2 のべき乗の値を返します。  <a href="#a71655747c24554cc0f2627b271e0f652">[詳解]</a><br /></td></tr>
<tr class="separator:a71655747c24554cc0f2627b271e0f652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e0fe7ee3200b52cca718befdabe5fb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa1e0fe7ee3200b52cca718befdabe5fb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aa1e0fe7ee3200b52cca718befdabe5fb">DivideUp</a> (T x, U divider) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa1e0fe7ee3200b52cca718befdabe5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">端数を切り上げつつ値を指定した数値で割ります。  <a href="#aa1e0fe7ee3200b52cca718befdabe5fb">[詳解]</a><br /></td></tr>
<tr class="separator:aa1e0fe7ee3200b52cca718befdabe5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">エンディアン変換</div></td></tr>
<tr class="memitem:a56e0e9db954e75303566caf960d8934f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56e0e9db954e75303566caf960d8934f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a56e0e9db954e75303566caf960d8934f">SwapEndian</a> (T *pData) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a56e0e9db954e75303566caf960d8934f"><td class="mdescLeft">&#160;</td><td class="mdescRight">エンディアンを反転します。  <a href="#a56e0e9db954e75303566caf960d8934f">[詳解]</a><br /></td></tr>
<tr class="separator:a56e0e9db954e75303566caf960d8934f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11528ff78b0c478ba7980afb1fb758ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11528ff78b0c478ba7980afb1fb758ac"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a11528ff78b0c478ba7980afb1fb758ac">LoadEndianReversed</a> (const T *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a11528ff78b0c478ba7980afb1fb758ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">エンディアンを反転しながらデータをメモリから読み込みます。  <a href="#a11528ff78b0c478ba7980afb1fb758ac">[詳解]</a><br /></td></tr>
<tr class="separator:a11528ff78b0c478ba7980afb1fb758ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc3f4e75adbd4dd9a3aaeb81fabb7a4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5cc3f4e75adbd4dd9a3aaeb81fabb7a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a5cc3f4e75adbd4dd9a3aaeb81fabb7a4">StoreEndianReversed</a> (T *pDst, T src) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5cc3f4e75adbd4dd9a3aaeb81fabb7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">エンディアンを反転しながらデータをメモリに書き出します。  <a href="#a5cc3f4e75adbd4dd9a3aaeb81fabb7a4">[詳解]</a><br /></td></tr>
<tr class="separator:a5cc3f4e75adbd4dd9a3aaeb81fabb7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bc440e1aa171900411796a54701ac7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93bc440e1aa171900411796a54701ac7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a93bc440e1aa171900411796a54701ac7">LoadBigEndian</a> (const T *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a93bc440e1aa171900411796a54701ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">ビッグエンディアンのデータをメモリから読み込みます。  <a href="#a93bc440e1aa171900411796a54701ac7">[詳解]</a><br /></td></tr>
<tr class="separator:a93bc440e1aa171900411796a54701ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502929487c357dad5613feb3cc1d8ca1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a502929487c357dad5613feb3cc1d8ca1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a502929487c357dad5613feb3cc1d8ca1">StoreBigEndian</a> (T *pDst, T src) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a502929487c357dad5613feb3cc1d8ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ビッグエンディアンでデータをメモリに書き出します。  <a href="#a502929487c357dad5613feb3cc1d8ca1">[詳解]</a><br /></td></tr>
<tr class="separator:a502929487c357dad5613feb3cc1d8ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1fe27e9543f7398c23221c9dc7f86f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abe1fe27e9543f7398c23221c9dc7f86f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#abe1fe27e9543f7398c23221c9dc7f86f">LoadLittleEndian</a> (const T *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abe1fe27e9543f7398c23221c9dc7f86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">リトルエンディアンのデータをメモリから読み込みます。  <a href="#abe1fe27e9543f7398c23221c9dc7f86f">[詳解]</a><br /></td></tr>
<tr class="separator:abe1fe27e9543f7398c23221c9dc7f86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2462759e94b37f3c9dfb92406fbc4ec9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2462759e94b37f3c9dfb92406fbc4ec9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a2462759e94b37f3c9dfb92406fbc4ec9">StoreLittleEndian</a> (T *pDst, T src) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2462759e94b37f3c9dfb92406fbc4ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">リトルエンディアンでデータをメモリに書き出します。  <a href="#a2462759e94b37f3c9dfb92406fbc4ec9">[詳解]</a><br /></td></tr>
<tr class="separator:a2462759e94b37f3c9dfb92406fbc4ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">TypedStorage 関連関数</div></td></tr>
<tr class="memitem:af9bcb6a04353d44c401b747d2ce7f812"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9bcb6a04353d44c401b747d2ce7f812"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#af9bcb6a04353d44c401b747d2ce7f812">Get</a> (<a class="el" href="structnn_1_1util_1_1_typed_storage.html">TypedStorage</a>&lt; T, sizeof(T), std::alignment_of&lt; T &gt;::value &gt; &amp;storage)</td></tr>
<tr class="memdesc:af9bcb6a04353d44c401b747d2ce7f812"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定された領域から実際の型の参照を取り出します。  <a href="#af9bcb6a04353d44c401b747d2ce7f812">[詳解]</a><br /></td></tr>
<tr class="separator:af9bcb6a04353d44c401b747d2ce7f812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8769650838b44c09ff5c036f7050bc35"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8769650838b44c09ff5c036f7050bc35"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a8769650838b44c09ff5c036f7050bc35">Get</a> (const <a class="el" href="structnn_1_1util_1_1_typed_storage.html">TypedStorage</a>&lt; T, sizeof(T), std::alignment_of&lt; T &gt;::value &gt; &amp;storage)</td></tr>
<tr class="memdesc:a8769650838b44c09ff5c036f7050bc35"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定された領域から実際の型の参照を取り出します。  <a href="#a8769650838b44c09ff5c036f7050bc35">[詳解]</a><br /></td></tr>
<tr class="separator:a8769650838b44c09ff5c036f7050bc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">文字エンコーディング変換</div></td></tr>
<tr class="memitem:ac299aadfc2d647eddfb7b48a002497d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ac299aadfc2d647eddfb7b48a002497d4">ConvertStringUtf8ToUtf16Native</a> (uint16_t *pDst, int dstLength, const char *pSrc, int srcLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac299aadfc2d647eddfb7b48a002497d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字コードを UTF-8 から UTF-16 に変換します。  <a href="#ac299aadfc2d647eddfb7b48a002497d4">[詳解]</a><br /></td></tr>
<tr class="separator:ac299aadfc2d647eddfb7b48a002497d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6dd6d63f9069c568f4f9e0a41171c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#acb6dd6d63f9069c568f4f9e0a41171c2">ConvertStringUtf8ToUtf16Native</a> (uint16_t *pDst, int dstLength, const char *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acb6dd6d63f9069c568f4f9e0a41171c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字コードを UTF-8 から UTF-16 に変換します。終端文字まで変換されます。  <a href="#acb6dd6d63f9069c568f4f9e0a41171c2">[詳解]</a><br /></td></tr>
<tr class="separator:acb6dd6d63f9069c568f4f9e0a41171c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7633254c8910e4e0b191121feddd95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a0f7633254c8910e4e0b191121feddd95">ConvertStringUtf16NativeToUtf8</a> (char *pDst, int dstLength, const uint16_t *pSrc, int srcLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0f7633254c8910e4e0b191121feddd95"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字コードを UTF-16 から UTF-8 に変換します。  <a href="#a0f7633254c8910e4e0b191121feddd95">[詳解]</a><br /></td></tr>
<tr class="separator:a0f7633254c8910e4e0b191121feddd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0256928bab392ea72f8d15e3ec6efb7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a0256928bab392ea72f8d15e3ec6efb7f">ConvertStringUtf16NativeToUtf8</a> (char *pDst, int dstLength, const uint16_t *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0256928bab392ea72f8d15e3ec6efb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字コードを UTF-16 から UTF-8 に変換します。終端文字まで変換されます。  <a href="#a0256928bab392ea72f8d15e3ec6efb7f">[詳解]</a><br /></td></tr>
<tr class="separator:a0256928bab392ea72f8d15e3ec6efb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c6fd4c3ccbb9129b10e6f2f9bed339"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a05c6fd4c3ccbb9129b10e6f2f9bed339">GetLengthOfConvertedStringUtf8ToUtf16Native</a> (int *pOutLength, const char *pSrc, int srcLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a05c6fd4c3ccbb9129b10e6f2f9bed339"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-8 から UTF-16 に変換するために必要な変換先の配列の長さを取得します。  <a href="#a05c6fd4c3ccbb9129b10e6f2f9bed339">[詳解]</a><br /></td></tr>
<tr class="separator:a05c6fd4c3ccbb9129b10e6f2f9bed339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdffba72eb466818e238d6ebb53b0dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a1fdffba72eb466818e238d6ebb53b0dc">GetLengthOfConvertedStringUtf16NativeToUtf8</a> (int *pOutLength, const uint16_t *pSrc, int srcLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1fdffba72eb466818e238d6ebb53b0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-16 から UTF-8 に変換するために必要な変換先の配列の長さを取得します。  <a href="#a1fdffba72eb466818e238d6ebb53b0dc">[詳解]</a><br /></td></tr>
<tr class="separator:a1fdffba72eb466818e238d6ebb53b0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420f497d6459647978b4fe9c04f654b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a420f497d6459647978b4fe9c04f654b9">ConvertStringUtf8ToUtf32</a> (uint32_t *pDst, int dstLength, const char *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a420f497d6459647978b4fe9c04f654b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字コードを UTF-8 から UTF-32 に変換します。終端文字まで変換されます。  <a href="#a420f497d6459647978b4fe9c04f654b9">[詳解]</a><br /></td></tr>
<tr class="separator:a420f497d6459647978b4fe9c04f654b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de5dec6adb8e4760e49502991983e7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a6de5dec6adb8e4760e49502991983e7b">ConvertStringUtf32ToUtf8</a> (char *pDst, int dstLength, const uint32_t *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6de5dec6adb8e4760e49502991983e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字コードを UTF-32 から UTF-8 に変換します。終端文字まで変換されます。  <a href="#a6de5dec6adb8e4760e49502991983e7b">[詳解]</a><br /></td></tr>
<tr class="separator:a6de5dec6adb8e4760e49502991983e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2095df7e200b19b396b87856c884ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a1d2095df7e200b19b396b87856c884ac">GetLengthOfConvertedStringUtf8ToUtf32</a> (int *pOutLength, const char *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1d2095df7e200b19b396b87856c884ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-8 から UTF-32 に変換するために必要な変換先の配列の長さを取得します。終端文字まで読み込まれます。  <a href="#a1d2095df7e200b19b396b87856c884ac">[詳解]</a><br /></td></tr>
<tr class="separator:a1d2095df7e200b19b396b87856c884ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68dd5a2f5c5ddfbb416ea6f6f434f7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ad68dd5a2f5c5ddfbb416ea6f6f434f7c">GetLengthOfConvertedStringUtf32ToUtf8</a> (int *pOutLength, const uint32_t *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad68dd5a2f5c5ddfbb416ea6f6f434f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-32 から UTF-8 に変換するために必要な変換先の配列の長さを取得します。終端文字まで読み込まれます。  <a href="#ad68dd5a2f5c5ddfbb416ea6f6f434f7c">[詳解]</a><br /></td></tr>
<tr class="separator:ad68dd5a2f5c5ddfbb416ea6f6f434f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c37393525e5cd94e22abe476c261c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ae3c37393525e5cd94e22abe476c261c9">ConvertCharacterUtf8ToUtf16Native</a> (uint16_t *pDst, const char *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae3c37393525e5cd94e22abe476c261c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字コードを UTF-8 から UTF-16 に 1 文字だけ変換します。  <a href="#ae3c37393525e5cd94e22abe476c261c9">[詳解]</a><br /></td></tr>
<tr class="separator:ae3c37393525e5cd94e22abe476c261c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac706453bef5ce6867499d41bff823a0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ac706453bef5ce6867499d41bff823a0b">ConvertCharacterUtf16NativeToUtf8</a> (char *pDst, const uint16_t *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac706453bef5ce6867499d41bff823a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字コードを UTF-16 から UTF-8 に 1 文字だけ変換します。  <a href="#ac706453bef5ce6867499d41bff823a0b">[詳解]</a><br /></td></tr>
<tr class="separator:ac706453bef5ce6867499d41bff823a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec102fea3e52b0d8ec9ce743f3156dd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aec102fea3e52b0d8ec9ce743f3156dd6">ConvertCharacterUtf8ToUtf32</a> (uint32_t *pDst, const char *pSrc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aec102fea3e52b0d8ec9ce743f3156dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字コードを UTF-8 から UTF-32 に 1 文字だけ変換します。  <a href="#aec102fea3e52b0d8ec9ce743f3156dd6">[詳解]</a><br /></td></tr>
<tr class="separator:aec102fea3e52b0d8ec9ce743f3156dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af955318b43cb855889cfce8799ae61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a8af955318b43cb855889cfce8799ae61">ConvertCharacterUtf32ToUtf8</a> (char *pDst, uint32_t src) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8af955318b43cb855889cfce8799ae61"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字コードを UTF-32 から UTF-8 に 1 文字だけ変換します。  <a href="#a8af955318b43cb855889cfce8799ae61">[詳解]</a><br /></td></tr>
<tr class="separator:a8af955318b43cb855889cfce8799ae61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae443a8ae5dbbb92d7f03fb2fba373ea3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ae443a8ae5dbbb92d7f03fb2fba373ea3">PickOutCharacterFromUtf8String</a> (char *pChar, const char **pStr) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae443a8ae5dbbb92d7f03fb2fba373ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-8 の文字列から 1 文字を切り出して、ポインタを進めます。  <a href="#ae443a8ae5dbbb92d7f03fb2fba373ea3">[詳解]</a><br /></td></tr>
<tr class="separator:ae443a8ae5dbbb92d7f03fb2fba373ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">圧縮</div></td></tr>
<tr class="memitem:ae0290996b2f08a558763e919ca74fd0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ae0290996b2f08a558763e919ca74fd0f">CompressZlib</a> (size_t *pOutSize, void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, void *pWork, size_t workSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae0290996b2f08a558763e919ca74fd0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">zlib 形式の deflate 圧縮を行う関数です。  <a href="#ae0290996b2f08a558763e919ca74fd0f">[詳解]</a><br /></td></tr>
<tr class="separator:ae0290996b2f08a558763e919ca74fd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a092e78b92cadba899c2abbc486f899"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a9a092e78b92cadba899c2abbc486f899">CompressZlib</a> (size_t *pOutSize, void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, void *pWork, size_t workSize, int memLevel, int compressionLevel) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9a092e78b92cadba899c2abbc486f899"><td class="mdescLeft">&#160;</td><td class="mdescRight">圧縮レベルと使用メモリレベルを指定し、zlib 形式の deflate 圧縮を行う関数です。  <a href="#a9a092e78b92cadba899c2abbc486f899">[詳解]</a><br /></td></tr>
<tr class="separator:a9a092e78b92cadba899c2abbc486f899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eaf5623ce101256fc619f5b5a03491c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a1eaf5623ce101256fc619f5b5a03491c">CompressGzip</a> (size_t *pOutSize, void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, void *pWork, size_t workSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1eaf5623ce101256fc619f5b5a03491c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gzip 形式の deflate 圧縮を行う関数です。  <a href="#a1eaf5623ce101256fc619f5b5a03491c">[詳解]</a><br /></td></tr>
<tr class="separator:a1eaf5623ce101256fc619f5b5a03491c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda6da1a7c7bb62667781877ec8521a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#abda6da1a7c7bb62667781877ec8521a9">CompressGzip</a> (size_t *pOutSize, void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, void *pWork, size_t workSize, int memLevel, int compressionLevel) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abda6da1a7c7bb62667781877ec8521a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">圧縮レベルと使用メモリレベルを指定し、gzip 形式の deflate 圧縮を行う関数です。  <a href="#abda6da1a7c7bb62667781877ec8521a9">[詳解]</a><br /></td></tr>
<tr class="separator:abda6da1a7c7bb62667781877ec8521a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394f55bc3df26d704f0fa46644aeee07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a394f55bc3df26d704f0fa46644aeee07">CompressDeflate</a> (size_t *pOutSize, void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, void *pWork, size_t workSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a394f55bc3df26d704f0fa46644aeee07"><td class="mdescLeft">&#160;</td><td class="mdescRight">raw deflate 形式の deflate 圧縮を行う関数です。  <a href="#a394f55bc3df26d704f0fa46644aeee07">[詳解]</a><br /></td></tr>
<tr class="separator:a394f55bc3df26d704f0fa46644aeee07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d02db25df3c786d3b84160a71a4ca4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a0d02db25df3c786d3b84160a71a4ca4c">CompressDeflate</a> (size_t *pOutSize, void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, void *pWork, size_t workSize, int memLevel, int compressionLevel) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0d02db25df3c786d3b84160a71a4ca4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">圧縮レベルと使用メモリレベルを指定し、raw deflate 形式の deflate 圧縮を行う関数です。  <a href="#a0d02db25df3c786d3b84160a71a4ca4c">[詳解]</a><br /></td></tr>
<tr class="separator:a0d02db25df3c786d3b84160a71a4ca4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">伸長</div></td></tr>
<tr class="memitem:af08749f6d24d2bf7d577a253fa2d3c59"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#af08749f6d24d2bf7d577a253fa2d3c59">GetGzipDecompressedSize</a> (const void *pSrc, size_t srcSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af08749f6d24d2bf7d577a253fa2d3c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">gzip 形式の圧縮データから圧縮前のデータサイズを取得します。  <a href="#af08749f6d24d2bf7d577a253fa2d3c59">[詳解]</a><br /></td></tr>
<tr class="separator:af08749f6d24d2bf7d577a253fa2d3c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef5750312d89f54f3e11496c3414ef7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a5ef5750312d89f54f3e11496c3414ef7">DecompressZlib</a> (void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, void *pWork, size_t workSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5ef5750312d89f54f3e11496c3414ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">zlib 形式の deflate 伸長を行います。  <a href="#a5ef5750312d89f54f3e11496c3414ef7">[詳解]</a><br /></td></tr>
<tr class="separator:a5ef5750312d89f54f3e11496c3414ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0dd598671e1a5e68b15f48e4b02045"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a8d0dd598671e1a5e68b15f48e4b02045">DecompressGzip</a> (void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, void *pWork, size_t workSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8d0dd598671e1a5e68b15f48e4b02045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gzip 形式の deflate 伸長を行います。  <a href="#a8d0dd598671e1a5e68b15f48e4b02045">[詳解]</a><br /></td></tr>
<tr class="separator:a8d0dd598671e1a5e68b15f48e4b02045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24276fbb8f0d3892fdd9b076078d690"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aa24276fbb8f0d3892fdd9b076078d690">DecompressDeflate</a> (void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, void *pWork, size_t workSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa24276fbb8f0d3892fdd9b076078d690"><td class="mdescLeft">&#160;</td><td class="mdescRight">raw deflate 形式の deflate 伸長を行います。  <a href="#aa24276fbb8f0d3892fdd9b076078d690">[詳解]</a><br /></td></tr>
<tr class="separator:aa24276fbb8f0d3892fdd9b076078d690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ストリーミング伸長</div></td></tr>
<tr class="memitem:a95a0c92775590454820ac267996f2461"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a95a0c92775590454820ac267996f2461">InitializeStreamingDecompressZlibContext</a> (<a class="el" href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html">StreamingDecompressZlibContext</a> *pContext) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a95a0c92775590454820ac267996f2461"><td class="mdescLeft">&#160;</td><td class="mdescRight">zlib 形式のストリーミング伸長用コンテキストを初期化します。  <a href="#a95a0c92775590454820ac267996f2461">[詳解]</a><br /></td></tr>
<tr class="separator:a95a0c92775590454820ac267996f2461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c59c5b4e3d814b813abf54a60ea4ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a64c59c5b4e3d814b813abf54a60ea4ec">InitializeStreamingDecompressGzipContext</a> (<a class="el" href="namespacenn_1_1util.html#ae9beb7ac8f35cef8dd13f0416662320a">StreamingDecompressGzipContext</a> *pContext) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a64c59c5b4e3d814b813abf54a60ea4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gzip 形式のストリーミング伸長用コンテキストを初期化します。  <a href="#a64c59c5b4e3d814b813abf54a60ea4ec">[詳解]</a><br /></td></tr>
<tr class="separator:a64c59c5b4e3d814b813abf54a60ea4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871190073dcf972d7212fe860883f208"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a871190073dcf972d7212fe860883f208">InitializeStreamingDecompressDeflateContext</a> (<a class="el" href="namespacenn_1_1util.html#af2ed3b5d58dc0275f9c96f4d4ec7a079">StreamingDecompressDeflateContext</a> *pContext) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a871190073dcf972d7212fe860883f208"><td class="mdescLeft">&#160;</td><td class="mdescRight">raw deflate 形式のストリーミング伸長用コンテキストを初期化します。  <a href="#a871190073dcf972d7212fe860883f208">[詳解]</a><br /></td></tr>
<tr class="separator:a871190073dcf972d7212fe860883f208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7545b1458e6ce1847a83d1a04d21cb7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a7545b1458e6ce1847a83d1a04d21cb7a">StreamingDecompressZlib</a> (size_t *pOutDstSize, size_t *pOutConsumedSrcSize, void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, <a class="el" href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html">StreamingDecompressZlibContext</a> *pContext) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7545b1458e6ce1847a83d1a04d21cb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">zlib 形式のストリーミング deflate 伸長を行います。  <a href="#a7545b1458e6ce1847a83d1a04d21cb7a">[詳解]</a><br /></td></tr>
<tr class="separator:a7545b1458e6ce1847a83d1a04d21cb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19480f506b13f96d397ab207377809f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ae19480f506b13f96d397ab207377809f">StreamingDecompressGzip</a> (size_t *pOutDstSize, size_t *pOutConsumedSrcSize, void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, <a class="el" href="namespacenn_1_1util.html#ae9beb7ac8f35cef8dd13f0416662320a">StreamingDecompressGzipContext</a> *pContext) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae19480f506b13f96d397ab207377809f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gzip 形式のストリーミング deflate 伸長を行います。  <a href="#ae19480f506b13f96d397ab207377809f">[詳解]</a><br /></td></tr>
<tr class="separator:ae19480f506b13f96d397ab207377809f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4538c0f548daf8eb7a9be82f0d05db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a0f4538c0f548daf8eb7a9be82f0d05db">StreamingDecompressDeflate</a> (size_t *pOutDstSize, size_t *pOutConsumedSrcSize, void *pDst, size_t dstSize, const void *pSrc, size_t srcSize, <a class="el" href="namespacenn_1_1util.html#af2ed3b5d58dc0275f9c96f4d4ec7a079">StreamingDecompressDeflateContext</a> *pContext) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0f4538c0f548daf8eb7a9be82f0d05db"><td class="mdescLeft">&#160;</td><td class="mdescRight">raw deflate 形式のストリーミング deflate 伸長を行います。  <a href="#a0f4538c0f548daf8eb7a9be82f0d05db">[詳解]</a><br /></td></tr>
<tr class="separator:a0f4538c0f548daf8eb7a9be82f0d05db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">三角関数</div></td></tr>
<tr class="memitem:a97ebb4e1469d08a7f51a21147375949b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a97ebb4e1469d08a7f51a21147375949b">RadianToAngleIndex</a> (float radian) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a97ebb4e1469d08a7f51a21147375949b"><td class="mdescLeft">&#160;</td><td class="mdescRight">角度をラジアン表現からインデックス表現に変換します。  <a href="#a97ebb4e1469d08a7f51a21147375949b">[詳解]</a><br /></td></tr>
<tr class="separator:a97ebb4e1469d08a7f51a21147375949b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1e7f71d2c5b0551d7b8c735d83d6a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ade1e7f71d2c5b0551d7b8c735d83d6a3">DegreeToAngleIndex</a> (float degree) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ade1e7f71d2c5b0551d7b8c735d83d6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">角度を度数表現からインデックス表現に変換します。  <a href="#ade1e7f71d2c5b0551d7b8c735d83d6a3">[詳解]</a><br /></td></tr>
<tr class="separator:ade1e7f71d2c5b0551d7b8c735d83d6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342713848fbb4ce6750da90d297bc824"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a342713848fbb4ce6750da90d297bc824">DegreeToRadian</a> (float degree) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a342713848fbb4ce6750da90d297bc824"><td class="mdescLeft">&#160;</td><td class="mdescRight">角度を度数表現からラジアン表現に変換します。  <a href="#a342713848fbb4ce6750da90d297bc824">[詳解]</a><br /></td></tr>
<tr class="separator:a342713848fbb4ce6750da90d297bc824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32747bc56d48f93666e0548ef312585"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ab32747bc56d48f93666e0548ef312585">RadianToDegree</a> (float radian) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab32747bc56d48f93666e0548ef312585"><td class="mdescLeft">&#160;</td><td class="mdescRight">角度をラジアン表現から度数表現に変換します。  <a href="#ab32747bc56d48f93666e0548ef312585">[詳解]</a><br /></td></tr>
<tr class="separator:ab32747bc56d48f93666e0548ef312585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b160179ea31b4eaf41284e73b925f6a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a6b160179ea31b4eaf41284e73b925f6a">AngleIndexToRadian</a> (<a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> angleIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6b160179ea31b4eaf41284e73b925f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">角度をインデックス表現からラジアン表現に変換します。  <a href="#a6b160179ea31b4eaf41284e73b925f6a">[詳解]</a><br /></td></tr>
<tr class="separator:a6b160179ea31b4eaf41284e73b925f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cc37b32cbeec92b9ad379e0e8a7a53"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a07cc37b32cbeec92b9ad379e0e8a7a53">AngleIndexToDegree</a> (<a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> angleIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a07cc37b32cbeec92b9ad379e0e8a7a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">角度をインデックス表現から度数表現に変換します。  <a href="#a07cc37b32cbeec92b9ad379e0e8a7a53">[詳解]</a><br /></td></tr>
<tr class="separator:a07cc37b32cbeec92b9ad379e0e8a7a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115590ce3ee8638bc4a1c7e561b58209"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a115590ce3ee8638bc4a1c7e561b58209">SinEst</a> (float radian) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a115590ce3ee8638bc4a1c7e561b58209"><td class="mdescLeft">&#160;</td><td class="mdescRight">多項式近似によって、正弦を求めます。  <a href="#a115590ce3ee8638bc4a1c7e561b58209">[詳解]</a><br /></td></tr>
<tr class="separator:a115590ce3ee8638bc4a1c7e561b58209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd65f177dec24038d8e796993dd6f19"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#abdd65f177dec24038d8e796993dd6f19">SinTable</a> (<a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> angleIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abdd65f177dec24038d8e796993dd6f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">テーブル引きによって、正弦を求めます。  <a href="#abdd65f177dec24038d8e796993dd6f19">[詳解]</a><br /></td></tr>
<tr class="separator:abdd65f177dec24038d8e796993dd6f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68268124ed7f0d8881db3fcebd01687f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a68268124ed7f0d8881db3fcebd01687f">CosEst</a> (float radian) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a68268124ed7f0d8881db3fcebd01687f"><td class="mdescLeft">&#160;</td><td class="mdescRight">多項式近似によって、余弦を求めます。  <a href="#a68268124ed7f0d8881db3fcebd01687f">[詳解]</a><br /></td></tr>
<tr class="separator:a68268124ed7f0d8881db3fcebd01687f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ba79c433fb71aa611fbead84b2c5a3"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a90ba79c433fb71aa611fbead84b2c5a3">CosTable</a> (<a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> angleIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a90ba79c433fb71aa611fbead84b2c5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">テーブル引きによって、余弦を求めます。  <a href="#a90ba79c433fb71aa611fbead84b2c5a3">[詳解]</a><br /></td></tr>
<tr class="separator:a90ba79c433fb71aa611fbead84b2c5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ba5bc072eae44853ce61976d55b001"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a32ba5bc072eae44853ce61976d55b001">SinCosEst</a> (float *pOutSin, float *pOutCos, float radian) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a32ba5bc072eae44853ce61976d55b001"><td class="mdescLeft">&#160;</td><td class="mdescRight">多項式近似によって、正弦と余弦を求めます。  <a href="#a32ba5bc072eae44853ce61976d55b001">[詳解]</a><br /></td></tr>
<tr class="separator:a32ba5bc072eae44853ce61976d55b001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168e5f5b41ec5ecd60c6f88b6aea163e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a168e5f5b41ec5ecd60c6f88b6aea163e">SinCosTable</a> (float *pOutSin, float *pOutCos, <a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> angleIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a168e5f5b41ec5ecd60c6f88b6aea163e"><td class="mdescLeft">&#160;</td><td class="mdescRight">テーブル引きによって、正弦と余弦を求めます。  <a href="#a168e5f5b41ec5ecd60c6f88b6aea163e">[詳解]</a><br /></td></tr>
<tr class="separator:a168e5f5b41ec5ecd60c6f88b6aea163e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdc076bfbd01224d54074c1f312165b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a0cdc076bfbd01224d54074c1f312165b">TanEst</a> (float radian) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0cdc076bfbd01224d54074c1f312165b"><td class="mdescLeft">&#160;</td><td class="mdescRight">多項式近似によって、正接を求めます。  <a href="#a0cdc076bfbd01224d54074c1f312165b">[詳解]</a><br /></td></tr>
<tr class="separator:a0cdc076bfbd01224d54074c1f312165b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ac3cee8ff11403595c42268db119ff"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ab8ac3cee8ff11403595c42268db119ff">TanTable</a> (<a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> angleIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab8ac3cee8ff11403595c42268db119ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">テーブル引きによって、正接を求めます。  <a href="#ab8ac3cee8ff11403595c42268db119ff">[詳解]</a><br /></td></tr>
<tr class="separator:ab8ac3cee8ff11403595c42268db119ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2699f371e3d783b78039ec8ac527de7b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a2699f371e3d783b78039ec8ac527de7b">AtanEst</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2699f371e3d783b78039ec8ac527de7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">多項式近似によって、逆正接を求めます。  <a href="#a2699f371e3d783b78039ec8ac527de7b">[詳解]</a><br /></td></tr>
<tr class="separator:a2699f371e3d783b78039ec8ac527de7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f23a5881abd9cc0bea5d1373a5f11e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a1f23a5881abd9cc0bea5d1373a5f11e6">AtanTable</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1f23a5881abd9cc0bea5d1373a5f11e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">テーブル引きによって、逆正接を求めます。  <a href="#a1f23a5881abd9cc0bea5d1373a5f11e6">[詳解]</a><br /></td></tr>
<tr class="separator:a1f23a5881abd9cc0bea5d1373a5f11e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7efae0dfa5a73c71deeadd9665477d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a0a7efae0dfa5a73c71deeadd9665477d">Atan2Est</a> (float y, float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0a7efae0dfa5a73c71deeadd9665477d"><td class="mdescLeft">&#160;</td><td class="mdescRight">多項式近似によって、逆正接を求めます。  <a href="#a0a7efae0dfa5a73c71deeadd9665477d">[詳解]</a><br /></td></tr>
<tr class="separator:a0a7efae0dfa5a73c71deeadd9665477d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c57759e10ba45d38bb7377edd0115a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a9c57759e10ba45d38bb7377edd0115a3">Atan2Table</a> (float y, float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9c57759e10ba45d38bb7377edd0115a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">テーブル引きによって、逆正接を求めます。  <a href="#a9c57759e10ba45d38bb7377edd0115a3">[詳解]</a><br /></td></tr>
<tr class="separator:a9c57759e10ba45d38bb7377edd0115a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c37527d1019f795ee78f5b51e9cd66"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a04c37527d1019f795ee78f5b51e9cd66">AsinEst</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a04c37527d1019f795ee78f5b51e9cd66"><td class="mdescLeft">&#160;</td><td class="mdescRight">多項式近似によって、逆正弦を求めます。  <a href="#a04c37527d1019f795ee78f5b51e9cd66">[詳解]</a><br /></td></tr>
<tr class="separator:a04c37527d1019f795ee78f5b51e9cd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6f39eabcabdbeaed5c5eeecd012a81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aae6f39eabcabdbeaed5c5eeecd012a81">AsinTable</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aae6f39eabcabdbeaed5c5eeecd012a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">テーブル引きによって、逆正弦を求めます。  <a href="#aae6f39eabcabdbeaed5c5eeecd012a81">[詳解]</a><br /></td></tr>
<tr class="separator:aae6f39eabcabdbeaed5c5eeecd012a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69079f75685a291d46ba591ddb60bbd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#af69079f75685a291d46ba591ddb60bbd">AcosEst</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af69079f75685a291d46ba591ddb60bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">多項式近似によって、逆余弦を求めます。  <a href="#af69079f75685a291d46ba591ddb60bbd">[詳解]</a><br /></td></tr>
<tr class="separator:af69079f75685a291d46ba591ddb60bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b10c3b5e379f2215fe0e65428e8543"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a13b10c3b5e379f2215fe0e65428e8543">AcosTable</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a13b10c3b5e379f2215fe0e65428e8543"><td class="mdescLeft">&#160;</td><td class="mdescRight">テーブル引きによって、逆余弦を求めます。  <a href="#a13b10c3b5e379f2215fe0e65428e8543">[詳解]</a><br /></td></tr>
<tr class="separator:a13b10c3b5e379f2215fe0e65428e8543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">算術ユーティリティ</div></td></tr>
<tr class="memitem:aee333695e4a66942a628f67d238c5fb3"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aee333695e4a66942a628f67d238c5fb3">Rcp</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aee333695e4a66942a628f67d238c5fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">逆数を求めます。  <a href="#aee333695e4a66942a628f67d238c5fb3">[詳解]</a><br /></td></tr>
<tr class="separator:aee333695e4a66942a628f67d238c5fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb31608117aba6428f8ad885f520594"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a6eb31608117aba6428f8ad885f520594"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a6eb31608117aba6428f8ad885f520594">RcpLowPrecision</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6eb31608117aba6428f8ad885f520594"><td class="mdescLeft">&#160;</td><td class="mdescRight">逆数を求めます。指定した回数だけ補正を行います。Rcp() よりも精度で劣ります。  <a href="#a6eb31608117aba6428f8ad885f520594">[詳解]</a><br /></td></tr>
<tr class="separator:a6eb31608117aba6428f8ad885f520594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2724ddb1495e6daec879773fdd3fe8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a0c2724ddb1495e6daec879773fdd3fe8">Rsqrt</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0c2724ddb1495e6daec879773fdd3fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">平方根の逆数を求めます。  <a href="#a0c2724ddb1495e6daec879773fdd3fe8">[詳解]</a><br /></td></tr>
<tr class="separator:a0c2724ddb1495e6daec879773fdd3fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcdeefaffc5e1034d28f7a0be702075"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a3bcdeefaffc5e1034d28f7a0be702075"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a3bcdeefaffc5e1034d28f7a0be702075">RsqrtLowPrecision</a> (float x) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3bcdeefaffc5e1034d28f7a0be702075"><td class="mdescLeft">&#160;</td><td class="mdescRight">平方根の逆数を求めます。 指定した回数だけ補正を行います。Rsqrt() よりも精度で劣ります。  <a href="#a3bcdeefaffc5e1034d28f7a0be702075">[詳解]</a><br /></td></tr>
<tr class="separator:a3bcdeefaffc5e1034d28f7a0be702075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d2e581fa3899d8d501a038439df039"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a43d2e581fa3899d8d501a038439df039">AreEqualAbs</a> (float x, float y, float absError) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a43d2e581fa3899d8d501a038439df039"><td class="mdescLeft">&#160;</td><td class="mdescRight">絶対誤差を用いて等値判定を行います。  <a href="#a43d2e581fa3899d8d501a038439df039">[詳解]</a><br /></td></tr>
<tr class="separator:a43d2e581fa3899d8d501a038439df039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2aa31b9b31c32958457d65f11b7987"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a7b2aa31b9b31c32958457d65f11b7987">AreEqualRelative</a> (float x, float y, float relativeError) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7b2aa31b9b31c32958457d65f11b7987"><td class="mdescLeft">&#160;</td><td class="mdescRight">相対誤差を用いて等値判定を行います。  <a href="#a7b2aa31b9b31c32958457d65f11b7987">[詳解]</a><br /></td></tr>
<tr class="separator:a7b2aa31b9b31c32958457d65f11b7987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41b86bc679691f454362ad06c268cb4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aa41b86bc679691f454362ad06c268cb4">AreEqual</a> (float x, float y, float error) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa41b86bc679691f454362ad06c268cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">絶対誤差、もしくは、相対誤差を用いて等値判定を行います。  <a href="#aa41b86bc679691f454362ad06c268cb4">[詳解]</a><br /></td></tr>
<tr class="separator:aa41b86bc679691f454362ad06c268cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">文字列操作関数</div></td></tr>
<tr class="memitem:a13a79a6dc84bdf279b045fc093ff2119"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a13a79a6dc84bdf279b045fc093ff2119"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a13a79a6dc84bdf279b045fc093ff2119">ToLower</a> (T c)</td></tr>
<tr class="memdesc:a13a79a6dc84bdf279b045fc093ff2119"><td class="mdescLeft">&#160;</td><td class="mdescRight">大文字を小文字に変換します。  <a href="#a13a79a6dc84bdf279b045fc093ff2119">[詳解]</a><br /></td></tr>
<tr class="separator:a13a79a6dc84bdf279b045fc093ff2119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a76533452983f6c48f18b8d13cb9dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a99a76533452983f6c48f18b8d13cb9dd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a99a76533452983f6c48f18b8d13cb9dd">ToUpper</a> (T c)</td></tr>
<tr class="memdesc:a99a76533452983f6c48f18b8d13cb9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">小文字を大文字に変換します。  <a href="#a99a76533452983f6c48f18b8d13cb9dd">[詳解]</a><br /></td></tr>
<tr class="separator:a99a76533452983f6c48f18b8d13cb9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea34b10628afe205af6f4d0d63637aa3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea34b10628afe205af6f4d0d63637aa3"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aea34b10628afe205af6f4d0d63637aa3">Strlcpy</a> (T *pOutDst, const T *pSrc, int count)</td></tr>
<tr class="memdesc:aea34b10628afe205af6f4d0d63637aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">コピー先のバッファの要素数や終端に配慮した文字列のコピーをおこないます。  <a href="#aea34b10628afe205af6f4d0d63637aa3">[詳解]</a><br /></td></tr>
<tr class="separator:aea34b10628afe205af6f4d0d63637aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c81364b3b9819789c1c4a429d253ea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab7c81364b3b9819789c1c4a429d253ea"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ab7c81364b3b9819789c1c4a429d253ea">Strnlen</a> (const T *pStr, int count)</td></tr>
<tr class="memdesc:ab7c81364b3b9819789c1c4a429d253ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">バッファの要素数や終端に配慮した文字数のカウントをおこないます。  <a href="#ab7c81364b3b9819789c1c4a429d253ea">[詳解]</a><br /></td></tr>
<tr class="separator:ab7c81364b3b9819789c1c4a429d253ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03c040b318b096258d333336c1adbc8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af03c040b318b096258d333336c1adbc8"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#af03c040b318b096258d333336c1adbc8">Strncmp</a> (const T *pStr1, const T *pStr2, int count)</td></tr>
<tr class="memdesc:af03c040b318b096258d333336c1adbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">バッファの要素数や終端に配慮して文字列を比較します。  <a href="#af03c040b318b096258d333336c1adbc8">[詳解]</a><br /></td></tr>
<tr class="separator:af03c040b318b096258d333336c1adbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bdf2f9bab2ff279262c7024abde9c7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a84bdf2f9bab2ff279262c7024abde9c7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a84bdf2f9bab2ff279262c7024abde9c7">Strnicmp</a> (const T *pStr1, const T *pStr2, int count)</td></tr>
<tr class="memdesc:a84bdf2f9bab2ff279262c7024abde9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">バッファの要素数や終端に配慮して文字列を英字の大小を区別せずに比較します。  <a href="#a84bdf2f9bab2ff279262c7024abde9c7">[詳解]</a><br /></td></tr>
<tr class="separator:a84bdf2f9bab2ff279262c7024abde9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
変数</h2></td></tr>
<tr class="memitem:ad88fffd214c821216806be73ef63704c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad88fffd214c821216806be73ef63704c"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ad88fffd214c821216806be73ef63704c">CompressDeflateWorkBufferSizeDefault</a> = <a class="el" href="namespacenn_1_1util.html#aa4dcb222bce2eb1d5209d12dad071028">CompressZlibWorkBufferSizeDefault</a></td></tr>
<tr class="memdesc:ad88fffd214c821216806be73ef63704c"><td class="mdescLeft">&#160;</td><td class="mdescRight">圧縮レベルと使用メモリレベルを指定しない <a class="el" href="namespacenn_1_1util.html#a394f55bc3df26d704f0fa46644aeee07" title="raw deflate 形式の deflate 圧縮を行う関数です。 ">CompressDeflate()</a> で必要となるワークバッファのサイズ (バイト数) を定義した定数です。 <br /></td></tr>
<tr class="separator:ad88fffd214c821216806be73ef63704c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a13350e1e0d435dccc7128af110815e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a13350e1e0d435dccc7128af110815e"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a2a13350e1e0d435dccc7128af110815e">CompressGzipWorkBufferSizeDefault</a> = <a class="el" href="namespacenn_1_1util.html#aa4dcb222bce2eb1d5209d12dad071028">CompressZlibWorkBufferSizeDefault</a></td></tr>
<tr class="memdesc:a2a13350e1e0d435dccc7128af110815e"><td class="mdescLeft">&#160;</td><td class="mdescRight">圧縮レベルと使用メモリレベルを指定しない <a class="el" href="namespacenn_1_1util.html#a1eaf5623ce101256fc619f5b5a03491c" title="Gzip 形式の deflate 圧縮を行う関数です。 ">CompressGzip()</a> で必要となるワークバッファのサイズ (バイト数) を定義した定数です。 <br /></td></tr>
<tr class="separator:a2a13350e1e0d435dccc7128af110815e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4dcb222bce2eb1d5209d12dad071028"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4dcb222bce2eb1d5209d12dad071028"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#aa4dcb222bce2eb1d5209d12dad071028">CompressZlibWorkBufferSizeDefault</a> = 268096</td></tr>
<tr class="memdesc:aa4dcb222bce2eb1d5209d12dad071028"><td class="mdescLeft">&#160;</td><td class="mdescRight">圧縮レベルと使用メモリレベルを指定しない <a class="el" href="namespacenn_1_1util.html#ae0290996b2f08a558763e919ca74fd0f" title="zlib 形式の deflate 圧縮を行う関数です。 ">CompressZlib()</a> で必要となるワークバッファのサイズ (バイト数) を定義した定数です。 <br /></td></tr>
<tr class="separator:aa4dcb222bce2eb1d5209d12dad071028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf5d72895f77ce0053fabf25e2f91f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcf5d72895f77ce0053fabf25e2f91f8"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#afcf5d72895f77ce0053fabf25e2f91f8">DecompressDeflateWorkBufferSize</a> = <a class="el" href="namespacenn_1_1util.html#ac41cb5e81653f3eecbe0a898da550b86">DecompressZlibWorkBufferSize</a></td></tr>
<tr class="memdesc:afcf5d72895f77ce0053fabf25e2f91f8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacenn_1_1util.html#aa24276fbb8f0d3892fdd9b076078d690" title="raw deflate 形式の deflate 伸長を行います。 ">DecompressDeflate()</a> で必要となるワークバッファのサイズ (バイト数) を定義した定数です。 <br /></td></tr>
<tr class="separator:afcf5d72895f77ce0053fabf25e2f91f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad5f8ed7845391894b9fe69be1f9a30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afad5f8ed7845391894b9fe69be1f9a30"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#afad5f8ed7845391894b9fe69be1f9a30">DecompressGzipWorkBufferSize</a> = <a class="el" href="namespacenn_1_1util.html#ac41cb5e81653f3eecbe0a898da550b86">DecompressZlibWorkBufferSize</a></td></tr>
<tr class="memdesc:afad5f8ed7845391894b9fe69be1f9a30"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacenn_1_1util.html#a8d0dd598671e1a5e68b15f48e4b02045" title="Gzip 形式の deflate 伸長を行います。 ">DecompressGzip()</a> で必要となるワークバッファのサイズ (バイト数) を定義した定数です。 <br /></td></tr>
<tr class="separator:afad5f8ed7845391894b9fe69be1f9a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41cb5e81653f3eecbe0a898da550b86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac41cb5e81653f3eecbe0a898da550b86"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#ac41cb5e81653f3eecbe0a898da550b86">DecompressZlibWorkBufferSize</a> = 7160</td></tr>
<tr class="memdesc:ac41cb5e81653f3eecbe0a898da550b86"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacenn_1_1util.html#a5ef5750312d89f54f3e11496c3414ef7" title="zlib 形式の deflate 伸長を行います。 ">DecompressZlib()</a> で必要となるワークバッファのサイズ (バイト数) を定義した定数です。 <br /></td></tr>
<tr class="separator:ac41cb5e81653f3eecbe0a898da550b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325b9b74fce32f090061ebdefb9b024b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a325b9b74fce32f090061ebdefb9b024b"></a>
const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1util.html#a325b9b74fce32f090061ebdefb9b024b">FloatPi</a></td></tr>
<tr class="memdesc:a325b9b74fce32f090061ebdefb9b024b"><td class="mdescLeft">&#160;</td><td class="mdescRight">float 型によって π の値を表現します。 <br /></td></tr>
<tr class="separator:a325b9b74fce32f090061ebdefb9b024b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p>ユーティリティライブラリの名前空間です。 </p>
</div><h2 class="groupheader">型定義詳解</h2>
<a class="anchor" id="a52f1145aad43f345157c51d999aff9fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* nn::util::FormatStringOutputFunction)(uintptr_t arg, const char *pCharacters, int count)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacenn_1_1util.html#a54f65dcb71d5cb6e32f327ccab7f796c">FormatString()</a>, <a class="el" href="namespacenn_1_1util.html#a1054c37da4a1d20fe6b0ca90a8ca351c">VFormatString()</a> が生成した文字列を受け取るコールバック関数の型です。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>ユーザ定義の引数です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCharacters</td><td>生成された文字列です。ヌル終端されていません。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>pCharacters が指す先の文字数です。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><em>pCharacters</em> != nullptr </dd>
<dd>
<em>count</em> &gt; 0 </dd>
<dd>
<em>pCharacters</em> は、<em>count</em> と同じ数のヌル文字ではない要素を持つ char 型の配列を指す</dd></dl>
<p><b>詳細</b> <br />
生成された文字列は、1 文字以上の複数のブロックに分割され、先頭から順に 1 ブロックずつこの関数に与えられます。この関数は、例外をスローしてはいけません。 </p>

</div>
</div>
<a class="anchor" id="ae9beb7ac8f35cef8dd13f0416662320a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html">StreamingDecompressZlibContext</a> <a class="el" href="namespacenn_1_1util.html#ae9beb7ac8f35cef8dd13f0416662320a">nn::util::StreamingDecompressGzipContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gzip 形式の圧縮データのストリーミング伸長用コンテキストです。 </p>
<p><b>詳細</b> <br />
 gzip 形式の圧縮データのストリーミング伸長用コンテキストです。メンバに直接アクセスしないでください。<br />
 サイズが大きいため、スタック上に置く場合にはスタックサイズにご注意ください。 本構造体は 8 Byte アラインされている必要があります。 </p>

</div>
</div>
<a class="anchor" id="af2ed3b5d58dc0275f9c96f4d4ec7a079"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html">StreamingDecompressZlibContext</a> <a class="el" href="namespacenn_1_1util.html#af2ed3b5d58dc0275f9c96f4d4ec7a079">nn::util::StreamingDecompressDeflateContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>raw deflate 形式の圧縮データのストリーミング伸長用コンテキストです。 </p>
<p><b>詳細</b> <br />
 raw deflate 形式の圧縮データのストリーミング伸長用コンテキストです。メンバに直接アクセスしないでください。<br />
 サイズが大きいため、スタック上に置く場合にはスタックサイズにご注意ください。 本構造体は 8 Byte アラインされている必要があります。 </p>

</div>
</div>
<a class="anchor" id="a57660aa7758ae3375aeffbd6b1424b24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1util_1_1_matrix_row_major3x2f_type.html">MatrixRowMajor3x2fType</a> <a class="el" href="namespacenn_1_1util.html#a57660aa7758ae3375aeffbd6b1424b24">nn::util::Matrix3x2fType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>単精度浮動小数点型による 3 行 2 列の行列を表現します。 </p>
<p><b>詳細</b> <br />
 ベクトル・行列計算を提供する型です。</p>
<p>この型を用いた計算は、SIMD ユニットを使える環境においては、SIMD ユニットを利用した実装に切り替わることを想定しています。 SIMD ユニットを使えない環境では、汎用の実装を提供します。</p>
<dl class="section attention"><dt>注意</dt><dd>この型は、計算のために最適化されています。このため、メモリレイアウトもサイズも環境によって 異なる場合があります。よって、 <b>内部要素への直接のアクセスは禁止します</b> 。 要素へのアクセスは、専用のマクロ、および、関数を利用してください。</dd>
<dd>
また、SIMD ユニットでの計算を最適化するため、この型はメモリアライメントを要求します。 <b>この型をメモリ上に確保する場合には、要求されるアライメントを満たすよう注意してください。</b> 要求するアライメントは内部実装ごとに異なる場合があります。それぞれの実装が要求するアライメントを列挙します。<ul>
<li>汎用実装版：16 byte</li>
<li>NEON 実装版：8 byte</li>
</ul>
汎用実装版は、他のすべての SIMD 実装版が要求するアライメントを満たすことができるようにアライメントを指定してします。 </dd></dl>

</div>
</div>
<a class="anchor" id="afb360b0e9579454c6af5804cc476c101"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1util_1_1_matrix_row_major4x3f_type.html">MatrixRowMajor4x3fType</a> <a class="el" href="namespacenn_1_1util.html#afb360b0e9579454c6af5804cc476c101">nn::util::Matrix4x3fType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>単精度浮動小数点型による 4 行 3 列の行列を表現します。 </p>
<p><b>詳細</b> <br />
 ベクトル・行列計算を提供する型です。</p>
<p>この型を用いた計算は、SIMD ユニットを使える環境においては、SIMD ユニットを利用した実装に切り替わることを想定しています。 SIMD ユニットを使えない環境では、汎用の実装を提供します。</p>
<dl class="section attention"><dt>注意</dt><dd>この型は、計算のために最適化されています。このため、メモリレイアウトもサイズも環境によって 異なる場合があります。よって、 <b>内部要素への直接のアクセスは禁止します</b> 。 要素へのアクセスは、専用のマクロ、および、関数を利用してください。</dd>
<dd>
また、SIMD ユニットでの計算を最適化するため、この型はメモリアライメントを要求します。 <b>この型をメモリ上に確保する場合には、要求されるアライメントを満たすよう注意してください。</b> 要求するアライメントは内部実装ごとに異なる場合があります。それぞれの実装が要求するアライメントを列挙します。<ul>
<li>汎用実装版：16 byte</li>
<li>NEON 実装版：16 byte</li>
</ul>
汎用実装版は、他のすべての SIMD 実装版が要求するアライメントを満たすことができるようにアライメントを指定してします。 </dd></dl>

</div>
</div>
<a class="anchor" id="a1bb0d5db7601e1af28a6f5b90cd5fd16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html">MatrixRowMajor4x4fType</a> <a class="el" href="namespacenn_1_1util.html#a1bb0d5db7601e1af28a6f5b90cd5fd16">nn::util::Matrix4x4fType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>単精度浮動小数点型による 4 行 4 列の行列を表現します。 </p>
<p><b>詳細</b> <br />
 ベクトル・行列計算を提供する型です。</p>
<p>この型を用いた計算は、SIMD ユニットを使える環境においては、SIMD ユニットを利用した実装に切り替わることを想定しています。 SIMD ユニットを使えない環境では、汎用の実装を提供します。</p>
<dl class="section attention"><dt>注意</dt><dd>この型は、計算のために最適化されています。このため、メモリレイアウトもサイズも環境によって 異なる場合があります。よって、 <b>内部要素への直接のアクセスは禁止します</b> 。 要素へのアクセスは、専用のマクロ、および、関数を利用してください。</dd>
<dd>
また、SIMD ユニットでの計算を最適化するため、この型はメモリアライメントを要求します。 <b>この型をメモリ上に確保する場合には、要求されるアライメントを満たすよう注意してください。</b> 要求するアライメントは内部実装ごとに異なる場合があります。それぞれの実装が要求するアライメントを列挙します。<ul>
<li>汎用実装版：16 byte</li>
<li>NEON 実装版：16 byte</li>
</ul>
汎用実装版は、他のすべての SIMD 実装版が要求するアライメントを満たすことができるようにアライメントを指定してします。 </dd></dl>

</div>
</div>
<a class="anchor" id="a0393f5ea2f2d2bc1a17ff98976f4b084"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1util_1_1_matrix_column_major3x2f_type.html">MatrixColumnMajor3x2fType</a> <a class="el" href="namespacenn_1_1util.html#a0393f5ea2f2d2bc1a17ff98976f4b084">nn::util::MatrixT3x2fType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>単精度浮動小数点型による 3 行 2 列の行列を表現します。 <a class="el" href="namespacenn_1_1util.html#a57660aa7758ae3375aeffbd6b1424b24" title="単精度浮動小数点型による 3 行 2 列の行列を表現します。 ">nn::util::Matrix3x2fType</a> に対し、行と列の優先度が逆転されたメモリレイアウトを持ちます。 </p>
<p><b>詳細</b> <br />
 ベクトル・行列計算を提供する型です。</p>
<p>この型を用いた計算は、SIMD ユニットを使える環境においては、SIMD ユニットを利用した実装に切り替わることを想定しています。 SIMD ユニットを使えない環境では、汎用の実装を提供します。</p>
<dl class="section attention"><dt>注意</dt><dd>この型は、計算のために最適化されています。このため、メモリレイアウトもサイズも環境によって 異なる場合があります。よって、 <b>内部要素への直接のアクセスは禁止します</b> 。 要素へのアクセスは、専用のマクロ、および、関数を利用してください。</dd>
<dd>
また、SIMD ユニットでの計算を最適化するため、この型はメモリアライメントを要求します。 <b>この型をメモリ上に確保する場合には、要求されるアライメントを満たすよう注意してください。</b> 要求するアライメントは内部実装ごとに異なる場合があります。それぞれの実装が要求するアライメントを列挙します。<ul>
<li>汎用実装版：16 byte</li>
<li>NEON 実装版：16 byte</li>
</ul>
汎用実装版は、他のすべての SIMD 実装版が要求するアライメントを満たすことができるようにアライメントを指定してします。 </dd></dl>

</div>
</div>
<a class="anchor" id="aae68b9728d824289e709226f88f4326d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1util_1_1_matrix_column_major4x3f_type.html">MatrixColumnMajor4x3fType</a> <a class="el" href="namespacenn_1_1util.html#aae68b9728d824289e709226f88f4326d">nn::util::MatrixT4x3fType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>単精度浮動小数点型による 4 行 3 列の行列を表現します。 <a class="el" href="namespacenn_1_1util.html#afb360b0e9579454c6af5804cc476c101" title="単精度浮動小数点型による 4 行 3 列の行列を表現します。 ">nn::util::Matrix4x3fType</a> に対し、行と列の優先度が逆転されたメモリレイアウトを持ちます。 </p>
<p><b>詳細</b> <br />
 ベクトル・行列計算を提供する型です。</p>
<p>この型を用いた計算は、SIMD ユニットを使える環境においては、SIMD ユニットを利用した実装に切り替わることを想定しています。 SIMD ユニットを使えない環境では、汎用の実装を提供します。</p>
<dl class="section attention"><dt>注意</dt><dd>この型は、計算のために最適化されています。このため、メモリレイアウトもサイズも環境によって 異なる場合があります。よって、 <b>内部要素への直接のアクセスは禁止します</b> 。 要素へのアクセスは、専用のマクロ、および、関数を利用してください。</dd>
<dd>
また、SIMD ユニットでの計算を最適化するため、この型はメモリアライメントを要求します。 <b>この型をメモリ上に確保する場合には、要求されるアライメントを満たすよう注意してください。</b> 要求するアライメントは内部実装ごとに異なる場合があります。それぞれの実装が要求するアライメントを列挙します。<ul>
<li>汎用実装版：16 byte</li>
<li>NEON 実装版：16 byte</li>
</ul>
汎用実装版は、他のすべての SIMD 実装版が要求するアライメントを満たすことができるようにアライメントを指定してします。 </dd></dl>

</div>
</div>
<a class="anchor" id="aa93b34341c777e6d93d6341520acebc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1util_1_1_matrix_column_major4x4f_type.html">MatrixColumnMajor4x4fType</a> <a class="el" href="namespacenn_1_1util.html#aa93b34341c777e6d93d6341520acebc8">nn::util::MatrixT4x4fType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>単精度浮動小数点型による 4 行 4 列の行列を表現します。 <a class="el" href="namespacenn_1_1util.html#a1bb0d5db7601e1af28a6f5b90cd5fd16" title="単精度浮動小数点型による 4 行 4 列の行列を表現します。 ">nn::util::Matrix4x4fType</a> に対し、行と列の優先度が逆転されたメモリレイアウトを持ちます。 </p>
<p><b>詳細</b> <br />
 ベクトル・行列計算を提供する型です。</p>
<p>この型を用いた計算は、SIMD ユニットを使える環境においては、SIMD ユニットを利用した実装に切り替わることを想定しています。 SIMD ユニットを使えない環境では、汎用の実装を提供します。</p>
<dl class="section attention"><dt>注意</dt><dd>この型は、計算のために最適化されています。このため、メモリレイアウトもサイズも環境によって 異なる場合があります。よって、 <b>内部要素への直接のアクセスは禁止します</b> 。 要素へのアクセスは、専用のマクロ、および、関数を利用してください。</dd>
<dd>
また、SIMD ユニットでの計算を最適化するため、この型はメモリアライメントを要求します。 <b>この型をメモリ上に確保する場合には、要求されるアライメントを満たすよう注意してください。</b> 要求するアライメントは内部実装ごとに異なる場合があります。それぞれの実装が要求するアライメントを列挙します。<ul>
<li>汎用実装版：16 byte</li>
<li>NEON 実装版：16 byte</li>
</ul>
汎用実装版は、他のすべての SIMD 実装版が要求するアライメントを満たすことができるようにアライメントを指定してします。 </dd></dl>

</div>
</div>
<a class="anchor" id="ad703d4cc91629b6b26764a5d1506efd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classnn_1_1util_1_1_matrix_row_major3x2f.html">MatrixRowMajor3x2f</a> <a class="el" href="namespacenn_1_1util.html#ad703d4cc91629b6b26764a5d1506efd8">nn::util::Matrix3x2f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>単精度浮動小数点型による 3 行 2 列の行列を行優先で表現するクラスです。 </p>
<p><b>詳細</b> <br />
 ベクトル・行列計算を提供する型です。</p>
<p><a class="el" href="structnn_1_1util_1_1_matrix_row_major3x2f_type.html" title="単精度浮動小数点型による 3 行 2 列の行列を行優先で表現します。 nn::util::MatrixColumnMajor3x2fType に...">nn::util::MatrixRowMajor3x2fType</a> を継承し、メソッドを追加するユーティリティクラスです。</p>
<p>この型を用いた計算は、SIMD ユニットを使える環境においては、SIMD ユニットを利用した実装に切り替わることを想定しています。 SIMD ユニットを使えない環境では、汎用の実装を提供します。</p>
<dl class="section attention"><dt>注意</dt><dd>この型は、計算のために最適化されています。このため、メモリレイアウトもサイズも環境によって 異なる場合があります。よって、 <b>内部要素への直接のアクセスは禁止します</b> 。 要素へのアクセスは、専用のマクロ、および、関数を利用してください。</dd>
<dd>
また、SIMD ユニットでの計算を最適化するため、この型は、 <b>メモリアライメントとして16byte境界に配置されることを要求します</b> 。 この型をメモリ上に確保する場合には、要求されるアライメントを満たすよう注意してください。 </dd></dl>

</div>
</div>
<a class="anchor" id="a144c36edc0c1d0762f88b59f0a754b6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classnn_1_1util_1_1_matrix_row_major4x3f.html">MatrixRowMajor4x3f</a> <a class="el" href="namespacenn_1_1util.html#a144c36edc0c1d0762f88b59f0a754b6a">nn::util::Matrix4x3f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>単精度浮動小数点型による 4 行 3 列の行列を行優先で表現するクラスです。 </p>
<p><b>詳細</b> <br />
 ベクトル・行列計算を提供する型です。</p>
<p><a class="el" href="structnn_1_1util_1_1_matrix_row_major4x3f_type.html" title="単精度浮動小数点型による 4 行 3 列の行列を行優先で表現します。 nn::util::MatrixColumnMajor4x3fType に...">nn::util::MatrixRowMajor4x3fType</a> を継承し、メソッドを追加するユーティリティクラスです。</p>
<p>この型を用いた計算は、SIMD ユニットを使える環境においては、SIMD ユニットを利用した実装に切り替わることを想定しています。 SIMD ユニットを使えない環境では、汎用の実装を提供します。</p>
<dl class="section attention"><dt>注意</dt><dd>この型は、計算のために最適化されています。このため、メモリレイアウトもサイズも環境によって 異なる場合があります。よって、 <b>内部要素への直接のアクセスは禁止します</b> 。 要素へのアクセスは、専用のマクロ、および、関数を利用してください。</dd>
<dd>
また、SIMD ユニットでの計算を最適化するため、この型は、 <b>メモリアライメントとして16byte境界に配置されることを要求します</b> 。 この型をメモリ上に確保する場合には、要求されるアライメントを満たすよう注意してください。 </dd></dl>

</div>
</div>
<a class="anchor" id="ad3916074464578212a8a939a4dbd08ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classnn_1_1util_1_1_matrix_row_major4x4f.html">MatrixRowMajor4x4f</a> <a class="el" href="namespacenn_1_1util.html#ad3916074464578212a8a939a4dbd08ae">nn::util::Matrix4x4f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>単精度浮動小数点型による 4 行 4 列の行列を行優先で表現するクラスです。 </p>
<p><b>詳細</b> <br />
 ベクトル・行列計算を提供する型です。</p>
<p><a class="el" href="structnn_1_1util_1_1_matrix_row_major4x4f_type.html" title="単精度浮動小数点型による 4 行 4 列の行列を行優先で表現します。 nn::util::MatrixColumnMajor4x4fType に...">nn::util::MatrixRowMajor4x4fType</a> を継承し、メソッドを追加するユーティリティクラスです。</p>
<p>この型を用いた計算は、SIMD ユニットを使える環境においては、SIMD ユニットを利用した実装に切り替わることを想定しています。 SIMD ユニットを使えない環境では、汎用の実装を提供します。</p>
<dl class="section attention"><dt>注意</dt><dd>この型は、計算のために最適化されています。このため、メモリレイアウトもサイズも環境によって 異なる場合があります。よって、 <b>内部要素への直接のアクセスは禁止します</b> 。 要素へのアクセスは、専用のマクロ、および、関数を利用してください。</dd>
<dd>
また、SIMD ユニットでの計算を最適化するため、この型は、 <b>メモリアライメントとして16byte境界に配置されることを要求します</b> 。 この型をメモリ上に確保する場合には、要求されるアライメントを満たすよう注意してください。 </dd></dl>

</div>
</div>
<h2 class="groupheader">列挙型詳解</h2>
<a class="anchor" id="a8ab72d7227a9a1b56f78d0caf2920478"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">nn::util::CharacterEncodingResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>文字エンコーディング変換の結果(エラーコード)です。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a8ab72d7227a9a1b56f78d0caf2920478a7f284c7d118115284232bd26b33c2149"></a>CharacterEncodingResult_Success&#160;</td><td class="fielddoc">
<p>正常に変換されました。 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8ab72d7227a9a1b56f78d0caf2920478aba616796fb8ce72bd5f1455c621a47b2"></a>CharacterEncodingResult_InsufficientLength&#160;</td><td class="fielddoc">
<p>変換先の配列の長さが不足しました。 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8ab72d7227a9a1b56f78d0caf2920478aae294bb0babe7737681d80af74cef4a4"></a>CharacterEncodingResult_InvalidFormat&#160;</td><td class="fielddoc">
<p>変換できない文字が検出されました。 </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a4a5a5a34319b208c9c23ac038d412a31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1util.html#a4a5a5a34319b208c9c23ac038d412a31">nn::util::ByteOrderMark</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>バイトオーダーマークを示す列挙体です。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a4a5a5a34319b208c9c23ac038d412a31af47a310dc26e97a75adae293e89fd52f"></a>ByteOrderMark_Normal&#160;</td><td class="fielddoc">
<p>通常のバイトオーダーマークです。 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4a5a5a34319b208c9c23ac038d412a31a59a43d310e2ac1c3f6a852eb5e2f789e"></a>ByteOrderMark_Reverse&#160;</td><td class="fielddoc">
<p>エンディアン反転したバイトオーダーマークです。 </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a class="anchor" id="a10095886df100ad8cf72878d35bc5977"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename Tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">BitFlagSet</a>&lt;N, Tag&gt; nn::util::MakeBitFlagSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>全てのビットフラグが false に初期化された <a class="el" href="structnn_1_1util_1_1_bit_flag_set.html" title="POD のビットフラグ集合を扱う型です。 ">BitFlagSet</a> を取得します。 </p>
<p><b>詳細</b> <br />
 関数内で自動変数を確保して、値渡しでコピーを返します。 N が大きい場合、スタックのサイズなどに注意してください。</p>
<dl class="section return"><dt>戻り値</dt><dd>全てのビットフラグが false のビットフラグ集合 </dd></dl>

</div>
</div>
<a class="anchor" id="a794d0154e80155ad5f358910b839f343"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1util_1_1_bit_flag_set.html">BitFlagSet</a>&lt;N, void&gt; nn::util::MakeBitFlagSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>全てのビットフラグが false に初期化された <a class="el" href="structnn_1_1util_1_1_bit_flag_set.html" title="POD のビットフラグ集合を扱う型です。 ">BitFlagSet</a> を取得します。 </p>
<p><b>詳細</b> <br />
 関数内で自動変数を確保して、値渡しでコピーを返します。 N が大きい場合、スタックのサイズなどに注意してください。</p>
<dl class="section return"><dt>戻り値</dt><dd>全てのビットフラグが false のビットフラグ集合 </dd></dl>

</div>
</div>
<a class="anchor" id="a442cc38c3c616eee03f1b66743376fa3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::reverse_bits </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subword_bits</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_swar_words</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>値をビット列に見立て、ビットの並び順を反転します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subword_bits</td><td>ビットの並び順を反転する単位を指定します。デフォルト値は 1 です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_swar_words</td><td>ビット列を分割するグループ数を指定します。デフォルト値は 1 です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>- 0 &lt; num_swar_words &lt;= <a class="el" href="nn___macro_8h.html#a23315db1de12907672e0e65f9211dda0">NN_BITSIZEOF( T )</a><ul>
<li><a class="el" href="nn___macro_8h.html#a23315db1de12907672e0e65f9211dda0">NN_BITSIZEOF( T )</a> % num_swar_words == 0</li>
<li>0 &lt; subword_bits &lt;= <a class="el" href="nn___macro_8h.html#a23315db1de12907672e0e65f9211dda0">NN_BITSIZEOF( T )</a></li>
<li>( <a class="el" href="nn___macro_8h.html#a23315db1de12907672e0e65f9211dda0">NN_BITSIZEOF( T )</a> / num_swar_words ) % subword_bits == 0</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 ビット列を num_swar_words 個に分割した各グループ内で、subword_bits 個のビットの組を作り、その並び順を反転します。 グループ自体の並び順は変化せず、組内のビットの並び順も変化しません。<br />
 例）8 ビットのビット列を ABCDEFGH と表記した場合、結果は以下のようになります。 <br />
 reverse_bits(ABCDEFGH) -&gt; HGFEDCBA<br />
 reverse_bits(ABCDEFGH, 1, 2) -&gt; DCBAHGFE<br />
 reverse_bits(ABCDEFGH, 1, 4) -&gt; BADCFEHG<br />
 reverse_bits(ABCDEFGH, 2, 1) -&gt; GHEFCDAB<br />
 reverse_bits(ABCDEFGH, 2, 2) -&gt; CDABGHEF<br />
 reverse_bits(ABCDEFGH, 4, 1) -&gt; EFGHABCD </p>

</div>
</div>
<a class="anchor" id="aec88a4a55dad4af44a729577bb2798f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::reverse_bytes </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subword_bytes</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_swar_words</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>値をバイト列に見立て、バイトの並び順を反転します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subword_bytes</td><td>バイトの並び順を反転する単位を指定します。デフォルト値は 1 です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_swar_words</td><td>バイト列を分割するグループ数を指定します。デフォルト値は 1 です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>- 0 &lt; num_swar_words &lt;= sizeof( T )<ul>
<li>sizeof( T ) % num_swar_words == 0</li>
<li>0 &lt; subword_bytes &lt;= sizeof( T )</li>
<li>( sizeof( T ) / num_swar_words ) % subword_bytes == 0</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 バイト列を num_swar_words 個に分割した各グループ内で、subword_bytes 個のバイトの組を作り、その並び順を反転します。 グループ自体の並び順は変化せず、組内のバイトの並び順も変化しません。<br />
 例）8 バイトのバイト列を ABCDEFGH と表記した場合、結果は以下のようになります。 <br />
 reverse_bytes(ABCDEFGH) -&gt; HGFEDCBA<br />
 reverse_bytes(ABCDEFGH, 1, 2) -&gt; DCBAHGFE<br />
 reverse_bytes(ABCDEFGH, 1, 4) -&gt; BADCFEHG<br />
 reverse_bytes(ABCDEFGH, 2, 1) -&gt; GHEFCDAB<br />
 reverse_bytes(ABCDEFGH, 2, 2) -&gt; CDABGHEF<br />
 reverse_bytes(ABCDEFGH, 4, 1) -&gt; EFGHABCD </p>

</div>
</div>
<a class="anchor" id="aa4bb961273418194ab364a658116159f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::is_aligned </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>値が指定したアライメントに揃っているかどうかを返します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">align</td><td>指定するアライメントです。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>align は 2 のべき乗である必要があります。 </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_memory_pool_8cpp-example.html#a97">AudioMemoryPool.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a20f6772d3ae70168e07e0f39d416d72e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::align_up </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>値を指定したアライメントまで切り上げます。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">align</td><td>指定するアライメントです。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>align は 2 のべき乗である必要があります。 </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_cpu_renderer_8cpp-example.html#a82">AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_echoback_8cpp-example.html#a45">AudioEchoback.cpp</a>, <a class="el" href="_audio_memory_pool_8cpp-example.html#a58">AudioMemoryPool.cpp</a>, <a class="el" href="_audio_out_8cpp-example.html#a63">AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_8cpp-example.html#a61">AudioOutWithResampler.cpp</a>, <a class="el" href="_audio_sink_8cpp-example.html#a80">AudioSink.cpp</a>, <a class="el" href="_codec_aac_decoder_8cpp-example.html#a29">CodecAacDecoder.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a44">FontDemo/Main.cpp</a>, <a class="el" href="_framework_demo_2_main_8cpp-example.html#a28">FrameworkDemo/Main.cpp</a>, <a class="el" href="_gfx_primitive_renderer_8cpp-example.html#a39">GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_gfx_shader_compile_8cpp-example.html#a49">GfxShaderCompile.cpp</a>, <a class="el" href="_gfx_simple_8cpp-example.html#a56">GfxSimple.cpp</a>, <a class="el" href="_gfx_simple_compute_8cpp-example.html#a23">GfxSimpleCompute.cpp</a>, <a class="el" href="_hid_gesture__main_8cpp-example.html#a2">HidGesture_Main.cpp</a>, <a class="el" href="_hid_keyboard_and_mouse__main_8cpp-example.html#a19">HidKeyboardAndMouse_Main.cpp</a>, <a class="el" href="_hid_npad_six_axis_sensor__main_8cpp-example.html#a72">HidNpadSixAxisSensor_Main.cpp</a>, <a class="el" href="_hid_simple__main_8cpp-example.html#a12">HidSimple_Main.cpp</a>, <a class="el" href="_mii_compressed_texture_8cpp-example.html#a60">MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_8cpp-example.html#a58">MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_8cpp-example.html#a61">MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_8cpp-example.html#a327">MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_8cpp-example.html#a308">MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_8cpp-example.html#a72">MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_8cpp-example.html#a57">MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_8cpp-example.html#a72">MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_8cpp-example.html#a62">MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_8cpp-example.html#a58">MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_8cpp-example.html#a73">MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_8cpp-example.html#a73">MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_8cpp-example.html#a75">MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_8cpp-example.html#a58">MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_8cpp-example.html#a73">MiiTransparentAdjuster.cpp</a>, <a class="el" href="_pcm_basic_8cpp-example.html#a11">PcmBasic.cpp</a>, <a class="el" href="_swkbd_simple_8cpp-example.html#a2">SwkbdSimple.cpp</a>, <a class="el" href="_tutorial_base_class_8_nx_8cpp-example.html#a2">TutorialBaseClass.Nx.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a60">Ui2dDemo/Main.cpp</a>, <a class="el" href="_vfx_custom_shader_2main_8cpp-example.html#a11">VfxCustomShader/main.cpp</a>, <a class="el" href="_vk_simple_8cpp-example.html#a20">VkSimple.cpp</a> (計38項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8a8aac07f25fdd659091e1065b8c89a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::align_down </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>値を指定したアライメントまで切り下げます。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">align</td><td>指定するアライメントです。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>align は 2 のべき乗である必要があります。 </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_gfx_primitive_renderer_8cpp-example.html#a43">GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_gfx_shader_compile_8cpp-example.html#a34">GfxShaderCompile.cpp</a>, <a class="el" href="_gfx_simple_8cpp-example.html#a41">GfxSimple.cpp</a>, <a class="el" href="_mii_compressed_texture_8cpp-example.html#a34">MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_8cpp-example.html#a32">MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_8cpp-example.html#a35">MiiDynamicMask.cpp</a>, <a class="el" href="_mii_headwear_example_8cpp-example.html#a46">MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_8cpp-example.html#a31">MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_8cpp-example.html#a48">MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_8cpp-example.html#a36">MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_8cpp-example.html#a32">MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_8cpp-example.html#a49">MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_8cpp-example.html#a49">MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_8cpp-example.html#a51">MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_8cpp-example.html#a32">MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_8cpp-example.html#a49">MiiTransparentAdjuster.cpp</a>, <a class="el" href="_os_user_exception_handler_sample_8cpp-example.html#a33">OsUserExceptionHandlerSample.cpp</a> (計17項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1e0e8eb18b9bf7c45a0b222f08026d36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::rstls1b </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>最下位の 1 のビットをオフにします。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。</dd></dl>
<p><b>詳細</b> <br />
 例) 1100 1100 -&gt; 1100 1000 </p>

</div>
</div>
<a class="anchor" id="a801a3a648e244cdd89d9160072cc45d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::setls0b </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>最下位の 0 のビットをオンにします。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。</dd></dl>
<p><b>詳細</b> <br />
 例) 0011 0011 -&gt; 0011 0111 </p>

</div>
</div>
<a class="anchor" id="a669332e770e1518ea78380e2d399f23d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::rstt1 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>末尾から連続した 1 のビットをオフにします。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。</dd></dl>
<p><b>詳細</b> <br />
 例) 0011 0011 -&gt; 0011 0000 </p>

</div>
</div>
<a class="anchor" id="aeacb11a5bb14955680167c808d46cefe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::sett0 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>末尾から連続した 0 のビットをオンにします。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。</dd></dl>
<p><b>詳細</b> <br />
 例) 1100 1100 -&gt; 1100 1111 </p>

</div>
</div>
<a class="anchor" id="aa000931755cf4ee96cef173d261906fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::isols1b </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>最下位の 1 のビットを取り出します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。</dd></dl>
<p><b>詳細</b> <br />
 例) 1100 1100 -&gt; 0000 0100 </p>

</div>
</div>
<a class="anchor" id="a0ce2d5521d5721a8369ab94a517a3025"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::isols0b </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>最下位の 0 のビットを取り出します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。</dd></dl>
<p><b>詳細</b> <br />
 例) 0011 0011 -&gt; 0000 0100 </p>

</div>
</div>
<a class="anchor" id="abf080f682f24fb4db8c3d4b7fc25a4d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::maskt1 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>末尾から連続した 1 のビットを取り出します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。</dd></dl>
<p><b>詳細</b> <br />
 例) 0011 0011 -&gt; 0000 0011 </p>

</div>
</div>
<a class="anchor" id="a44e5c98cd030634573aa1f3501a12736"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::maskt0 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>末尾から連続した 0 のビットを取り出します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。</dd></dl>
<p><b>詳細</b> <br />
 例) 1100 1100 -&gt; 0000 0011 </p>

</div>
</div>
<a class="anchor" id="ad1602964837b0e9b8356a0542732429a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::maskt1ls0b </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>末尾から連続した 1 のビットと最下位の 0 のビットを取り出します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。</dd></dl>
<p><b>詳細</b> <br />
 例) 0011 0011 -&gt; 0000 0111 </p>

</div>
</div>
<a class="anchor" id="a72c58ebce6b25b6a63ed95fdbbd386a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::maskt0ls1b </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>末尾から連続した 0 のビットと最下位の 1 のビットを取り出します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。</dd></dl>
<p><b>詳細</b> <br />
 例) 1100 1100 -&gt; 0000 0111 </p>

</div>
</div>
<a class="anchor" id="afa975b1fe1cbcef0ad99b6645570ab58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int nn::util::popcount </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 のビットを数えます。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="af91281f707e3985a66a2c928437f9fc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int nn::util::cntl0 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>最上位から連続する 0 のビットの数を返します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a14aa0f35aab537531b957aae86e34d94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int nn::util::cntt0 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>最下位から連続する 0 のビットの数を返します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="ab102f7cde538f702ebfef646d607a6ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::ispow2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定した値が 2 のべき乗かどうかを返します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>x が正の 2 のべき乗である場合に true を返します。 x が 0 の場合は false を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a88ee8bca4a8928f620e06490c8482ceb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::floorp2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定した値以下の最大の 2 のべき乗の値を返します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>x &gt; 0 </dd></dl>

</div>
</div>
<a class="anchor" id="a71655747c24554cc0f2627b271e0f652"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::ceilp2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定した値以上の最小の 2 のべき乗の値を返します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数値の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>指定する値です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>x &gt; 0 </dd></dl>

</div>
</div>
<a class="anchor" id="aa1e0fe7ee3200b52cca718befdabe5fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::DivideUp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>divider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>端数を切り上げつつ値を指定した数値で割ります。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>被除数の型です。 </td></tr>
    <tr><td class="paramname">U</td><td>除数の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>被除数です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">divider</td><td>除数です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>x &gt; 0</li>
<li>divider &gt; 0 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a56e0e9db954e75303566caf960d8934f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::SwapEndian </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>エンディアンを反転します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>データの型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pData</td><td>指定するデータのポインタです。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11528ff78b0c478ba7980afb1fb758ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::LoadEndianReversed </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pSrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>エンディアンを反転しながらデータをメモリから読み込みます。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>データの型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>指定するデータです。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>読み込んだ結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a5cc3f4e75adbd4dd9a3aaeb81fabb7a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::StoreEndianReversed </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>エンディアンを反転しながらデータをメモリに書き出します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>データの型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>データの書き出し先です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>書き出すデータです。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93bc440e1aa171900411796a54701ac7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::LoadBigEndian </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pSrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ビッグエンディアンのデータをメモリから読み込みます。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>データの型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>指定するデータです。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>読み込んだ結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a502929487c357dad5613feb3cc1d8ca1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::StoreBigEndian </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ビッグエンディアンでデータをメモリに書き出します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>データの型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>データの書き出し先です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>書き出すデータです。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abe1fe27e9543f7398c23221c9dc7f86f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::LoadLittleEndian </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pSrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>リトルエンディアンのデータをメモリから読み込みます。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>データの型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>指定するデータです。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>読み込んだ結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a2462759e94b37f3c9dfb92406fbc4ec9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::StoreLittleEndian </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>リトルエンディアンでデータをメモリに書き出します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>データの型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>データの書き出し先です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>書き出すデータです。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54f65dcb71d5cb6e32f327ccab7f796c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::FormatString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#a52f1145aad43f345157c51d999aff9fb">FormatStringOutputFunction</a>&#160;</td>
          <td class="paramname"><em>pOutputFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>outputFunctionArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>文字列をフォーマットします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pOutputFunction</td><td>生成された文字列を順次受け取る出力コールバック関数です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputFunctionArg</td><td>出力コールバック関数に与えられる、ユーザ定義の引数です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFormat</td><td>printf スタイルの書式指定文字列です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>書式指定文字列に与える引数です。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><em>pOutputFunction</em> != nullptr </dd>
<dd>
<em>pFormat</em> != nullptr </dd>
<dd>
書式指定文字列 <em>pFormat</em> は、printf スタイルの書式指定文字列である </dd>
<dd>
書式指定文字列 <em>pFormat</em> が要求する引数が ... に与えられている </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>生成された文字列全体が <em>pOutputFunction</em> に与えられた</dd></dl>
<p><b>詳細</b> <br />
文字列をフォーマットし、順次 <em>pOutputFunction</em> に与えます。 生成された文字列は、1 文字以上の複数のブロックに分割され、先頭から順に 1 ブロックずつ <em>pOutputFunction</em> に与えられます。</p>
<p><em>pOutputFunction</em> は、例外をスローしてはいけません。</p>
<p>書式指定文字列の形式は、C99 printf と同様です。ただし、以下の相違点があります。</p>
<ul>
<li>変換指定子 n が削除されています。</li>
</ul>
<p>変換指定は、以下のものが指定可能です。</p>
<ul>
<li>フラグ<ul>
<li>+, -, 空白, #, 0</li>
</ul>
</li>
<li>フィールド幅<ul>
<li>数値, *</li>
</ul>
</li>
<li>精度<ul>
<li>数値, *</li>
</ul>
</li>
<li>長さ修飾子<ul>
<li>hh, h, l, j, z, t, L</li>
</ul>
</li>
<li>変換指定子<ul>
<li>s, c, d, i, o, u, x, X, a, A, e, E, f, F, g, G, p, %</li>
</ul>
</li>
</ul>
<dl class="section attention"><dt>注意</dt><dd>現在、以下の制限があります。<ul>
<li>long double の値は、 double にキャストされて double の精度で文字列に変換されます。</li>
<li>浮動小数点数の変換は、丸め精度が正しくありません。 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1054c37da4a1d20fe6b0ca90a8ca351c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::VFormatString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#a52f1145aad43f345157c51d999aff9fb">FormatStringOutputFunction</a>&#160;</td>
          <td class="paramname"><em>pOutputFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>outputFunctionArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::va_list&#160;</td>
          <td class="paramname"><em>formatArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>文字列をフォーマットします。書式指定文字列に与える引数を std::va_list で受け取る以外は、<a class="el" href="namespacenn_1_1util.html#a54f65dcb71d5cb6e32f327ccab7f796c">FormatString()</a> と同一です。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pOutputFunction</td><td>出力文字列を順次受け取る出力コールバック関数です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputFunctionArg</td><td>出力コールバック関数に与えられる、ユーザ定義の引数です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFormat</td><td>printf スタイルの書式指定文字列です。詳細は <a class="el" href="namespacenn_1_1util.html#a54f65dcb71d5cb6e32f327ccab7f796c">FormatString()</a> を参照してください。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">formatArg</td><td>書式指定文字列に与える引数です。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1util.html#a54f65dcb71d5cb6e32f327ccab7f796c" title="文字列をフォーマットします。 ">FormatString()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad0cf8c9c361735e4387e4274f26660fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::util::SNPrintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>文字列をフォーマットします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>生成された文字列を格納するバッファです。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferLength</td><td>バッファの要素数です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFormat</td><td>printf スタイルの書式指定文字列です。詳細は <a class="el" href="namespacenn_1_1util.html#a54f65dcb71d5cb6e32f327ccab7f796c">FormatString()</a> を参照してください。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>書式指定文字列に与える引数です。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>生成された文字列の文字数（ヌル文字を含まない）を返します。 出力が切りつめられた場合でも、切りつめられる前の文字数を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>(<em>buffer</em> != nullptr) || (<em>bufferLength</em> == 0) </dd>
<dd>
<em>buffer</em> の領域と書式指定文字列の領域が重なっていない </dd>
<dd>
<em>pFormat</em> != nullptr </dd>
<dd>
書式指定文字列 <em>pFormat</em> は、printf スタイルの書式指定文字列である </dd>
<dd>
書式指定文字列 <em>pFormat</em> が要求する引数が ... に与えられている </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><em>bufferLength</em> != 0 ならば、生成された文字列のうち <em>bufferLength</em> - 1 文字を超えない部分が <em>buffer</em> に格納されている </dd>
<dd>
<em>bufferLength</em> != 0 ならば、<em>buffer</em> に格納されている文字列はヌル終端されている</dd></dl>
<p><b>詳細</b> <br />
文字列をフォーマットしてバッファに出力します。</p>
<p><em>bufferLength</em> == 0 の場合、バッファには何も格納しません。 生成された文字列の文字数だけを計算します。</p>
<p><em>bufferLength</em> != 0 の場合、生成された文字列をバッファに格納します。 文字列のうち、<em>bufferLength</em> - 1 文字を超える部分は切りつめられ、バッファに出力されません。 バッファに格納された文字列はヌル終端されます。</p>
<dl class="section attention"><dt>注意</dt><dd>現在、以下の制限があります。<ul>
<li>long double の値は、 double にキャストされて double の精度で変換されます。</li>
<li>浮動小数点数の変換は、丸め精度が正しくありません </li>
</ul>
</dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_friends_presence_8cpp-example.html#a32">FriendsPresence.cpp</a>, <a class="el" href="_fs_sd_card_for_debug_8cpp-example.html#a14">FsSdCardForDebug.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="afb19ebf42335aea1037895832e167857"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::util::VSNPrintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::va_list&#160;</td>
          <td class="paramname"><em>formatArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>文字列をフォーマットします。書式指定文字列に与える引数を std::va_list で受け取る以外は、 <a class="el" href="namespacenn_1_1util.html#ad0cf8c9c361735e4387e4274f26660fb">SNPrintf()</a> と同一です。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>出力文字列を格納するバッファです。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferLength</td><td>バッファの要素数です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFormat</td><td>printf スタイルの書式指定文字列です。詳細は <a class="el" href="namespacenn_1_1util.html#a54f65dcb71d5cb6e32f327ccab7f796c">FormatString()</a> を参照してください。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">formatArg</td><td>書式指定文字列に与える引数です。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>生成された文字列の文字数（ヌル文字を含まない）を返します。 出力が切りつめられた場合でも、切りつめられる前の文字数を返します。 </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_bcat_practical_8cpp-example.html#a51">BcatPractical.cpp</a>, <a class="el" href="_nifm_network_connection_simple__program_base_8h-example.html#a1">NifmNetworkConnectionSimple_ProgramBase.h</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af9bcb6a04353d44c401b747d2ce7f812"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; nn::util::Get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1util_1_1_typed_storage.html">TypedStorage</a>&lt; T, sizeof(T), std::alignment_of&lt; T &gt;::value &gt; &amp;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定された領域から実際の型の参照を取り出します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>取り出す型と同一のサイズとアライメントの領域です。</td></tr>
  </table>
  </dd>
</dl>
<p><b>詳細</b> <br />
 storage のサイズまたはアライメントが実際と異なる際はコンパイルエラーとなります。 </p><dl class="section return"><dt>戻り値</dt><dd>内部に持つ実際の型の参照を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a8769650838b44c09ff5c036f7050bc35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; nn::util::Get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1util_1_1_typed_storage.html">TypedStorage</a>&lt; T, sizeof(T), std::alignment_of&lt; T &gt;::value &gt; &amp;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定された領域から実際の型の参照を取り出します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">storage</td><td>取り出す型と同一のサイズとアライメントの領域です。</td></tr>
  </table>
  </dd>
</dl>
<p><b>詳細</b> <br />
 storage のサイズまたはアライメントが実際と異なる際はコンパイルエラーとなります。 </p><dl class="section return"><dt>戻り値</dt><dd>内部に持つ実際の型の参照を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="ac299aadfc2d647eddfb7b48a002497d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf8ToUtf16Native </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>文字コードを UTF-8 から UTF-16 に変換します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>変換先の配列。終端文字は付加されません。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>変換先の配列の長さ。*pDst の型換算の長さ(バッファサイズ / 型サイズ)です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>変換元の配列。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcLength</td><td>変換元の配列の長さ。*pSrc の型換算の長さ(バッファサイズ / 型サイズ)です。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000093">戻り値一覧:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - 正常に変換されました。 <br />
 </p>
<p><b>CharacterEncodingResult_InsufficientLength</b> - 変換先の配列の長さが不足しました。 <br />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - 変換できない文字が検出されました。 </p>
</dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_util_convert_sjis_8cpp-example.html#a5">UtilConvertSjis.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="acb6dd6d63f9069c568f4f9e0a41171c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf8ToUtf16Native </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>文字コードを UTF-8 から UTF-16 に変換します。終端文字まで変換されます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>変換先の配列。終端文字が付加されます。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>変換先の配列の長さ。*pDst の型換算の長さ(バッファサイズ / 型サイズ)です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>変換元の配列。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000094">戻り値一覧:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - 正常に変換されました。 <br />
 </p>
<p><b>CharacterEncodingResult_InsufficientLength</b> - 変換先の配列の長さが不足しました。 <br />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - 変換できない文字が検出されました。 </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0f7633254c8910e4e0b191121feddd95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf16NativeToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>文字コードを UTF-16 から UTF-8 に変換します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>変換先の配列。終端文字は付加されません。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>変換先の配列の長さ。*pDst の型換算の長さ(バッファサイズ / 型サイズ)です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>変換元の配列。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcLength</td><td>変換元の配列の長さ。*pSrc の型換算の長さ(バッファサイズ / 型サイズ)です。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000095">戻り値一覧:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - 正常に変換されました。 <br />
 </p>
<p><b>CharacterEncodingResult_InsufficientLength</b> - 変換先の配列の長さが不足しました。 <br />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - 変換できない文字が検出されました。 </p>
</dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_util_convert_sjis_8cpp-example.html#a4">UtilConvertSjis.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a0256928bab392ea72f8d15e3ec6efb7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf16NativeToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>文字コードを UTF-16 から UTF-8 に変換します。終端文字まで変換されます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>変換先の配列。終端文字が付加されます。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>変換先の配列の長さ。*pDst の型換算の長さ(バッファサイズ / 型サイズ)です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>変換元の配列。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000096">戻り値一覧:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - 正常に変換されました。 <br />
 </p>
<p><b>CharacterEncodingResult_InsufficientLength</b> - 変換先の配列の長さが不足しました。 <br />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - 変換できない文字が検出されました。 </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="a05c6fd4c3ccbb9129b10e6f2f9bed339"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">nn::util::CharacterEncodingResult</a> nn::util::GetLengthOfConvertedStringUtf8ToUtf16Native </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UTF-8 から UTF-16 に変換するために必要な変換先の配列の長さを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutLength</td><td>変換先の配列に文字列を書き込むのに必要な配列の長さ。終端文字の分は含まれません。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>変換元の配列。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcLength</td><td>変換元の配列の長さ。*pSrc の型換算の長さ(バッファサイズ / 型サイズ)です。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000097">戻り値一覧:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - 正常に変換されました。 <br />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - 変換できない文字が検出されました。 </p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><em>pOutLength</em> != nullptr </dd>
<dd>
[<em>pSrc</em>, <em>pSrc</em> + <em>srcLength</em>) を正常に読み出せる </dd>
<dd>
<em>srcLength</em> &gt;= 0 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><em>*pOutLength</em> &gt;= 0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1fdffba72eb466818e238d6ebb53b0dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::GetLengthOfConvertedStringUtf16NativeToUtf8 </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UTF-16 から UTF-8 に変換するために必要な変換先の配列の長さを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutLength</td><td>変換先の配列に文字列を書き込むのに必要な配列の長さ。終端文字の分は含まれません。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>変換元の配列。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcLength</td><td>変換元の配列の長さ。*pSrc の型換算の長さ(バッファサイズ / 型サイズ)です。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000098">戻り値一覧:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - 正常に変換されました。 <br />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - 変換できない文字が検出されました。 </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="a420f497d6459647978b4fe9c04f654b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf8ToUtf32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>文字コードを UTF-8 から UTF-32 に変換します。終端文字まで変換されます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>変換先の配列。終端文字が付加されます。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>変換先の配列の長さ。*pDst の型換算の長さ(バッファサイズ / 型サイズ)です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>変換元の配列。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000099">戻り値一覧:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - 正常に変換されました。 <br />
 </p>
<p><b>CharacterEncodingResult_InsufficientLength</b> - 変換先の配列の長さが不足しました。 <br />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - 変換できない文字が検出されました。 </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6de5dec6adb8e4760e49502991983e7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertStringUtf32ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>文字コードを UTF-32 から UTF-8 に変換します。終端文字まで変換されます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>変換先の配列。終端文字が付加されます。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstLength</td><td>変換先の配列の長さ。*pDst の型換算の長さ(バッファサイズ / 型サイズ)です。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>変換元の配列。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000100">戻り値一覧:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - 正常に変換されました。 <br />
 </p>
<p><b>CharacterEncodingResult_InsufficientLength</b> - 変換先の配列の長さが不足しました。 <br />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - 変換できない文字が検出されました。 </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1d2095df7e200b19b396b87856c884ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::GetLengthOfConvertedStringUtf8ToUtf32 </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UTF-8 から UTF-32 に変換するために必要な変換先の配列の長さを取得します。終端文字まで読み込まれます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutLength</td><td>変換先の配列に文字列を書き込むのに必要な配列の長さ。終端文字の分は含まれません。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>変換元の配列。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000101">戻り値一覧:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - 正常に変換されました。 <br />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - 変換できない文字が検出されました。 </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad68dd5a2f5c5ddfbb416ea6f6f434f7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::GetLengthOfConvertedStringUtf32ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UTF-32 から UTF-8 に変換するために必要な変換先の配列の長さを取得します。終端文字まで読み込まれます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutLength</td><td>変換先の配列に文字列を書き込むのに必要な配列の長さ。終端文字の分は含まれません。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>変換元の配列。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000102">戻り値一覧:</a></b></dt><dd><p class="startdd"><b>CharacterEncodingResult_Success</b> - 正常に変換されました。 <br />
 </p>
<p class="enddd"><b>CharacterEncodingResult_InvalidFormat</b> - 変換できない文字が検出されました。 </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae3c37393525e5cd94e22abe476c261c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertCharacterUtf8ToUtf16Native </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>文字コードを UTF-8 から UTF-16 に 1 文字だけ変換します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>変換先の文字。配列 2 つ分のバッファを渡してください。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>変換元の文字。配列 4 つ分のバッファを渡してください。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="ac706453bef5ce6867499d41bff823a0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertCharacterUtf16NativeToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>文字コードを UTF-16 から UTF-8 に 1 文字だけ変換します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>変換先の文字。配列 4 つ分のバッファを渡してください。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>変換元の文字。配列 2 つ分のバッファを渡してください。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="aec102fea3e52b0d8ec9ce743f3156dd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertCharacterUtf8ToUtf32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>文字コードを UTF-8 から UTF-32 に 1 文字だけ変換します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>変換先の文字。配列 1 つ分のバッファを渡してください。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>変換元の文字。配列 4 つ分のバッファを渡してください。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a8af955318b43cb855889cfce8799ae61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::ConvertCharacterUtf32ToUtf8 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>文字コードを UTF-32 から UTF-8 に 1 文字だけ変換します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>変換先の文字。配列 4 つ分のバッファを渡してください。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>変換元の文字。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="ae443a8ae5dbbb92d7f03fb2fba373ea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a8ab72d7227a9a1b56f78d0caf2920478">CharacterEncodingResult</a> nn::util::PickOutCharacterFromUtf8String </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pChar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>pStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UTF-8 の文字列から 1 文字を切り出して、ポインタを進めます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pChar</td><td>切り出した 1 文字を格納する 4byte 分のバッファ。 </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pStr</td><td>切り出す文字列。切り出した後に 1 文字分ポインタを進めます。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a89fad03d3f71a12026b6dcb2365180bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::Exchange </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定したポインタが指す変数に対し、指定した値を代入し、古い値を返します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>ポインタの指す変数の型 (T はコピー・ムーブ構築可能である必要があります) </td></tr>
    <tr><td class="paramname">U</td><td>代入する値の型 (U&amp;&amp; は T&amp; に代入可能である必要があります) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>値を設定・取得する変数のポインタを指定します。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>設定する値を指定します。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>古い *p の値を返します。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>p != nullptr </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>*p == static_cast&lt;T&gt;(value)</dd></dl>
<p><b>詳細</b> <br />
 T がポインタ型の場合、value には、nullptr や 0 リテラルを指定することが可能です。 </p>

</div>
</div>
<a class="anchor" id="ae0290996b2f08a558763e919ca74fd0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::CompressZlib </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>zlib 形式の deflate 圧縮を行う関数です。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSize</td><td>圧縮後のデータサイズ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>圧縮したデータを書き込むバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>pDst が指すバッファのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>圧縮するデータが格納されたバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>圧縮するデータのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWork</td><td>ワークバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workSize</td><td>ワークバッファのサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>圧縮に成功したかどうかを返します。<br />
 失敗した場合は出力用バッファのサイズを大きくし、再度実行してください。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>pWork には CompressZlibWorkBufferSizeDefault 以上の領域が必要です。<br />
</dd></dl>
<p><b>詳細</b> <br />
 zlib を使用した zlib 形式の deflate 圧縮を行います。<br />
 zlib は deflate アルゴリズムを用いてデータ圧縮/伸長を行うオープンソースライブラリです。 <a href="http://www.zlib.net/">http://www.zlib.net/</a> で配布されています。<br />
 本関数では zlib 内部の圧縮レベルは 6 (Z_DEFAULT_COMPRESSION)、メモリの消費量(memLevel)は 8 に設定されています。<br />
 本関数は入力データや出力バッファを分割せずに一括で圧縮を行います。<br />
 本関数で圧縮したデータには先頭と末尾に zlib 形式のヘッダとフッタが付与され、 <a class="el" href="namespacenn_1_1util.html#a5ef5750312d89f54f3e11496c3414ef7">DecompressZlib()</a> で展開できます。<br />
 本関数で圧縮した圧縮データから圧縮前のサイズは取得できません。<br />
 圧縮前のデータサイズは別途保持するようにしてください。<br />
 本関数で扱えるデータサイズは 4GB までです。 </p>

</div>
</div>
<a class="anchor" id="a9a092e78b92cadba899c2abbc486f899"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::CompressZlib </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>memLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>圧縮レベルと使用メモリレベルを指定し、zlib 形式の deflate 圧縮を行う関数です。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSize</td><td>圧縮後のデータサイズ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>圧縮したデータを書き込むバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>pDst が指すバッファのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>圧縮するデータが格納されたバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>圧縮するデータのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWork</td><td>ワークバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workSize</td><td>ワークバッファのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memLevel</td><td>メモリの消費量 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compressionLevel</td><td>圧縮レベル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>圧縮に成功したかどうかを返します。<br />
 失敗した場合は出力用バッファのサイズを大きくし、再度実行してください。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>pWork には <a class="el" href="util___compression_8h.html#a04522ad294b1a8fc24505134c1a5d9b6" title="CompressZlib() で必要となるワークバッファのサイズ (バイト数) を計算するマクロです。 ...">NN_UTIL_CALCULATE_COMPRESS_ZLIB_WORKBUFFER_SIZE(memLevel)</a> 以上の領域が必要です。<br />
 1 &lt;= memLevel &amp;&amp; memLevel &lt;= 9 <br />
 0 &lt;= compressLevel &amp;&amp; compressLevel &lt;= 9</dd></dl>
<p><b>詳細</b> <br />
 本関数はデフォルト値で圧縮する <a class="el" href="namespacenn_1_1util.html#ae0290996b2f08a558763e919ca74fd0f" title="zlib 形式の deflate 圧縮を行う関数です。 ">CompressZlib()</a> に圧縮レベルと使用メモリレベルを指定できるようにオーバーロードした関数です。<br />
 本関数ではメモリの消費量と圧縮レベルを指定できます。<br />
 メモリの消費量は 1 以上 9 以下の値を指定することが可能であり、数値を大きくするほど、より多くのメモリを使用し、圧縮率と圧縮速度が向上します。<br />
 圧縮レベルは 0 以上 9 以下の値を指定することが可能であり、一般的に数値を小さくすると圧縮時間が短くなり、大きくすると圧縮後のサイズが小さくなります。<br />
 0 を指定すると無圧縮となります。 </p>

</div>
</div>
<a class="anchor" id="a1eaf5623ce101256fc619f5b5a03491c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::CompressGzip </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gzip 形式の deflate 圧縮を行う関数です。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSize</td><td>圧縮後のデータサイズ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>圧縮したデータを書き込むバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>pDst が指すバッファのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>圧縮するデータが格納されたバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>圧縮するデータのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWork</td><td>ワークバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workSize</td><td>ワークバッファのサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>圧縮に成功したかどうかを返します。<br />
 失敗した場合は出力用バッファのサイズを大きくし、再度実行してください。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>pWork には CompressGzipWorkBufferSizeDefault 以上の領域が必要です。<br />
</dd></dl>
<p><b>詳細</b> <br />
 zlib を使用した Gzip 形式の deflate 圧縮を行います。<br />
 zlib は deflate アルゴリズムを用いてデータ圧縮/伸長を行うオープンソースライブラリです。 <a href="http://www.zlib.net/">http://www.zlib.net/</a> で配布されています。<br />
 本関数では zlib 内部の圧縮レベルは 6 (Z_DEFAULT_COMPRESSION)、メモリの消費量(memLevel)は 8 に設定されています。<br />
 本関数は入力データや出力バッファを分割せずに一括で圧縮を行います。<br />
 本関数で圧縮したデータには先頭と末尾に gzip 形式のヘッダとフッタが付与され、 <a class="el" href="namespacenn_1_1util.html#a8d0dd598671e1a5e68b15f48e4b02045">DecompressGzip()</a> で展開できます。<br />
 また、gzip 形式の圧縮データの圧縮前のサイズは <a class="el" href="namespacenn_1_1util.html#af08749f6d24d2bf7d577a253fa2d3c59" title="gzip 形式の圧縮データから圧縮前のデータサイズを取得します。 ">GetGzipDecompressedSize()</a> で取得できます。<br />
 本関数で扱えるデータサイズは 4GB までです。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_util_compression_8cpp-example.html#a2">UtilCompression.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="abda6da1a7c7bb62667781877ec8521a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::CompressGzip </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>memLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>圧縮レベルと使用メモリレベルを指定し、gzip 形式の deflate 圧縮を行う関数です。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSize</td><td>圧縮後のデータサイズ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>圧縮したデータを書き込むバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>pDst が指すバッファのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>圧縮するデータが格納されたバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>圧縮するデータのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWork</td><td>ワークバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workSize</td><td>ワークバッファのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memLevel</td><td>メモリの消費量 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compressionLevel</td><td>圧縮レベル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>圧縮に成功したかどうかを返します。<br />
 失敗した場合は出力用バッファのサイズを大きくし、再度実行してください。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>pWork には <a class="el" href="util___compression_8h.html#af230005a41eb23b12422c84a801a0582" title="CompressGzip() で必要となるワークバッファのサイズ (バイト数) を計算するマクロです。 ...">NN_UTIL_CALCULATE_COMPRESS_GZIP_WORKBUFFER_SIZE(memLevel)</a> 以上の領域が必要です。<br />
 1 &lt;= memLevel &amp;&amp; memLevel &lt;= 9 <br />
 0 &lt;= compressLevel &amp;&amp; compressLevel &lt;= 9</dd></dl>
<p><b>詳細</b> <br />
 本関数はデフォルト値で圧縮する <a class="el" href="namespacenn_1_1util.html#a1eaf5623ce101256fc619f5b5a03491c" title="Gzip 形式の deflate 圧縮を行う関数です。 ">CompressGzip()</a> に圧縮レベルと使用メモリレベルを指定できるようにオーバーロードした関数です。<br />
 本関数ではメモリの消費量と圧縮レベルを指定できます。<br />
 メモリの消費量は 1 以上 9 以下の値を指定することが可能であり、数値を大きくするほど、より多くのメモリを使用し、圧縮率と圧縮速度が向上します。<br />
 圧縮レベルは 0 以上 9 以下の値を指定することが可能であり、一般的に数値を小さくすると圧縮時間が短くなり、大きくすると圧縮後のサイズが小さくなります。<br />
 0 を指定すると無圧縮となります。 </p>

</div>
</div>
<a class="anchor" id="a394f55bc3df26d704f0fa46644aeee07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::CompressDeflate </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>raw deflate 形式の deflate 圧縮を行う関数です。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSize</td><td>圧縮後のデータサイズ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>圧縮したデータを書き込むバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>pDst が指すバッファのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>圧縮するデータが格納されたバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>圧縮するデータのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWork</td><td>ワークバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workSize</td><td>ワークバッファのサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>圧縮に成功したかどうかを返します。<br />
 失敗した場合は出力用バッファのサイズを大きくし、再度実行してください。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>pWork には CompressDeflateWorkBufferSizeDefault 以上の領域が必要です。<br />
</dd></dl>
<p><b>詳細</b> <br />
 zlib を使用した raw deflate 形式の deflate 圧縮を行います。<br />
 zlib は deflate アルゴリズムを用いてデータ圧縮/伸長を行うオープンソースライブラリです。 <a href="http://www.zlib.net/">http://www.zlib.net/</a> で配布されています。<br />
 本関数では zlib 内部の圧縮レベルは 6 (Z_DEFAULT_COMPRESSION)、メモリの消費量(memLevel)は 8 に設定されています。<br />
 本関数は入力データや出力バッファを分割せずに一括で圧縮を行います。<br />
 この関数で圧縮したデータは <a class="el" href="namespacenn_1_1util.html#aa24276fbb8f0d3892fdd9b076078d690">DecompressDeflate()</a> で展開できます。<br />
 本関数で圧縮した圧縮データから圧縮前のサイズは取得できません。<br />
 圧縮前のデータサイズは別途保持するようにしてください。<br />
 本関数で扱えるデータサイズは 4GB までです。 </p>

</div>
</div>
<a class="anchor" id="a0d02db25df3c786d3b84160a71a4ca4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::CompressDeflate </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>memLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>圧縮レベルと使用メモリレベルを指定し、raw deflate 形式の deflate 圧縮を行う関数です。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSize</td><td>圧縮後のデータサイズ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>圧縮したデータを書き込むバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>pDst が指すバッファのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>圧縮するデータが格納されたバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>圧縮するデータのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWork</td><td>ワークバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workSize</td><td>ワークバッファのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memLevel</td><td>メモリの消費量 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compressionLevel</td><td>圧縮レベル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>圧縮に成功したかどうかを返します。<br />
 失敗した場合は出力用バッファのサイズを大きくし、再度実行してください。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>pWork には <a class="el" href="util___compression_8h.html#af0484f5b779970f4fdc77f3e6a7f7d7e" title="CompressDeflate() で必要となるワークバッファのサイズ (バイト数) を計算するマクロです。 ...">NN_UTIL_CALCULATE_COMPRESS_DEFLATE_WORKBUFFER_SIZE(memLevel)</a> 以上の領域が必要です。<br />
 1 &lt;= memLevel &amp;&amp; memLevel &lt;= 9 <br />
 0 &lt;= compressLevel &amp;&amp; compressLevel &lt;= 9</dd></dl>
<p><b>詳細</b> <br />
 本関数はデフォルト値で圧縮する <a class="el" href="namespacenn_1_1util.html#a1eaf5623ce101256fc619f5b5a03491c" title="Gzip 形式の deflate 圧縮を行う関数です。 ">CompressGzip()</a> に圧縮レベルと使用メモリレベルを指定できるようにオーバーロードした関数です。<br />
 本関数ではメモリの消費量と圧縮レベルを指定できます。<br />
 メモリの消費量は 1 以上 9 以下の値を指定することが可能であり、数値を大きくするほど、より多くのメモリを使用し、圧縮率と圧縮速度が向上します。<br />
 圧縮レベルは 0 以上 9 以下の値を指定することが可能であり、一般的に数値を小さくすると圧縮時間が短くなり、大きくすると圧縮後のサイズが小さくなります。<br />
 0 を指定すると無圧縮となります。 </p>

</div>
</div>
<a class="anchor" id="af08749f6d24d2bf7d577a253fa2d3c59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::util::GetGzipDecompressedSize </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gzip 形式の圧縮データから圧縮前のデータサイズを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>圧縮データが格納されたバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>圧縮データのサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>圧縮前のデータサイズを返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>pSrc には gzip 形式の圧縮データを指定する必要があります。</dd></dl>
<p><b>詳細</b> <br />
 gzip 形式の圧縮データから圧縮前のデータサイズを取得します。 srcSize にはバッファのサイズではなく、圧縮データのサイズを入力してください。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_util_decompression_8cpp-example.html#a5">UtilDecompression.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a5ef5750312d89f54f3e11496c3414ef7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::DecompressZlib </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>zlib 形式の deflate 伸長を行います。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>伸長したデータを書き込むバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>pDst が指すバッファのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>伸長するデータが格納されたバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>伸長するデータのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWork</td><td>ワークバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workSize</td><td>ワークバッファのサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>伸長に成功したかどうかを返します。<br />
 失敗した場合はサポートされていないフォーマットのデータか壊れたデータが入力されています。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>pWork には DecompressZlibWorkBufferSize 以上の領域が必要です。<br />
</li>
<li>dstSize == (圧縮前のデータサイズ)</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 zlib を使用した zlib 形式の deflate 伸長を行います。<br />
 zlib は deflate アルゴリズムを用いてデータ圧縮/伸長を行うオープンソースライブラリです。 <a href="http://www.zlib.net/">http://www.zlib.net/</a> で配布されています。<br />
 本関数は入力データや出力バッファを分割せずに一括で伸長を行います。<br />
 本関数は dstSize を超えて pDst に書き込むことはありません。<br />
 本関数で扱えるデータサイズは 4GB までです。<br />
 分割したストリーミング伸長を行いたい場合は <a class="el" href="namespacenn_1_1util.html#a7545b1458e6ce1847a83d1a04d21cb7a" title="zlib 形式のストリーミング deflate 伸長を行います。 ">StreamingDecompressZlib()</a> を使用してください。 </p>

</div>
</div>
<a class="anchor" id="a8d0dd598671e1a5e68b15f48e4b02045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::DecompressGzip </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gzip 形式の deflate 伸長を行います。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>伸長したデータを書き込むバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>pDst が指すバッファのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>伸長するデータが格納されたバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>伸長するデータのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWork</td><td>ワークバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workSize</td><td>ワークバッファのサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>伸長に成功したかどうかを返します。<br />
 失敗した場合はサポートされていないフォーマットのデータか壊れたデータが入力されています。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>pWork には DecompressGzipWorkBufferSize 以上の領域が必要です。<br />
</li>
<li>dstSize == (圧縮前のデータサイズ)</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 zlib を使用した Gzip 形式の deflate 伸長を行います。<br />
 zlib は deflate アルゴリズムを用いてデータ圧縮/伸長を行うオープンソースライブラリです。 <a href="http://www.zlib.net/">http://www.zlib.net/</a> で配布されています。<br />
 本関数は入力データや出力バッファを分割せずに一括で伸長を行います。<br />
 本関数は dstSize を超えて pDst に書き込むことはありません。<br />
 本関数で扱えるデータサイズは 4GB までです。<br />
 分割したストリーミング伸長を行いたい場合は <a class="el" href="namespacenn_1_1util.html#ae19480f506b13f96d397ab207377809f" title="Gzip 形式のストリーミング deflate 伸長を行います。 ">StreamingDecompressGzip()</a> を使用してください。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_util_decompression_8cpp-example.html#a2">UtilDecompression.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa24276fbb8f0d3892fdd9b076078d690"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::DecompressDeflate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pWork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>workSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>raw deflate 形式の deflate 伸長を行います。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>伸長したデータを書き込むバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>pDst が指すバッファのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>伸長するデータが格納されたバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>伸長するデータのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pWork</td><td>ワークバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">workSize</td><td>ワークバッファのサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>伸長に成功したかどうかを返します。<br />
 失敗した場合はサポートされていないフォーマットのデータか壊れたデータが入力されています。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>pWork には DecompressDeflateWorkBufferSize 以上の領域が必要です。<br />
</li>
<li>dstSize == (圧縮前のデータサイズ)</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 zlib を使用した raw deflate 形式の deflate 伸長を行います。<br />
 zlib は deflate アルゴリズムを用いてデータ圧縮/伸長を行うオープンソースライブラリです。 <a href="http://www.zlib.net/">http://www.zlib.net/</a> で配布されています。<br />
 本関数は入力データや出力バッファを分割せずに一括で伸長を行います。<br />
 本関数は dstSize を超えて pDst に書き込むことはありません。<br />
 本関数で扱えるデータサイズは 4GB までです。<br />
 分割したストリーミング伸長を行いたい場合は <a class="el" href="namespacenn_1_1util.html#a0f4538c0f548daf8eb7a9be82f0d05db" title="raw deflate 形式のストリーミング deflate 伸長を行います。 ">StreamingDecompressDeflate()</a> を使用してください。 </p>

</div>
</div>
<a class="anchor" id="a95a0c92775590454820ac267996f2461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::InitializeStreamingDecompressZlibContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html">StreamingDecompressZlibContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>zlib 形式のストリーミング伸長用コンテキストを初期化します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pContext</td><td>ストリーミング伸長用のコンテキスト</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>事後条件</dt><dd>コンテキスト領域が初期化され、 <a class="el" href="namespacenn_1_1util.html#a7545b1458e6ce1847a83d1a04d21cb7a" title="zlib 形式のストリーミング deflate 伸長を行います。 ">StreamingDecompressZlib()</a> が使用可能になります。</dd></dl>
<p><b>詳細</b> <br />
 ストリーミング伸長用のコンテキスト領域の初期化を行い、 <a class="el" href="namespacenn_1_1util.html#a7545b1458e6ce1847a83d1a04d21cb7a" title="zlib 形式のストリーミング deflate 伸長を行います。 ">StreamingDecompressZlib()</a> を使用可能な状態にします。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_util_streaming_decompression_8cpp-example.html#a2">UtilStreamingDecompression.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a64c59c5b4e3d814b813abf54a60ea4ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::InitializeStreamingDecompressGzipContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#ae9beb7ac8f35cef8dd13f0416662320a">StreamingDecompressGzipContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gzip 形式のストリーミング伸長用コンテキストを初期化します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pContext</td><td>ストリーミング伸長用のコンテキスト</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>事後条件</dt><dd>コンテキスト領域が初期化され、 <a class="el" href="namespacenn_1_1util.html#ae19480f506b13f96d397ab207377809f" title="Gzip 形式のストリーミング deflate 伸長を行います。 ">StreamingDecompressGzip()</a> が使用可能になります。</dd></dl>
<p>　　　　</p>
<p><b>詳細</b> <br />
 ストリーミング伸長用のコンテキスト領域の初期化を行い、 <a class="el" href="namespacenn_1_1util.html#ae19480f506b13f96d397ab207377809f" title="Gzip 形式のストリーミング deflate 伸長を行います。 ">StreamingDecompressGzip()</a> を使用可能な状態にします。 </p>

</div>
</div>
<a class="anchor" id="a871190073dcf972d7212fe860883f208"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::InitializeStreamingDecompressDeflateContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#af2ed3b5d58dc0275f9c96f4d4ec7a079">StreamingDecompressDeflateContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>raw deflate 形式のストリーミング伸長用コンテキストを初期化します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pContext</td><td>ストリーミング伸長用のコンテキスト</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>事後条件</dt><dd>コンテキスト領域が初期化され、 <a class="el" href="namespacenn_1_1util.html#a0f4538c0f548daf8eb7a9be82f0d05db" title="raw deflate 形式のストリーミング deflate 伸長を行います。 ">StreamingDecompressDeflate()</a> が使用可能になります。</dd></dl>
<p><b>詳細</b> <br />
 ストリーミング伸長用のコンテキスト領域の初期化を行い、 <a class="el" href="namespacenn_1_1util.html#a0f4538c0f548daf8eb7a9be82f0d05db" title="raw deflate 形式のストリーミング deflate 伸長を行います。 ">StreamingDecompressDeflate()</a> を使用可能な状態にします。 </p>

</div>
</div>
<a class="anchor" id="a7545b1458e6ce1847a83d1a04d21cb7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::StreamingDecompressZlib </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutDstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutConsumedSrcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1util_1_1_streaming_decompress_zlib_context.html">StreamingDecompressZlibContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>zlib 形式のストリーミング deflate 伸長を行います。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutDstSize</td><td>出力用バッファに書き込んだサイズ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConsumedSrcSize</td><td>入力バッファから読み込んだサイズ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>伸長したデータを書き込むバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>pDst が指すバッファのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>伸長するデータが格納されたバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>pSrc が指すバッファのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pContext</td><td>ストリーミング伸長用のコンテキスト領域へのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ストリーミング伸長に成功したかどうかを返します。<br />
 失敗した場合はデータが壊れているかサポートされていない圧縮データが入力されています。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>InitializeStreamingZlibContext() でストリーミング伸長用のコンテキストが初期化されている必要があります。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 zlib 形式の ストリーミング deflate 伸長を行います。<br />
 サイズの大きな圧縮済みデータや出力バッファが十分に用意できないときにもストリーミングして読み出すことが可能です。<br />
 本関数は指定された入力バッファを読みきるか出力先バッファがいっぱいになると true を返します。<br />
 pOutDstSize と pOutConsumedSize を確認し、出力バッファと入力データを再設定し、繰り返し本関数を実行してください。<br />
 全ての圧縮データの伸長処理が完了すると、 pOutDstSize と pOutConsumedSize は共に 0 となり、すべての伸長処理の完了を表します。<br />
 本関数で扱えるデータサイズは 4GB までです。4GB 以上のデータを扱いたい場合は分けて読み込ませてください。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_util_streaming_decompression_8cpp-example.html#a3">UtilStreamingDecompression.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ae19480f506b13f96d397ab207377809f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::StreamingDecompressGzip </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutDstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutConsumedSrcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#ae9beb7ac8f35cef8dd13f0416662320a">StreamingDecompressGzipContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gzip 形式のストリーミング deflate 伸長を行います。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutDstSize</td><td>出力用バッファに書き込んだサイズ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConsumedSrcSize</td><td>入力バッファから読み込んだサイズ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>伸長したデータを書き込むバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>pDst が指すバッファのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>伸長するデータが格納されたバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>pSrc が指すバッファのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pContext</td><td>ストリーミング伸長用のコンテキスト領域へのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ストリーミング伸長に成功したかどうかを返します。<br />
 失敗した場合はデータが壊れているかサポートされていない圧縮データが入力されています。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>InitializeStreamingGzipContext()　でストリーミング伸長用のコンテキスト用領域が初期化されている必要があります。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 Gzip 形式の ストリーミング deflate 伸長を行います。<br />
 サイズの大きな圧縮済みデータや出力バッファが十分に用意できないときにもストリーミングして読み出すことが可能です。<br />
 本関数は指定された入力バッファを読みきるか出力先バッファがいっぱいになると true を返します。<br />
 pOutDstSize と pOutConsumedSize を確認し、出力バッファと入力データを再設定し、繰り返し本関数を実行してください。<br />
 全ての圧縮データの伸長処理が完了すると、 pOutDstSize と pOutConsumedSize は共に 0 となり、すべての伸長処理の完了を表します。<br />
 本関数で扱えるデータサイズは 4GB までです。4GB 以上のデータを扱いたい場合は分けて読み込ませてください。 </p>

</div>
</div>
<a class="anchor" id="a0f4538c0f548daf8eb7a9be82f0d05db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::StreamingDecompressDeflate </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutDstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutConsumedSrcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#af2ed3b5d58dc0275f9c96f4d4ec7a079">StreamingDecompressDeflateContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>raw deflate 形式のストリーミング deflate 伸長を行います。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutDstSize</td><td>出力用バッファに書き込んだサイズ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutConsumedSrcSize</td><td>入力バッファから読み込んだサイズ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDst</td><td>伸長したデータを書き込むバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstSize</td><td>pDst が指すバッファのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>伸長するデータが格納されたバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcSize</td><td>pSrc が指すバッファのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pContext</td><td>ストリーミング伸長用のコンテキスト領域へのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ストリーミング伸長に成功したかどうかを返します。<br />
 失敗した場合はデータが壊れているかサポートされていない圧縮データが入力されています。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>InitializeStreamingDeflateContext()　でストリーミング伸長用のコンテキスト用領域が初期化されている必要があります。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 raw deflate 形式の ストリーミング deflate 伸長を行います。<br />
 サイズの大きな圧縮済みデータや出力バッファが十分に用意できないときにもストリーミングして読み出すことが可能です。<br />
 本関数は指定された入力バッファを読みきるか出力先バッファがいっぱいになると true を返します。<br />
 pOutDstSize と pOutConsumedSize を確認し、出力バッファと入力データを再設定し、繰り返し本関数を実行してください。<br />
 全ての圧縮データの伸長処理が完了すると、 pOutDstSize と pOutConsumedSize は共に 0 となり、すべての伸長処理の完了を表します。<br />
 本関数で扱えるデータサイズは 4GB までです。4GB 以上のデータを扱いたい場合は分けて読み込ませてください。 </p>

</div>
</div>
<a class="anchor" id="a97ebb4e1469d08a7f51a21147375949b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> nn::util::RadianToAngleIndex </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radian</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>角度をラジアン表現からインデックス表現に変換します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radian</td><td>角度（ラジアン表現）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="ade1e7f71d2c5b0551d7b8c735d83d6a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> nn::util::DegreeToAngleIndex </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>角度を度数表現からインデックス表現に変換します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">degree</td><td>角度（度数表現）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a342713848fbb4ce6750da90d297bc824"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::DegreeToRadian </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>角度を度数表現からラジアン表現に変換します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">degree</td><td>角度（度数表現）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_edit_8cpp-example.html#a87">Edit.cpp</a>, <a class="el" href="_hid_controller_sequence__game_8cpp-example.html#a19">HidControllerSequence_Game.cpp</a>, <a class="el" href="_hid_controller_sequence__title_8cpp-example.html#a25">HidControllerSequence_Title.cpp</a>, <a class="el" href="_nns_g3d_simple_8cpp-example.html#a8">NnsG3dSimple.cpp</a>, <a class="el" href="_outline_8cpp-example.html#a10">Outline.cpp</a>, <a class="el" href="_parallel_8cpp-example.html#a7">Parallel.cpp</a>, <a class="el" href="_shape_animation_8cpp-example.html#a83">ShapeAnimation.cpp</a>, <a class="el" href="_skeletal_animation_8cpp-example.html#a33">SkeletalAnimation.cpp</a>, <a class="el" href="_town_8cpp-example.html#a49">Town.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a40">VfxManualEmitterSet/main.cpp</a>, <a class="el" href="_vfx_simple_2main_8cpp-example.html#a100">VfxSimple/main.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab32747bc56d48f93666e0548ef312585"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::RadianToDegree </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radian</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>角度をラジアン表現から度数表現に変換します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radian</td><td>角度（ラジアン表現）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_vfx_simple_2main_8cpp-example.html#a101">VfxSimple/main.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6b160179ea31b4eaf41284e73b925f6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::AngleIndexToRadian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td>
          <td class="paramname"><em>angleIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>角度をインデックス表現からラジアン表現に変換します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angleIndex</td><td>角度（インデックス表現）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a07cc37b32cbeec92b9ad379e0e8a7a53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::AngleIndexToDegree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td>
          <td class="paramname"><em>angleIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>角度をインデックス表現から度数表現に変換します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angleIndex</td><td>角度（インデックス表現）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a115590ce3ee8638bc4a1c7e561b58209"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::SinEst </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radian</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>多項式近似によって、正弦を求めます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radian</td><td>角度（ラジアン表現）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_hid_controller_sequence__game_8cpp-example.html#a18">HidControllerSequence_Game.cpp</a>, <a class="el" href="_hid_controller_sequence__title_8cpp-example.html#a24">HidControllerSequence_Title.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a41">VfxManualEmitterSet/main.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="abdd65f177dec24038d8e796993dd6f19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::SinTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td>
          <td class="paramname"><em>angleIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>テーブル引きによって、正弦を求めます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angleIndex</td><td>角度（インデックス表現）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a68268124ed7f0d8881db3fcebd01687f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::CosEst </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radian</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>多項式近似によって、余弦を求めます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radian</td><td>角度（ラジアン表現）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a42">VfxManualEmitterSet/main.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a90ba79c433fb71aa611fbead84b2c5a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::CosTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td>
          <td class="paramname"><em>angleIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>テーブル引きによって、余弦を求めます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angleIndex</td><td>角度（インデックス表現）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a32ba5bc072eae44853ce61976d55b001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::SinCosEst </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pOutSin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pOutCos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>多項式近似によって、正弦と余弦を求めます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSin</td><td>正弦の格納先 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCos</td><td>余弦の格納先 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radian</td><td>角度（ラジアン表現） </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_atk_sound3_d_8cpp-example.html#a12">AtkSound3D.cpp</a>, <a class="el" href="_vfx_simple_2main_8cpp-example.html#a99">VfxSimple/main.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a168e5f5b41ec5ecd60c6f88b6aea163e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::util::SinCosTable </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pOutSin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pOutCos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td>
          <td class="paramname"><em>angleIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>テーブル引きによって、正弦と余弦を求めます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSin</td><td>正弦の格納先 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCos</td><td>余弦の格納先 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angleIndex</td><td>角度（インデックス表現） </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0cdc076bfbd01224d54074c1f312165b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::TanEst </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radian</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>多項式近似によって、正接を求めます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radian</td><td>角度（ラジアン表現）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_parallel_8cpp-example.html#a6">Parallel.cpp</a>, <a class="el" href="_town_8cpp-example.html#a262">Town.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab8ac3cee8ff11403595c42268db119ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::TanTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a>&#160;</td>
          <td class="paramname"><em>angleIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>テーブル引きによって、正接を求めます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angleIndex</td><td>角度（インデックス表現）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a2699f371e3d783b78039ec8ac527de7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::AtanEst </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>多項式近似によって、逆正接を求めます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>正弦値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a1f23a5881abd9cc0bea5d1373a5f11e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> nn::util::AtanTable </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>テーブル引きによって、逆正接を求めます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>正弦値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a0a7efae0dfa5a73c71deeadd9665477d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::Atan2Est </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>多項式近似によって、逆正接を求めます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>値 Y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>値 X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a9c57759e10ba45d38bb7377edd0115a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> nn::util::Atan2Table </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>テーブル引きによって、逆正接を求めます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>値 Y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>値 X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a04c37527d1019f795ee78f5b51e9cd66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::AsinEst </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>多項式近似によって、逆正弦を求めます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>正弦値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="aae6f39eabcabdbeaed5c5eeecd012a81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> nn::util::AsinTable </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>テーブル引きによって、逆正弦を求めます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>正弦値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="af69079f75685a291d46ba591ddb60bbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::AcosEst </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>多項式近似によって、逆余弦を求めます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>余弦値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a13b10c3b5e379f2215fe0e65428e8543"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1util.html#a9a123aed03be22d1567aeb27d70c1a56">AngleIndex</a> nn::util::AcosTable </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>テーブル引きによって、逆余弦を求めます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>余弦値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="aee333695e4a66942a628f67d238c5fb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::Rcp </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>逆数を求めます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_skeletal_animation_8cpp-example.html#a23">SkeletalAnimation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6eb31608117aba6428f8ad885f520594"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::RcpLowPrecision </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>逆数を求めます。指定した回数だけ補正を行います。Rcp() よりも精度で劣ります。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>補正回数</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>値</td></tr>
  </table>
  </dd>
</dl>
<p><b>詳細</b> <br />
 プラットフォームによっては、精度で劣るかわりに高速な実装を利用できる場合があります。 本関数は、そのような最適化を期待する箇所で利用することを想定しています。 </p>

</div>
</div>
<a class="anchor" id="a0c2724ddb1495e6daec879773fdd3fe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::Rsqrt </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>平方根の逆数を求めます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a3bcdeefaffc5e1034d28f7a0be702075"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float nn::util::RsqrtLowPrecision </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>平方根の逆数を求めます。 指定した回数だけ補正を行います。Rsqrt() よりも精度で劣ります。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>補正回数</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。</dd></dl>
<p><b>詳細</b> <br />
 プラットフォームによっては、精度で劣るかわりに高速な実装を利用できる場合があります。 本関数は、そのような最適化を期待する箇所で利用することを想定しています。 </p>

</div>
</div>
<a class="anchor" id="a43d2e581fa3899d8d501a038439df039"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::AreEqualAbs </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>absError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>絶対誤差を用いて等値判定を行います。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>値1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>値2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">absError</td><td>絶対誤差による誤差許容範囲</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000103">戻り値一覧:</a></b></dt><dd><p class="startdd"><b>true</b> 等値です。 <br />
 </p>
<p class="enddd"><b>false</b> 等値ではありません。 </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="a7b2aa31b9b31c32958457d65f11b7987"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::AreEqualRelative </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>relativeError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>相対誤差を用いて等値判定を行います。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>値1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>値2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relativeError</td><td>相対誤差による誤差許容範囲</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000104">戻り値一覧:</a></b></dt><dd><p class="startdd"><b>true</b> 等値です。 <br />
 </p>
<p class="enddd"><b>false</b> 等値ではありません。 </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa41b86bc679691f454362ad06c268cb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::AreEqual </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>絶対誤差、もしくは、相対誤差を用いて等値判定を行います。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>値1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>値2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error</td><td>絶対誤差、もしくは、相対誤差による誤差許容範囲</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>結果を返します。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000105">戻り値一覧:</a></b></dt><dd><p class="startdd"><b>true</b> 等値です。 <br />
 </p>
<p class="enddd"><b>false</b> 等値ではありません。</p>
</dd></dl>
<p><b>詳細</b> <br />
 値1,2 の両方が 1 より小さい場合には絶対誤差として、いずれかの値が 1 より大きい場合には相対誤差として、指定された誤差許容範囲を用います。 </p>

</div>
</div>
<a class="anchor" id="a13a79a6dc84bdf279b045fc093ff2119"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::ToLower </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>大文字を小文字に変換します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>文字の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>変換する文字を指定します。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>変換後の文字を返します。</dd></dl>
<p><b>詳細</b> <br />
 本関数は C ロケールのシステムであることを前提として、アルファベットのみを変換します。 大文字以外を指定した場合、入力した文字をそのまま返します。 </p>

</div>
</div>
<a class="anchor" id="a99a76533452983f6c48f18b8d13cb9dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T nn::util::ToUpper </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>小文字を大文字に変換します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>文字の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>変換する文字を指定します。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>変換後の文字を返します。</dd></dl>
<p><b>詳細</b> <br />
 本関数は C ロケールのシステムであることを前提として、アルファベットのみを変換します。 小文字以外を指定した場合、入力した文字をそのまま返します。 </p>

</div>
</div>
<a class="anchor" id="aea34b10628afe205af6f4d0d63637aa3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int nn::util::Strlcpy </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pOutDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コピー先のバッファの要素数や終端に配慮した文字列のコピーをおこないます。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>文字の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutDst</td><td>コピー先のバッファの先頭へのポインタを指定します。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSrc</td><td>コピー元の文字列の先頭へのポインタを指定します。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>コピー先のバッファの要素数を指定します。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>pSrc に与えられた文字列の長さ（終端のヌル文字を含まない要素数）を返します。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>pOutDst != nullptr</li>
<li>pSrc != nullptr</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 count の値が文字列 pSrc の長さより大きい場合、文字列 pSrc を、終端のヌル文字も含めて pOutDst へコピーします。 count の値が 1 以上かつ文字列 pSrc の長さが count 以上の場合、 count - 1 文字分のコピーをおこない、ヌル文字で終端します。 count の値が 0 以下の場合、ヌル文字での終端を含め、コピー先のバッファへは一切の書き込みをおこないません。 関数の返り値が count 未満であれば、 pSrc の文字列は切り詰めなく pOutDst にコピーされています。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ngc_simple_8cpp-example.html#a14">NgcSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab7c81364b3b9819789c1c4a429d253ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int nn::util::Strnlen </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>バッファの要素数や終端に配慮した文字数のカウントをおこないます。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>文字の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pStr</td><td>文字列の先頭へのポインタを指定します。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>文字列が格納されたバッファの要素数を指定します。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>pStr に与えられた文字列の長さ（終端のヌル文字を含まない要素数）を返します。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>pStr != nullptr</li>
<li>count &gt;= 0</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 count の値が文字列 pStr の長さより大きい場合、文字列 pStr の、終端のヌル文字を含まない要素数を返します。 count の値が文字列 pStr の長さ以下の場合は count の値を返し、 count 番目以降の要素にはアクセスしません。 関数の返り値が count と等しい場合、 pStr がヌル終端されていることは保証されません。 複数要素で成り立つ文字があった場合もそれを1文字と数えることはなく、要素数をもって文字数とします。 </p>

</div>
</div>
<a class="anchor" id="af03c040b318b096258d333336c1adbc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int nn::util::Strncmp </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pStr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>バッファの要素数や終端に配慮して文字列を比較します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>文字の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pStr1</td><td>比較する文字列の一方の先頭へのポインタを指定します。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pStr2</td><td>比較する文字列の他方の先頭へのポインタを指定します。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>文字列の比較をおこなう最大の要素数を指定します。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>文字列が一致すれば 0 、一致しなければ非 0 の値を返します。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>pStr1 != nullptr</li>
<li>pStr2 != nullptr</li>
<li>count &gt;= 0</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 与えられた二つの文字列に対し、最大で count - 1 番目までの文字を比較します。 最初に発見した異なる文字の値が、 pStr1 の指す文字列のほうが小さかった場合は負の値が、大きかった場合は正の値が返ります。 非 0 の値が返った場合に双方の文字列が異なることは保証されますが、 0 が返った場合に双方の文字列が一致することは保証されません。 双方の文字列が一致していることを保証するには、返り値が 0 であることに加え、いずれかの文字列の長さが count 未満であることを確認する必要があります。 </p>

</div>
</div>
<a class="anchor" id="a84bdf2f9bab2ff279262c7024abde9c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int nn::util::Strnicmp </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pStr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>バッファの要素数や終端に配慮して文字列を英字の大小を区別せずに比較します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>文字の型です。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pStr1</td><td>比較する文字列の一方の先頭へのポインタを指定します。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pStr2</td><td>比較する文字列の他方の先頭へのポインタを指定します。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>文字列の比較をおこなう最大の要素数を指定します。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>文字列が一致すれば 0 、一致しなければ非 0 の値を返します。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>pStr1 != nullptr</li>
<li>pStr2 != nullptr</li>
<li>count &gt;= 0</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 与えられた二つの文字列に対し、最大で count - 1 番目までの文字を英字の大小を区別せずに比較します。 最初に発見した異なる文字の値が、 pStr1 の指す文字列のほうが小さかった場合は負の値が、大きかった場合は正の値が返ります。 本関数は各文字を小文字に変換してから比較するため、ASCII コードの 'Z' と 'a' の間の記号文字と大文字の比較が行われる文字列を指定した場合、Strncmp と返り値の大小が逆転します。 非 0 の値が返った場合に双方の文字列が異なることは保証されますが、 0 が返った場合に双方の文字列が一致することは保証されません。 双方の文字列が一致していることを保証するには、返り値が 0 であることに加え、いずれかの文字列の長さが count 未満であることを確認する必要があります。 </p>

</div>
</div>
<a class="anchor" id="a128d9474fb20b3fa7c743c864aeb3f56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Destination , typename Source &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nn::util::IsIntValueRepresentable </td>
          <td>(</td>
          <td class="paramtype">Source&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>引数で指定した整数値が、指定した型で表現できるかどうかを取得します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Destination</td><td>変換先の整数型を指定します。 </td></tr>
    <tr><td class="paramname">Source</td><td>変換元の整数型を指定します。通常は省略可能です。</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>変換元の整数値を指定します。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>整数値 n を、整数型 Destination で表現できれば true を、そうでなければ false を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a7df2ac5ca47857cc945af5421ea54aa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1util_1_1_uuid.html">Uuid</a> nn::util::GenerateUuid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RFC 4122に規定されたUniversally Unique Identifier (UUID)を生成します。 </p>
<p><b>詳細</b> <br />
 RFC 4122 に規定されたUniversally Unique Identifier (UUID)を生成します。</p>
<p>なお、本 API はスレッドセーフです。 </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
