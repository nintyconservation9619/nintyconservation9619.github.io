<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>NintendoSDK API Reference: nvn::Device クラス</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>総合概要</span></a></li>
      <li><a href="pages.html"><span>諸情報</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>名前空間</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>クラス一覧</span></a></li>
      <li><a href="classes.html"><span>クラス索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>クラスメンバ</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenvn.html">nvn</a></li><li class="navelem"><a class="el" href="classnvn_1_1_device.html">Device</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="classnvn_1_1_device-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">nvn::Device クラス<div class="ingroups"><a class="el" href="group__nvn__cpp__interface.html">NVN C++ API Bindings</a> &raquo; <a class="el" href="group__nvn__cpp__apiclasses.html">API Classes</a> &#124; <a class="el" href="group__nvn__cpp__interface.html">NVN C++ API Bindings</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>API class used to represent a specific GPU/device.  
 <a href="classnvn_1_1_device.html#details">[詳解]</a></p>

<p><code>#include &lt;nvn/nvn_Cpp.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:a64777ed907fab92b47ff9edb9a3f731d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a64777ed907fab92b47ff9edb9a3f731d">ApplyDeferredFinalizes</a> (int age)</td></tr>
<tr class="memdesc:a64777ed907fab92b47ff9edb9a3f731d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize buffers, textures, and samplers previously scheduled for finalization.  <a href="#a64777ed907fab92b47ff9edb9a3f731d">[詳解]</a><br /></td></tr>
<tr class="separator:a64777ed907fab92b47ff9edb9a3f731d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02562438c161015a28a045ac7fbb2930"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02562438c161015a28a045ac7fbb2930"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a02562438c161015a28a045ac7fbb2930">Finalize</a> ()</td></tr>
<tr class="memdesc:a02562438c161015a28a045ac7fbb2930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device. ">Device</a> object. <br /></td></tr>
<tr class="separator:a02562438c161015a28a045ac7fbb2930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61010691331b790d583d62686eb0ef35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a61010691331b790d583d62686eb0ef35">FinalizeCommandHandle</a> (<a class="el" href="group__nvn__cpp__handle.html#ga48a6926aea0b934109f96ae32027b7fb">CommandHandle</a> handles)</td></tr>
<tr class="memdesc:a61010691331b790d583d62686eb0ef35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a command handle.  <a href="#a61010691331b790d583d62686eb0ef35">[詳解]</a><br /></td></tr>
<tr class="separator:a61010691331b790d583d62686eb0ef35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c41f3351aadfd8e94bdd9aaef7c47a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga721dd09710079ec7e1d153842dbc7665">NVNdebugDomainId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a0c41f3351aadfd8e94bdd9aaef7c47a2">GenerateDebugDomainId</a> (const char *name) const </td></tr>
<tr class="memdesc:a0c41f3351aadfd8e94bdd9aaef7c47a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a unique ID by atomically incrementing a global counter on each request.  <a href="#a0c41f3351aadfd8e94bdd9aaef7c47a2">[詳解]</a><br /></td></tr>
<tr class="separator:a0c41f3351aadfd8e94bdd9aaef7c47a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8da256aa7e1652cc3a7fb074de75e9d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#af8da256aa7e1652cc3a7fb074de75e9d">GetCurrentTimestampInNanoseconds</a> () const </td></tr>
<tr class="memdesc:af8da256aa7e1652cc3a7fb074de75e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get timestamp from the device, without queuing like the ReportCounter functions.  <a href="#af8da256aa7e1652cc3a7fb074de75e9d">[詳解]</a><br /></td></tr>
<tr class="separator:af8da256aa7e1652cc3a7fb074de75e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0049e14a9f8528dbd9cd5e521918a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f0049e14a9f8528dbd9cd5e521918a9"></a>
<a class="el" href="structnvn_1_1_depth_mode.html">DepthMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a7f0049e14a9f8528dbd9cd5e521918a9">GetDepthMode</a> () const </td></tr>
<tr class="memdesc:a7f0049e14a9f8528dbd9cd5e521918a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth mode for a device. <br /></td></tr>
<tr class="separator:a7f0049e14a9f8528dbd9cd5e521918a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f16243c11b4ff143ab0908dd5994057"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__cpp__handle.html#ga0ad8373f5da7065f67ab5d14eed99ac2">ImageHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a9f16243c11b4ff143ab0908dd5994057">GetImageHandle</a> (int imageID) const </td></tr>
<tr class="memdesc:a9f16243c11b4ff143ab0908dd5994057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to use for image loads and stores to a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object.  <a href="#a9f16243c11b4ff143ab0908dd5994057">[詳解]</a><br /></td></tr>
<tr class="separator:a9f16243c11b4ff143ab0908dd5994057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4c028efd3575064282daf004181ace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a5d4c028efd3575064282daf004181ace">GetInteger</a> (<a class="el" href="structnvn_1_1_device_info.html">DeviceInfo</a> pname, int *v) const </td></tr>
<tr class="memdesc:a5d4c028efd3575064282daf004181ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query properties of a device.  <a href="#a5d4c028efd3575064282daf004181ace">[詳解]</a><br /></td></tr>
<tr class="separator:a5d4c028efd3575064282daf004181ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146352417804f83a3afb37f86c2307c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__cpp__funcptrs.html#gafb622688ee73f45c633b6592386a8b16">GenericFuncPtrFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a146352417804f83a3afb37f86c2307c5">GetProcAddress</a> (const char *name) const </td></tr>
<tr class="memdesc:a146352417804f83a3afb37f86c2307c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a function pointer for a specified C interface entry point for a device.  <a href="#a146352417804f83a3afb37f86c2307c5">[詳解]</a><br /></td></tr>
<tr class="separator:a146352417804f83a3afb37f86c2307c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ce168413073f07079025748e9a572a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnvn_1_1_separate_sampler_handle.html">SeparateSamplerHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#ae5ce168413073f07079025748e9a572a">GetSeparateSamplerHandle</a> (int samplerID) const </td></tr>
<tr class="memdesc:ae5ce168413073f07079025748e9a572a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">Sampler</a> object.  <a href="#ae5ce168413073f07079025748e9a572a">[詳解]</a><br /></td></tr>
<tr class="separator:ae5ce168413073f07079025748e9a572a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7522a850ed7058114a6681dfaae07994"><td class="memItemLeft" align="right" valign="top">NVN_PRE_DEPRECATED <a class="el" href="structnvn_1_1_separate_sampler_handle.html">SeparateSamplerHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a7522a850ed7058114a6681dfaae07994">getSeparateSamplerHandle</a> (int samplerID) const NVN_POST_DEPRECATED</td></tr>
<tr class="memdesc:a7522a850ed7058114a6681dfaae07994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">Sampler</a> object.  <a href="#a7522a850ed7058114a6681dfaae07994">[詳解]</a><br /></td></tr>
<tr class="separator:a7522a850ed7058114a6681dfaae07994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463633b886dd17440d45b7e8eb7afd5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnvn_1_1_separate_texture_handle.html">SeparateTextureHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a463633b886dd17440d45b7e8eb7afd5a">GetSeparateTextureHandle</a> (int textureID) const </td></tr>
<tr class="memdesc:a463633b886dd17440d45b7e8eb7afd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object.  <a href="#a463633b886dd17440d45b7e8eb7afd5a">[詳解]</a><br /></td></tr>
<tr class="separator:a463633b886dd17440d45b7e8eb7afd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79589e14ce5376baa5acb751db41950a"><td class="memItemLeft" align="right" valign="top">NVN_PRE_DEPRECATED <a class="el" href="structnvn_1_1_separate_texture_handle.html">SeparateTextureHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a79589e14ce5376baa5acb751db41950a">getSeparateTextureHandle</a> (int textureID) const NVN_POST_DEPRECATED</td></tr>
<tr class="memdesc:a79589e14ce5376baa5acb751db41950a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object.  <a href="#a79589e14ce5376baa5acb751db41950a">[詳解]</a><br /></td></tr>
<tr class="separator:a79589e14ce5376baa5acb751db41950a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c6f6628ee2a0bd11bb043f09b9a4e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08">TextureHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a53c6f6628ee2a0bd11bb043f09b9a4e9">GetTexelFetchHandle</a> (int textureID) const </td></tr>
<tr class="memdesc:a53c6f6628ee2a0bd11bb043f09b9a4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object for use in texel fetches.  <a href="#a53c6f6628ee2a0bd11bb043f09b9a4e9">[詳解]</a><br /></td></tr>
<tr class="separator:a53c6f6628ee2a0bd11bb043f09b9a4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de478a90f3f8003471d0cd7a8e9c948"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08">TextureHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a9de478a90f3f8003471d0cd7a8e9c948">GetTextureHandle</a> (int textureID, int samplerID) const </td></tr>
<tr class="memdesc:a9de478a90f3f8003471d0cd7a8e9c948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a combined pair of <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> and <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">Sampler</a> objects.  <a href="#a9de478a90f3f8003471d0cd7a8e9c948">[詳解]</a><br /></td></tr>
<tr class="separator:a9de478a90f3f8003471d0cd7a8e9c948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ada4e77f22189e43cab2ca2fcc49d7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a83ada4e77f22189e43cab2ca2fcc49d7">GetTimestampInNanoseconds</a> (const <a class="el" href="structnvn_1_1_counter_data.html">CounterData</a> *counterData) const </td></tr>
<tr class="memdesc:a83ada4e77f22189e43cab2ca2fcc49d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the timestamp contained in a counter report, with time values converted from the platform-specific timestamp resolution to nanoseconds.  <a href="#a83ada4e77f22189e43cab2ca2fcc49d7">[詳解]</a><br /></td></tr>
<tr class="separator:a83ada4e77f22189e43cab2ca2fcc49d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce4c7922b5ed109000e841743bfb537"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ce4c7922b5ed109000e841743bfb537"></a>
<a class="el" href="structnvn_1_1_window_origin_mode.html">WindowOriginMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a7ce4c7922b5ed109000e841743bfb537">GetWindowOriginMode</a> () const </td></tr>
<tr class="memdesc:a7ce4c7922b5ed109000e841743bfb537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the window origin mode for a device. <br /></td></tr>
<tr class="separator:a7ce4c7922b5ed109000e841743bfb537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf52158b706accb2295c006c86f9c446"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#abf52158b706accb2295c006c86f9c446">Initialize</a> (const <a class="el" href="classnvn_1_1_device_builder.html">DeviceBuilder</a> *builder)</td></tr>
<tr class="memdesc:abf52158b706accb2295c006c86f9c446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device. ">Device</a> object from a device builder.  <a href="#abf52158b706accb2295c006c86f9c446">[詳解]</a><br /></td></tr>
<tr class="separator:abf52158b706accb2295c006c86f9c446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6e83411cc5edbc861c58f9c34dbb77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#abf6e83411cc5edbc861c58f9c34dbb77">InstallDebugCallback</a> (const <a class="el" href="group__nvn__cpp__funcptrs.html#ga1702f082fd2917bebd7419011ce2ab37">DebugCallbackFunc</a> callback, void *callbackData, NVNboolean enable)</td></tr>
<tr class="memdesc:abf6e83411cc5edbc861c58f9c34dbb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install or remove a callback function to be called whenever the debug layer generates a message.  <a href="#abf6e83411cc5edbc861c58f9c34dbb77">[詳解]</a><br /></td></tr>
<tr class="separator:abf6e83411cc5edbc861c58f9c34dbb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf33848f725670e58720fb19fc7168c4"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#acf33848f725670e58720fb19fc7168c4">IsExternalDebuggerAttached</a> () const </td></tr>
<tr class="memdesc:acf33848f725670e58720fb19fc7168c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an external debugger is attached when running an NVN application.  <a href="#acf33848f725670e58720fb19fc7168c4">[詳解]</a><br /></td></tr>
<tr class="separator:acf33848f725670e58720fb19fc7168c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738e79b4293d108d8dc311840bfb3cd8"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a738e79b4293d108d8dc311840bfb3cd8">RegisterFastClearColor</a> (const float *color, <a class="el" href="structnvn_1_1_format.html">Format</a> format)</td></tr>
<tr class="memdesc:a738e79b4293d108d8dc311840bfb3cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a fast clear color value.  <a href="#a738e79b4293d108d8dc311840bfb3cd8">[詳解]</a><br /></td></tr>
<tr class="separator:a738e79b4293d108d8dc311840bfb3cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ad1a88a3be2802f1ff0b91fe681d40"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a13ad1a88a3be2802f1ff0b91fe681d40">RegisterFastClearColori</a> (const int *color, <a class="el" href="structnvn_1_1_format.html">Format</a> format)</td></tr>
<tr class="memdesc:a13ad1a88a3be2802f1ff0b91fe681d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a signed integer fast clear color value.  <a href="#a13ad1a88a3be2802f1ff0b91fe681d40">[詳解]</a><br /></td></tr>
<tr class="separator:a13ad1a88a3be2802f1ff0b91fe681d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156ddbeb91f3c434ec521ecee88b7221"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a156ddbeb91f3c434ec521ecee88b7221">RegisterFastClearColorui</a> (const uint32_t *color, <a class="el" href="structnvn_1_1_format.html">Format</a> format)</td></tr>
<tr class="memdesc:a156ddbeb91f3c434ec521ecee88b7221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an unsigned integer fast clear color value.  <a href="#a156ddbeb91f3c434ec521ecee88b7221">[詳解]</a><br /></td></tr>
<tr class="separator:a156ddbeb91f3c434ec521ecee88b7221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c6011bf315852aebffc88f052fee23"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#aa3c6011bf315852aebffc88f052fee23">RegisterFastClearDepth</a> (float depth)</td></tr>
<tr class="memdesc:aa3c6011bf315852aebffc88f052fee23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a fast clear depth value.  <a href="#aa3c6011bf315852aebffc88f052fee23">[詳解]</a><br /></td></tr>
<tr class="separator:aa3c6011bf315852aebffc88f052fee23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814ee872c59196a0a66ccad71f02cd32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a814ee872c59196a0a66ccad71f02cd32">SetDebugLabel</a> (const char *label)</td></tr>
<tr class="memdesc:a814ee872c59196a0a66ccad71f02cd32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device. ">Device</a> object.  <a href="#a814ee872c59196a0a66ccad71f02cd32">[詳解]</a><br /></td></tr>
<tr class="separator:a814ee872c59196a0a66ccad71f02cd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a7a578db399ec77a9ecccc24fd4695"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a11a7a578db399ec77a9ecccc24fd4695">SetDepthMode</a> (<a class="el" href="structnvn_1_1_depth_mode.html">DepthMode</a> depthMode)</td></tr>
<tr class="memdesc:a11a7a578db399ec77a9ecccc24fd4695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global clipping range for normalized depth in clip space.  <a href="#a11a7a578db399ec77a9ecccc24fd4695">[詳解]</a><br /></td></tr>
<tr class="separator:a11a7a578db399ec77a9ecccc24fd4695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef418dbea511a5d15eee5743b35f8c4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#aef418dbea511a5d15eee5743b35f8c4e">SetIntermediateShaderCache</a> (int numMaxEntries)</td></tr>
<tr class="memdesc:aef418dbea511a5d15eee5743b35f8c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the shader cache for the Windows reference platform to store fat binary intermediate results.  <a href="#aef418dbea511a5d15eee5743b35f8c4e">[詳解]</a><br /></td></tr>
<tr class="separator:aef418dbea511a5d15eee5743b35f8c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9b476ebbecf1ccfe30270b088de497"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#ace9b476ebbecf1ccfe30270b088de497">SetWindowOriginMode</a> (<a class="el" href="structnvn_1_1_window_origin_mode.html">WindowOriginMode</a> windowOriginMode)</td></tr>
<tr class="memdesc:ace9b476ebbecf1ccfe30270b088de497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global location for window coordinates (0,0).  <a href="#ace9b476ebbecf1ccfe30270b088de497">[詳解]</a><br /></td></tr>
<tr class="separator:ace9b476ebbecf1ccfe30270b088de497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61545e8c3aee505841ab9c2f4a07c917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_device.html#a61545e8c3aee505841ab9c2f4a07c917">WalkDebugDatabase</a> (<a class="el" href="structnvn_1_1_debug_object_type.html">DebugObjectType</a> type, <a class="el" href="group__nvn__cpp__funcptrs.html#gab8489c6918b599061b30dc5b079dbc69">WalkDebugDatabaseCallbackFunc</a> callback, void *userParam) const </td></tr>
<tr class="memdesc:a61545e8c3aee505841ab9c2f4a07c917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk through the debug layer object database.  <a href="#a61545e8c3aee505841ab9c2f4a07c917">[詳解]</a><br /></td></tr>
<tr class="separator:a61545e8c3aee505841ab9c2f4a07c917"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p>API class used to represent a specific GPU/device. </p>
</div><h2 class="groupheader">関数詳解</h2>
<a class="anchor" id="abf52158b706accb2295c006c86f9c446"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvn::Device::Initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_device_builder.html">DeviceBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device. ">Device</a> object from a device builder. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="classnvn_1_1_device_builder.html" title="Object specifying state used to construct new device objects. ">DeviceBuilder</a> object holding properties of the new <a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device. ">Device</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a814ee872c59196a0a66ccad71f02cd32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Device::SetDebugLabel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device. ">Device</a> object. </p>
<p>Annotates a <a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device. ">Device</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="classnvn_1_1_device.html" title="API class used to represent a specific GPU/device. ">Device</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a146352417804f83a3afb37f86c2307c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__cpp__funcptrs.html#gafb622688ee73f45c633b6592386a8b16">GenericFuncPtrFunc</a> nvn::Device::GetProcAddress </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query a function pointer for a specified C interface entry point for a device. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the C entry point to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d4c028efd3575064282daf004181ace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Device::GetInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_device_info.html">DeviceInfo</a>&#160;</td>
          <td class="paramname"><em>pname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query properties of a device. </p>
<dl class="section note"><dt>覚え書き</dt><dd><em>device</em> may be NULL when querying supported API or GPU shader code versions prior to creating a device object. For all other queries, <em>device</em> must point at a valid NVN device object.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pname</td><td>Property to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Value associated with the property, returned to the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8da256aa7e1652cc3a7fb074de75e9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nvn::Device::GetCurrentTimestampInNanoseconds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get timestamp from the device, without queuing like the ReportCounter functions. </p>
<p>See the <a class="el" href="nvn_index.html#nvn_guide_counters">Counters</a> section of the NVN Programming Guide for more detail.</p>
<dl class="section note"><dt>覚え書き</dt><dd><em>device</em> must point at a valid NVN device object. </dd></dl>

</div>
</div>
<a class="anchor" id="aef418dbea511a5d15eee5743b35f8c4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Device::SetIntermediateShaderCache </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numMaxEntries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the shader cache for the Windows reference platform to store fat binary intermediate results. </p>
<p>If the NVN platform is NX, this function does nothing.</p>
<p>On the Windows reference implemenetation, <a class="el" href="classnvn_1_1_program.html#ac63e6fe9122a01f15cc9955628ec8fd9" title="Initialize a program object to use pre-compiled GPU code from one or multiple shaders. ">Program::SetShaders</a> will compile machine code that can run on the attached GPU, using intermediate shader code and specialization information stored in the provided control data. If the same shader is compiled with different specialization information (via glslcCompileSpecialized) using this cache can avoid re-processing the same shader code on each call to <a class="el" href="classnvn_1_1_program.html#ac63e6fe9122a01f15cc9955628ec8fd9" title="Initialize a program object to use pre-compiled GPU code from one or multiple shaders. ">Program::SetShaders</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">numMaxEntries</td><td>Maximum number of entries that the intermediate shader cache can hold. If this is 0, the cache will be disabled and any previous cache resources will be cleaned up. If a non-zero value is used, the cache will hold intermediate code for up to <em>numMaxEntries</em> unique shaders. Programs containing multiple shader stages will consume multiple entries in this cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9de478a90f3f8003471d0cd7a8e9c948"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08">TextureHandle</a> nvn::Device::GetTextureHandle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samplerID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a combined pair of <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> and <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">Sampler</a> objects. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureID</td><td>Registered ID of the <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da1585230ba0778552b803fbe968704677" title="Number of entries reserved at the beginning of the texture pool for internal driver usage...">nvn::DeviceInfo::RESERVED_TEXTURE_DESCRIPTORS</a>).</td></tr>
    <tr><td class="paramname">samplerID</td><td>Registered ID of the <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">Sampler</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da7d6275bfbc504ca717d30c0adf52e07f" title="Number of samplers that must be reserved for use by the driver. ">nvn::DeviceInfo::RESERVED_SAMPLER_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53c6f6628ee2a0bd11bb043f09b9a4e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__cpp__handle.html#gafe744b035d9582a86872d256349c5e08">TextureHandle</a> nvn::Device::GetTexelFetchHandle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object for use in texel fetches. </p>
<p>A handle produced by this entry point can be used for texel fetches via the texelFetch() GLSL built-in function. Using such handles in texture lookups will use undefined sampler state.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureID</td><td>Registered ID of the <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da1585230ba0778552b803fbe968704677" title="Number of entries reserved at the beginning of the texture pool for internal driver usage...">nvn::DeviceInfo::RESERVED_TEXTURE_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f16243c11b4ff143ab0908dd5994057"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__cpp__handle.html#ga0ad8373f5da7065f67ab5d14eed99ac2">ImageHandle</a> nvn::Device::GetImageHandle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>imageID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle to use for image loads and stores to a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageID</td><td>Registered image ID of the <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da1585230ba0778552b803fbe968704677" title="Number of entries reserved at the beginning of the texture pool for internal driver usage...">nvn::DeviceInfo::RESERVED_TEXTURE_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf6e83411cc5edbc861c58f9c34dbb77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Device::InstallDebugCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__nvn__cpp__funcptrs.html#ga1702f082fd2917bebd7419011ce2ab37">DebugCallbackFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install or remove a callback function to be called whenever the debug layer generates a message. </p>
<p>Multiple callback functions (each with separate callback data) are supported.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">callback</td><td>Pointer to a callback function to call.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">callbackData</td><td>Pointer to arbitrary data to pass in each call to the callback function.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) the specified callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c41f3351aadfd8e94bdd9aaef7c47a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga721dd09710079ec7e1d153842dbc7665">NVNdebugDomainId</a> nvn::Device::GenerateDebugDomainId </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a unique ID by atomically incrementing a global counter on each request. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name to associate to new domain id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace9b476ebbecf1ccfe30270b088de497"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Device::SetWindowOriginMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_window_origin_mode.html">WindowOriginMode</a>&#160;</td>
          <td class="paramname"><em>windowOriginMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global location for window coordinates (0,0). </p>
<p>Applications should set the window origin mode in the device before creating any queues or command buffers, and should use that mode for the lifetime of the application. Rendering results are undefined if there are any inconsistencies between the window origin mode (a) currently set for the device, (b) set when creating the command buffer used to create rendering commands, or (c) set when creating the queue used to submit rendering commands.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">windowOriginMode</td><td>New location for the window origin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11a7a578db399ec77a9ecccc24fd4695"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Device::SetDepthMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_depth_mode.html">DepthMode</a>&#160;</td>
          <td class="paramname"><em>depthMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global clipping range for normalized depth in clip space. </p>
<p>Applications should set the depth mode in the device before creating any queues or command buffers, and should use that mode for the lifetime of the application. Rendering results are undefined if there are any inconsistencies between the depth mode (a) currently set for the device, (b) set when creating the command buffer used to create rendering commands, or (c) set when creating the queue used to submit rendering commands.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthMode</td><td>New policy for depth clipping. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a738e79b4293d108d8dc311840bfb3cd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvn::Device::RegisterFastClearColor </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_format.html">Format</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a fast clear color value. </p>
<p>Applications can register specific combinations of clear values and formats that it expects to use for future framebuffer clears. Clearing the framebuffer using one of these registered clear colors will result in reduced memory bandwidth usage and increased performance when used with compressible textures.</p>
<p>The number of clear values that can be registered is limited. Additionally, this command is supported only for formats with more than 16 bits per pixel and floating-point or normalized components. If a clear value or format can not be registered, NVN_FALSE is returned. If registration is successful, NVN_TRUE is returned.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Array of four floating-point (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">format</td><td><a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> format to encode the value into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13ad1a88a3be2802f1ff0b91fe681d40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvn::Device::RegisterFastClearColori </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_format.html">Format</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a signed integer fast clear color value. </p>
<p>Applications can register specific combinations of clear values and formats that it expects to use for future framebuffer clears. Clearing the framebuffer using one of these registered clear colors will result in reduced memory bandwidth usage and increased performance when used with compressible textures.</p>
<p>The number of clear values that can be registered is limited. Additionally, this command is supported only for formats with more than 16 bits per pixel and signed integer components. If a clear value or format can not be registered, NVN_FALSE is returned. If registration is successful, NVN_TRUE is returned.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Array of four signed integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">format</td><td><a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> format to encode the value into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a156ddbeb91f3c434ec521ecee88b7221"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvn::Device::RegisterFastClearColorui </td>
          <td>(</td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_format.html">Format</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an unsigned integer fast clear color value. </p>
<p>Applications can register specific combinations of clear values and formats that it expects to use for future framebuffer clears. Clearing the framebuffer using one of these registered clear colors will result in reduced memory bandwidth usage and increased performance when used with compressible textures.</p>
<p>The number of clear values that can be registered is limited. Additionally, this command is supported only for formats with more than 16 bits per pixel and unsigned integer components. If a clear value or format can not be registered, NVN_FALSE is returned. If registration is successful, NVN_TRUE is returned.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Array of four unsigned integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">format</td><td><a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> format to encode the value into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3c6011bf315852aebffc88f052fee23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvn::Device::RegisterFastClearDepth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a fast clear depth value. </p>
<p>Applications can register specific clear values that it expects to use for future depth buffer clears. Clearing the depth buffer using one of these registered clear depth values will result in reduced memory bandwidth usage and increased performance when used with compressible textures.</p>
<p>The number of clear values that can be registered is finite. If a clear value can not be registered, NVN_FALSE is returned. If registration is successful, NVN_TRUE is returned. </p><dl class="section note"><dt>覚え書き</dt><dd>16-bit depth textures (<a class="el" href="structnvn_1_1_format.html#aba2b1aac491639bb6601c28a040f5042a3938e9721df440bbebaf6a977acf300c" title="A 16-bit unsigned normalized depth component. ">Format::DEPTH16</a>) have limited support for fast clears. See documentation on <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea53256b41d86cf0e10c4aaa29c206a331" title="Favor fast clear over depth compression for DEPTH16 depth textures. ">TextureFlags::DEPTH16_PREFER_FAST_CLEAR</a> for more information.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>Depth value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83ada4e77f22189e43cab2ca2fcc49d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nvn::Device::GetTimestampInNanoseconds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvn_1_1_counter_data.html">CounterData</a> *&#160;</td>
          <td class="paramname"><em>counterData</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the timestamp contained in a counter report, with time values converted from the platform-specific timestamp resolution to nanoseconds. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">counterData</td><td>Pointer to a full <a class="el" href="structnvn_1_1_counter_data.html" title="Data structure describing how counter values are written to buffer memory. ">CounterData</a> structure containing the timestamp value to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64777ed907fab92b47ff9edb9a3f731d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Device::ApplyDeferredFinalizes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>age</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize buffers, textures, and samplers previously scheduled for finalization. </p>
<p>When a device is initialized with <a class="el" href="structnvn_1_1_device_flag_bits.html#ad00406a44172ac4052ce983e8b978999a9dd1a8b8787a145bd49607f81d50a3d7" title="Enable deferred finalization of textures, buffers and sampler objects. ">DeviceFlagBits::DEFERRED_FINALIZE</a> set, calls to <a class="el" href="classnvn_1_1_buffer.html#aed117298fd0ffcb911c02c708a93802a" title="Finalize a Buffer object. ">Buffer::Finalize</a>, <a class="el" href="classnvn_1_1_texture.html#a8c7b46637959e0e244c50a75f87b6bb6" title="Finalize a Texture object. ">Texture::Finalize</a>, and <a class="el" href="classnvn_1_1_sampler.html#ad73ddd960dcdfbd13a40ac5f5b72e169" title="Finalize a Sampler object. ">Sampler::Finalize</a> don't immediately finalize buffer, texture, and sampler objects, but instead schedule them for future finalization. This command finalizes such objects, where the set of objects finalized by this command depends on the <em>age</em> parameter. This command has no effect if deferred finalization is not enabled in <em>device</em>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">age</td><td>Minimum age for deferred finalizations. Objects scheduled for finalization have an 'age' that is initially set to zero and incremented each time <a class="el" href="classnvn_1_1_device.html#a64777ed907fab92b47ff9edb9a3f731d" title="Finalize buffers, textures, and samplers previously scheduled for finalization. ">Device::ApplyDeferredFinalizes</a> is called. Each object scheduled for finalization will be finalized by this call if and only if its age (before incrementing) is greater than or equal to <em>age</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61010691331b790d583d62686eb0ef35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Device::FinalizeCommandHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__handle.html#ga48a6926aea0b934109f96ae32027b7fb">CommandHandle</a>&#160;</td>
          <td class="paramname"><em>handles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a command handle. </p>
<p>This command can be used to free any memory associated with a command handle that may have been allocated by the debug layer or other developer tools that track the contents of a command set. If command handles are not explicitly finalized, associated memory will be freed only when the command or control memory associated with the command set is freed or reused.</p>
<p>This command has no effect if the debug layer and other developer tools are disabled.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">handles</td><td>Command handle to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61545e8c3aee505841ab9c2f4a07c917"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Device::WalkDebugDatabase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_debug_object_type.html">DebugObjectType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__cpp__funcptrs.html#gab8489c6918b599061b30dc5b079dbc69">WalkDebugDatabaseCallbackFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk through the debug layer object database. </p>
<p>Debug layer must be enabled.</p>
<p>Reports the debug layer's list of objects of the given type through the callback function. At least Level 1 debug layer must be enabled, as object tracking is not done at debug layer level 0. See <a class="el" href="nvn_index.html#nvn_guide_api_object_tracking">API Object Tracking</a> for detail.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">type</td><td>Type of objects to walk through.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">callback</td><td>Callback function to be called for every object matching the given device and object type.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">userParam</td><td>Value to be passed to the callback holding a 'user pointer' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a463633b886dd17440d45b7e8eb7afd5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvn_1_1_separate_texture_handle.html">SeparateTextureHandle</a> nvn::Device::GetSeparateTextureHandle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureID</td><td>Registered ID of the <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da1585230ba0778552b803fbe968704677" title="Number of entries reserved at the beginning of the texture pool for internal driver usage...">nvn::DeviceInfo::RESERVED_TEXTURE_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79589e14ce5376baa5acb751db41950a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvn_1_1_separate_texture_handle.html">SeparateTextureHandle</a> nvn::Device::getSeparateTextureHandle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a separate <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. </p>
<p>Deprecated in favor of <a class="el" href="classnvn_1_1_device.html#a463633b886dd17440d45b7e8eb7afd5a" title="Get a handle for a separate Texture object. ">Device::GetSeparateTextureHandle</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureID</td><td>Registered ID of the <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da1585230ba0778552b803fbe968704677" title="Number of entries reserved at the beginning of the texture pool for internal driver usage...">nvn::DeviceInfo::RESERVED_TEXTURE_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae5ce168413073f07079025748e9a572a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvn_1_1_separate_sampler_handle.html">SeparateSamplerHandle</a> nvn::Device::GetSeparateSamplerHandle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samplerID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">Sampler</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">samplerID</td><td>Registered ID of the <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">Sampler</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da7d6275bfbc504ca717d30c0adf52e07f" title="Number of samplers that must be reserved for use by the driver. ">nvn::DeviceInfo::RESERVED_SAMPLER_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7522a850ed7058114a6681dfaae07994"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvn_1_1_separate_sampler_handle.html">SeparateSamplerHandle</a> nvn::Device::getSeparateSamplerHandle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samplerID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a separate <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">Sampler</a> object. </p>
<p>Deprecated in favor of <a class="el" href="classnvn_1_1_device.html#ae5ce168413073f07079025748e9a572a" title="Get a handle for a separate Sampler object. ">Device::GetSeparateSamplerHandle</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">samplerID</td><td>Registered ID of the <a class="el" href="classnvn_1_1_sampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">Sampler</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61da7d6275bfbc504ca717d30c0adf52e07f" title="Number of samplers that must be reserved for use by the driver. ">nvn::DeviceInfo::RESERVED_SAMPLER_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf33848f725670e58720fb19fc7168c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvn::Device::IsExternalDebuggerAttached </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if an external debugger is attached when running an NVN application. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
