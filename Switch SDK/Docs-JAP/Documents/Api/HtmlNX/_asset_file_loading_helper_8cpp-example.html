<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>NintendoSDK API Reference: AssetFileLoadingHelper.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>総合概要</span></a></li>
      <li><a href="pages.html"><span>諸情報</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>名前空間</span></a></li>
      <li><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">AssetFileLoadingHelper.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>ソースコードの説明は、<a class="el" href="_page_sample_nvn_tutorial_library.html">NVN Tutorial Library</a> および <a class="el" href="_asset_file_loading_helper_8cpp.html" title="This file defines a helper class used to load in asset files generated by Tutorial02. ">AssetFileLoadingHelper.cpp</a> を参照してください。</p>
<div class="fragment"><div class="line"><span class="comment">/*--------------------------------------------------------------------------------*</span></div>
<div class="line"><span class="comment">  Copyright (C)Nintendo All rights reserved.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  These coded instructions, statements, and computer programs contain proprietary</span></div>
<div class="line"><span class="comment">  information of Nintendo and/or its licensed developers and are protected by</span></div>
<div class="line"><span class="comment">  national and international copyright laws. They may not be disclosed to third</span></div>
<div class="line"><span class="comment">  parties or copied or duplicated in any form, in whole or in part, without the</span></div>
<div class="line"><span class="comment">  prior written consent of Nintendo.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  The content herein is highly confidential and should be handled accordingly.</span></div>
<div class="line"><span class="comment"> *--------------------------------------------------------------------------------*/</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstring&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fs_8h.html">nn/fs.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="nn___assert_8h.html">nn/nn_Assert.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="nn___log_8h.html">nn/nn_Log.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="nvn_8h.html">nvn/nvn.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="nvn___func_ptr_inline_8h.html">nvn/nvn_FuncPtrInline.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_asset_file_loading_helper_8h.html">nvntutorial/AssetFileLoadingHelper.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_output_file_headers_8h.html">nvntutorial/OutputFileHeaders.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_tutorial_util_8h.html">nvntutorial/TutorialUtil.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_texture_i_d_manager_8h.html">nvntutorial/TextureIDManager.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_memory_pool_8h.html">nvntutorial/MemoryPool.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper Constructor</span></div>
<div class="line"><span class="comment"> * ----------------------------------</span></div>
<div class="line"><span class="comment"> * Sets up the file loader with a pointer to the NVNdevice and</span></div>
<div class="line"><span class="comment"> * the texture ID manager for the application.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">AssetFileLoadingHelper::AssetFileLoadingHelper(<a name="_a0"></a><a class="code" href="struct_n_v_ndevice.html">NVNdevice</a>* pDevice, TextureIDManager* pTextureIDManager) :</div>
<div class="line">    m_pDevice(pDevice),</div>
<div class="line">    m_pTextureIDManager(pTextureIDManager),</div>
<div class="line">    m_pFileHead(NULL),</div>
<div class="line">    m_FileSize(0)</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">* AssetFileLoadingHelper Destructor</span></div>
<div class="line"><span class="comment">* ---------------------------------</span></div>
<div class="line"><span class="comment">* Cleans up the file loader.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">AssetFileLoadingHelper::~AssetFileLoadingHelper()</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper::LoadAssetFile</span></div>
<div class="line"><span class="comment"> * -------------------------------------</span></div>
<div class="line"><span class="comment"> * Loads the binary asset file, checks for each section of</span></div>
<div class="line"><span class="comment"> * the file, and interprets the data for the sections that</span></div>
<div class="line"><span class="comment"> * exist.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">AssetFileDataHolder* AssetFileLoadingHelper::LoadAssetFile(<span class="keyword">const</span> <span class="keywordtype">char</span>* pFilename)</div>
<div class="line">{</div>
<div class="line">    <a name="a1"></a><a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pFilename != NULL, <span class="stringliteral">&quot;File name to load NULL&quot;</span>);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Reads in the binary file and grabs a pointer to its head. */</span></div>
<div class="line">    <a name="_a2"></a><a class="code" href="structnn_1_1fs_1_1_file_handle.html">nn::fs::FileHandle</a> fileHandle;</div>
<div class="line">    std::string rom(<span class="stringliteral">&quot;rom:/&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <a name="_a3"></a><a class="code" href="classnn_1_1_result.html">nn::Result</a> res = <a name="a4"></a><a class="code" href="namespacenn_1_1fs.html#a0f2b5b30657b1ffaf1dec49bfb36462b">nn::fs::OpenFile</a>(&amp;fileHandle, (rom + pFilename).c_str(), <a name="a5"></a><a class="code" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393afde4472d2b455879cad02aade386ac0d">nn::fs::OpenMode_Read</a>);</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(res.<a name="a6"></a><a class="code" href="classnn_1_1_result.html#a80792d8ec8b6b9e9b34025100baa67ec">IsSuccess</a>());</div>
<div class="line"></div>
<div class="line">    res = <a name="a7"></a><a class="code" href="namespacenn_1_1fs.html#aba29e01d386e809349d60eccdb15ff21">nn::fs::GetFileSize</a>(&amp;m_FileSize, fileHandle);</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(res.IsSuccess());</div>
<div class="line"></div>
<div class="line">    m_pFileHead = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(AlignedAllocate(static_cast&lt;size_t&gt;(m_FileSize + 1), 8));</div>
<div class="line">    memset(m_pFileHead, 0, static_cast&lt;size_t&gt;(m_FileSize + 1));</div>
<div class="line">    <span class="keywordtype">size_t</span> out;</div>
<div class="line">    res = <a name="a8"></a><a class="code" href="namespacenn_1_1fs.html#a81801a404563984f8c6cc1483cc6d730">nn::fs::ReadFile</a>(&amp;out, fileHandle, 0, m_pFileHead, static_cast&lt;size_t&gt;(m_FileSize));</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(res.IsSuccess());</div>
<div class="line"></div>
<div class="line">    OutputFileHeader* pFileHeader = <span class="keyword">reinterpret_cast&lt;</span>OutputFileHeader*<span class="keyword">&gt;</span>(m_pFileHead);</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pFileHeader != NULL, <span class="stringliteral">&quot;Failed to read file header&quot;</span>)</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Creates a default buffer builder. */</span></div>
<div class="line">    <a name="a9"></a><a class="code" href="group__nvn__c__functions.html#ga7f1e5a40cc9b049892a527b95ac9b9fc">nvnBufferBuilderSetDevice</a>(&amp;m_BufferBuilder, m_pDevice);</div>
<div class="line">    <a name="a10"></a><a class="code" href="group__nvn__c__functions.html#ga17550ab21d8136e4f5c48c91c21716f2">nvnBufferBuilderSetDefaults</a>(&amp;m_BufferBuilder);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Creates a default texture builder. */</span></div>
<div class="line">    <a name="a11"></a><a class="code" href="group__nvn__c__functions.html#ga3125b10128cdf01e0c489ebf9644cc36">nvnTextureBuilderSetDevice</a>(&amp;m_TextureBuilder, m_pDevice);</div>
<div class="line">    <a name="a12"></a><a class="code" href="group__nvn__c__functions.html#ga6287f82327692478ee9040e4fe73dd36">nvnTextureBuilderSetDefaults</a>(&amp;m_TextureBuilder);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Creates a default sampler builder. */</span></div>
<div class="line">    <a name="a13"></a><a class="code" href="group__nvn__c__functions.html#ga7504233cce44b1f5a7223f322b76a84d">nvnSamplerBuilderSetDevice</a>(&amp;m_SamplerBuilder, m_pDevice);</div>
<div class="line">    <a name="a14"></a><a class="code" href="group__nvn__c__functions.html#ga889b306858059648c66e88a226391acc">nvnSamplerBuilderSetDefaults</a>(&amp;m_SamplerBuilder);</div>
<div class="line"></div>
<div class="line">    m_pDataHolder = new AssetFileDataHolder();</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Check for the shader section of the file and interpret the data. */</span></div>
<div class="line">    if (pFileHeader-&gt;m_ShaderBlockOffset &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">char</span>* pShaderBlockHead = m_pFileHead + pFileHeader-&gt;m_ShaderBlockOffset;</div>
<div class="line">        LoadShaders(pShaderBlockHead);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Check for the texture section of the file and interpret the data. */</span></div>
<div class="line">    <span class="keywordflow">if</span> (pFileHeader-&gt;m_TextureBlockOffset &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">char</span>* pTextureBlockHead = m_pFileHead + pFileHeader-&gt;m_TextureBlockOffset;</div>
<div class="line">        LoadTextures(pTextureBlockHead);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Check for the model section of the file and interpret the data. */</span></div>
<div class="line">    <span class="keywordflow">if</span> (pFileHeader-&gt;m_ModelBlockOffset &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">char</span>* pModelBlockHead = m_pFileHead + pFileHeader-&gt;m_ModelBlockOffset;</div>
<div class="line">        LoadModels(pModelBlockHead);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a name="a15"></a><a class="code" href="namespacenn_1_1fs.html#ac8bd9e828751bd4f953acfa765278f84">nn::fs::CloseFile</a>(fileHandle);</div>
<div class="line"></div>
<div class="line">    AlignedDeallocate(m_pFileHead);</div>
<div class="line">    m_pFileHead = NULL;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> m_pDataHolder;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper::LoadSpecializedShaders</span></div>
<div class="line"><span class="comment"> * -------------------------------------</span></div>
<div class="line"><span class="comment"> * Generates the specialized versions of a set of shaders</span></div>
<div class="line"><span class="comment"> * passed in and loaded at runtime into a number of unique</span></div>
<div class="line"><span class="comment"> * shader programs, new NVNProgramData objects are loaded</span></div>
<div class="line"><span class="comment"> * into the AssetFileLoadingHelper class used to call</span></div>
<div class="line"><span class="comment"> * this function</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> AssetFileLoadingHelper::LoadSpecializedShaders(</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>** ppShaderSources,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;NVNshaderStage&gt;&amp; shaderStages,</div>
<div class="line">    <a name="_a16"></a><a class="code" href="struct_g_l_s_l_cspecialization_batch.html">GLSLCspecializationBatch</a>* specializationBatch,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* shaderProgramName,</div>
<div class="line">    <span class="keywordtype">int</span> nameLength,</div>
<div class="line">    ReflectionBlockInfoFunction blockFunction,</div>
<div class="line">    ReflectionUniformInfoFunction uniformFunction,</div>
<div class="line">    AttributeReflectionInfoFunction attributeFunction)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(ppShaderSources != NULL, <span class="stringliteral">&quot;No shader source passed in\n&quot;</span>);</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(shaderStages.size() &gt; 0, <span class="stringliteral">&quot;No shader stages passed in\n&quot;</span>);</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(specializationBatch != NULL, <span class="stringliteral">&quot;No shader specialization batch passed in\n&quot;</span>);</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(blockFunction != NULL &amp;&amp; uniformFunction != NULL, <span class="stringliteral">&quot;No reflection functions passed to shader specialization\n&quot;</span>);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * The compile object contains the input shader source, options for compilation,</span></div>
<div class="line"><span class="comment">         * and all the results (error logs in the result of failure) of each step of</span></div>
<div class="line"><span class="comment">         * compilation.  Valid until the object is used for another regular Compile</span></div>
<div class="line"><span class="comment">         * operation, Pre-Specialized + Specialized operation, or until the object</span></div>
<div class="line"><span class="comment">         * is finalized.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <a name="_a17"></a><a class="code" href="struct_g_l_s_l_ccompile_object.html">GLSLCcompileObject</a> compileObject;</div>
<div class="line">    uint8_t initializeResult = <a name="a18"></a><a class="code" href="nvn_tool___glslc_interface_8h.html#a648dfc0b503357a72dad03652fc31e57">glslcInitialize</a>(&amp;compileObject);</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(initializeResult == 1, <span class="stringliteral">&quot;Failed to initialize glslc compile object\n&quot;</span>);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Contains input array of shader source */</span></div>
<div class="line">    <a name="_a19"></a><a class="code" href="struct_g_l_s_l_cinput.html">GLSLCinput</a>&amp; glslcInput = compileObject.<a name="a20"></a><a class="code" href="struct_g_l_s_l_ccompile_object.html#a1439e7a28e5232e1dc82924e8c4d063d">input</a>;</div>
<div class="line">    glslcInput.sources = ppShaderSources;</div>
<div class="line">    glslcInput.<a name="a21"></a><a class="code" href="struct_g_l_s_l_cinput.html#a2dd94f2657ef155e688d6a9927c6c381">count</a> = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(shaderStages.size());</div>
<div class="line">    glslcInput.stages = &amp;shaderStages[0];</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Various options available for compiling the shaders */</span></div>
<div class="line">    <a name="_a22"></a><a class="code" href="struct_g_l_s_l_coptions.html">GLSLCoptions</a>&amp; glslcOptions = compileObject.<a name="a23"></a><a class="code" href="struct_g_l_s_l_ccompile_object.html#a6cc042ea5fe41d3aa6c9fac773a447b8">options</a>;</div>
<div class="line">    glslcOptions.<a name="a24"></a><a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a25"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#af673dc6b82db05442d203619be5a022d">glslSeparable</a> = shaderStages.size() &lt; 2;</div>
<div class="line">    glslcOptions.<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a26"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#ac0396d28c3ec928aaa280cb90e71f485">outputAssembly</a> = <span class="keyword">false</span>;</div>
<div class="line">    <span class="comment">// NOTE: This must be set to true for now.</span></div>
<div class="line">    glslcOptions.<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a27"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#aec0779a250ad31f6deafe470820ffbb8">outputGpuBinaries</a> = <span class="keyword">true</span>;</div>
<div class="line">    glslcOptions.<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a28"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#ad57cedc549a410a87a8b5e667afd31b9">outputPerfStats</a> = <span class="keyword">true</span>;</div>
<div class="line">    glslcOptions.<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a29"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#a723afb9e18cdf4c92bfe315c94e37c96">outputShaderReflection</a> = <span class="keyword">true</span>;</div>
<div class="line">    glslcOptions.<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a30"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#af2b81192a389ab5093f074ced7ceea29">outputDebugInfo</a> = <a name="a31"></a><a class="code" href="nvn_tool___glslc_interface_8h.html#a238b82c174a58d9f9e2be6aa3e8a5bfea81704ec256f338d05d20e0d618decdef">GLSLC_DEBUG_LEVEL_G0</a>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Denotes whether to output gpu binaries of</span></div>
<div class="line"><span class="comment">         * a smaller size for exclusive use on the NX</span></div>
<div class="line"><span class="comment">         * device. This option has no effect on binaries</span></div>
<div class="line"><span class="comment">         * generated on Windows, which will continue to</span></div>
<div class="line"><span class="comment">         * contain the data necessary for both Windows</span></div>
<div class="line"><span class="comment">         * and NX use.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"><span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line">    glslcOptions.<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a32"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#acb869c3adcd98163305142fba3d84e2b">outputThinGpuBinaries</a> = 0;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    glslcOptions.<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a class="code" href="struct_g_l_s_l_coption_flags.html#acb869c3adcd98163305142fba3d84e2b">outputThinGpuBinaries</a> = 1;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * The first step of shader specialization, the pre-specialized compile</span></div>
<div class="line"><span class="comment">         * function takes the raw shader source and generates intermediary</span></div>
<div class="line"><span class="comment">         * data that will be used in the specialized compile function below.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * NOTE: When using glslc online, it is required that glslcSetAllocator</span></div>
<div class="line"><span class="comment">         * is called with function pointers to an allocator and deallocator function</span></div>
<div class="line"><span class="comment">         * for glslc functions (bar glslcInitialize) to work.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordflow">if</span>(!<a name="a33"></a><a class="code" href="nvn_tool___glslc_interface_8h.html#a8a7629609d27a49283b8cb9587dcca48">glslcCompilePreSpecialized</a>(&amp;compileObject))</div>
<div class="line">    {</div>
<div class="line">        <a name="a34"></a><a class="code" href="nn___log_8h.html#aa8c0b58247a2078e37f2fe0974b98a61">NN_LOG</a>(compileObject.lastCompiledResults-&gt;compilationStatus-&gt;infoLog);</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Shader specialization precompilation failed\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Reflection information is ALWAYS generated by the pre-specialized function</span></div>
<div class="line"><span class="comment">         * above, regardless of whether the outputShaderReflection flag is set in the</span></div>
<div class="line"><span class="comment">         * glslc options above.  The reflection header contains offsets into the header</span></div>
<div class="line"><span class="comment">         * itself that contain the actual reflection information.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <a name="_a35"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html">GLSLCprogramReflectionHeader</a>* pReflectionHeader = compileObject.reflectionSection;</div>
<div class="line">    <span class="keyword">const</span> uint8_t* pReflectionData = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint8_t*<span class="keyword">&gt;</span>(pReflectionHeader) + pReflectionHeader-&gt;<a name="a36"></a>common.<a name="a37"></a><a class="code" href="struct_g_l_s_l_csection_header_common.html#abb6e96b70bad30c94477317328d384d5">dataOffset</a>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* pStringPool = reinterpret_cast&lt;const char*&gt;(pReflectionData) + pReflectionHeader-&gt;<a name="a38"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a23a3fcd75086c2b537f992e212661622">stringPoolOffset</a>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Grabs a pointer to the reflection information of the first uniform block</span></div>
<div class="line"><span class="comment">         * listed.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keyword">const</span> <a name="_a39"></a><a class="code" href="struct_g_l_s_l_cuniform_block_info.html">GLSLCuniformBlockInfo</a>* pUniformBlock = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="struct_g_l_s_l_cuniform_block_info.html">GLSLCuniformBlockInfo</a> *<span class="keyword">&gt;</span>(pReflectionData + pReflectionHeader-&gt;<a name="a40"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#ab7239cf2349bda4632d8382ffddcde85">uniformBlockOffset</a>);</div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; pReflectionHeader-&gt;<a name="a41"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a006944206bfbf2bbfb56c1dfb9dc7f96">numUniformBlocks</a>; ++i)</div>
<div class="line">    {</div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * Grab the binding location of the uniform block.  Each of the</span></div>
<div class="line"><span class="comment">             * entries in the bindings array corresponds to the enum values</span></div>
<div class="line"><span class="comment">             * in NVNshaderStage and lists the binding location of the block</span></div>
<div class="line"><span class="comment">             * in that stage;  a value of -1 means the block is not bound</span></div>
<div class="line"><span class="comment">             * in that stage.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        int32_t bindingLocation = -1;</div>
<div class="line">        <span class="keywordflow">for</span>(uint32_t j = 0; j &lt; GLSLC_NUM_SHADER_STAGES; ++j)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span>(pUniformBlock-&gt;<a name="a42"></a><a class="code" href="struct_g_l_s_l_cuniform_block_info.html#a3089f78f6431b069fca45643190b8f88">bindings</a>[j] &gt; -1)</div>
<div class="line">            {</div>
<div class="line">                bindingLocation = pUniformBlock-&gt;<a class="code" href="struct_g_l_s_l_cuniform_block_info.html#a3089f78f6431b069fca45643190b8f88">bindings</a>[j];</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * Pass the reflection information (binding location, block size, and name)</span></div>
<div class="line"><span class="comment">             * through the function pointer passed in.  Additional reflection parameters</span></div>
<div class="line"><span class="comment">             * can be found in the definition of the GLSLCuniformBlockInfo struct.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        <span class="keywordflow">if</span>(bindingLocation &gt; -1)</div>
<div class="line">        {</div>
<div class="line">            std::string blockName = pStringPool + pUniformBlock-&gt;<a name="a43"></a><a class="code" href="struct_g_l_s_l_cuniform_block_info.html#af581f038ae9544eb77e43729691532a8">nameInfo</a>.<a name="a44"></a><a class="code" href="struct_g_l_s_l_cpiq_name.html#a95cb55a78c99bc13a5442a4ec038fe64">nameOffset</a>;</div>
<div class="line">                <span class="comment">/* Call reflection function */</span></div>
<div class="line">            blockFunction(pUniformBlock-&gt;<a name="a45"></a><a class="code" href="struct_g_l_s_l_cuniform_block_info.html#a449b0310144f865d20c9152228c1f5c2">stagesReferencedIn</a>, bindingLocation, pUniformBlock-&gt;<a name="a46"></a><a class="code" href="struct_g_l_s_l_cuniform_block_info.html#a995ad7b06ac8f754faceea20cb6b8443">size</a>, blockName);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* Advance to the next uniform block&#39;s reflection info */</span></div>
<div class="line">        ++pUniformBlock;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Grabs a pointer to the reflection information of the first uniform variable</span></div>
<div class="line"><span class="comment">         * listed.  The uniforms in this part of the reflection header come from all</span></div>
<div class="line"><span class="comment">         * uniform blocks in the shaders provided and no guarantee is made to their</span></div>
<div class="line"><span class="comment">         * ordering.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keyword">const</span> <a name="_a47"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html">GLSLCuniformInfo</a>* pUniformData = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="struct_g_l_s_l_cuniform_info.html">GLSLCuniformInfo</a> *<span class="keyword">&gt;</span>(pReflectionData + pReflectionHeader-&gt;<a name="a48"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a7116c27cf2638894a145fcdbb7d05568">uniformOffset</a>);</div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; pReflectionHeader-&gt;<a name="a49"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a0bf19ae5c6027329eec9480f13c71d3c">numUniforms</a>; ++j)</div>
<div class="line">    {</div>
<div class="line">        std::string uniformName = pStringPool + pUniformData-&gt;<a name="a50"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#af3c2cf0a643a810defd8f1964ee5347c">nameInfo</a>.<a class="code" href="struct_g_l_s_l_cpiq_name.html#a95cb55a78c99bc13a5442a4ec038fe64">nameOffset</a>;</div>
<div class="line"></div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * Pass the reflection information (stages uniform is referenced in, offset in uniform block, and name)</span></div>
<div class="line"><span class="comment">             * through the function pointer passed in.  Additional reflection parameters can be found in the</span></div>
<div class="line"><span class="comment">             * definition of the GLSLCuniformInfo struct.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        uniformFunction(pUniformData-&gt;<a name="a51"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#a062aec36dd8b1203f67b1a8bd12948ee">stagesReferencedIn</a>, pUniformData-&gt;<a name="a52"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#a2f72999cec8d93607ffc6c9488c8bd6e">blockOffset</a>, 0, uniformName);</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* Advance to the next uniform variable&#39;s reflection info */</span></div>
<div class="line">        ++pUniformData;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Grabs a pointer to the reflection information of the shader</span></div>
<div class="line"><span class="comment">         * program inputs.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keyword">const</span> <a name="_a53"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html">GLSLCprogramInputInfo</a>* pProgramInput = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="struct_g_l_s_l_cprogram_input_info.html">GLSLCprogramInputInfo</a> *<span class="keyword">&gt;</span>(pReflectionData + pReflectionHeader-&gt;<a name="a54"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a9f264ef95c68193971b360b4df2f259d">programInputsOffset</a>);</div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t j = 0; j &lt; pReflectionHeader-&gt;<a name="a55"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#aca10eea8e482a030016556875aec0a7f">numProgramInputs</a>; ++j)</div>
<div class="line">    {</div>
<div class="line">        std::string name = pStringPool + pProgramInput-&gt;<a name="a56"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#a30e2dc0f471667ac41cdde8329d71e25">nameInfo</a>.<a class="code" href="struct_g_l_s_l_cpiq_name.html#a95cb55a78c99bc13a5442a4ec038fe64">nameOffset</a>;</div>
<div class="line"></div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * Pass the reflection information (stages attribute is referenced in, binding location, and name)</span></div>
<div class="line"><span class="comment">             * through the function pointer passed in.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        attributeFunction(pProgramInput-&gt;<a name="a57"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#aa850abcd72ca572b118cea86cc858af7">stagesReferencedIn</a>, pProgramInput-&gt;<a name="a58"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#ac0100c9580f95e97b101ae505680bef0">location</a>, name);</div>
<div class="line">        ++pProgramInput;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * The second and last step of shader specialization, the specialized</span></div>
<div class="line"><span class="comment">         * compile function takes the intermediary data stored in the compile</span></div>
<div class="line"><span class="comment">         * object and generates an array of GLSLCoutput objects, each one</span></div>
<div class="line"><span class="comment">         * representing the compiled output of one of the shader programs.</span></div>
<div class="line"><span class="comment">         * The number of output objects corresponds to the number of</span></div>
<div class="line"><span class="comment">         * specialization sets contained in the specialization batch object.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keyword">const</span> <a name="_a59"></a><a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a>* <span class="keyword">const</span>* ppGlslcOutputs = <a name="a60"></a><a class="code" href="nvn_tool___glslc_interface_8h.html#a64bdf010fc635ccc01dc9f1625557da1">glslcCompileSpecialized</a>(&amp;compileObject, specializationBatch);</div>
<div class="line">    <span class="keywordflow">if</span>(ppGlslcOutputs == NULL || compileObject.lastCompiledResults-&gt;compilationStatus-&gt;success != 1)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nn___log_8h.html#aa8c0b58247a2078e37f2fe0974b98a61">NN_LOG</a>(compileObject.lastCompiledResults-&gt;compilationStatus-&gt;infoLog);</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Shader specialization compilation failed\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Looping through the array of output objects, the data within</span></div>
<div class="line"><span class="comment">         * is placed into ShaderStageHeader structs and passed to the</span></div>
<div class="line"><span class="comment">         * CreateShaderProgram function to be placed into memory pools</span></div>
<div class="line"><span class="comment">         * and NVNprograms created.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; specializationBatch-&gt;<a name="a61"></a><a class="code" href="struct_g_l_s_l_cspecialization_batch.html#a0be46d42422ea32ebcc5e31ca3016484">numEntries</a>; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a>* currentGlslcOutput = ppGlslcOutputs[i];</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">int</span> shaderSections = currentGlslcOutput-&gt;<a name="a62"></a><a class="code" href="struct_g_l_s_l_coutput.html#a6cbb6ec5e8a4ff04512fd1c442aa3d92">numSections</a>;</div>
<div class="line">        std::vector&lt;ShaderStageHeader&gt; shaderStageHeaders;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; shaderSections; ++j)</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * Each shader stage (vertex, fragment, etc...) will have a glslc section that</span></div>
<div class="line"><span class="comment">                 * contains all the relevant data for it, as denoted by the GLSLC_SECTION_TYPE_GPU_CODE</span></div>
<div class="line"><span class="comment">                 * enum.  Other types of glslc sections can be found in GLSLCsectionTypeEnum in</span></div>
<div class="line"><span class="comment">                 * nvnToolGlslcInterface.h</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">            <a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59">GLSLCsectionTypeEnum</a> type = currentGlslcOutput-&gt;<a name="a63"></a><a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[j].<a name="a64"></a>genericHeader.<a name="a65"></a>common.<a name="a66"></a><a class="code" href="struct_g_l_s_l_csection_header_common.html#a6a8aed7a5a7e82acff908d084fd85e4a">type</a>;</div>
<div class="line">            <span class="keywordflow">if</span> (type == <a name="a67"></a><a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59a332c55c4b44004865dda7d54c91df448">GLSLC_SECTION_TYPE_GPU_CODE</a>)</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">const</span> <a name="_a68"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html">GLSLCgpuCodeHeader</a>&amp; pGpuHeader = (currentGlslcOutput-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[j].<a name="a69"></a>gpuCodeHeader);</div>
<div class="line">                <span class="keyword">const</span> uint8_t* pData = (<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint8_t*<span class="keyword">&gt;</span>(currentGlslcOutput)) + pGpuHeader.<a name="a70"></a>common.<a class="code" href="struct_g_l_s_l_csection_header_common.html#abb6e96b70bad30c94477317328d384d5">dataOffset</a>;</div>
<div class="line"></div>
<div class="line">                shaderStageHeaders.push_back(ShaderStageHeader());</div>
<div class="line">                ShaderStageHeader&amp; currentHeader    = shaderStageHeaders.back();</div>
<div class="line">                currentHeader.m_ShaderStage         = pGpuHeader.<a name="a71"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#ab1e6be676a326a7281e18ad3a4607ced">stage</a>;</div>
<div class="line">                currentHeader.m_ShaderDataSize      = pGpuHeader.<a name="a72"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#a2617848640a161d41ed59f1a7c0ccb35">dataSize</a>;</div>
<div class="line">                currentHeader.m_ShaderControlSize   = pGpuHeader.<a name="a73"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#aff5295c90f2dc5eb969fb14660f31712">controlSize</a>;</div>
<div class="line">                currentHeader.m_ShaderControlOffset = 0;</div>
<div class="line">                currentHeader.m_pShaderData         = <span class="keyword">const_cast&lt;</span>uint8_t*<span class="keyword">&gt;</span>(pData + pGpuHeader.<a name="a74"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#aafdececf784595d922fe1b95b06db976">dataOffset</a>);</div>
<div class="line">                currentHeader.m_pShaderControl      = <span class="keyword">const_cast&lt;</span>uint8_t*<span class="keyword">&gt;</span>(pData + pGpuHeader.<a name="a75"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#a3b606fedf8582a1a47162d210e8a1448">controlOffset</a>);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        NVNProgramData* pProgramData = <span class="keyword">new</span> NVNProgramData;</div>
<div class="line">        pProgramData-&gt;Initialize();</div>
<div class="line">        pProgramData-&gt;SetName(shaderProgramName, nameLength);</div>
<div class="line"></div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * Creates the actual NVNprogram using the shader data pulled above.</span></div>
<div class="line"><span class="comment">             * An NVNProgramData object is inserted into this asset loaders&#39;s</span></div>
<div class="line"><span class="comment">             * data holder.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        CreateShaderProgram(shaderStageHeaders, pProgramData);</div>
<div class="line">        m_pDataHolder-&gt;AddProgramData(pProgramData);</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Finalize the compile object, rendering all data it held invalid</span></div>
<div class="line"><span class="comment">         * and preventing reuse of the object until glslcInitialize is called</span></div>
<div class="line"><span class="comment">         * on it again.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <a name="a76"></a><a class="code" href="nvn_tool___glslc_interface_8h.html#a05b2032c99f789df2a34ebf32271c320">glslcFinalize</a>(&amp;compileObject);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper::LoadShaders</span></div>
<div class="line"><span class="comment"> * -----------------------------------</span></div>
<div class="line"><span class="comment"> * Receives a pointer to the shader block of data and passes</span></div>
<div class="line"><span class="comment"> * a pointer to the start of an individual shader program&#39;s</span></div>
<div class="line"><span class="comment"> * block to be parsed.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> AssetFileLoadingHelper::LoadShaders(<span class="keyword">const</span> <span class="keywordtype">char</span>* pShaderBlockHead)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pShaderBlockHead != NULL, <span class="stringliteral">&quot;Shader block header pointer NULL&quot;</span>);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Grabs the number of shaders and their offsets. */</span></div>
<div class="line">    <span class="keyword">const</span> ShaderBlockHeader* pShaderBlockHeader = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>ShaderBlockHeader*<span class="keyword">&gt;</span>(pShaderBlockHead);</div>
<div class="line">    uint32_t numPrograms = pShaderBlockHeader-&gt;m_NumShaderPrograms;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> uint64_t* pShaderProgramHeaderOffsets = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint64_t*<span class="keyword">&gt;</span>((pShaderBlockHead + <span class="keyword">sizeof</span>(uint32_t) * 2));</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Creates a program for each shader. */</span></div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; numPrograms; ++i)</div>
<div class="line">    {</div>
<div class="line">        NVNProgramData* pProgramData = LoadShaderHeaders(m_pFileHead + pShaderProgramHeaderOffsets[i]);</div>
<div class="line">        m_pDataHolder-&gt;AddProgramData(pProgramData);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper::LoadShaderHeaders</span></div>
<div class="line"><span class="comment"> * -----------------------------------</span></div>
<div class="line"><span class="comment"> * Parses the pointer passed in for the data necessary to build</span></div>
<div class="line"><span class="comment"> * an NVNprogram.  This data is then passed onto CreateShaderProgram</span></div>
<div class="line"><span class="comment"> * to actually create the NVNprogram and set up the memory pools</span></div>
<div class="line"><span class="comment"> * for the data to be copied into.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">NVNProgramData* AssetFileLoadingHelper::LoadShaderHeaders(<span class="keyword">const</span> <span class="keywordtype">char</span>* pShaderProgramHead)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pShaderProgramHead != NULL, <span class="stringliteral">&quot;Shader program header pointer NULL&quot;</span>);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Grabs the metadata and the list of offsets to individual shader stages. */</span></div>
<div class="line">    <span class="keyword">const</span> ShaderProgramHeader* pShaderProgramHeader = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>ShaderProgramHeader*<span class="keyword">&gt;</span>(pShaderProgramHead);</div>
<div class="line"></div>
<div class="line">    uint32_t                   numShaderStages      = pShaderProgramHeader-&gt;m_NumShaderStages;</div>
<div class="line">    <span class="keyword">const</span> uint64_t*            pShaderStageOffsets  = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint64_t*<span class="keyword">&gt;</span>(pShaderProgramHead + <span class="keyword">sizeof</span>(uint32_t) * 2);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>*                pProgramName         = pShaderProgramHead + <span class="keyword">sizeof</span>(uint32_t) * 2 + <span class="keyword">sizeof</span>(uint64_t) * numShaderStages;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (pShaderProgramHeader == NULL ||</div>
<div class="line">        pShaderProgramHeader-&gt;m_ProgramNameLength == 0 ||</div>
<div class="line">        pProgramName == NULL ||</div>
<div class="line">        numShaderStages == 0 ||</div>
<div class="line">        pShaderStageOffsets == NULL)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to read ShaderProgramHeader&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    NVNProgramData* pProgramData = <span class="keyword">new</span> NVNProgramData;</div>
<div class="line">    pProgramData-&gt;Initialize();</div>
<div class="line">    pProgramData-&gt;SetName(pProgramName, pShaderProgramHeader-&gt;m_ProgramNameLength);</div>
<div class="line">    pProgramData-&gt;m_ShaderType = ShaderTypes::GetShaderTypeEnum(std::string(pProgramData-&gt;m_pProgramName));</div>
<div class="line"></div>
<div class="line">    std::vector&lt;ShaderStageHeader&gt; shaderStageHeaders;</div>
<div class="line">    shaderStageHeaders.resize(numShaderStages, ShaderStageHeader());</div>
<div class="line"></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Grab the stage metadata and pointers to the control and data section</span></div>
<div class="line"><span class="comment">         * of the compiled shader.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; numShaderStages; ++i)</div>
<div class="line">    {</div>
<div class="line">        ShaderStageHeader* pShaderStageHeader = <span class="keyword">reinterpret_cast&lt;</span>ShaderStageHeader*<span class="keyword">&gt;</span>(m_pFileHead + pShaderStageOffsets[i]);</div>
<div class="line"></div>
<div class="line">        shaderStageHeaders[i].m_ShaderStage         = pShaderStageHeader-&gt;m_ShaderStage;</div>
<div class="line">        shaderStageHeaders[i].m_ShaderDataSize      = pShaderStageHeader-&gt;m_ShaderDataSize;</div>
<div class="line">        shaderStageHeaders[i].m_ShaderControlSize   = pShaderStageHeader-&gt;m_ShaderControlSize;</div>
<div class="line">        shaderStageHeaders[i].m_ShaderControlOffset = pShaderStageHeader-&gt;m_ShaderControlOffset;</div>
<div class="line">        shaderStageHeaders[i].m_pShaderData         = m_pFileHead + pShaderStageOffsets[i] + 4 * <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">        shaderStageHeaders[i].m_pShaderControl      = m_pFileHead + shaderStageHeaders[i].m_ShaderControlOffset;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    CreateShaderProgram(shaderStageHeaders, pProgramData);</div>
<div class="line">    <span class="keywordflow">return</span> pProgramData;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper::CreateShaderProgram</span></div>
<div class="line"><span class="comment"> * -------------------------------------------</span></div>
<div class="line"><span class="comment"> * Saves the shader metadata in an NVNProgramData object</span></div>
<div class="line"><span class="comment"> * and creates an NVNprogram object from the compiled</span></div>
<div class="line"><span class="comment"> * shader binary.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> AssetFileLoadingHelper::CreateShaderProgram(std::vector&lt;ShaderStageHeader&gt;&amp; shaderStageHeaders, NVNProgramData* pProgramData)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pProgramData != NULL, <span class="stringliteral">&quot;Pointer to program data to modify is NULL&quot;</span>);</div>
<div class="line"></div>
<div class="line">    uint32_t numShaderStages = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(shaderStageHeaders.size());</div>
<div class="line"></div>
<div class="line">    std::vector&lt;size_t&gt; alignmentOffsets;</div>
<div class="line">    alignmentOffsets.resize(numShaderStages, 0);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Grab the stage metadata and pointers to the control and data section</span></div>
<div class="line"><span class="comment">         * of the compiled shader.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordtype">size_t</span> shaderDataBufferMemoryPoolSize = 0;</div>
<div class="line">    <span class="keywordtype">int</span> bufferAlignment = 0;</div>
<div class="line">    <a name="a77"></a><a class="code" href="group__nvn__c__functions.html#ga6f739de39c3818a65b190be3a82cf891">nvnDeviceGetInteger</a>(m_pDevice, <a name="a78"></a><a class="code" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ac5b90148e47e9a26cd38b367123ff374">NVN_DEVICE_INFO_UNIFORM_BUFFER_ALIGNMENT</a>, &amp;bufferAlignment);</div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; numShaderStages; ++i)</div>
<div class="line">    {</div>
<div class="line">            <span class="comment">/* Store offsets for filling the memory pool and initializing buffers. */</span></div>
<div class="line">        alignmentOffsets[i] = shaderDataBufferMemoryPoolSize;</div>
<div class="line">        shaderDataBufferMemoryPoolSize += shaderStageHeaders[i].m_ShaderDataSize;</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* Make sure the size is at the correct alignment. */</span></div>
<div class="line">        shaderDataBufferMemoryPoolSize = Align(shaderDataBufferMemoryPoolSize, bufferAlignment);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Shader code is not allowed to be in the last 1024 bytes of a memory pool,</span></div>
<div class="line"><span class="comment">         * additional padding is added to ensure that does not happen.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    shaderDataBufferMemoryPoolSize += 1024;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Copy the shader data into a contiguous block of memory to wrap a pool around. */</span></div>
<div class="line">    <span class="keywordtype">size_t</span> memoryPoolAlignedSize;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (shaderDataBufferMemoryPoolSize &lt; g_MinimumPoolSize)</div>
<div class="line">    {</div>
<div class="line">        memoryPoolAlignedSize = g_MinimumPoolSize;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        memoryPoolAlignedSize = Align(shaderDataBufferMemoryPoolSize, <a name="a79"></a><a class="code" href="group__nvn__c__defines.html#gadfd69601d2d9f953c55808127ba60853">NVN_MEMORY_POOL_STORAGE_GRANULARITY</a>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">char</span>* shaderDataArray = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(AlignedAllocate(memoryPoolAlignedSize, <a name="a80"></a><a class="code" href="group__nvn__c__defines.html#gace820e752b400cf7aa36e9684a7f45cb">NVN_MEMORY_POOL_STORAGE_ALIGNMENT</a>));</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; shaderStageHeaders.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        memcpy(shaderDataArray + alignmentOffsets[i], shaderStageHeaders[i].m_pShaderData, shaderStageHeaders[i].m_ShaderDataSize);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Create new memory pool around the shader data. Any memory pool</span></div>
<div class="line"><span class="comment">         * that wishes to load compiled shader data must have the</span></div>
<div class="line"><span class="comment">         * NVN_MEMORY_POOL_FLAGS_SHADER_CODE_BIT bit set.</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * NOTE: Avoid loading a shader into the last 1kb of memory in the</span></div>
<div class="line"><span class="comment">         * memory pool. GPU shader cores may pre-fetch from instruction</span></div>
<div class="line"><span class="comment">         * memory beyond the last byte of actual shader code, which could</span></div>
<div class="line"><span class="comment">         * fault if the GPU virtual address space beyond the end of the</span></div>
<div class="line"><span class="comment">         * pool is unpopulated.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    pProgramData-&gt;m_ShaderMemoryPool.Init(shaderDataArray,</div>
<div class="line">                                          memoryPoolAlignedSize,</div>
<div class="line">                                          <a name="a81"></a><a class="code" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654ae90d91fe770d2eb3e1476c404c003369">NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT</a> | <a name="a82"></a><a class="code" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a81b40bf9e82d33f8c546a95fc5ce5f7e">NVN_MEMORY_POOL_FLAGS_GPU_CACHED_BIT</a> | <a name="a83"></a><a class="code" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654ae206e58ed83cb0e9936783c9f4764fe6">NVN_MEMORY_POOL_FLAGS_SHADER_CODE_BIT</a>,</div>
<div class="line">                                          m_pDevice);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * NVNprogram</span></div>
<div class="line"><span class="comment">         * ----------</span></div>
<div class="line"><span class="comment">         * The NVNprogram object is a collection of different shader stages</span></div>
<div class="line"><span class="comment">         * that can be used for rendering or compute operations. The object</span></div>
<div class="line"><span class="comment">         * cannot hold both rendering and compute shaders at the same time</span></div>
<div class="line"><span class="comment">         * and can only have one compute shader. The program is created</span></div>
<div class="line"><span class="comment">         * through a call to nvnProgramInitialize followed by a call to</span></div>
<div class="line"><span class="comment">         * nvnProgramSetShaders. This function takes a list of NVNshaderData</span></div>
<div class="line"><span class="comment">         * structures (described below) that provide the object with shader</span></div>
<div class="line"><span class="comment">         * binary compiled by GLSLC. The shader program is bound using</span></div>
<div class="line"><span class="comment">         * nvnCommandBufferBindProgram which sets the active shader for</span></div>
<div class="line"><span class="comment">         * each stage.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * NVNshaderData</span></div>
<div class="line"><span class="comment">         * -------------</span></div>
<div class="line"><span class="comment">         * This structure is used to define an individual shader stage</span></div>
<div class="line"><span class="comment">         * that is to be made a part of an NVNprogram object. The structure</span></div>
<div class="line"><span class="comment">         * holds a pointer to the control section output by the GLSLC</span></div>
<div class="line"><span class="comment">         * compile as well as an NVNbufferAddress that holds the address</span></div>
<div class="line"><span class="comment">         * of an NVNbuffer created from the shader data section of the</span></div>
<div class="line"><span class="comment">         * GLSLC output.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"></div>
<div class="line">    std::vector&lt;NVNshaderData&gt; nvnShaderData;</div>
<div class="line">    nvnShaderData.resize(numShaderStages, <a name="_a84"></a><a class="code" href="struct_n_v_nshader_data.html">NVNshaderData</a>());</div>
<div class="line">    pProgramData-&gt;m_ShaderBuffers.resize(numShaderStages, NULL);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Create NVNbuffer objects out of the memory pool for each shader stage.</span></div>
<div class="line"><span class="comment">         * The NVNbufferAddress for these buffers are placed in a list with the</span></div>
<div class="line"><span class="comment">         * pointers to the corresponding shader control sections.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; shaderStageHeaders.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        pProgramData-&gt;m_ShaderStages |= ConvertNVNStageToBitField(static_cast&lt;NVNshaderStage&gt;(shaderStageHeaders[i].m_ShaderStage));</div>
<div class="line">        pProgramData-&gt;m_ShaderBuffers[i] = <span class="keyword">new</span> <a name="_a85"></a><a class="code" href="struct_n_v_nbuffer.html">NVNbuffer</a>;</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__nvn__c__functions.html#ga17550ab21d8136e4f5c48c91c21716f2">nvnBufferBuilderSetDefaults</a>(&amp;m_BufferBuilder);</div>
<div class="line">        <a name="a86"></a><a class="code" href="group__nvn__c__functions.html#gaaaa4fd698902c746debccb3fa967e324">nvnBufferBuilderSetStorage</a>(&amp;m_BufferBuilder, pProgramData-&gt;m_ShaderMemoryPool.GetMemoryPool(), alignmentOffsets[i], shaderStageHeaders[i].m_ShaderDataSize);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!<a name="a87"></a><a class="code" href="group__nvn__c__functions.html#ga862eafc1a9c42ce08a7c40ba004d7b57">nvnBufferInitialize</a>(pProgramData-&gt;m_ShaderBuffers[i], &amp;m_BufferBuilder))</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">delete</span> pProgramData-&gt;m_ShaderBuffers[i];</div>
<div class="line">            <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to initialize shader buffer storage&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        nvnShaderData[i].control = shaderStageHeaders[i].m_pShaderControl;</div>
<div class="line">        nvnShaderData[i].data    = <a name="a88"></a><a class="code" href="group__nvn__c__functions.html#gac38c964075df642306d6490b8b50ace3">nvnBufferGetAddress</a>(pProgramData-&gt;m_ShaderBuffers[i]);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Initialize the shader program and provide it with the compiled shader data. */</span></div>
<div class="line">    <a name="a89"></a><a class="code" href="group__nvn__c__functions.html#ga94b5dc5a5043495db9e6c3bc41ed6098">nvnProgramInitialize</a>(&amp;pProgramData-&gt;m_Program, m_pDevice);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!<a name="a90"></a><a class="code" href="group__nvn__c__functions.html#gad6a517c8312bcaea2bafddfdf59f426a">nvnProgramSetShaders</a>(&amp;pProgramData-&gt;m_Program, numShaderStages, &amp;nvnShaderData[0]))</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to set pre-compiled shaders&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper::LoadTextures</span></div>
<div class="line"><span class="comment"> * ------------------------------------</span></div>
<div class="line"><span class="comment"> * Grabs the texture block header of the asset file and loads</span></div>
<div class="line"><span class="comment"> * the texture data at the specified offsets.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> AssetFileLoadingHelper::LoadTextures(<span class="keyword">const</span> <span class="keywordtype">char</span>* pTextureBlockHead)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pTextureBlockHead != NULL, <span class="stringliteral">&quot;Texture block header pointer NULL&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> TextureBlockHeader* pTextureBlockHeader = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>TextureBlockHeader*<span class="keyword">&gt;</span>(pTextureBlockHead);</div>
<div class="line">    <span class="keyword">const</span> uint64_t* pTextureOffsets = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint64_t*<span class="keyword">&gt;</span>(pTextureBlockHead + <span class="keyword">sizeof</span>(uint32_t) * 2);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; pTextureBlockHeader-&gt;m_NumTextures; ++i)</div>
<div class="line">    {</div>
<div class="line">        NVNTextureData* pTextureData = LoadTextureData(m_pFileHead + pTextureOffsets[i]);</div>
<div class="line">        m_pDataHolder-&gt;AddTextureData(pTextureData);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper::LoadTextureData</span></div>
<div class="line"><span class="comment"> * ---------------------------------------</span></div>
<div class="line"><span class="comment"> * Loads the packaged texture data and metadata from the texture header.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">NVNTextureData* AssetFileLoadingHelper::LoadTextureData(<span class="keywordtype">char</span>* pTextureDataHead)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pTextureDataHead != NULL, <span class="stringliteral">&quot;Texture data pointer NULL&quot;</span>);</div>
<div class="line"></div>
<div class="line">    NVNTextureData* pNvnTextureData = <span class="keyword">new</span> NVNTextureData;</div>
<div class="line">    pNvnTextureData-&gt;Initialize();</div>
<div class="line"></div>
<div class="line">    uint32_t currentDataEntryOffset = 0;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Grab the texture&#39;s metadata. */</span></div>
<div class="line">    pNvnTextureData-&gt;m_TextureDataSize      = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);          currentDataEntryOffset += <span class="keyword">sizeof</span>(uint64_t);</div>
<div class="line">    pNvnTextureData-&gt;m_GpuVersion           = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">int</span>*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);               currentDataEntryOffset += <span class="keyword">sizeof</span>(int);</div>
<div class="line">    pNvnTextureData-&gt;m_Alignment            = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);          currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    pNvnTextureData-&gt;m_Width                = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);          currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    pNvnTextureData-&gt;m_Height               = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);          currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    pNvnTextureData-&gt;m_Depth                = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);          currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    pNvnTextureData-&gt;m_NvnTextureTarget     = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a>*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);  currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    pNvnTextureData-&gt;m_NvnFormat            = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);         currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    pNvnTextureData-&gt;m_MipLevels            = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);          currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    uint32_t textureNameLength              = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);          currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    uint32_t textureDataOffset              = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);          currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* pTextureName                = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(pTextureDataHead + currentDataEntryOffset);               currentDataEntryOffset += <span class="keyword">sizeof</span>(char) * textureNameLength;</div>
<div class="line">    <span class="keywordtype">void</span>* pTextureData                      = (m_pFileHead + textureDataOffset);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!textureNameLength ||</div>
<div class="line">        pTextureName == NULL ||</div>
<div class="line">        !pNvnTextureData-&gt;m_Width ||</div>
<div class="line">        !pNvnTextureData-&gt;m_Height ||</div>
<div class="line">        !pNvnTextureData-&gt;m_Depth ||</div>
<div class="line">        pNvnTextureData-&gt;m_NvnTextureTarget &gt; <a name="a91"></a><a class="code" href="group__nvn__c__enum.html#gga7f247010f53480c7dd1f3b2ad638c431ad76c4748580ea6bff4859bc20c034cb9">NVN_TEXTURE_TARGET_BUFFER</a> ||</div>
<div class="line">        !pNvnTextureData-&gt;m_NvnFormat ||</div>
<div class="line">        !pNvnTextureData-&gt;m_MipLevels ||</div>
<div class="line">        pTextureData == NULL)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to read texture data&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span> memoryPoolSize;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (pNvnTextureData-&gt;m_TextureDataSize &lt; g_MinimumPoolSize)</div>
<div class="line">    {</div>
<div class="line">        memoryPoolSize = g_MinimumPoolSize;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        memoryPoolSize = Align(static_cast&lt;size_t&gt;(pNvnTextureData-&gt;m_TextureDataSize), <a class="code" href="group__nvn__c__defines.html#gadfd69601d2d9f953c55808127ba60853">NVN_MEMORY_POOL_STORAGE_GRANULARITY</a>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span>* memoryPoolData = AlignedAllocate(memoryPoolSize, <a class="code" href="group__nvn__c__defines.html#gace820e752b400cf7aa36e9684a7f45cb">NVN_MEMORY_POOL_STORAGE_ALIGNMENT</a>);</div>
<div class="line"></div>
<div class="line">    memcpy(memoryPoolData, pTextureData, static_cast&lt;uint32_t&gt;(pNvnTextureData-&gt;m_TextureDataSize));</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Wrap a memory pool around the texture data. */</span></div>
<div class="line">    pNvnTextureData-&gt;m_TextureMemoryPool.Init(memoryPoolData,</div>
<div class="line">                                              memoryPoolSize,</div>
<div class="line">                                              <a class="code" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654ae90d91fe770d2eb3e1476c404c003369">NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT</a> | <a class="code" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a81b40bf9e82d33f8c546a95fc5ce5f7e">NVN_MEMORY_POOL_FLAGS_GPU_CACHED_BIT</a>,</div>
<div class="line">                                              m_pDevice);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Set up the texture builder based on the loaded metadata. */</span></div>
<div class="line">    pNvnTextureData-&gt;SetName(pTextureName, textureNameLength);</div>
<div class="line">    <a class="code" href="group__nvn__c__functions.html#ga6287f82327692478ee9040e4fe73dd36">nvnTextureBuilderSetDefaults</a>(&amp;m_TextureBuilder);</div>
<div class="line">    <a name="a92"></a><a class="code" href="group__nvn__c__functions.html#gaa7e80e3d31c6cffc51d255cbe86694b3">nvnTextureBuilderSetTarget</a>(&amp;m_TextureBuilder, pNvnTextureData-&gt;m_NvnTextureTarget);</div>
<div class="line">    <a name="a93"></a><a class="code" href="group__nvn__c__functions.html#gad83f59e208a24b5843543e1d0c7aec8a">nvnTextureBuilderSetFormat</a>(&amp;m_TextureBuilder, pNvnTextureData-&gt;m_NvnFormat);</div>
<div class="line">    <a name="a94"></a><a class="code" href="group__nvn__c__functions.html#ga1eb945f455f851adf9b738be38cfb0bc">nvnTextureBuilderSetSize2D</a>(&amp;m_TextureBuilder, pNvnTextureData-&gt;m_Width, pNvnTextureData-&gt;m_Height);</div>
<div class="line">    <a name="a95"></a><a class="code" href="group__nvn__c__functions.html#gad86f04179d66882fe758554678311e42">nvnTextureBuilderSetDepth</a>(&amp;m_TextureBuilder, pNvnTextureData-&gt;m_Depth);</div>
<div class="line">    <a name="a96"></a><a class="code" href="group__nvn__c__functions.html#ga7b84b7b97960b702cd6e8438e0bc303b">nvnTextureBuilderSetLevels</a>(&amp;m_TextureBuilder, pNvnTextureData-&gt;m_MipLevels);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">        * On Windows, the packaged texture data cannot be used by the GPU as</span></div>
<div class="line"><span class="comment">        * it will not be compatible with the format used by the device. To</span></div>
<div class="line"><span class="comment">        * remedy this, it can be provided to the texture builder through the</span></div>
<div class="line"><span class="comment">        * SetPackagedTextureData function. The windows driver will decode the</span></div>
<div class="line"><span class="comment">        * texture data and re-encode it to the proper format. On the device, the</span></div>
<div class="line"><span class="comment">        * function is a no-op; the pointer is ignored and its contents unmodified.</span></div>
<div class="line"><span class="comment">        */</span></div>
<div class="line">    <a name="a97"></a><a class="code" href="group__nvn__c__functions.html#ga6ccd08d4bafb09088fb0c39aea731354">nvnTextureBuilderSetPackagedTextureData</a>(&amp;m_TextureBuilder, pTextureData);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Set the storage for the texture. */</span></div>
<div class="line">    <a name="a98"></a><a class="code" href="group__nvn__c__functions.html#gaf6530c01a016b836ad82434f6a793cd8">nvnTextureBuilderSetStorage</a>(&amp;m_TextureBuilder, pNvnTextureData-&gt;m_TextureMemoryPool.GetMemoryPool(), 0);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Initialize the texture with the builder&#39;s settings. */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!<a name="a99"></a><a class="code" href="group__nvn__c__functions.html#gad8c5cbaa3292721f1de9d521a66aac3e">nvnTextureInitialize</a>(&amp;pNvnTextureData-&gt;m_Texture, &amp;m_TextureBuilder))</div>
<div class="line">    {</div>
<div class="line">        pNvnTextureData-&gt;Finalize();</div>
<div class="line">        <span class="keyword">delete</span> pNvnTextureData;</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to initialize texture&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> NULL;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        pNvnTextureData-&gt;m_TextureInitialized = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Register the texture and hold onto its ID. */</span></div>
<div class="line">    pNvnTextureData-&gt;m_TextureID = m_pTextureIDManager-&gt;RegisterTexture(&amp;pNvnTextureData-&gt;m_Texture);</div>
<div class="line">    <span class="keywordflow">return</span> pNvnTextureData;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper::LoadModels</span></div>
<div class="line"><span class="comment"> * ----------------------------------</span></div>
<div class="line"><span class="comment"> * Grabs the model block header and loads the model data</span></div>
<div class="line"><span class="comment"> * at the specified offsets.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> AssetFileLoadingHelper::LoadModels(<span class="keyword">const</span> <span class="keywordtype">char</span>* pModelBlockHead)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pModelBlockHead != NULL, <span class="stringliteral">&quot;Model block header pointer NULL&quot;</span>);</div>
<div class="line"></div>
<div class="line">    uint32_t numModels = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pModelBlockHead);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> uint64_t* pModelOffsets = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint64_t*<span class="keyword">&gt;</span>(pModelBlockHead + <span class="keyword">sizeof</span>(uint32_t) * 2);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; numModels; ++i)</div>
<div class="line">    {</div>
<div class="line">        NVNModelData* pModelData = LoadModelData(m_pFileHead + pModelOffsets[i]);</div>
<div class="line">        m_pDataHolder-&gt;AddModelData(pModelData);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AssetFileLoadingHelper::LoadModelData</span></div>
<div class="line"><span class="comment"> * -------------------------------------</span></div>
<div class="line"><span class="comment"> * Loads in the model vertex attributes and index buffer as well</span></div>
<div class="line"><span class="comment"> * as some data describing the model.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">NVNModelData* AssetFileLoadingHelper::LoadModelData(<span class="keyword">const</span> <span class="keywordtype">char</span>* pModelHead)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(pModelHead != NULL, <span class="stringliteral">&quot;Model data pointer NULL&quot;</span>);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Grab the model&#39;s metadata. */</span></div>
<div class="line">    uint32_t            currentDataEntryOffset  = 0;</div>
<div class="line">    uint32_t            numPrimitives           = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pModelHead + currentDataEntryOffset);              currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    <a class="code" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>    nvnDrawPrimitiveType    = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>*<span class="keyword">&gt;</span>(pModelHead + currentDataEntryOffset);      currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    uint32_t            numVertexAttributes     = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pModelHead + currentDataEntryOffset);              currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    uint32_t            modelNameLength         = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pModelHead + currentDataEntryOffset);              currentDataEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    uint64_t            indexBufferOffset       = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint64_t*<span class="keyword">&gt;</span>(pModelHead + currentDataEntryOffset);              currentDataEntryOffset += <span class="keyword">sizeof</span>(uint64_t);</div>
<div class="line">    <span class="keyword">const</span> uint64_t*     pVertexAttributeOffsets = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint64_t*<span class="keyword">&gt;</span>(pModelHead + currentDataEntryOffset);               currentDataEntryOffset += <span class="keyword">sizeof</span>(uint64_t) * numVertexAttributes;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>*         pModelName              = pModelHead + currentDataEntryOffset;                                                  currentDataEntryOffset += <span class="keyword">sizeof</span>(char) * modelNameLength;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (modelNameLength == 0 ||</div>
<div class="line">        pModelName == NULL ||</div>
<div class="line">        !numPrimitives ||</div>
<div class="line">        nvnDrawPrimitiveType &gt; <a name="a100"></a><a class="code" href="group__nvn__c__enum.html#ggab22437710b6816a67a1263d0087ded72a7c5c040a874eb7f85eb65e4b2f979b98">NVN_DRAW_PRIMITIVE_PATCHES</a> ||</div>
<div class="line">        !numVertexAttributes ||</div>
<div class="line">        pVertexAttributeOffsets == NULL ||</div>
<div class="line">        !indexBufferOffset)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to read model data&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    NVNModelData* pModelData = <span class="keyword">new</span> NVNModelData;</div>
<div class="line">    pModelData-&gt;Initialize();</div>
<div class="line">    pModelData-&gt;SetName(pModelName, modelNameLength);</div>
<div class="line"></div>
<div class="line">    Model* pModel = &amp;pModelData-&gt;m_Model;</div>
<div class="line">    pModel-&gt;m_NumVertexAttributes = numVertexAttributes;</div>
<div class="line">    pModel-&gt;m_NumPrimitives = numPrimitives;</div>
<div class="line">    pModel-&gt;m_NvnDrawPrimitiveType = nvnDrawPrimitiveType;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Grab the data for the individual vertex attributes. */</span></div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; numVertexAttributes; ++i)</div>
<div class="line">    {</div>
<div class="line">        VertexAttributeHeader header;</div>
<div class="line">        <span class="keywordtype">char</span>* pAttributeHeader = m_pFileHead + pVertexAttributeOffsets[i];</div>
<div class="line">        uint32_t currVertexEntryOffset  = 0;</div>
<div class="line"></div>
<div class="line">        header.m_AttributeStride        = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pAttributeHeader + currVertexEntryOffset);     currVertexEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">        header.m_NvnFormat              = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pAttributeHeader + currVertexEntryOffset);     currVertexEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">        header.m_AttributeDataSize      = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pAttributeHeader + currVertexEntryOffset);     currVertexEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">        header.m_AttributeNameLength    = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pAttributeHeader + currVertexEntryOffset);     currVertexEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">        header.m_AttributeDataOffset    = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pAttributeHeader + currVertexEntryOffset);     currVertexEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">        header.m_MagicPadding           = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pAttributeHeader + currVertexEntryOffset);     currVertexEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">        header.m_pAttributeName         = pAttributeHeader + currVertexEntryOffset;                                         currVertexEntryOffset += <span class="keyword">sizeof</span>(char) * header.m_AttributeNameLength;</div>
<div class="line">        header.m_AttributeData          = m_pFileHead + header.m_AttributeDataOffset;</div>
<div class="line"></div>
<div class="line">        pModelData-&gt;AddVertexAttribute(header);</div>
<div class="line">        pModelData-&gt;m_VertexBufferSize += header.m_AttributeDataSize;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Grab the index buffer data. */</span></div>
<div class="line">    <span class="keywordtype">char</span>* pIndexBufferHead          = m_pFileHead + indexBufferOffset;</div>
<div class="line">    uint32_t currIndexEntryOffset   = 0;</div>
<div class="line"></div>
<div class="line">    uint32_t indexBufferSize        = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pIndexBufferHead + currIndexEntryOffset);        currIndexEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    uint32_t numIndices             = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pIndexBufferHead + currIndexEntryOffset);        currIndexEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    uint32_t indexType              = *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(pIndexBufferHead + currIndexEntryOffset);        currIndexEntryOffset += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    currIndexEntryOffset            += <span class="keyword">sizeof</span>(uint32_t); <span class="comment">/* Account for padding in struct */</span></div>
<div class="line">    <span class="keywordtype">void</span>* pIndexData                = (pIndexBufferHead + currIndexEntryOffset);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Align the index buffer according to its type. */</span></div>
<div class="line">    <span class="keywordtype">size_t</span> memoryPoolSize = pModelData-&gt;m_VertexBufferSize;</div>
<div class="line">    uint32_t indexBufferAlignment = 0;</div>
<div class="line">    <span class="keywordflow">switch</span>((<a class="code" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a>)indexType)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> <a name="a101"></a><a class="code" href="group__nvn__c__enum.html#ggaaf90e0c2dbdc1e42db8192f0c0cb1522a9d49b4695541469d3ecbadeac29c98b8">NVN_INDEX_TYPE_UNSIGNED_BYTE</a>:</div>
<div class="line">            indexBufferAlignment = <span class="keyword">sizeof</span>(uint8_t);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <a name="a102"></a><a class="code" href="group__nvn__c__enum.html#ggaaf90e0c2dbdc1e42db8192f0c0cb1522a01b3069396b6d9c7ca2f6c7579627e32">NVN_INDEX_TYPE_UNSIGNED_SHORT</a>:</div>
<div class="line">            indexBufferAlignment = <span class="keyword">sizeof</span>(uint16_t);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <a name="a103"></a><a class="code" href="group__nvn__c__enum.html#ggaaf90e0c2dbdc1e42db8192f0c0cb1522aedbe4967c83f6b7f1b800e51bc7f3ab6">NVN_INDEX_TYPE_UNSIGNED_INT</a>:</div>
<div class="line">            indexBufferAlignment = <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            <a name="a104"></a><a class="code" href="nn___macro_8h.html#abfe6f7c5f80ef52b7c0616042aba59b9">NN_UNEXPECTED_DEFAULT</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(indexBufferSize / numIndices == indexBufferAlignment);</div>
<div class="line">        <span class="comment">/* Get the aligned pool size. */</span></div>
<div class="line">    memoryPoolSize = Align(memoryPoolSize, indexBufferAlignment);</div>
<div class="line">    <span class="keywordtype">size_t</span> indexBufferAlignedLocation = memoryPoolSize;</div>
<div class="line">    memoryPoolSize += indexBufferSize;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Save the index buffer data in the model. */</span></div>
<div class="line">    pModel-&gt;m_IndexData.m_IndexType = indexType;</div>
<div class="line">    pModel-&gt;m_IndexData.m_DataSize  = indexBufferSize;</div>
<div class="line">    pModel-&gt;m_IndexData.m_Stride    = indexBufferAlignment;</div>
<div class="line">    pModel-&gt;m_IndexData.m_pData     = <span class="keyword">new</span> <span class="keywordtype">char</span>[indexBufferSize];</div>
<div class="line"></div>
<div class="line">    memcpy(pModel-&gt;m_IndexData.m_pData, pIndexData, indexBufferSize);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Allocate memory for the pool. */</span></div>
<div class="line">    <span class="keywordflow">if</span> (memoryPoolSize &lt; g_MinimumPoolSize)</div>
<div class="line">    {</div>
<div class="line">        memoryPoolSize = g_MinimumPoolSize;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        memoryPoolSize = Align(memoryPoolSize, <a class="code" href="group__nvn__c__defines.html#gadfd69601d2d9f953c55808127ba60853">NVN_MEMORY_POOL_STORAGE_GRANULARITY</a>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">char</span>* modelDataBuffer = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(AlignedAllocate(memoryPoolSize, <a class="code" href="group__nvn__c__defines.html#gace820e752b400cf7aa36e9684a7f45cb">NVN_MEMORY_POOL_STORAGE_ALIGNMENT</a>));</div>
<div class="line">    memset(modelDataBuffer, 0, memoryPoolSize);</div>
<div class="line"></div>
<div class="line">    uint32_t currentBufferOffset = 0;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Copy in the vertex data. */</span></div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; pModel-&gt;m_VertexAttributes.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        memcpy(modelDataBuffer + currentBufferOffset, pModel-&gt;m_VertexAttributes[i].m_pData, pModel-&gt;m_VertexAttributes[i].m_DataSize);</div>
<div class="line">        pModelData-&gt;m_VertexAttributeBufferOffsets.push_back(currentBufferOffset);</div>
<div class="line">        currentBufferOffset += pModel-&gt;m_VertexAttributes[i].m_DataSize;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Copy the index data. */</span></div>
<div class="line">    memcpy(modelDataBuffer + indexBufferAlignedLocation, pIndexData, indexBufferSize);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Create a memory pool around the model data. */</span></div>
<div class="line">    pModelData-&gt;m_BufferMemoryPool.Init(modelDataBuffer,</div>
<div class="line">                                        memoryPoolSize,</div>
<div class="line">                                        <a class="code" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654ae90d91fe770d2eb3e1476c404c003369">NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT</a> | <a class="code" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a81b40bf9e82d33f8c546a95fc5ce5f7e">NVN_MEMORY_POOL_FLAGS_GPU_CACHED_BIT</a>,</div>
<div class="line">                                        m_pDevice);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__nvn__c__functions.html#ga17550ab21d8136e4f5c48c91c21716f2">nvnBufferBuilderSetDefaults</a>(&amp;m_BufferBuilder);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Create the vertex buffer from the memory pool at the correct offset. */</span></div>
<div class="line">    <a class="code" href="group__nvn__c__functions.html#gaaaa4fd698902c746debccb3fa967e324">nvnBufferBuilderSetStorage</a>(&amp;m_BufferBuilder, pModelData-&gt;m_BufferMemoryPool.GetMemoryPool(), 0, pModelData-&gt;m_VertexBufferSize);</div>
<div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="group__nvn__c__functions.html#ga862eafc1a9c42ce08a7c40ba004d7b57">nvnBufferInitialize</a>(&amp;pModelData-&gt;m_VertexBuffer, &amp;m_BufferBuilder))</div>
<div class="line">    {</div>
<div class="line">        pModelData-&gt;Finalize();</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to initialize vertex buffer storage&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__nvn__c__functions.html#ga17550ab21d8136e4f5c48c91c21716f2">nvnBufferBuilderSetDefaults</a>(&amp;m_BufferBuilder);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Create the index buffer from the memory pool at the correct offset. */</span></div>
<div class="line">    <a class="code" href="group__nvn__c__functions.html#gaaaa4fd698902c746debccb3fa967e324">nvnBufferBuilderSetStorage</a>(&amp;m_BufferBuilder, pModelData-&gt;m_BufferMemoryPool.GetMemoryPool(), indexBufferAlignedLocation, indexBufferSize);</div>
<div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="group__nvn__c__functions.html#ga862eafc1a9c42ce08a7c40ba004d7b57">nvnBufferInitialize</a>(&amp;pModelData-&gt;m_IndexBuffer, &amp;m_BufferBuilder))</div>
<div class="line">    {</div>
<div class="line">        pModelData-&gt;Finalize();</div>
<div class="line">        <a class="code" href="nn___assert_8h.html#ade59d1d911907a16c0241f8fe3b31542">NN_ASSERT</a>(0, <span class="stringliteral">&quot;Failed to initialize index buffer storage&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> pModelData;</div>
<div class="line">}<span class="comment">//NOLINT(impl/function_size)</span></div>
</div><!-- fragment --> </div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
