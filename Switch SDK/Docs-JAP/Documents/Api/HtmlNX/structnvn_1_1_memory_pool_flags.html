<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>NintendoSDK API Reference: nvn::MemoryPoolFlags 構造体</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>総合概要</span></a></li>
      <li><a href="pages.html"><span>諸情報</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>名前空間</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>クラス一覧</span></a></li>
      <li><a href="classes.html"><span>クラス索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>クラスメンバ</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenvn.html">nvn</a></li><li class="navelem"><a class="el" href="structnvn_1_1_memory_pool_flags.html">MemoryPoolFlags</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">公開型</a> &#124;
<a href="structnvn_1_1_memory_pool_flags-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">nvn::MemoryPoolFlags 構造体<div class="ingroups"><a class="el" href="group__nvn__cpp__interface.html">NVN C++ API Bindings</a> &raquo; <a class="el" href="group__nvn__cpp__enum.html">API Enum Types</a> &#124; <a class="el" href="group__nvn__cpp__interface.html">NVN C++ API Bindings</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Specifies properties of memory pools created from a memory pool builder.  
 <a href="structnvn_1_1_memory_pool_flags.html#details">[詳解]</a></p>

<p><code>#include &lt;nvn/nvn_Cpp.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
公開型</h2></td></tr>
<tr class="memitem:a9cfd88ffbebcaed533927f83672e1356"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356">Enum</a> { <br />
&#160;&#160;<a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a9e5c8ae3712a42748dcf3e211c8be384">CPU_NO_ACCESS</a> = 0x00000001, 
<br />
&#160;&#160;<a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ac8d67a6455dce7ff64bb8b593a144369">CPU_UNCACHED</a> = 0x00000002, 
<br />
&#160;&#160;<a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a99a56351eafbaab331298fbc1a78e152">CPU_CACHED</a> = 0x00000004, 
<br />
&#160;&#160;<a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a82454078e08d859b53b6fc954fe955be">GPU_NO_ACCESS</a> = 0x00000008, 
<br />
&#160;&#160;<a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356afb36e42ea7fdd4da445f195ccd641c58">GPU_UNCACHED</a> = 0x00000010, 
<br />
&#160;&#160;<a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a1e3d71cce5c57e973a183fe75c85fc9b">GPU_CACHED</a> = 0x00000020, 
<br />
&#160;&#160;<a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a1ffdc01c00bf57c8a42913d7600f9233">SHADER_CODE</a> = 0x00000040, 
<br />
&#160;&#160;<a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ae3494cd47a1faa5920389aad57917efe">COMPRESSIBLE</a> = 0x00000080, 
<br />
&#160;&#160;<a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a7351464c30c867fbf6dc717b7535f6eb">PHYSICAL</a> = 0x00000100, 
<br />
&#160;&#160;<a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a74439d2a74792ba1f2bfd7049a035b8d">VIRTUAL</a> = 0x000000200
<br />
 }<tr class="memdesc:a9cfd88ffbebcaed533927f83672e1356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated values for the type <a class="el" href="structnvn_1_1_memory_pool_flags.html" title="Specifies properties of memory pools created from a memory pool builder. ">MemoryPoolFlags</a>.  <a href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356">[詳解]</a><br /></td></tr>
<tr class="separator:a9cfd88ffbebcaed533927f83672e1356"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p>Specifies properties of memory pools created from a memory pool builder. </p>
</div><h2 class="groupheader">列挙型メンバ詳解</h2>
<a class="anchor" id="a9cfd88ffbebcaed533927f83672e1356"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356">nvn::MemoryPoolFlags::Enum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerated values for the type <a class="el" href="structnvn_1_1_memory_pool_flags.html" title="Specifies properties of memory pools created from a memory pool builder. ">MemoryPoolFlags</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a9cfd88ffbebcaed533927f83672e1356a9e5c8ae3712a42748dcf3e211c8be384"></a>CPU_NO_ACCESS&#160;</td><td class="fielddoc">
<p>Indicates that the memory pool will not be accessed by the CPU. </p>
<p>When CPU_NO_ACCESS is set, the pool memory may not be accessed by the CPU.</p>
<p>Applications must set exactly one of CPU_NO_ACCESS, CPU_UNCACHED, and CPU_CACHED when initializing a memory pool.</p>
<dl class="section note"><dt>覚え書き</dt><dd>On NX, initializing a pool with CPU_NO_ACCESS does not change existing CPU memory mappings and thus does not prevent applications from accessing the pool memory using the pointer provided to <a class="el" href="classnvn_1_1_memory_pool_builder.html#a2101949c9372178c1ed735015461fde5" title="Provides memory to be used by memory pools initialized using a MemoryPoolBuilder. ...">nvn::MemoryPoolBuilder::SetStorage</a>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9cfd88ffbebcaed533927f83672e1356ac8d67a6455dce7ff64bb8b593a144369"></a>CPU_UNCACHED&#160;</td><td class="fielddoc">
<p>Indicates that the memory pool will be accessed by the CPU without caching. </p>
<p>When CPU_UNCACHED is set, writes to pool memory with the CPU will be visible to subsequent commands submitted to the GPU. CPU reads from pool memory will reflect the results of all GPU commands that have completed execution at the time of the read. CPU_UNCACHED memory will not be cached in the CPU's internal caches, which will result in significantly reduced performance for reads and random-access writes. Sequential writes to CPU_UNCACHED memory will have good performance.</p>
<p>Applications must set exactly one of CPU_NO_ACCESS, CPU_UNCACHED, and CPU_CACHED when initializing a memory pool. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9cfd88ffbebcaed533927f83672e1356a99a56351eafbaab331298fbc1a78e152"></a>CPU_CACHED&#160;</td><td class="fielddoc">
<p>Indicates that the memory pool will be accessed by the CPU with caching. </p>
<p>When CPU_CACHED is set, writes to pool memory with the NX CPU will be stored in a write-back CPU cache and may not be visible to subsequent commands submitted to the GPU. <a class="el" href="classnvn_1_1_memory_pool.html#a4654ff6426a2ff3822b9fcbf291c4b45" title="Flush previous CPU writes to a range of the memory pool to be visible to the GPU. ...">MemoryPool::FlushMappedRange</a> or <a class="el" href="classnvn_1_1_buffer.html#a25eb48cb1611c4bf0cdfdd11adea6f26" title="Flush previous CPU writes to a range of a buffer to be visible to the GPU. ">Buffer::FlushMappedRange</a> must be called to ensure such CPU writes are visible to the GPU. CPU reads from pool memory may return values from the CPU cache that do not reflect writes to main memory performed by previously completed GPU commands. <a class="el" href="classnvn_1_1_memory_pool.html#adfac3b4327a82cfdd1fae4ba84f99e5c" title="Invalidate CPU caches for a range of the memory pool that may have been written by the GPU...">MemoryPool::InvalidateMappedRange</a> or <a class="el" href="classnvn_1_1_buffer.html#a7f3ffba87e2fef7cb9a637e49e56daf1" title="Invalidate CPU caches for a range of a buffer that may have been written by the GPU. ">Buffer::InvalidateMappedRange</a> must be called to ensure such GPU writes are visible to the CPU. On the Windows reference implementation, CPU_CACHED memory pools use separate copies of pool memory for CPU and GPU accesses. FlushMappedRange and InvalidateMappedRange copy memory between the two copies.</p>
<p>Applications must set exactly one of CPU_NO_ACCESS, CPU_UNCACHED, and CPU_CACHED when initializing a memory pool. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9cfd88ffbebcaed533927f83672e1356a82454078e08d859b53b6fc954fe955be"></a>GPU_NO_ACCESS&#160;</td><td class="fielddoc">
<p>Indicates that the memory pool will not be accessed by the GPU. </p>
<p>When GPU_NO_ACCESS is set, pool memory will not be accessed by the GPU.</p>
<p>Applications must set exactly one of GPU_NO_ACCESS, GPU_UNCACHED, and GPU_CACHED when initializing a memory pool. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9cfd88ffbebcaed533927f83672e1356afb36e42ea7fdd4da445f195ccd641c58"></a>GPU_UNCACHED&#160;</td><td class="fielddoc">
<p>Indicates that the memory pool will be accessed by the GPU without caching. </p>
<p>When GPU_UNCACHED is set, pool memory will not be cached in the GPU's internal caches, which will result in significantly reduced performance for GPU operations that repeatedly access the pool memory. However, if pool memory is not fetched more than once by the GPU, GPU_UNCACHED may improve performance by not consuming GPU cache lines for resources in the pool. Command memory used by <a class="el" href="classnvn_1_1_command_buffer.html" title="Collection of commands to send to the GPU via queues. ">CommandBuffer</a> objects may benefit from using GPU_UNCACHED.</p>
<p>Applications must set exactly one of GPU_NO_ACCESS, GPU_UNCACHED, and GPU_CACHED when initializing a memory pool. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9cfd88ffbebcaed533927f83672e1356a1e3d71cce5c57e973a183fe75c85fc9b"></a>GPU_CACHED&#160;</td><td class="fielddoc">
<p>Indicates that the memory pool will be accessed by the GPU with caching. </p>
<p>When GPU_CACHED is set, pool memory will be cached in the GPU's internal caches, which is the preferred behavior for most use cases. CPU writes to GPU_CACHED memory pools will be visible to any commands submitted to the GPU after the write. GPU writes to GPU_CACHED memory pools are guaranteed to be visible to the CPU only after waiting on a <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">Sync</a> object signalled by calling <a class="el" href="classnvn_1_1_queue.html#ae1f5ed18214950f9d34a55cc61ab9ef6" title="Mark a Sync object as signaled when all previous commands have completed in the Queue object...">Queue::FenceSync</a> with <a class="el" href="structnvn_1_1_sync_flag_bits.html#ac1ec0d9eacc08a459d9780280227013ca2fccff48d70ff398363e997420ee7fa5" title="Ensures that all GPU memory transactions performed for commands prior to the fence will be visible to...">SyncFlagBits::FLUSH_FOR_CPU</a> set.</p>
<p>Applications must set exactly one of GPU_NO_ACCESS, GPU_UNCACHED, and GPU_CACHED when initializing a memory pool. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9cfd88ffbebcaed533927f83672e1356a1ffdc01c00bf57c8a42913d7600f9233"></a>SHADER_CODE&#160;</td><td class="fielddoc">
<p>Indicates that the memory pool may be used to store shader code for execution. </p>
<p>When SHADER_CODE is set, pool memory may be used to store executable shader code passed to <a class="el" href="classnvn_1_1_program.html#ac63e6fe9122a01f15cc9955628ec8fd9" title="Initialize a program object to use pre-compiled GPU code from one or multiple shaders. ">Program::SetShaders</a> using GPU addresses in <a class="el" href="structnvn_1_1_shader_data.html#a87b294150cf84ca6248c4e495222705a" title="Address within a memory pool where the program resides. ">ShaderData::data</a>. When this flag is set, the memory pool is mapped so that its contents can be used for shader execution. If the flag is not set, GPU addresses in the pool may not be used to point at shaders.</p>
<dl class="section note"><dt>覚え書き</dt><dd>In the current NVN implementation, shaders may not be run from physical or virtual memory pools. Memory pools with the SHADER_CODE flag set may not set either the PHYSICAL or VIRTUAL flag.</dd>
<dd>
Applications must avoid loading shaders into the last 1KB of a pool with SHADER_CODE set. GPU shader cores may pre-fetch from instruction memory beyond the last byte of actual shader code, which could fault if the GPU virtual address space beyond the end of the pool is unpopulated. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9cfd88ffbebcaed533927f83672e1356ae3494cd47a1faa5920389aad57917efe"></a>COMPRESSIBLE&#160;</td><td class="fielddoc">
<p>Indicates that the memory pool supports compressible textures. </p>
<p>When COMPRESSIBLE is set, this pool can be used to initialize compressible textures. For compressible textures, the NVN driver will set up special hardware resources and memory mappings allowing the contents of the texture to be transparently compressed by the GPU to save memory bandwidth. This form of compression can significantly increase performance when using textures as render targets. The COMPRESSIBLE bit is ignored for virtual memory pools, but should be set on physical memory pools providing storage for compressible textures.</p>
<dl class="section warning"><dt>警告</dt><dd>It is an error to initialize compressible textures using non-virtual memory pools without the COMPRESSIBLE bit set.</dd>
<dd>
When reusing memory from a compressible pool for compressible textures, applications must clear compressible textures before reading or writing with the GPU. Failing to do so could result in undefined behavior including GPU errors. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9cfd88ffbebcaed533927f83672e1356a7351464c30c867fbf6dc717b7535f6eb"></a>PHYSICAL&#160;</td><td class="fielddoc">
<p>Indicates that the memory pool may only be used as physical storage for memory mappings into virtual memory pools. </p>
<p>When PHYSICAL is set, the memory pool is used only to provide storage that can be mapped into virtual memory pools. Physical pools can not be used to create <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> or <a class="el" href="classnvn_1_1_buffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">Buffer</a> resources. Physical pools are not directly accessible by the GPU and must be initialized with GPU_NO_ACCESS set. When mapping memory into virtual pools, the pools providing memory must have been initalized with PHYSICAL set.</p>
<dl class="section note"><dt>覚え書き</dt><dd>The size of all physical memory pools must be a multiple of the GPU page size (<a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dae49ce57d078023cc8ca0890cd3ee8957" title="Size of memory pages used in physical and virtual memory pools. ">DeviceInfo::MEMORY_POOL_PAGE_SIZE</a>).</dd>
<dd>
On the Windows reference implementation, physical pools may not be initialized with the CPU_UNCACHED flag set.</dd>
<dd>
When a compressible texture is created in a virtual pool, the physical memory pool(s) providing storage for the texture must be initialized with the COMPRESSIBLE flag set. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9cfd88ffbebcaed533927f83672e1356a74439d2a74792ba1f2bfd7049a035b8d"></a>VIRTUAL&#160;</td><td class="fielddoc">
<p>Indicates that the memory pool may be used for sparse operations. </p>
<p>When VIRTUAL is set, the memory pool is used only to provide GPU-accessible virtual memory that can be used to create buffer and texture resources. Virtual memory pools have no physical memory storage, and all pages of the virtual memory pool are initially unpopulated. When reading unpopulated memory in the GPU, accesses will return zero (NX and second-generation Maxwell GPUs) or undefined values. After a virtual memory pool is initialized, it can be populated with pages from physical pools using <a class="el" href="classnvn_1_1_memory_pool.html#ad365e705a5c4d1520043731c7db3dc04" title="Map memory pages from physical memory pools into a virtual memory pool. ">MemoryPool::MapVirtual</a>. Virtual pools are not directly accessible by the CPU and must be initialized with CPU_NO_ACCESS set.</p>
<dl class="section note"><dt>覚え書き</dt><dd>The size of all virtual memory pools must be a multiple of the GPU page size (<a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61dae49ce57d078023cc8ca0890cd3ee8957" title="Size of memory pages used in physical and virtual memory pools. ">DeviceInfo::MEMORY_POOL_PAGE_SIZE</a>). </dd></dl>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
