<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>NintendoSDK API Reference: nvn::Texture クラス</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>総合概要</span></a></li>
      <li><a href="pages.html"><span>諸情報</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>名前空間</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>クラス一覧</span></a></li>
      <li><a href="classes.html"><span>クラス索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>クラスメンバ</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenvn.html">nvn</a></li><li class="navelem"><a class="el" href="classnvn_1_1_texture.html">Texture</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="classnvn_1_1_texture-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">nvn::Texture クラス<div class="ingroups"><a class="el" href="group__nvn__cpp__interface.html">NVN C++ API Bindings</a> &raquo; <a class="el" href="group__nvn__cpp__apiclasses.html">API Classes</a> &#124; <a class="el" href="group__nvn__cpp__interface.html">NVN C++ API Bindings</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Block of GPU-accessible memory and related state used to hold image data.  
 <a href="classnvn_1_1_texture.html#details">[詳解]</a></p>

<p><code>#include &lt;nvn/nvn_Cpp.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:ab298e62cbb28cd3b8fad0a3b2415d12e"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#ab298e62cbb28cd3b8fad0a3b2415d12e">Compare</a> (const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *otherTexture) const </td></tr>
<tr class="memdesc:ab298e62cbb28cd3b8fad0a3b2415d12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if texture objects are equivalent.  <a href="#ab298e62cbb28cd3b8fad0a3b2415d12e">[詳解]</a><br /></td></tr>
<tr class="separator:ab298e62cbb28cd3b8fad0a3b2415d12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7b46637959e0e244c50a75f87b6bb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c7b46637959e0e244c50a75f87b6bb6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a8c7b46637959e0e244c50a75f87b6bb6">Finalize</a> ()</td></tr>
<tr class="memdesc:a8c7b46637959e0e244c50a75f87b6bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. <br /></td></tr>
<tr class="separator:a8c7b46637959e0e244c50a75f87b6bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011f2387ececb593ee0469db195b67fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a011f2387ececb593ee0469db195b67fd">FlushTexels</a> (const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *textureView, const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *region) const </td></tr>
<tr class="memdesc:a011f2387ececb593ee0469db195b67fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush CPU cache lines holding portions of a texture.  <a href="#a011f2387ececb593ee0469db195b67fd">[詳解]</a><br /></td></tr>
<tr class="separator:a011f2387ececb593ee0469db195b67fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea69b814baa57df64472afde284d76e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a7ea69b814baa57df64472afde284d76e">GetDebugID</a> () const </td></tr>
<tr class="memdesc:a7ea69b814baa57df64472afde284d76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug layer unique ID of this texture.  <a href="#a7ea69b814baa57df64472afde284d76e">[詳解]</a><br /></td></tr>
<tr class="separator:a7ea69b814baa57df64472afde284d76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafab5aa6384104d5c0fae0f104b954d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeafab5aa6384104d5c0fae0f104b954d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#aeafab5aa6384104d5c0fae0f104b954d">GetDepth</a> () const </td></tr>
<tr class="memdesc:aeafab5aa6384104d5c0fae0f104b954d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. <br /></td></tr>
<tr class="separator:aeafab5aa6384104d5c0fae0f104b954d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5519b374bfa5f76f3286d3352a366c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a5519b374bfa5f76f3286d3352a366c"></a>
<a class="el" href="structnvn_1_1_texture_depth_stencil_mode.html">TextureDepthStencilMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a8a5519b374bfa5f76f3286d3352a366c">GetDepthStencilMode</a> () const </td></tr>
<tr class="memdesc:a8a5519b374bfa5f76f3286d3352a366c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth/stencil mode for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. <br /></td></tr>
<tr class="separator:a8a5519b374bfa5f76f3286d3352a366c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3226546a44a62ee0222d307852e9fc6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3226546a44a62ee0222d307852e9fc6b"></a>
<a class="el" href="structnvn_1_1_texture_flags.html">TextureFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a3226546a44a62ee0222d307852e9fc6b">GetFlags</a> () const </td></tr>
<tr class="memdesc:a3226546a44a62ee0222d307852e9fc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the flags for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. <br /></td></tr>
<tr class="separator:a3226546a44a62ee0222d307852e9fc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63531db11ea12215abdc75502aac750f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63531db11ea12215abdc75502aac750f"></a>
<a class="el" href="structnvn_1_1_format.html">Format</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a63531db11ea12215abdc75502aac750f">GetFormat</a> () const </td></tr>
<tr class="memdesc:a63531db11ea12215abdc75502aac750f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the format for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. <br /></td></tr>
<tr class="separator:a63531db11ea12215abdc75502aac750f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad7e32afa19f7f286507a87258f0ba7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afad7e32afa19f7f286507a87258f0ba7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#afad7e32afa19f7f286507a87258f0ba7">GetHeight</a> () const </td></tr>
<tr class="memdesc:afad7e32afa19f7f286507a87258f0ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the height for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. <br /></td></tr>
<tr class="separator:afad7e32afa19f7f286507a87258f0ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907561bc23f7502798ea9190da3856b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a907561bc23f7502798ea9190da3856b8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a907561bc23f7502798ea9190da3856b8">GetLevels</a> () const </td></tr>
<tr class="memdesc:a907561bc23f7502798ea9190da3856b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the level count for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. <br /></td></tr>
<tr class="separator:a907561bc23f7502798ea9190da3856b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b61c5f7b10c6757390d64c75dceb3d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b61c5f7b10c6757390d64c75dceb3d7"></a>
ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a8b61c5f7b10c6757390d64c75dceb3d7">GetMemoryOffset</a> () const </td></tr>
<tr class="memdesc:a8b61c5f7b10c6757390d64c75dceb3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool offset used by a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. <br /></td></tr>
<tr class="separator:a8b61c5f7b10c6757390d64c75dceb3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3626859f18fa7d027319342fb470653c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3626859f18fa7d027319342fb470653c"></a>
<a class="el" href="classnvn_1_1_memory_pool.html">MemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a3626859f18fa7d027319342fb470653c">GetMemoryPool</a> () const </td></tr>
<tr class="memdesc:a3626859f18fa7d027319342fb470653c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool used by a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. <br /></td></tr>
<tr class="separator:a3626859f18fa7d027319342fb470653c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf78e41fd73e5673d0b1e1cf1dd003a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaf78e41fd73e5673d0b1e1cf1dd003a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#acaf78e41fd73e5673d0b1e1cf1dd003a">GetSamples</a> () const </td></tr>
<tr class="memdesc:acaf78e41fd73e5673d0b1e1cf1dd003a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the sample count for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. <br /></td></tr>
<tr class="separator:acaf78e41fd73e5673d0b1e1cf1dd003a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99240ee8da42da429a508e6b395d79d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a99240ee8da42da429a508e6b395d79d3">GetSparseTileLayout</a> (<a class="el" href="structnvn_1_1_texture_sparse_tile_layout.html">TextureSparseTileLayout</a> *layout) const </td></tr>
<tr class="memdesc:a99240ee8da42da429a508e6b395d79d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns properties of the sparse memory layout for a texture.  <a href="#a99240ee8da42da429a508e6b395d79d3">[詳解]</a><br /></td></tr>
<tr class="separator:a99240ee8da42da429a508e6b395d79d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6202d8d28e78f06c0a7691806f61db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga4e21960c2b9244bbd2753954b23580d3">NVNstorageClass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a5b6202d8d28e78f06c0a7691806f61db">GetStorageClass</a> () const </td></tr>
<tr class="memdesc:a5b6202d8d28e78f06c0a7691806f61db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the storage class needed for virtual memory mappings for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object.  <a href="#a5b6202d8d28e78f06c0a7691806f61db">[詳解]</a><br /></td></tr>
<tr class="separator:a5b6202d8d28e78f06c0a7691806f61db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4c652f1e2ccf1e65e477f6c5c67895"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea4c652f1e2ccf1e65e477f6c5c67895"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#aea4c652f1e2ccf1e65e477f6c5c67895">GetStorageSize</a> () const </td></tr>
<tr class="memdesc:aea4c652f1e2ccf1e65e477f6c5c67895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the storage size for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. <br /></td></tr>
<tr class="separator:aea4c652f1e2ccf1e65e477f6c5c67895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112b3f1a8aa8bb60f831708b7ba4a358"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a112b3f1a8aa8bb60f831708b7ba4a358"></a>
ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a112b3f1a8aa8bb60f831708b7ba4a358">GetStride</a> () const </td></tr>
<tr class="memdesc:a112b3f1a8aa8bb60f831708b7ba4a358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the stride for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. <br /></td></tr>
<tr class="separator:a112b3f1a8aa8bb60f831708b7ba4a358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac260693c9aac7ba9d03b8a85f89baf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a8ac260693c9aac7ba9d03b8a85f89baf">GetSwizzle</a> (<a class="el" href="structnvn_1_1_texture_swizzle.html">TextureSwizzle</a> *r, <a class="el" href="structnvn_1_1_texture_swizzle.html">TextureSwizzle</a> *g, <a class="el" href="structnvn_1_1_texture_swizzle.html">TextureSwizzle</a> *b, <a class="el" href="structnvn_1_1_texture_swizzle.html">TextureSwizzle</a> *a) const </td></tr>
<tr class="memdesc:a8ac260693c9aac7ba9d03b8a85f89baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the swizzles for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object.  <a href="#a8ac260693c9aac7ba9d03b8a85f89baf">[詳解]</a><br /></td></tr>
<tr class="separator:a8ac260693c9aac7ba9d03b8a85f89baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa050461eea30b3269b378ce3473cd19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa050461eea30b3269b378ce3473cd19"></a>
<a class="el" href="structnvn_1_1_texture_target.html">TextureTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#afa050461eea30b3269b378ce3473cd19">GetTarget</a> () const </td></tr>
<tr class="memdesc:afa050461eea30b3269b378ce3473cd19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the target for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. <br /></td></tr>
<tr class="separator:afa050461eea30b3269b378ce3473cd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3a3bf6c30da62e86606b509614e26d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__cpp__handle.html#ga7043b07c83539d3871a526626530255a">TextureAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a7d3a3bf6c30da62e86606b509614e26d">GetTextureAddress</a> () const </td></tr>
<tr class="memdesc:a7d3a3bf6c30da62e86606b509614e26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the GPU address of the first byte of memory used by a texture.  <a href="#a7d3a3bf6c30da62e86606b509614e26d">[詳解]</a><br /></td></tr>
<tr class="separator:a7d3a3bf6c30da62e86606b509614e26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c06c40eaa84156c3067b252d6a0e2c5"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a8c06c40eaa84156c3067b252d6a0e2c5">GetViewOffset</a> (const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *textureView) const </td></tr>
<tr class="memdesc:a8c06c40eaa84156c3067b252d6a0e2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset (in bytes) of the first byte of storage used by a view of a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object.  <a href="#a8c06c40eaa84156c3067b252d6a0e2c5">[詳解]</a><br /></td></tr>
<tr class="separator:a8c06c40eaa84156c3067b252d6a0e2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcc3fd3e0a490cf30eb8cdc04a0147a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bcc3fd3e0a490cf30eb8cdc04a0147a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a3bcc3fd3e0a490cf30eb8cdc04a0147a">GetWidth</a> () const </td></tr>
<tr class="memdesc:a3bcc3fd3e0a490cf30eb8cdc04a0147a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the width for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. <br /></td></tr>
<tr class="separator:a3bcc3fd3e0a490cf30eb8cdc04a0147a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6252c83c2f3e03484eec8ac38b602c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a6e6252c83c2f3e03484eec8ac38b602c">GetZCullStorageSize</a> () const </td></tr>
<tr class="memdesc:a6e6252c83c2f3e03484eec8ac38b602c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth texture.  <a href="#a6e6252c83c2f3e03484eec8ac38b602c">[詳解]</a><br /></td></tr>
<tr class="separator:a6e6252c83c2f3e03484eec8ac38b602c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac369f6845c5776de5dbedc84b9191e4c"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#ac369f6845c5776de5dbedc84b9191e4c">Initialize</a> (const <a class="el" href="classnvn_1_1_texture_builder.html">TextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ac369f6845c5776de5dbedc84b9191e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a texture object from a texture builder using storage provided by a memory pool.  <a href="#ac369f6845c5776de5dbedc84b9191e4c">[詳解]</a><br /></td></tr>
<tr class="separator:ac369f6845c5776de5dbedc84b9191e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a891a66ea201b3d4cb71f74f7af445"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a58a891a66ea201b3d4cb71f74f7af445">InvalidateTexels</a> (const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *textureView, const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *region) const </td></tr>
<tr class="memdesc:a58a891a66ea201b3d4cb71f74f7af445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate CPU cache lines holding portions of a texture.  <a href="#a58a891a66ea201b3d4cb71f74f7af445">[詳解]</a><br /></td></tr>
<tr class="separator:a58a891a66ea201b3d4cb71f74f7af445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6f73c7e3dcf036d92c52fc5637f29a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#afb6f73c7e3dcf036d92c52fc5637f29a">ReadTexels</a> (const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *textureView, const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *region, void *data) const </td></tr>
<tr class="memdesc:afb6f73c7e3dcf036d92c52fc5637f29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read texture data from a region of a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object into memory.  <a href="#afb6f73c7e3dcf036d92c52fc5637f29a">[詳解]</a><br /></td></tr>
<tr class="separator:afb6f73c7e3dcf036d92c52fc5637f29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e1e381dac6abf3b701db1e25577a47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a37e1e381dac6abf3b701db1e25577a47">ReadTexelsStrided</a> (const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *textureView, const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *region, void *data, ptrdiff_t rowStride, ptrdiff_t imageStride) const </td></tr>
<tr class="memdesc:a37e1e381dac6abf3b701db1e25577a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read texture data from a region of a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object into memory.  <a href="#a37e1e381dac6abf3b701db1e25577a47">[詳解]</a><br /></td></tr>
<tr class="separator:a37e1e381dac6abf3b701db1e25577a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e06f6970a803509d49dacbd9e8f203a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#a0e06f6970a803509d49dacbd9e8f203a">SetDebugLabel</a> (const char *label)</td></tr>
<tr class="memdesc:a0e06f6970a803509d49dacbd9e8f203a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object.  <a href="#a0e06f6970a803509d49dacbd9e8f203a">[詳解]</a><br /></td></tr>
<tr class="separator:a0e06f6970a803509d49dacbd9e8f203a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8dc8fd619bb9afece667b519ec5797d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#af8dc8fd619bb9afece667b519ec5797d">WriteTexels</a> (const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *textureView, const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *region, const void *data) const </td></tr>
<tr class="memdesc:af8dc8fd619bb9afece667b519ec5797d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy texture data from memory into a region of a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object.  <a href="#af8dc8fd619bb9afece667b519ec5797d">[詳解]</a><br /></td></tr>
<tr class="separator:af8dc8fd619bb9afece667b519ec5797d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8453ab7900ae7cad9d7c829fb30c5db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_texture.html#ae8453ab7900ae7cad9d7c829fb30c5db">WriteTexelsStrided</a> (const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *textureView, const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *region, const void *data, ptrdiff_t rowStride, ptrdiff_t imageStride) const </td></tr>
<tr class="memdesc:ae8453ab7900ae7cad9d7c829fb30c5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy texture data from memory into a region of a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object with user-specified stride.  <a href="#ae8453ab7900ae7cad9d7c829fb30c5db">[詳解]</a><br /></td></tr>
<tr class="separator:ae8453ab7900ae7cad9d7c829fb30c5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p>Block of GPU-accessible memory and related state used to hold image data. </p>
</div><h2 class="groupheader">関数詳解</h2>
<a class="anchor" id="ac369f6845c5776de5dbedc84b9191e4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvn::Texture::Initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture_builder.html">TextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a texture object from a texture builder using storage provided by a memory pool. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="classnvn_1_1_texture_builder.html" title="Object specifying state used to construct new texture objects. ">TextureBuilder</a> object holding properties of the new <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e6252c83c2f3e03484eec8ac38b602c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvn::Texture::GetZCullStorageSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth texture. </p>
<p>The buffer should be aligned to <a class="el" href="structnvn_1_1_device_info.html#a3a3f1fadbedcce8403a4df3b3fdea61daf4b271b11114e1c43afe1f7006c84059" title="Minimum alignment for ZCull save/restore buffers. ">DeviceInfo::ZCULL_SAVE_RESTORE_ALIGNMENT</a> bytes.</p>
<p>If the texture has a format with no depth or stencil components, this function returns zero. </p>

</div>
</div>
<a class="anchor" id="a0e06f6970a803509d49dacbd9e8f203a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Texture::SetDebugLabel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. </p>
<p>Annotates a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b6202d8d28e78f06c0a7691806f61db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga4e21960c2b9244bbd2753954b23580d3">NVNstorageClass</a> nvn::Texture::GetStorageClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the storage class needed for virtual memory mappings for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. </p>
<p>When memory from a physical memory pool is mapped into a virtual memory pool, the mapping must be established with a storage class appropriate for texture or buffer resources using the virtual memory. The value returned by this command should be used for memory mappings used by this texture. </p>

</div>
</div>
<a class="anchor" id="a8c06c40eaa84156c3067b252d6a0e2c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvn::Texture::GetViewOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the offset (in bytes) of the first byte of storage used by a view of a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. </p>
<p>The offset returned is a value relative to the offset of the first byte of storage used by the full texture. Textures are stored in (virtually) contiguous memory. For array and cube map textures, each layer or face is stored in memory as a unit with offsets increasing by layer number. For mipmapped textures, each mipmap level in the texture (or in each layer for array and cube map textures) is stored as a unit with offsets increasing by mipmap level number.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureView</td><td>View of the texture used to determine an offset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ac260693c9aac7ba9d03b8a85f89baf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Texture::GetSwizzle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_texture_swizzle.html">TextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_texture_swizzle.html">TextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_texture_swizzle.html">TextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_texture_swizzle.html">TextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the swizzles for a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>Input component value used for the first (R) output component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>Input component value used for the second (G) output component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>Input component value used for the third (B) output component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a</td><td>Input component value used for the fourth (A) output component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d3a3bf6c30da62e86606b509614e26d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__cpp__handle.html#ga7043b07c83539d3871a526626530255a">TextureAddress</a> nvn::Texture::GetTextureAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the GPU address of the first byte of memory used by a texture. </p>
<dl class="section warning"><dt>警告</dt><dd>Except for buffer and linear textures, a TextureAddress returned by <a class="el" href="classnvn_1_1_texture.html#a7d3a3bf6c30da62e86606b509614e26d" title="Returns the GPU address of the first byte of memory used by a texture. ">Texture::GetTextureAddress</a> corresponds to a special memory mapping that can not be used to view or manipulate memory in commands accepting a buffer address. </dd></dl>

</div>
</div>
<a class="anchor" id="a99240ee8da42da429a508e6b395d79d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Texture::GetSparseTileLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_texture_sparse_tile_layout.html">TextureSparseTileLayout</a> *&#160;</td>
          <td class="paramname"><em>layout</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns properties of the sparse memory layout for a texture. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">layout</td><td>Pointer to a <a class="el" href="structnvn_1_1_texture_sparse_tile_layout.html" title="Data structure used by queries of the memory layout used by sparse textures. ">TextureSparseTileLayout</a> structure to receive layout information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8dc8fd619bb9afece667b519ec5797d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Texture::WriteTexels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy texture data from memory into a region of a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object. </p>
<p>Copies texture data from the memory pointed to by <em>data</em> to the specified region of a texture, using the CPU. This command behaves like <a class="el" href="classnvn_1_1_command_buffer.html#a3a08f2105e0c5dce61161fbcbbe25b9e" title="Copy texture data from buffer memory into a region of a Texture object. ">CommandBuffer::CopyBufferToTexture</a>, except that the copy is performed immediately and does not involve the GPU on NX. On the Windows reference implementation, this copy will use the GPU to update GPU-attached video memory. If the texture is stored in a memory pool created with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a99a56351eafbaab331298fbc1a78e152" title="Indicates that the memory pool will be accessed by the CPU with caching. ">MemoryPoolFlags::CPU_CACHED</a>, the caller must use <a class="el" href="classnvn_1_1_texture.html#a011f2387ececb593ee0469db195b67fd" title="Flush CPU cache lines holding portions of a texture. ">Texture::FlushTexels</a> to flush relevant portions of the CPU cache prior to using the updated texture in the GPU.</p>
<dl class="section warning"><dt>警告</dt><dd>Because the CPU does not have access to GPU compression information needed to properly interpret GPU-compressed textures, it is an error to use this command to operate on a texture with the <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea8debc4c2f35f9947fdb4f17e36a6393d" title="The contents of this texture can be compressed by the GPU. ">TextureFlags::COMPRESSIBLE</a> flag set.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureView</td><td>View of the texture object used as the destination for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>texture</em>. If NULL is specified, the base level of the texture <em>texture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">region</td><td>Region of the destination texture to update.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to source texel data in system memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8453ab7900ae7cad9d7c829fb30c5db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Texture::WriteTexelsStrided </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>rowStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>imageStride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy texture data from memory into a region of a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object with user-specified stride. </p>
<p>Copies texture data from the memory pointed to by <em>data</em> to the specified region of a texture, using the CPU. This command behaves like the combination of <a class="el" href="classnvn_1_1_command_buffer.html#a0207cc2151b50b8b0fd1957612482e67" title="Set the row stride used for copies between buffer and texture memory. ">CommandBuffer::SetCopyRowStride</a>, <a class="el" href="classnvn_1_1_command_buffer.html#a9ed848d8f9360fa17c44e9570a6d8bc4" title="Set the image stride used for copies between buffer and texture memory. ">CommandBuffer::SetCopyImageStride</a>, and <a class="el" href="classnvn_1_1_command_buffer.html#a3a08f2105e0c5dce61161fbcbbe25b9e" title="Copy texture data from buffer memory into a region of a Texture object. ">CommandBuffer::CopyBufferToTexture</a>, except that no stride state is retained, and the copy is performed immediately and does not involve the GPU on NX. Note this means that <em>rowStride</em> must be at least the number of bytes in a row of the image, and <em>imageStride</em> must be at least the number of bytes in one full image. On the Windows reference implementation, this copy will use the GPU to update GPU-attached video memory. If the texture is stored in a memory pool created with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a99a56351eafbaab331298fbc1a78e152" title="Indicates that the memory pool will be accessed by the CPU with caching. ">MemoryPoolFlags::CPU_CACHED</a>, the caller must use <a class="el" href="classnvn_1_1_texture.html#a011f2387ececb593ee0469db195b67fd" title="Flush CPU cache lines holding portions of a texture. ">Texture::FlushTexels</a> to flush relevant portions of the CPU cache prior to using the updated texture in the GPU.</p>
<dl class="section warning"><dt>警告</dt><dd>Because the CPU does not have access to GPU compression information needed to properly interpret GPU-compressed textures, it is an error to use this command to operate on a texture with the <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea8debc4c2f35f9947fdb4f17e36a6393d" title="The contents of this texture can be compressed by the GPU. ">TextureFlags::COMPRESSIBLE</a> flag set.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureView</td><td>View of the texture object used as the destination for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>texture</em>. If NULL is specified, the base level of the texture <em>texture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">region</td><td>Region of the destination texture to update.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to source texel data in system memory.</td></tr>
    <tr><td class="paramname">rowStride</td><td>Stride (in bytes) between rows of texels in <em>data</em>. If specified as 0, rows of texels in <em>data</em> will be treated as densely packed, where each new row in memory starts immediately after the end of the previous row. For compressed texture formats, <em>rowStride</em> indicates the stride between rows of blocks.</td></tr>
    <tr><td class="paramname">imageStride</td><td>Stride (in bytes) between 2D arrays of texels in <em>data</em>. If specified as 0, 2D arrays of texels (corresponding to 2d texture layers, cube faces, or slices of a 3D texture) will be treated as densely packed, where each 2D array in memory starts immediately after the end of the previous 2D array. If <em>imageStride</em> is 0 and <em>rowStride</em> is non-zero, each 2D array is treated as an array of rows, each consuming <em>rowStride</em> bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb6f73c7e3dcf036d92c52fc5637f29a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Texture::ReadTexels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read texture data from a region of a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object into memory. </p>
<p>Copies texture data from the specified region of a texture to the memory pointed to by <em>data</em>, using the CPU. This command behaves like <a class="el" href="classnvn_1_1_command_buffer.html#a58614a879993e898fb202d6d455bc435" title="Copy texture data from a region of a Texture object into buffer memory. ">CommandBuffer::CopyTextureToBuffer</a>, except that the copy is performed immediately and does not involve the GPU on NX. On the Windows reference implementation, this copy will use the GPU to read GPU-attached video memory. If the texture is stored in a memory pool created with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a99a56351eafbaab331298fbc1a78e152" title="Indicates that the memory pool will be accessed by the CPU with caching. ">MemoryPoolFlags::CPU_CACHED</a> and has been updated using the GPU, the caller must use <a class="el" href="classnvn_1_1_texture.html#a58a891a66ea201b3d4cb71f74f7af445" title="Invalidate CPU cache lines holding portions of a texture. ">Texture::InvalidateTexels</a> to invalidate relevant portions of the CPU cache prior to using this command to read from the texture.</p>
<dl class="section warning"><dt>警告</dt><dd>Because the CPU does not have access to GPU compression information needed to properly interpret GPU-compressed textures, it is an error to use this command to operate on a texture with the <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea8debc4c2f35f9947fdb4f17e36a6393d" title="The contents of this texture can be compressed by the GPU. ">TextureFlags::COMPRESSIBLE</a> flag set.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">textureView</td><td>View of the texture object used as the source for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>texture</em>. If NULL is specified, the base level of the texture <em>texture</em> will be used as-is.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">region</td><td>Region of the source texture to read.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Pointer to destination texel data in system memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37e1e381dac6abf3b701db1e25577a47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Texture::ReadTexelsStrided </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>rowStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>imageStride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read texture data from a region of a <a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object into memory. </p>
<p>Copies texture data from the specified region of a texture to the memory pointed to by <em>data</em>, using the CPU. This command behaves like the combination of <a class="el" href="classnvn_1_1_command_buffer.html#a0207cc2151b50b8b0fd1957612482e67" title="Set the row stride used for copies between buffer and texture memory. ">CommandBuffer::SetCopyRowStride</a>, <a class="el" href="classnvn_1_1_command_buffer.html#a9ed848d8f9360fa17c44e9570a6d8bc4" title="Set the image stride used for copies between buffer and texture memory. ">CommandBuffer::SetCopyImageStride</a>, and <a class="el" href="classnvn_1_1_command_buffer.html#a58614a879993e898fb202d6d455bc435" title="Copy texture data from a region of a Texture object into buffer memory. ">CommandBuffer::CopyTextureToBuffer</a>, except that no stride state is retained, and the copy is performed immediately and does not involve the GPU on NX. Note this means that <em>rowStride</em> must be at least the number of bytes in a row of the image, and <em>imageStride</em> must be at least the number of bytes in one full image. On the Windows reference implementation, this copy will use the GPU to read GPU-attached video memory. If the texture is stored in a memory pool created with <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a99a56351eafbaab331298fbc1a78e152" title="Indicates that the memory pool will be accessed by the CPU with caching. ">MemoryPoolFlags::CPU_CACHED</a> and has been updated using the GPU, the caller must use <a class="el" href="classnvn_1_1_texture.html#a58a891a66ea201b3d4cb71f74f7af445" title="Invalidate CPU cache lines holding portions of a texture. ">Texture::InvalidateTexels</a> to invalidate relevant portions of the CPU cache prior to using this command to read from the texture.</p>
<dl class="section warning"><dt>警告</dt><dd>Because the CPU does not have access to GPU compression information needed to properly interpret GPU-compressed textures, it is an error to use this command to operate on a texture with the <a class="el" href="structnvn_1_1_texture_flags.html#a586ca7e85b6c38bfde1bd377a4d9873ea8debc4c2f35f9947fdb4f17e36a6393d" title="The contents of this texture can be compressed by the GPU. ">TextureFlags::COMPRESSIBLE</a> flag set.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">textureView</td><td>View of the texture object used as the source for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>texture</em>. If NULL is specified, the base level of the texture <em>texture</em> will be used as-is.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">region</td><td>Region of the source texture to read.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Pointer to destination texel data in system memory.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rowStride</td><td>Stride (in bytes) between rows of texels in <em>data</em>. If specified as 0, rows of texels in <em>data</em> will be treated as densely packed, where each new row in memory starts immediately after the end of the previous row. For compressed texture formats, <em>rowStride</em> indicates the stride between rows of blocks.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">imageStride</td><td>Stride (in bytes) between 2D arrays of texels in <em>data</em>. If specified as 0, 2D arrays of texels (corresponding to 2d texture layers, cube faces, or slices of a 3D texture) will be treated as densely packed, where each 2D array in memory starts immediately after the end of the previous 2D array. If <em>imageStride</em> is 0 and <em>rowStride</em> is non-zero, each 2D array is treated as an array of rows, each consuming <em>rowStride</em> bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a011f2387ececb593ee0469db195b67fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Texture::FlushTexels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush CPU cache lines holding portions of a texture. </p>
<p>When a texture object is stored in a memory pool created using <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a99a56351eafbaab331298fbc1a78e152" title="Indicates that the memory pool will be accessed by the CPU with caching. ">MemoryPoolFlags::CPU_CACHED</a>, texel updates using <a class="el" href="classnvn_1_1_texture.html#af8dc8fd619bb9afece667b519ec5797d" title="Copy texture data from memory into a region of a Texture object. ">Texture::WriteTexels</a> will use the CPU cache and may not be immediately visible to the GPU. Before using the contents of such textures on the GPU, this command should be used to flush relevant portions of the CPU cache to ensure that updated texels are written to main memory and will be visible to the GPU. This operation is not needed for textures stored in memory pools created using <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ac8d67a6455dce7ff64bb8b593a144369" title="Indicates that the memory pool will be accessed by the CPU without caching. ">MemoryPoolFlags::CPU_UNCACHED</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureView</td><td>View of the texture object used for the flush operation. A texture view, if specified, can be used to override properties of the corresponding texture <em>texture</em>. If NULL is specified, the base level of the texture <em>texture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">region</td><td>Region of the texture used by the flush operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58a891a66ea201b3d4cb71f74f7af445"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Texture::InvalidateTexels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture_view.html">TextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnvn_1_1_copy_region.html">CopyRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate CPU cache lines holding portions of a texture. </p>
<p>When a texture object is stored in a memory pool created using <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356a99a56351eafbaab331298fbc1a78e152" title="Indicates that the memory pool will be accessed by the CPU with caching. ">MemoryPoolFlags::CPU_CACHED</a>, texels accessed by the CPU may be stored in CPU caches. If texel values are updated using the GPU, subsequent accesses using <a class="el" href="classnvn_1_1_texture.html#afb6f73c7e3dcf036d92c52fc5637f29a" title="Read texture data from a region of a Texture object into memory. ">Texture::ReadTexels</a> may read old texel values if any of the old data remains in the CPU cache. Before reading GPU-modified textures using <a class="el" href="classnvn_1_1_texture.html#afb6f73c7e3dcf036d92c52fc5637f29a" title="Read texture data from a region of a Texture object into memory. ">Texture::ReadTexels</a>, this command should be used to invalidate relevant portions of the CPU cache to ensure that stale texel values do not remain in the CPU caches. This operation is not needed for textures stored in memory pools created using <a class="el" href="structnvn_1_1_memory_pool_flags.html#a9cfd88ffbebcaed533927f83672e1356ac8d67a6455dce7ff64bb8b593a144369" title="Indicates that the memory pool will be accessed by the CPU without caching. ">MemoryPoolFlags::CPU_UNCACHED</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureView</td><td>View of the texture object used for the invalidate operation. A texture view, if specified, can be used to override properties of the corresponding texture <em>texture</em>. If NULL is specified, the base level of the texture <em>texture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">region</td><td>Region of the texture used for the invalidate operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab298e62cbb28cd3b8fad0a3b2415d12e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvn::Texture::Compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_texture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>otherTexture</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if texture objects are equivalent. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherTexture</td><td><a class="el" href="classnvn_1_1_texture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">Texture</a> object to compare against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ea69b814baa57df64472afde284d76e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nvn::Texture::GetDebugID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the debug layer unique ID of this texture. </p>
<p>Returns 0 if debug layer disabled. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
