<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>NintendoSDK API Reference: GLSLC Programming Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>総合概要</span></a></li>
      <li class="current"><a href="pages.html"><span>諸情報</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>名前空間</span></a></li>
      <li><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="_page_graphics_for_n_x.html">グラフィックス for NX</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">GLSLC Programming Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>目次</h3>
<ul><li class="level1"><a href="#nvn_glslc_guide_introduction">1. Introduction</a></li>
<li class="level1"><a href="#nvn_glslc_guide_usage">2. Usage Model</a><ul><li class="level2"><a href="#nvn_glslc_guide_sec_2_1">2.1. Compilation Overview</a></li>
<li class="level2"><a href="#nvn_glslc_compilation_life_cycle">2.2. Compilation Life Cycle</a></li>
<li class="level2"><a href="#nvn_glslc_guide_glslcinput">2.3. Input</a><ul><li class="level3"><a href="#nvn_glslc_guide_glslcoptions">Options</a></li>
</ul>
</li>
<li class="level2"><a href="#nvn_glslc_guide_glslcoutput">2.4. Output</a></li>
<li class="level2"><a href="#nvn_glslc_guide_errorchecking">2.5. Error Checking</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_glslc_guide_scratchmemory">3. Scratch Memory</a><ul><li class="level2"><a href="#nvn_glslc_guide_error_on_scratch_mem_usage">3.1. Error on scratch usage</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_glslc_guide_dataconsistency">4. Data Consistency</a></li>
<li class="level1"><a href="#nvn_glslc_guide_includesupport">5. Include Support</a></li>
<li class="level1"><a href="#nvn_glslc_guide_forceinclude">6. Compiler Force Include of Standard Headers</a></li>
<li class="level1"><a href="#nvn_glslc_guide_versioning">7. Versioning and Compatibility</a><ul><li class="level2"><a href="#nvn_glslc_guide_apiversion">7.1. API Version</a></li>
<li class="level2"><a href="#nvn_glslc_guide_sec_7_2">7.2. GPU code version</a></li>
<li class="level2"><a href="#nvn_glslc_guide_sec_7_3">7.3. Querying driver support</a></li>
<li class="level2"><a href="#nvn_glslc_guide_sec_7_4">7.4. Package Version</a></li>
<li class="level2"><a href="#nvn_glslc_guide_sec_7_5">7.5. Obtaining the version from the GLSLC DLL</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_glslc_guide_macros">8. Predefined GLSLC macros</a></li>
<li class="level1"><a href="#nvn_glslc_guide_performance_stats">9. Compiler Performance Statistics</a><ul><li class="level2"><a href="#nvn_glslc_guide_sec_9_1">9.1. Use of the DLL interface for perf statistics.</a></li>
<li class="level2"><a href="#nvn_glslc_guide_sec_9_2">9.2. Perf Statistics Usage Model</a></li>
<li class="level2"><a href="#nvn_glslc_guide_sec_9_3">9.3. Perf stats Limitations</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_glslc_guide_register_spill_control">10. Register Spill Control</a></li>
<li class="level1"><a href="#nvn_glslc_guide_prioritize_consecutive_texture_instructions">11. Prioritize Consecutive Texture Instructions</a></li>
<li class="level1"><a href="#nvn_glslc_guide_sec_12">12. Vertex Culling Optimizations</a><ul><li class="level2"><a href="#nvn_glslc_guide_warpculling">12.1. Vertex Warp Culling</a></li>
<li class="level2"><a href="#nvn_glslc_guide_cbf">12.2. Cull-Before-Fetch</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_glslc_guide_sec_13">13. Floating-Point Math Rules</a><ul><li class="level2"><a href="#nvn_glslc_guide_sec_13_1">13.1. Implementation of pow(a, b)</a></li>
<li class="level2"><a href="#nvn_glslc_guide_fastmath">13.2. Fast math</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_glslc_guide_shader_reflection">14. Shader reflection</a></li>
<li class="level1"><a href="#nvn_glslc_glsl_differences">15. GLSL Differences</a><ul><li class="level2"><a href="#nvn_glslc_guide_uniforms">15.1. Uniforms</a></li>
<li class="level2"><a href="#nvn_glslc_guide_sec_15_2">15.2. Pragma directives</a></li>
<li class="level2"><a href="#nvn_glslc_guide_glsl_extensions_supported">15.3. GLSL Extensions Supported</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_glslc_guide_shader_specialization">16. Shader Specialization</a><ul><li class="level2"><a href="#nvn_glslc_guide_sec_16_1">16.1. Usage Model</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_glslc_guide_sec_17">17. Debug Information</a></li>
<li class="level1"><a href="#nvn_glslc_guide_sec_18">18. Retrieving assembly output</a><ul><li class="level2"><a href="#nvn_glslc_guide_sec_18_1">18.1. Constant Buffer Accesses</a></li>
<li class="level2"><a href="#nvn_glslc_guide_sec_18_2">18.2. Vertex attributes and Varyings</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_glslc_fp16">19. FP16 Support</a><ul><li class="level2"><a href="#nvn_glslc_desktop_lowp_mediump">19.1. GL_NV_desktop_lowp_mediump Extension Specification Version 1.0</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_glslc_guide_sec_20">20. Shader subroutine support</a><ul><li class="level2"><a href="#nvn_glslc_guide_sec_20_1">20.1. Syntax</a></li>
<li class="level2"><a href="#nvn_glslc_guide_sec_20_2">20.2. Linkage map</a></li>
<li class="level2"><a href="#nvn_glslc_guide_sec_20_3">20.3. Reflection Info</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_glslc_guide_sec_21">21. SPIR-V support</a><ul><li class="level2"><a href="#nvn_glslc_guide_sec_21_1">21.1. Usage</a></li>
<li class="level2"><a href="#nvn_glslc_guide_spirv_spec">21.2. SPIR-V execution environment and GLSLC SPIR-V specification</a></li>
<li class="level2"><a href="#nvn_glslc_guide_sec_21_3">21.3. Usage Example</a></li>
<li class="level2"><a href="#nvn_glslc_guide_sec_21_4">21.4. Limitations</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_glslc_guide_sec_22">22. Separate Sampler and Texture Uniforms</a><ul><li class="level2"><a href="#nvn_glslc_guide_sec_22_1">22.1. Limits</a></li>
<li class="level2"><a href="#nvn_glslc_guide_sec_22_2">22.2. Bindless Separate Sampler and Texture Handles</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_glslc_guide_sec_23">23. Comparing compiled programs for functional equality</a><ul><li class="level2"><a href="#nvn_glslc_guide_sec_23_1">23.1. Specialized fat binaries</a></li>
</ul>
</li>
<li class="level1"><a href="#nvn_glslc_guide_sec_24">24. GLASM internal limits</a></li>
<li class="level1"><a href="#nvn_glslc_guide_knownissues">25. Known Issues</a></li>
<li class="level1"><a href="#nvn_glslc_guide_terminology">26. Terminology</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="nvn_glslc_guide_introduction"></a>
1. Introduction</h1>
<p>On a high-level, GLSLC is an offline compiler for compiling shaders to GPU programs which can be used with NVN on both Windows and NX platforms. GLSLC outputs the compilation result along with any warnings and failures. Additionally, GLSLC contains many options to output meta-information about the compiled programs. GLSLC is the only way to compile shaders to be used by applications and to be loaded into the NVN API.</p>
<p>GLSLC is delivered as a library (DLL) which is meant to be linked into applications and used to compile binaries which could contain code for use with the NVN API or to obtain information about the compiled programs.</p>
<p>GLSLC can be used to compile GLSL shaders to program binaries compatible with the NX and Windows platforms using the NVN API. By default, the binaries that GLSLC produces for use with NVN are "fat" binaries that contain enough information to reconstruct the shader programs on non-NX platforms. In other words, a single instance of an output program binary produced from GLSLC can be used on all platforms supporting NVN. There is an option to support "thin" binaries which would output binaries only compatible with NX hardware. These binaries generally use up less memory at the cost of losing support on non-NX platforms. See the <a class="el" href="struct_g_l_s_l_coptions.html" title="Options structure to control compilation phase, what gets output in the GLSLCOutput structure...">GLSLCoptions</a> structure for information on output options.</p>
<h1><a class="anchor" id="nvn_glslc_guide_usage"></a>
2. Usage Model</h1>
<p>Any application that wishes to compile shaders to use with the NVN API must use the GLSLC library for shader compilation, although the way in which the library is used is left up to the application. The GLSLC library is provided on both Windows and NX platforms.</p>
<p>On Windows platforms, the library is named NvnGlslc.dll or NvnGlslc32.dll for the 64-bit and 32-bit versions respectively. Additionally, two static import libraries are provided: NvnGlslc.lib and NvnGlslc32.lib for the 64-bit and 32-bit versions respectively. On NX platforms, the library is named libglslc.a and can be linked to by applications using the build toolchain. On both platforms (Windows and NX), the "fat" binaries that GLSLC produces are compatible with the NVN API on all supported platforms. "Thin" binaries (binaries produced when using the <a class="el" href="struct_g_l_s_l_coption_flags.html#acb869c3adcd98163305142fba3d84e2b" title="Controls whether the resulting output contains a GPU program that is a thin binary (only contains pro...">GLSLCoptionFlags::outputThinGpuBinaries</a> flag) are only supported by NX drivers and can not be loaded into the NVN driver on a Windows platform. The GLSLC API is also identical regardless of platform.</p>
<p>NVN applications do not need to link to the GLSLC compiler library to execute. The GLSLC library and the output binaries have been designed for offline compilation. For example, an asset packager application built for Windows can link to the GLSLC DLL and compile all the shaders needed by a NVN application into a set of binaries. The asset packager could then save those binaries to external media in any format it wishes to use (the GLSLC output binaries are serialized and can be copied/stored directly to media if needed). The NVN application that needs the compiled shader binaries can load them from the external media into memory and use them when needed with the NVN API function nvnProgramSetShaders. The NVN application does not need to link against or use the GLSLC library in this example since all shader compilation was performed offline using the asset packager.</p>
<p>There are two common scenarios in which applications may want to use the GLSLC library: "offline" compilation, or "online" compilation.</p>
<ul>
<li>"Offline" compilation - Applications can precompile all shaders into binaries and store to disk or other media as part of a packaging step. The binaries can the be loaded into an NVN application on any platform where NVN is supported, parsed by the application, and then used as input to the NVN API via nvnProgramSetShaders. The NVN application does not need to link to or use the GLSLC library if the compiled shader binaries are available.</li>
<li>"Online" compilation - NVN applications can link to the GLSLC library, call the appropriate GLSLC API functions to compile shaders when needed, then load the resulting binary into the NVN API via nvnProgramSetShaders. This usage model is similar to that used by OpenGL applications. Applications using online compilation must link to the GLSLC library and use the GLSLC API for compilation since no compiler support is available in the NVN API itself.</li>
</ul>
<p>Applications that wish to use GLSLC must link to the GLSLC library and call into the API interface functions to obtain the compilation results. Although the API and GLSLC input/output format is the same regardless of platform, the method for linking to the GLSLC library varies depending on which platform the NVN application is executing on:</p>
<ol type="1">
<li><p class="startli">Windows applications - The GLSLC library and its API are contained in a dynamic link library (DLL) and the DLL is required by the application.</p>
<p class="startli">a. Static import library - Applications can link against the static import library which allows applications to call directly into the GLSLC API functions without requiring the application to load them manually. A matching GLSLC DLL (NvnGlslc.dll or NvnGlslc32.dll for 64- or 32-bit applications respectively) must be found in the application's DLL search path.</p>
<p class="startli">b. Demand Loading - Applications must load the GLSLC DLL from disk manually and obtain the function pointers exposed in the DLL interface. This is most commonly achieved via the Windows-based "LoadLibrary" and "GetProcAddress" functions. For more information on how to use these functions to load a DLL and obtain the exported function pointers, please consult the Microsoft developer manuals.</p>
</li>
<li><p class="startli">NX applications - The GLSLC library and its API are exposed through the static library libglslc.a.</p>
<p class="startli">a. Link to static library - NX applications that wish to compile shaders on the device can link against the NX GLSLC library which provides the same API interface as the Windows GLSLC library. This can allow applications to perform "online" compilation at run-time if required. If precompiled binaries are available to the application, no linkage or use of this library is nessesary.</p>
</li>
</ol>
<blockquote class="doxtable">
<p>Note: #include support with the NX version of GLSLC is still experimental and may not function correctly. </p>
</blockquote>
<h2><a class="anchor" id="nvn_glslc_guide_sec_2_1"></a>
2.1. Compilation Overview</h2>
<blockquote class="doxtable">
<p>Note: Starting with GLSLC version 16.1, if using an HOS version of GLSLC, all applications must call "glslcSetAllocator" prior to any other GLSLC function call. Failure to do so will result in a GLSLC compilation warning. Future versions of GLSLC will fail to compile completely if this step is not performed. This is not required if using a Windows GLSLC DLL. </p>
</blockquote>
<p>The <a class="el" href="struct_g_l_s_l_ccompile_object.html" title="The main object that holds input/output variables for compilation. ">GLSLCcompileObject</a> contains various input structures for the compilation routine, and this object will be used throughout the lifetime of a program compilation until it is either cleaned up with glslcFinalize or a new compilation is performed.</p>
<p>To perform basic compilation, two required variables first need to be set up.</p>
<ul>
<li><a class="el" href="struct_g_l_s_l_ccompile_object.html#a6cc042ea5fe41d3aa6c9fac773a447b8" title="Compilation options. ">GLSLCcompileObject::options</a>. This structure allows for specifying what type of data is requested in the output and how to perform the compilation. See the <a class="el" href="struct_g_l_s_l_coptions.html" title="Options structure to control compilation phase, what gets output in the GLSLCOutput structure...">GLSLCoptions</a> and <a class="el" href="struct_g_l_s_l_coption_flags.html" title="Option flags that control compilation and GLSLC output. ">GLSLCoptionFlags</a> documentation for more information on what options are available now or planned for the subsequent releases.</li>
<li><a class="el" href="struct_g_l_s_l_ccompile_object.html#a1439e7a28e5232e1dc82924e8c4d063d" title="Input shaders. ">GLSLCcompileObject::input</a> - This variable allows the application to set up the input shaders from source text and specify which stages the input shaders come from.</li>
</ul>
<p>For obtaining results, the GLSLCcompileObject::lastCompiledResults will contain the output data from a successful or an unsuccessful compilation, including the GPU code and any other sections requested via the <a class="el" href="struct_g_l_s_l_ccompile_object.html#a6cc042ea5fe41d3aa6c9fac773a447b8" title="Compilation options. ">GLSLCcompileObject::options</a> parameters.</p>
<p>The flow of compilation an application would take would look something like this:</p>
<p>1) If using the HOS version of GLSLC, initialize the GLSLC library by providing memory allocator callbacks using the GLSLC API function "glslcSetAllocator". On Windows this is not required.</p>
<p>2) Create a <a class="el" href="struct_g_l_s_l_ccompile_object.html" title="The main object that holds input/output variables for compilation. ">GLSLCcompileObject</a>, either as a local or dynamically allocated.</p>
<p>3) Call glslcInitialize with the compile object. This will initialize any options/internal data structures that might be used during the lifetime of the object.</p>
<p>4) Set the compile object's options. These options are contained in <a class="el" href="struct_g_l_s_l_ccompile_object.html#a6cc042ea5fe41d3aa6c9fac773a447b8" title="Compilation options. ">GLSLCcompileObject::options</a>.</p>
<p>5) Set the input shaders. These are contained in <a class="el" href="struct_g_l_s_l_ccompile_object.html#a1439e7a28e5232e1dc82924e8c4d063d" title="Input shaders. ">GLSLCcompileObject::input</a></p>
<p>6) Call glslcCompile (or one of the specialization variants, refer to the specialization section of this guide).</p>
<p>7) Save the compiled results contained inside the <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> to disk or to an application managed piece of memory.</p>
<p>8) Perform more compiles with the same compileObject if desired.</p>
<p>9) Call glslcFinalize on the compile object to clean up all results and internal data structures.</p>
<h2><a class="anchor" id="nvn_glslc_compilation_life_cycle"></a>
2.2. Compilation Life Cycle</h2>
<p>All compilation in GLSLC takes place with a <a class="el" href="struct_g_l_s_l_ccompile_object.html" title="The main object that holds input/output variables for compilation. ">GLSLCcompileObject</a> structure. The <a class="el" href="struct_g_l_s_l_ccompile_object.html" title="The main object that holds input/output variables for compilation. ">GLSLCcompileObject</a> contains data structures that the user must set up before compilation. Compilation is performed with the function glslcCompile using the <a class="el" href="struct_g_l_s_l_ccompile_object.html" title="The main object that holds input/output variables for compilation. ">GLSLCcompileObject</a> as input. Upon successful compilation, the object will contain the results of the compilation in an attached <a class="el" href="struct_g_l_s_l_cresults.html" title="A section that will contain the results of a compile. ">GLSLCresults</a> structure. Otherwise, the results structure contains the info log returned from the compiler. In case of a success, a valid <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> structure will be available in the results for futher parsing by the application.</p>
<p>In order to set up a <a class="el" href="struct_g_l_s_l_ccompile_object.html" title="The main object that holds input/output variables for compilation. ">GLSLCcompileObject</a>, the user must first initialize it via the function glslcInitialize. This will ensure any input structures attached to the compile object are initialized prior to the user modifying these to set options and input shader data for compilation. During compilation, GLSLC may allocate internal memory that will be used to read by the calling application, such as an info log a <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> structure, or other internal compiler data objects. The application needs to free these structures once it is done using the compiler in order to free any internal allocations by using glslcFinalize. The application may reuse an initialized <a class="el" href="struct_g_l_s_l_ccompile_object.html" title="The main object that holds input/output variables for compilation. ">GLSLCcompileObject</a> without finalizing. In that case, the results of the previous compilation will be overwritten, but the input structures will be reused to produce a compiled binary.</p>
<p>An example of how to set up the compile object for use with compilation is below:</p>
<div class="fragment"><div class="line"><a class="code" href="struct_g_l_s_l_ccompile_object.html">GLSLCcompileObject</a> compileObject;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="nvn_tool___glslc_interface_8h.html#a648dfc0b503357a72dad03652fc31e57">glslcInitialize</a>(&amp;compileObject) == 0) {</div>
<div class="line">    <span class="comment">// Some error occurred during initialization.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// compileObject is now set up and can be used.</span></div>
</div><!-- fragment --><p>When finished with a <a class="el" href="struct_g_l_s_l_ccompile_object.html" title="The main object that holds input/output variables for compilation. ">GLSLCcompileObject</a>, the data it holds that was previously allocated internally by the driver must be freed:</p>
<div class="fragment"><div class="line"><span class="comment">// Assume compileObject was previously set up with glslcInitialize.  Do NOT try to finalize</span></div>
<div class="line"><span class="comment">// an object that hasn&#39;t been initialized.</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="nvn_tool___glslc_interface_8h.html#a05b2032c99f789df2a34ebf32271c320">glslcFinalize</a>(&amp;compileObject).</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>Note: Any application-side storage of the <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> structure by the application needs to be finished once glslcFinalize is called since those objects will automatically be cleaned up and freed by GLSLC during a glslcFinalize call. </p>
</blockquote>
<p>The compileObject does not need to be finalized if a new compilation is desired. Instead, the application just needs to call glslcCompile again. If this happens, the GLSLCcompileObject::lastCompiledResults pointer will be freed will point to a new <a class="el" href="struct_g_l_s_l_cresults.html" title="A section that will contain the results of a compile. ">GLSLCresults</a> section. Applications are expected to copy what is needed from this structure before performing another recompile or calling glslcFinalize.</p>
<p>An example of using glslcCompileObject for multiple compiles in order to reuse parts of the options:</p>
<div class="fragment"><div class="line"><span class="comment">// Assume compileObject has been previously set up, and shaderSources1 is a set of vertex and</span></div>
<div class="line"><span class="comment">// fragment shaders, and shaderSources2 is a different set of vertex and fragment shaders.</span></div>
<div class="line"></div>
<div class="line">compileObject.<a class="code" href="struct_g_l_s_l_ccompile_object.html#a1439e7a28e5232e1dc82924e8c4d063d">input</a>.sources = shaderSources1;</div>
<div class="line">compileObject.<a class="code" href="struct_g_l_s_l_ccompile_object.html#a1439e7a28e5232e1dc82924e8c4d063d">input</a>.stages = shaderStages1;</div>
<div class="line">compileObject.<a class="code" href="struct_g_l_s_l_ccompile_object.html#a1439e7a28e5232e1dc82924e8c4d063d">input</a>.<a class="code" href="struct_g_l_s_l_cinput.html#a2dd94f2657ef155e688d6a9927c6c381">count</a> = 2;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Compile first set.</span></div>
<div class="line"><a class="code" href="nvn_tool___glslc_interface_8h.html#ad0fd458cbbcd554a1dc81ac61fdcf7e3">glslcCompile</a>(&amp;compileObject);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Copy out the compileObject-&gt;lastCompiledResults-&gt;glslcOutput to an application-allocated region of memory</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Compile with the second set of sources, overriding the results of the first compile.</span></div>
<div class="line"><span class="comment">// Note: The original options and input shader count is still set from the previously set-up values.</span></div>
<div class="line">compileObject.input.sources = shaderSources2;</div>
<div class="line">compileObject.<a class="code" href="struct_g_l_s_l_ccompile_object.html#a1439e7a28e5232e1dc82924e8c4d063d">input</a>.stages = shaderStages2;</div>
<div class="line"></div>
<div class="line"><a class="code" href="nvn_tool___glslc_interface_8h.html#ad0fd458cbbcd554a1dc81ac61fdcf7e3">glslcCompile</a>(&amp;compileObject);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Copy out the compileObject.lastCompiledResults-&gt;glslcOutput to an application-allocated region of memory.</span></div>
<div class="line">...</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>Note: GLSLC supports multi-threaded compilation. If the application enables the option <a class="el" href="struct_g_l_s_l_coption_flags.html#adbd30471af6cce7481cb8ea2fb894b0a" title="Option to enable multithreaded compilation using separate GLSLCcompileObject. ">GLSLCoptionFlags::enableMultithreadCompilation</a> when initializing the compile object, that compile object can be used in a separate thread with other compile objects in the same process. Note that <a class="el" href="struct_g_l_s_l_coption_flags.html#adbd30471af6cce7481cb8ea2fb894b0a" title="Option to enable multithreaded compilation using separate GLSLCcompileObject. ">GLSLCoptionFlags::enableMultithreadCompilation</a> <em>must</em> be enabled for all compile objects running on separate threads for this capability to work. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: As of package version 50, GLSLC supports up to 64 concurrent compile objects. Prior to package version 50, only up to 16 concurrent compile objects were supported. Applications can query the GLSLC library's package version via the API function glslcGetVersion. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: During compilation, GLSLC will retain memory to hold the <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> results until the next compilation or until glslcFinalize is called. In specialized compiles (i.e. using glslcCompileSpecialized), each of the specialization sets are compiled by GLSLC and the memory for all the GLSLCoutputs from each set is retained by GLSLC until finalized or a new compile operation. Memory consumption from a monolithic glslcCompileSpecialized call can be reduced by using multiple calls and storing the results of each call to disk. </p>
</blockquote>
<h2><a class="anchor" id="nvn_glslc_guide_glslcinput"></a>
2.3. Input</h2>
<p>GLSLC shader input is specified by using the structure <a class="el" href="struct_g_l_s_l_cinput.html" title="A structure used as input into GLSLC functions. ">GLSLCinput</a>. <a class="el" href="struct_g_l_s_l_cinput.html" title="A structure used as input into GLSLC functions. ">GLSLCinput</a> contains three entries: GLSLCinput::sources, GLSLCinput::stages, and <a class="el" href="struct_g_l_s_l_cinput.html#a2dd94f2657ef155e688d6a9927c6c381" title="Number of entries in both the sources and stages arrays. ">GLSLCinput::count</a>. GLSLCinput::sources is a pointer to a string array. GLSLCinput::stages is a pointer to an array where each entry is the stage for the corresponding entry in the shader input string array. <a class="el" href="struct_g_l_s_l_cinput.html#a2dd94f2657ef155e688d6a9927c6c381" title="Number of entries in both the sources and stages arrays. ">GLSLCinput::count</a> should be set to the total number of shaders in the array.</p>
<p>After a call to glslcInitialize, <a class="el" href="struct_g_l_s_l_ccompile_object.html" title="The main object that holds input/output variables for compilation. ">GLSLCcompileObject</a> will initially set these inputs to NULL or zero. It is the application's responsibility to set these prior to compilation.</p>
<p>The following is an example to show how to set up a <a class="el" href="struct_g_l_s_l_cinput.html" title="A structure used as input into GLSLC functions. ">GLSLCinput</a> structure to compile a vertex and a fragment shader:</p>
<div class="fragment"><div class="line"><span class="comment">// vsshader_src and fsshader_src are GLSL shader source strings.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> * shaderSources[2] = {vsshader_src, fsshader_src};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> shaderStages[2] = {<a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abdda5a6e5f69e0f338221cc5acf7882a21c7">NVN_SHADER_STAGE_VERTEX</a>, <a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf979f751d1526164abb522c640c8eb06">NVN_SHADER_STAGE_FRAGMENT</a>};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Assume compileObject is a GLSLCcompileObject type previously initialized via glslcInitialize.</span></div>
<div class="line">compileObject.<a class="code" href="struct_g_l_s_l_ccompile_object.html#a1439e7a28e5232e1dc82924e8c4d063d">input</a>.sources = shaderSources;</div>
<div class="line">compileObject.<a class="code" href="struct_g_l_s_l_ccompile_object.html#a1439e7a28e5232e1dc82924e8c4d063d">input</a>.stages = shaderStages;</div>
<div class="line">compileObject.<a class="code" href="struct_g_l_s_l_ccompile_object.html#a1439e7a28e5232e1dc82924e8c4d063d">input</a>.<a class="code" href="struct_g_l_s_l_cinput.html#a2dd94f2657ef155e688d6a9927c6c381">count</a> = 2;</div>
<div class="line"></div>
<div class="line"><span class="comment">// At this point, compileObject is set up with the nessesary GLSL shader sources for compilation.</span></div>
</div><!-- fragment --><h3><a class="anchor" id="nvn_glslc_guide_glslcoptions"></a>
Options</h3>
<p>GLSLC has multiple options to control compilation and also to control what outputs are provided from the compiler to the application. Some examples of options which can be set:</p><ul>
<li>Enable the output of compiler performance statstics.</li>
<li>Perform specialization of uniforms when generating code.</li>
<li>Enable separable compilation (corresponds to ARB_separate_shader_objects)</li>
<li>Set include paths for using include directives inside GLSLC</li>
<li>Enable the output of "thin" GPU binaries.</li>
</ul>
<p>As an example of how to set simple options:</p>
<div class="fragment"><div class="line"><span class="comment">// Assume compileObject was previously set up</span></div>
<div class="line">compileObject.<a class="code" href="struct_g_l_s_l_ccompile_object.html#a6cc042ea5fe41d3aa6c9fac773a447b8">options</a>.<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a class="code" href="struct_g_l_s_l_coption_flags.html#ad57cedc549a410a87a8b5e667afd31b9">outputPerfStats</a> = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *includePaths = {<span class="stringliteral">&quot;C:/include/path/one/&quot;</span>, <span class="stringliteral">&quot;C:/include/path/two&quot;</span>};</div>
<div class="line">compileObject.<a class="code" href="struct_g_l_s_l_ccompile_object.html#a6cc042ea5fe41d3aa6c9fac773a447b8">options</a>.<a class="code" href="struct_g_l_s_l_coptions.html#ab5a776f09115d6e36fd37988abf15530">includeInfo</a>.includePaths = includePaths;</div>
<div class="line">compileObject.<a class="code" href="struct_g_l_s_l_ccompile_object.html#a6cc042ea5fe41d3aa6c9fac773a447b8">options</a>.<a class="code" href="struct_g_l_s_l_coptions.html#ab5a776f09115d6e36fd37988abf15530">includeInfo</a>.<a class="code" href="struct_g_l_s_l_cinclude_info.html#a8e083ff029a90d02e6b48df28eab6fd3">numPaths</a> = 2;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Perform compilation with these options.</span></div>
<div class="line"><a class="code" href="nvn_tool___glslc_interface_8h.html#ad0fd458cbbcd554a1dc81ac61fdcf7e3">glslcCompile</a>(&amp;compileObject);</div>
</div><!-- fragment --><p>For more detailed information about the various options, please see the interface documentation for <a class="el" href="nvn_tool___glslc_interface_8h.html" title="API data type and function definitions for the GLSLC shader compiler tool. ">nvnTool_GlslcInterface.h</a></p>
<blockquote class="doxtable">
<p>Note: The option <a class="el" href="struct_g_l_s_l_coption_flags.html#aec0779a250ad31f6deafe470820ffbb8" title="Output individual program binary sections in the GLSLCoutput. ">GLSLCoptionFlags::outputGpuBinaries</a> is currently required to be enabled. This gets enabled automatically during compile object initialization with glslcInitialize. This restriction is expected to be lifted in future releases. </p>
</blockquote>
<h2><a class="anchor" id="nvn_glslc_guide_glslcoutput"></a>
2.4. Output</h2>
<p>A <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> structure that is returned from glslcCompileShaders is a complete binary of compilation data, including compiled machine code and any other requested information about the compiled code.</p>
<p>The data returned by glslcCompileShaders is a single block of memory with N section headers. Each section header indicates the size of the data and its offset relative to the beginning of the returned <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> structure.</p>
<blockquote class="doxtable">
<p><b>Note</b>: All offsets into individual sections are from the beginning of the <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> structure. </p>
</blockquote>
<p>For example, to obtain access to the block of data corresponding to a <a class="el" href="struct_g_l_s_l_cgpu_code_header.html" title="GPU code section header containing GPU code for an individual shader stage. ">GLSLCgpuCodeHeader</a> structure, the following can be performed:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> * gpuData = NULL;</div>
<div class="line"><span class="keywordtype">char</span> * vertexGpuCode = NULL;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Compile the shaders.  Assume that compileObject is a previously initialized GLSLCcompileObject.</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="nvn_tool___glslc_interface_8h.html#ad0fd458cbbcd554a1dc81ac61fdcf7e3">glslcCompile</a>(&amp;compileObject)) {</div>
<div class="line">    <a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a> * output = compileObject.lastCompiledResults-&gt;glslcOutput;</div>
<div class="line">    <span class="comment">// Loop through the number of sections to look for a vertex GPU program.</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; output-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a6cbb6ec5e8a4ff04512fd1c442aa3d92">numSections</a>; ++i) {</div>
<div class="line">        <span class="comment">// Use the genericHeader when referencing a GLSLC section header of an unknown type.</span></div>
<div class="line">        <a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59">GLSLCsectionTypeEnum</a> type = output-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].genericHeader.common.<a class="code" href="struct_g_l_s_l_csection_header_common.html#a6a8aed7a5a7e82acff908d084fd85e4a">type</a>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Check if the section contains GPU code.</span></div>
<div class="line">        <span class="keywordflow">if</span> (type == <a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59a332c55c4b44004865dda7d54c91df448">GLSLC_SECTION_TYPE_GPU_CODE</a>) {</div>
<div class="line">            <span class="comment">// Check the stage of this.  Reference the gpuCodeHeader type to access the stage.</span></div>
<div class="line">            <a class="code" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage = output-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].gpuCodeHeader.<a class="code" href="struct_g_l_s_l_cgpu_code_header.html#ab1e6be676a326a7281e18ad3a4607ced">stage</a>;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Check if the section corresponds to a vertex program, and if so set it.  This is</span></div>
<div class="line">            <span class="comment">// accomplished by offseting from output by the appropriate offset specified</span></div>
<div class="line">            <span class="comment">// in the section.</span></div>
<div class="line">            <span class="keywordflow">if</span> (stage == <a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abdda5a6e5f69e0f338221cc5acf7882a21c7">NVN_SHADER_STAGE_VERTEX</a>) {</div>
<div class="line">                vertexGpuCode =</div>
<div class="line">                    (<span class="keywordtype">char</span> *)output + output-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].genericHeader.common.<a class="code" href="struct_g_l_s_l_csection_header_common.html#abb6e96b70bad30c94477317328d384d5">dataOffset</a>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// At this point, if vertexGpuCode == NULL, then no vertex GPU code was found in the GLSLCoutput structure.</span></div>
</div><!-- fragment --><p>The application needs to ensure that the <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> is copied out completely to application memory before recompiling with the compile object or calling glslcFinalize on it.</p>
<div class="fragment"><div class="line"><span class="comment">// Assume compileObject is a GLSLCcompileObject type that has been previously set up with</span></div>
<div class="line"><span class="comment">// glslcInitialize.</span></div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="nvn_tool___glslc_interface_8h.html#ad0fd458cbbcd554a1dc81ac61fdcf7e3">glslcCompile</a>(&amp;compileObject)) {</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy out the GLSLCoutput structure.</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a> * compileOutput = compileObject.lastCompiledResults-&gt;glslcOutput;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a> * appMem = (<a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a> *)malloc(compileOutput-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#ac6e8159c6357796e5c51b6eb91f279b7">size</a>);</div>
<div class="line"></div>
<div class="line">    memcpy(appMem, compileOutput, compileOutput-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#ac6e8159c6357796e5c51b6eb91f279b7">size</a>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Now compileObject can be finalized which will clean up internal memory, including the internal</span></div>
<div class="line"><span class="comment">// glslcOutput structure.</span></div>
<div class="line"><a class="code" href="nvn_tool___glslc_interface_8h.html#a05b2032c99f789df2a34ebf32271c320">glslcFinalize</a>(&amp;compileObject)</div>
</div><!-- fragment --><blockquote class="doxtable">
<p><b>Note</b>: The GLSLC binaries are in a "fat" binary format, containing both NX GPU machine code as well as information needed to construct the shader programs internally on non-NX platforms. On non-NX platforms, an intermediate representation of the compiled programs will be used to provide enough information to the internal compiler to reconstruct the program, as long as the GLSLC option "outputThinGpuBinaries" is set to false. On NX platforms, the GPU machine code is loaded into a memory pool by the application and is used directly from the memory pool by the NVN driver. </p>
</blockquote>
<p>The GPU code section (vertexGpuCode in the previous example) corresponds to a binary for one shader stage. This binary contains two sections that can be used to load programs into the NVN API. The GPU program's data section is divided into two separate internal subsections, a control subsection and a data subsection. Each of these components can be obtained by offsetting into the GPU section's data using the variables &lt;controlOffset&gt; and &lt;dataOffset&gt; contained within the <a class="el" href="struct_g_l_s_l_cgpu_code_header.html" title="GPU code section header containing GPU code for an individual shader stage. ">GLSLCgpuCodeHeader</a> structure.</p>
<blockquote class="doxtable">
<p>Note: Offsets specified in data sections are offsets from the beginning of that section's data, not from the beginning of the <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> structure. </p>
</blockquote>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; output-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a6cbb6ec5e8a4ff04512fd1c442aa3d92">numSections</a>; ++i) {</div>
<div class="line">    <span class="comment">// Use the genericHeader when referencing a GLSLC section header of an unknown type.</span></div>
<div class="line">    <a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59">GLSLCsectionTypeEnum</a> type = output-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].genericHeader.common.<a class="code" href="struct_g_l_s_l_csection_header_common.html#a6a8aed7a5a7e82acff908d084fd85e4a">type</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check if the section contains reflection info.</span></div>
<div class="line">    <span class="keywordflow">if</span> (type == <a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59a332c55c4b44004865dda7d54c91df448">GLSLC_SECTION_TYPE_GPU_CODE</a>) {</div>
<div class="line">        <a class="code" href="struct_g_l_s_l_cgpu_code_header.html">GLSLCgpuCodeHeader</a> * gpuSection = &amp;output-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].gpuCodeHeader;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Base data pointer</span></div>
<div class="line">        <span class="keywordtype">void</span> * data = ((<span class="keywordtype">char</span>*)output) + gpuSection-&gt;common.<a class="code" href="struct_g_l_s_l_csection_header_common.html#abb6e96b70bad30c94477317328d384d5">dataOffset</a>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Data subsection for this program.</span></div>
<div class="line">        <span class="keywordtype">void</span> * dataSubSection = NULL;</div>
<div class="line">          </div>
<div class="line">        <span class="comment">// Control subsection for this program.</span></div>
<div class="line">        <span class="keywordtype">void</span> * controlSubSection = NULL;</div>
<div class="line"></div>
<div class="line">        dataSubSection = ((<span class="keywordtype">char</span>*)data) + gpuSection-&gt;<a class="code" href="struct_g_l_s_l_cgpu_code_header.html#aafdececf784595d922fe1b95b06db976">dataOffset</a>;</div>
<div class="line">        controlSubSection = ((<span class="keywordtype">char</span>*)data) + gpuSection-&gt;<a class="code" href="struct_g_l_s_l_cgpu_code_header.html#a3b606fedf8582a1a47162d210e8a1448">controlOffset</a>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// &lt;dataSubSection&gt; now points to the data section whose size is given by gpuSection-&gt;dataSize</span></div>
<div class="line">        <span class="comment">// &lt;controlSubSection&gt; now points to the control section whose size is given by gpuSection-&gt;controlSize</span></div>
<div class="line">        <span class="comment">// The application is free to copy these elsewhere for use later with the NVN API.</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The above &lt;dataSubSection&gt; variable contains the GPU machine code which will be loaded directly into GPU memory for execution. The &lt;controlSubSection&gt; variable contains control information which will be stored in CPU memory and used by NVN to set up the program objects for execution of the &lt;data&gt; section code. These are used in conjunction with nvnProgramSetShaders. Please see the NVN programming guide for more information.</p>
<p>In order to load programs into NVN, the application must use the &lt;data&gt; code and load it up into an <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a>. After the data has been loaded into an <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a>, an <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> for each loaded program needs to be created. The GPU pointer for each program can be obtained by calling nvnBufferGetAddress on the buffer. For more information on working with NVN buffers and memory pools, please see the NVN programming guide.</p>
<h2><a class="anchor" id="nvn_glslc_guide_errorchecking"></a>
2.5. Error Checking</h2>
<p>After an unsuccessful compilation, the info log can be used to obtain error results from the compiler. The info log is part of the structure <a class="el" href="struct_g_l_s_l_ccompilation_status.html" title="Status of the compilation. ">GLSLCcompilationStatus</a>, which is in turn a part of a <a class="el" href="struct_g_l_s_l_cresults.html" title="A section that will contain the results of a compile. ">GLSLCresults</a> structure.</p>
<div class="fragment"><div class="line"><span class="comment">// Assume compileObject was previously set up</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// If the following compilation is unsuccessful, print the info log containing the error.</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="nvn_tool___glslc_interface_8h.html#ad0fd458cbbcd554a1dc81ac61fdcf7e3">glslcCompile</a>(&amp;compileObject) == 0) {</div>
<div class="line">    <span class="comment">// Get the results of the unsuccessful compile.</span></div>
<div class="line">    <a class="code" href="struct_g_l_s_l_cresults.html">GLSLCresults</a> * results = compileObject.lastCompiledResults;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the GLSLCcompilationStatus structure associated with the results.</span></div>
<div class="line">    <a class="code" href="struct_g_l_s_l_ccompilation_status.html">GLSLCcompilationStatus</a> * status = results-&gt;compilationStatus;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain the info log</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *infoLog = status-&gt;infoLog;</div>
<div class="line">    printf(<span class="stringliteral">&quot;Compilation failed!  Info log:\n%s\n&quot;</span>, infoLog);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Compiler errors can occur when compiling each individual shader stage, linking the shader stages together (if not using separable shaders), validating options/inputs, or generating errors from internal issues (such as out of memory).</p>
<h3>Shader Compilation Errors</h3>
<p>Shader compilation errors occur when the compiler fails to compile or to parse the incoming shader source string. Errors for each stage will be output separately. The info log string will indicate which stages the compilation failures correlate with, list descriptive information about the errors, and identify which line numbers the errors occur on.</p>
<p>Below is an example vertex shader which contains a compile error.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 450 core</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    gl_Position = errorvar;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The infolog will contain the following output: </p><pre class="fragment">Vertex shader compilation failed.
Shader info log:
0(5) : error C1008: undefined variable "errorvar"
</pre><p>The line with the "error C1008" string in the above message indicates that an undefined variable error has occurred on line 5 in the main GLSL shader for the vertex stage.</p>
<p>The following example shows the format of individual shader compilation errors: </p><pre class="fragment">&lt;Shader stage&gt; shader compilation failed.
Shader info log:
&lt;file indicator&gt;(&lt;line number&gt;) : error &lt;error code&gt;: &lt;Error message&gt;
</pre><p>&lt;Shader stage&gt; indicates which stage the compilation failures occurred in. If errors occur in multiple shader stage, separate messages will be output for each shader stage as part of the same infolog string.</p>
<p>&lt;file indicator&gt; indicates which shader file the errors occurred in. This value will be "0" unless the error is in a file loaded through the #include directive, in which case &lt;file indicator&gt; will be the file name string.</p>
<p>&lt;line number&gt; indicates which line the error occurs on within the GLSL shader.</p>
<p>&lt;error code&gt; indicates which type of error has occurred (see below).</p>
<p>&lt;error message&gt; is a descriptive string in English indicating what error occurred.</p>
<p>The values for &lt;error code&gt; are as follows:</p>
<p>0 through 149: Preprocessor errors.</p>
<p>150 through 599: Parser errors and GLSL version compatibility errors.</p>
<p>1000 through 5999: GLSL-specific compilation errors.</p>
<p>If the shaders compile successfully, the compiler will then attempt to link the programs together and will output linker errors if any occur.</p>
<p>An example linker error string can be seen with the following example:</p>
<p>Vertex shader: </p><pre class="fragment">#version 450 core

in vec4 errorvar;
void main()
{
    gl_Position = errorvar;
}
</pre><p>Fragment shader: </p><pre class="fragment">#version 450 core

in vec4 incol;
out vec4 outcol;
void main()
{
    outcol = incol;
}
</pre><p>Link error info log: </p><pre class="fragment">Link failed
Link info
---------
error: "incol" not declared as an output from the previous stage
</pre><p>The format for linker errors is: </p><pre class="fragment">Link failed
Link info
---------
error: &lt;error message string&gt;
</pre><p>&lt;error message string&gt; is a descriptive error string in English.</p>
<p>Verification errors or internal errors will simply be emitted in the infolog as descriptive English messages indicating what went wrong. Examples of this type of error would include a failure for GLSLC to allocate internal memory or a validation failure on the input options.</p>
<h1><a class="anchor" id="nvn_glslc_guide_scratchmemory"></a>
3. Scratch Memory</h1>
<p>In addition to the GPU code section, each <a class="el" href="struct_g_l_s_l_cgpu_code_header.html" title="GPU code section header containing GPU code for an individual shader stage. ">GLSLCgpuCodeHeader</a> will also contain the amount of scratch memory needed (if any) by the GPU program. This scratch memory is local memory that needs to be available to the hardware in order to run certain programs and includes the following:</p>
<ul>
<li>Variables spilled to local memory</li>
<li>User-specified local variables that require local memory</li>
<li>Additional local memory required to handle divergence. Divergence handling is required for performance and, in some cases, also for correctness.</li>
</ul>
<p>These variables should be used in conjunction with NVN's nvnCommandBufferSetShaderScratchMemory API function. See the NVN programming guide for more details about how these are used by the API.</p>
<p><a class="el" href="struct_g_l_s_l_cgpu_code_header.html#a804117e2ce22cbcc85316d5d2e8b1c84" title="The amount of local memory (in bytes per warp) required for this program. ">GLSLCgpuCodeHeader::scratchMemBytesPerWarp</a> contains the amount of additional GPU scratch memory, if any, needed per warp. This indicates the amount of scratch memory required to successfully run the application. Failure to set this properly could lead to run-time errors.</p>
<p><a class="el" href="struct_g_l_s_l_cgpu_code_header.html#ac8b1eef84fa9f0debec1874f8b570e62" title="The total amount of local memory recommended for this program on a NX device. ">GLSLCgpuCodeHeader::scratchMemBytesRecommended</a> contains the recommended amount of total GPU scratch memory for NX devices for full performance.</p>
<blockquote class="doxtable">
<p>Note: NVN's debug layer will warn when there is insufficient scratch memory provided to prevent throttling at draw time, and the debug layer will throw an error if there is insufficient scratch memory provided to the driver to prevent running on even 1 SM. Please see the NVN programming guide for more info. </p>
</blockquote>
<p>For more information about the <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> structure, please refer to the documentation for <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a>.</p>
<p>For more information about how scratch memory can be imported into the NVN API, please refer to the NVN programming guide.</p>
<h2><a class="anchor" id="nvn_glslc_guide_error_on_scratch_mem_usage"></a>
3.1. Error on scratch usage</h2>
<p>GLSLC provides an option "errorOnScratchMemUsage", which, when set to true will cause GLSLC to error out if the shader uses any scratch memory to store data. </p><blockquote class="doxtable">
<p>Note: GLSLC will not error out under this option if the only scratch memory used is for handling divergence. </p>
</blockquote>
<h1><a class="anchor" id="nvn_glslc_guide_dataconsistency"></a>
4. Data Consistency</h1>
<p>To help with debugging and error checking, magic numbers have been added to the beginning of all graphics shader data sections. Each type of data section has a unique magic number, and these are defined in the interface header with defines of the format "GLSLC_&lt;SECTION TYPE&gt;_MAGIC_NUMBER". The first 4 bytes of each data section is a magic number corresponding to that expected data section.</p>
<p>Due to data formatting constraints, data sections for compute shaders will not contain a magic number in the first 4 bytes.</p>
<div class="fragment"><div class="line"><span class="comment">// Assume &lt;gpuSection&gt; points to a valid GLSLCgpuCodeHeader object.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Data subsection for this program.</span></div>
<div class="line"><span class="keywordtype">void</span> * dataSubSection = NULL;</div>
<div class="line">  </div>
<div class="line"><span class="comment">// Control subsection for this program.</span></div>
<div class="line"><span class="keywordtype">void</span> * controlSubSection = NULL;</div>
<div class="line"></div>
<div class="line">dataSubSection = ((<span class="keywordtype">char</span>*)data) + gpuSection-&gt;dataOffset;</div>
<div class="line">controlSubSection = ((<span class="keywordtype">char</span>*)data) + gpuSection-&gt;controlOffset;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Assert that the dataSubSection and controlSubSection have the correct data.</span></div>
<div class="line">assert(((<span class="keywordtype">int</span>*)controlSubSection)[0] == <a class="code" href="nvn_tool___glslc_interface_8h.html#ab64e7c0967df12424930441d711dffec">GLSLC_GPU_CODE_SECTION_CONTROL_MAGIC_NUMBER</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// In non-compute shaders, the data section magic number is contained in the first 4 bytes.</span></div>
<div class="line"><span class="keywordflow">if</span> (gpuSection-&gt;stage != <a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddae173bae8c554c2f196ff291335408395">NVN_SHADER_STAGE_COMPUTE</a>) {</div>
<div class="line">    assert(((<span class="keywordtype">int</span>*)dataSubSection)[0] == <a class="code" href="nvn_tool___glslc_interface_8h.html#a72a2b9833d5d9b0b899d0b98e470e710">GLSLC_GPU_CODE_SECTION_DATA_MAGIC_NUMBER</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="nvn_glslc_guide_includesupport"></a>
5. Include Support</h1>
<p>GLSLC supports the option to include files via the standard include preprocessor directive. The files and file names may be encoded in UTF-8. Additionally, include paths can be specified and the compiler will search through these paths to find the included files.</p>
<p>All include support is done through the <a class="el" href="struct_g_l_s_l_cinclude_info.html" title="Options for setting the include search paths. ">GLSLCincludeInfo</a> object that is part of the <a class="el" href="struct_g_l_s_l_coptions.html" title="Options structure to control compilation phase, what gets output in the GLSLCOutput structure...">GLSLCoptions</a> structure.</p>
<div class="fragment"><div class="line"><span class="comment">// Assume compileObject is a previously initialized GLSLCcompileObject</span></div>
<div class="line"><a class="code" href="struct_g_l_s_l_coptions.html">GLSLCoptions</a> * options = &amp;compileObject.<a class="code" href="struct_g_l_s_l_ccompile_object.html#a6cc042ea5fe41d3aa6c9fac773a447b8">options</a>;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">char</span> * includePaths[2] = {</div>
<div class="line">    <span class="stringliteral">&quot;C:\\file\\path1\\&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;C:\\file\\path2&quot;</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Set up the number of paths that are being used as input.</span></div>
<div class="line">uint32_t numPaths = 2;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Assuming a GLSLCoptions structure pointer pointing into a valid GLSLCcompileObject&#39;s options member.</span></div>
<div class="line">options-&gt;<a class="code" href="struct_g_l_s_l_coptions.html#ab5a776f09115d6e36fd37988abf15530">includeInfo</a>.<a class="code" href="struct_g_l_s_l_cinclude_info.html#a8e083ff029a90d02e6b48df28eab6fd3">numPaths</a> = numPaths;</div>
<div class="line">options-&gt;<a class="code" href="struct_g_l_s_l_coptions.html#ab5a776f09115d6e36fd37988abf15530">includeInfo</a>.paths = includePaths;</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>Note: Included files must have EOL markers at the end of the file. </p>
</blockquote>
<h1><a class="anchor" id="nvn_glslc_guide_forceinclude"></a>
6. Compiler Force Include of Standard Headers</h1>
<p>GLSLC supports the inclusion of developer-maintained standard headers with the use of a force #include header option for all shaders. The idea is to allow the developers to enable or disable any default extensions in the standard header that would be used for all shaders, regardless of whether the shaders explicitly enable the option. The shaders can alternatively explicitly disable any extensions that may have been included in the standard header. Additionally, GLSL typically requires the #version directive be the first non-comment entry in a shader if used, but this restriction is relaxed in GLSLC.</p>
<p>As an example of how to use this feature, see the following code segment:</p>
<div class="fragment"><div class="line"><span class="comment">// Assume options is a pointer to a valid GLSLCoptions structure from an initialized GLSLCcompileObject.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> * stdHeader = <span class="stringliteral">&quot;header.h&quot;</span>;</div>
<div class="line"></div>
<div class="line">options-&gt;forceIncludeStdHeader = stdHeader;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Unless the absolute path is provided in forceIncludeStdHeader or the standard header is in the current working directory,</span></div>
<div class="line"><span class="comment">// the application must also define the include path to search for the header file.</span></div>
<div class="line"><span class="keywordtype">char</span> * includePaths[2] = {<span class="stringliteral">&quot;C:/tmp&quot;</span>, <span class="stringliteral">&quot;C:/work&quot;</span>};</div>
<div class="line">options-&gt;<a class="code" href="struct_g_l_s_l_coptions.html#ab5a776f09115d6e36fd37988abf15530">includeInfo</a>.paths = includePaths;</div>
<div class="line">options-&gt;<a class="code" href="struct_g_l_s_l_coptions.html#ab5a776f09115d6e36fd37988abf15530">includeInfo</a>.<a class="code" href="struct_g_l_s_l_cinclude_info.html#a8e083ff029a90d02e6b48df28eab6fd3">numPaths</a> = 2;</div>
</div><!-- fragment --><blockquote class="doxtable">
<p><b>Note</b>: If the file to be included is not found in any of the paths provided or in the current working directory, GLSLC will throw an error. </p>
</blockquote>
<h1><a class="anchor" id="nvn_glslc_guide_versioning"></a>
7. Versioning and Compatibility</h1>
<p>GLSLC has three distinct versions: API version, GPU code section version, and package version.</p>
<h2><a class="anchor" id="nvn_glslc_guide_apiversion"></a>
7.1. API Version</h2>
<p>The API version corresponds to the application's view of the GLSLC interface as defined in nvnTools_GlslcInterface.h. The version reflects the data structures and functions exported from the DLL.</p>
<h3>Major Version</h3>
<p>The Major version indicates application compatibility with the GLSLC binary. If a major version changes between releases, this means that the application code using the GLSLC interface may need to be modified. Using an application which compiles in a different API version of the interface than the DLL binary it's using may lead to errors.</p>
<h3>Minor Version</h3>
<p>The minor version indicates API features or additions which would not break compatibility with applications using an interface with the same major version. For example, applications which compile in the nvnTools_GlslcInterface.h at version x.y are expected to work with GLSLC DLLs built to version x.z, where y &lt; z. On the other hand, applications building an a newer minor versioned GLSLC interface should not be expected to work with DLLs with a lower minor version number.</p>
<h2><a class="anchor" id="nvn_glslc_guide_sec_7_2"></a>
7.2. GPU code version</h2>
<p>This version reflects the data section of the GPU code subsection of the <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a>, which is the section NVN uses for input shader programs.</p>
<h3>Major Version</h3>
<p>The major version indicates binary compatibility with NVN. If the major version is not supported with NVN, then the driver will reject such binaries.</p>
<h3>Minor Version</h3>
<p>The minor version indicates features to the GLSLC binary which don't break compatibility with NVN. For instance, a driver could accept GLSLC gpu code version 1.0 through 1.8. Any binary with a minor version 0 through 8 would be accepted and processed by NVN.</p>
<h2><a class="anchor" id="nvn_glslc_guide_sec_7_3"></a>
7.3. Querying driver support</h2>
<p>NVN has 4 device properties which can be queried to determine which versions of GLSLC gpu code it supports: </p><pre class="fragment">NVN_DEVICE_INFO_GLSLC_MAX_SUPPORTED_GPU_CODE_MAJOR_VERSION
NVN_DEVICE_INFO_GLSLC_MIN_SUPPORTED_GPU_CODE_MAJOR_VERSION
NVN_DEVICE_INFO_GLSLC_MAX_SUPPORTED_GPU_CODE_MINOR_VERSION
NVN_DEVICE_INFO_GLSLC_MIN_SUPPORTED_GPU_CODE_MINOR_VERSION
</pre><p>See the NVN programming guide for how to query device properties.</p>
<h2><a class="anchor" id="nvn_glslc_guide_sec_7_4"></a>
7.4. Package Version</h2>
<p>This version reflects the overall version of GLSLC for each release.</p>
<h2><a class="anchor" id="nvn_glslc_guide_sec_7_5"></a>
7.5. Obtaining the version from the GLSLC DLL</h2>
<p>In order to query the version of the GLSLC DLL being used, starting with GLSLC version 6.1, a function glslcGetVersion has been exported from the DLL.</p>
<p>As an example on how to use in C code:</p>
<div class="fragment"><div class="line"><a class="code" href="struct_g_l_s_l_cversion.html">GLSLCversion</a> versionInfo;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Version info contains the API, gpu code, and package versions.</span></div>
<div class="line">versionInfo = <a class="code" href="nvn_tool___glslc_interface_8h.html#a9e9385a1667fb5642494cb2916b7b91c">glslcGetVersion</a>();</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (versionInfo.<a class="code" href="struct_g_l_s_l_cversion.html#a6c5169beb9f2ec70db8961c1d0c6084a">apiMajor</a> &gt;= 13)</div>
<div class="line">    ...</div>
<div class="line">else</div>
<div class="line">    ...</div>
</div><!-- fragment --><h1><a class="anchor" id="nvn_glslc_guide_macros"></a>
8. Predefined GLSLC macros</h1>
<p>GLSLC provides a few predefined version macros which can be used in GLSL shaders: </p><pre class="fragment">__GLSLC_VER_MAJOR
__GLSLC_VER_MINOR
</pre><p>These version macros will always correspond to the GLSLC version.</p>
<p>Sample usage of pre-defined macros in GLSL sources:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 440</span></div>
<div class="line">in vec3 ocolor;</div>
<div class="line">out vec4 fcolor;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">    #if __GLSLC_VER_MAJOR &lt;= 6</span></div>
<div class="line">        ...</div>
<div class="line">    #<span class="keywordflow">else</span></div>
<div class="line">        <span class="comment">// use feature available only from version 7 and above</span></div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line"><span class="preprocessor">}</span></div>
</div><!-- fragment --><h1><a class="anchor" id="nvn_glslc_guide_performance_stats"></a>
9. Compiler Performance Statistics</h1>
<p>Compiler produces the following performance statistics when invoked with the compiler option "outputPerfStats".</p>
<ol type="1">
<li>latency : Estimated latency of shader. Lower is better. Inaccurate in the presence of loops with dynamic bounds, branches and variable latency instructions. Rule of thumb: If latency &gt; 10 * numInsts, the shader is likely latency bottlenecked.</li>
<li>Spill local memory info: Lower is generally better. Can be reduced by using the spillControl knob. However, reducing spills can hurt occupancy.<ul>
<li>numLmemSpillBytes : Amount of local memory written due to spills in the shader considering estimated spill execution count.</li>
<li>numLmemRefillBytes : Amount of local memory read due to refills in the shader considering estimated refill execution count.</li>
<li>numSmemSpillBytes : Amount of shared memory written due to spills in the shader considering estimated spill execution count.</li>
<li>numSmemRefillBytes : Amount of shared memory read due to refills in the shader considering estimated refill execution count.</li>
<li>size: Amount of spill memory used in the shader.</li>
</ul>
</li>
<li><p class="startli">Non spill local memory info: Lower is better. This may require source level changes in some cases where the compiler is unable to promote local memory accesses to registers, such as in the case of local arrays with dynamically indexed accesses.</p><ul>
<li>storeBytes: Amount of local memory written by stores other than spill stores in the shader considering estimated store execution count.</li>
<li>loadBytes: Amount of local memory read by loads other than refill loads in the shader considering estimated load execution count.</li>
<li>size: Amount of local memory used in the shader not including extra memory required for divergence handling.</li>
</ul>
<p class="startli">&gt; Note: Local memory in the absence of spills could come from local variables used in the shader. Here's a sample shader with lmem usage:</p>
</li>
</ol>
<div class="fragment"><div class="line"><span class="preprocessor">#version 440</span></div>
<div class="line">in vec3 ocolor;</div>
<div class="line">out vec4 fcolor;</div>
<div class="line"></div>
<div class="line">uniform Block {</div>
<div class="line">                <span class="keywordtype">float</span> n;</div>
<div class="line">            };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> local_array[100];</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = 0; ii &lt; n; ii *= 2)</div>
<div class="line">        fcolor.x += local_array[ii];</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>occupancy: Ratio of active warps to maximum number of warps supported by the GPU. Maximum number of warps supported by NX is 128 And number of active warps for NX can be computed as <pre>
    min(128, 4 ×floor(512/roundUpToMultipleOf8(registers used by the shader)))
    </pre> Note that higher is better.</li>
<li>numDivergentBranches : Number of divergent branches in the shader considering branch execution count.<ul>
<li>Lower is better.</li>
<li>Divergence also adds to the final local memory requirement of the shader program as reported in the GPU code section by GLSLC.</li>
</ul>
</li>
<li>attributeMemUsage : Amount of attribute memory used by shader for input, output attributes. Lower is better. In order to reduce attribute memory usage, the application developer should try and group all attribute reads in the beginning of the shader and all attribute writes after the reads. This ensures that the attribute memory buffer can be reused. This is an optimization that the compiler attempts but it has certain limitations in programs with branches.</li>
<li>programSize: Size of the shader executable micro code. Lower is better.</li>
<li>loop unroll data: Compiler dumps the number of partially unrolled and non-unrolled loops in the program at the end of compilation.<ul>
<li>partially unrolled: the compiler was unable to fully unroll a loop but unrolled it by some factor for optimization purposes.</li>
<li>non-unrolled: the compiler was unable to unroll the loop fully or partially.</li>
</ul>
</li>
<li>throughput limiters: Compiler dumps the following through put limiter values in <em>warps/clock</em>. Higher value is better.<ul>
<li>issue : Instruction issue limited throughput</li>
<li>fp : Single precision floating point operation limited throughput</li>
<li>half : half operation limited throughput</li>
<li>trancedental : Transcendental, Conversion operation limited throughput</li>
<li>ipa : Attribute interpolation limited throughput</li>
<li>shared : Attribute load/store, shared memory load/store limited throughput</li>
<li>controlFlow : Control flow operation limited throughput</li>
<li>texLoadStore : texture fetch, global/local load/store limited throughput</li>
<li>reg : register limited throughput</li>
<li>warp : warp id limited throughput</li>
<li>sharedMemResource : Shared memory limited throughput</li>
</ul>
</li>
<li>Percentage of FP16 instructions vectorized. Higher is better. This is computed as <pre>
        ((numFP16VectorInstructions*2)/(numFP16Mathops))*100
</pre> Instruction issue limiters are computed as <pre>
    numSubPartitionsInSM / numIssueGroupsPerWarp
</pre></li>
</ol>
<p>Function unit limiters (fp, half, trancedental, ipa, shared, controlFlow, texLoadStore) for resource <em>i</em> is computed as </p><pre>
    (numFunctionalUnits_i×1/repeatRate_i)/numOpsUsingUnit_i
</pre><p>Shared resource limiters(reg, warp) for resource <em>i</em> is computed as </p><pre>
    maxResourcesPerSM_i/(resourcePerWarp_i × shaderLatency)
</pre><p> The Total Shared memory available in NX is 64KB, the maximum number of CTAs that can be launched is 32 and the maximum number of compute warps supported is 64. Shared memory limiter is then computed as </p><pre>
    numLaunchedCtas = min(32, 64/numWarpsPerCta, 65536/totalSMemUsedPerCTA) 
    sharedMemoryLimitedThroughput = (numLaunchedCtas * numWarpsPerCta)/shaderLatency
</pre><h2><a class="anchor" id="nvn_glslc_guide_sec_9_1"></a>
9.1. Use of the DLL interface for perf statistics.</h2>
<p>The perf statistics are obtained by setting the outputPerfStats option in the <a class="el" href="struct_g_l_s_l_coptions.html" title="Options structure to control compilation phase, what gets output in the GLSLCOutput structure...">GLSLCoptions</a> structure before compilation. After compilation, <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> will contain a separate section with the type of GLSLC_SECTION_TYPE_PERF_STATS. The corresponding data section will contain a <a class="el" href="struct_g_l_s_l_cperf_stats_data.html" title="Data containing the perf statistics returned from GLSLC. ">GLSLCperfStatsData</a> structure which contains all of the perf statistics available.</p>
<p>An example of obtaining these statistics:</p>
<div class="fragment"><div class="line"><span class="comment">// Assume compile object has been previously initialized.</span></div>
<div class="line">compileObject.<a class="code" href="struct_g_l_s_l_ccompile_object.html#a6cc042ea5fe41d3aa6c9fac773a447b8">options</a>-&gt;outputPerfStats = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Compile and obtain the perf statistics.</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="nvn_tool___glslc_interface_8h.html#ad0fd458cbbcd554a1dc81ac61fdcf7e3">glslcCompile</a>(&amp;compileObject)) {</div>
<div class="line">    <a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a> * output = compileObject.lastCompiledResults-&gt;glslcOutput;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Loop through the number of sections to look for a GPU program.  The GPU section</span></div>
<div class="line">    <span class="comment">// contains the index into the associated perf statistics section for that program.</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; output-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a6cbb6ec5e8a4ff04512fd1c442aa3d92">numSections</a>; ++i) {</div>
<div class="line">        <span class="comment">// Use the genericHeader when referencing a GLSLC section header of an unknown type.</span></div>
<div class="line">        <a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59">GLSLCsectionTypeEnum</a> type = output-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].genericHeader.common.<a class="code" href="struct_g_l_s_l_csection_header_common.html#a6a8aed7a5a7e82acff908d084fd85e4a">type</a>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Check if the section contains a perf statistics section (only if requested).</span></div>
<div class="line">        <span class="keywordflow">if</span> (type == <a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59a332c55c4b44004865dda7d54c91df448">GLSLC_SECTION_TYPE_GPU_CODE</a>) {</div>
<div class="line">            <span class="comment">// Perf statistics have their own section, and each GPU code section contains an index</span></div>
<div class="line">            <span class="comment">// corresponding to that section.</span></div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_cgpu_code_header.html">GLSLCgpuCodeHeader</a> * gpuHeader = &amp;(output-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].gpuCodeHeader);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// The perfStatsSectionNdx is the ndx of the perfstats section inside the GLSLCoutput structure.</span></div>
<div class="line">            <span class="keywordtype">int</span> perfStatsSectionNdx = gpuHeader-&gt;<a class="code" href="struct_g_l_s_l_cgpu_code_header.html#a210237850b30911ca52acf10d628bc0e">perfStatsSectionNdx</a>;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// The perf stats section ndx will never be 0.</span></div>
<div class="line">            <span class="keywordflow">if</span> (perfStatsSectionNdx != 0) {</div>
<div class="line">                <span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_cperf_stats_header.html">GLSLCperfStatsHeader</a> * perfStatsSection =</div>
<div class="line">                    &amp;(output-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[perfStatsSectionNdx].perfStatsHeader);</div>
<div class="line"></div>
<div class="line">                <span class="comment">// The data offset is from the beginning of the GLSLCoutput structure.</span></div>
<div class="line">                <span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_cperf_stats_data.html">GLSLCperfStatsData</a> * perfStatsData =</div>
<div class="line">                    (<span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_cperf_stats_data.html">GLSLCperfStatsData</a> *)((<span class="keyword">const</span> <span class="keywordtype">char</span>*)output + perfStatsSection-&gt;common.<a class="code" href="struct_g_l_s_l_csection_header_common.html#abb6e96b70bad30c94477317328d384d5">dataOffset</a>);</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Print out latency</span></div>
<div class="line">                printf(<span class="stringliteral">&quot;Latency: %d\n&quot;</span>, perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#aeba2f57d7a5786cfac325cd5ea99250c">latency</a>);</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Handle other perf statistics here.</span></div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="nvn_glslc_guide_sec_9_2"></a>
9.2. Perf Statistics Usage Model</h2>
<ul>
<li>The performance statistics are intended to be used to identify performance bottlenecks with a given shader.</li>
<li>The performance statistics are intended to be used as a comparative tool for identifying goodness of a shader compared to other variant of the same shader or a different shader. For example,<ul>
<li>User can compare the occupancy of 2 variations of the same shader and can chose the one with better occupancy</li>
<li>User can compare the throughout limiters values for a given shader, identify critical bottleneck and take appropriate action to remove the bottleneck. For instance if the FP limited throughput value is lesser than all other throughput limiters then user can do shader changes to reduce the FP work load if possible.<ul>
<li>A shader variant spilling/refilling to/from shared memory is better than the shader spilling/refilling to/from local memory as the cost of shared memory load/store lower comparatively.<ul>
<li>To get the number of local spills divide the numLmemSpillBytes by 4. Do the similar math for getting number of refills, local loads and local stores.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>While the recommendation is to look at the top bottleneck, because of the limitations of static performance estimation, it is generally beneficial to try and improve the top 3-4 bottlenecks.</li>
<li>Certain perf stats can be considered more important than others. In general, latency, occupancy and texLoadStore throughput generally have a higher impact on performance than perf stats such as shared throughput, control flow throughput, transcendental throughput, and attribute memory usage, which are rarely bottlenecks.</li>
<li>Some perf stats also affect certain shader stages more. For instance, while occupancy is very important for pixel and compute shaders, other shader stages such as vertex, geometry and tessellation don’t benefit as much from higher occupancy and it is usually better to use a higher register target that prevents spilling.</li>
<li>Furthermore, application properties may affect the relative priority of various perf stats. For instance, an application that requires few threads may benefit from the use of more registers to improve latency at the cost of occupancy. Conversely, an application may require a higher number of warps, indicating that increased latency and spills may be beneficial for performance if it helps occupancy. Additionally, applications that are bottlenecked on memory throughput may not gain from optimizations to reduce the number of instructions, and applications that are bottlenecked on pixel shaders may not gain from improving bottlenecks in vertex shaders.</li>
</ul>
<h2><a class="anchor" id="nvn_glslc_guide_sec_9_3"></a>
9.3. Perf stats Limitations</h2>
<ul>
<li>The performance statistics are indicative of run time performance but subject to limitations of static analysis. The formulas to compute these statistics may change as the compiler evolves.<ul>
<li>For instance compiler uses the estimated loop iteration count to compute the latency when the loop has unknown bounds. This estimated loop iteration count may or may not actually match the real iteration count.</li>
<li>Similarly, Compiler uses assumed latencies for variable latency operations. This can cause the real shader latency to vary from the estimated latency.</li>
<li>In general, the following conditions affect the reliability of certain performance statistics:<ul>
<li>Divergence, branches</li>
<li>Loop unrolling</li>
<li>Presence of variable latency instructions such as memory accesses</li>
</ul>
</li>
</ul>
</li>
<li>Looking at a single performance stat in isolation may not give the whole picture of the performance impact. For example, reducing the number of registers to improve occupancy is good in general but if that increases the latency or number of spills then that may adversely affect performance.<ul>
<li>Possible interdependencies:<ul>
<li>Increased occupancy may hurt latency (and vice versa)</li>
<li>Improved loop unrolling affects instruction count and latency, specifically, static latency may increase while dynamic latency may actually improve</li>
<li>Increased occupancy may also increase the number of spills/refills and affect texLoadStore throughput, and vice versa</li>
<li>Improved fp16 vectorization could, in some rare cases, impact the number of F2F instructions and therefore affect fp throughput</li>
</ul>
</li>
</ul>
</li>
<li>Statistics are generated while generating microcode from GLSLC. So the compilations that don't generate microcode will not generate these statistics.</li>
<li>Currently, throughput limiters are not supported for the following units and will be added as an extension if required:<ul>
<li>integer</li>
<li>logical</li>
<li>double</li>
</ul>
</li>
<li>With optimizations disabled, the following performance statistics are invalid:<ul>
<li>Latency</li>
<li>Reg throughput</li>
<li>Warp throughput</li>
</ul>
</li>
<li>Performance statistics are not supported in the presence of shader subroutines. If performance statistics are requested for programs using subroutines, the program will be compiled, but a warning will be emitted by GLSLC, and no perf stats section will be part of the GLSLC output.</li>
</ul>
<h1><a class="anchor" id="nvn_glslc_guide_register_spill_control"></a>
10. Register Spill Control</h1>
<p>GLSLC provides an option "spillControl" used to enable/disable spilling on NX platforms. The option has two settings:</p><ul>
<li>DEFAULT_SPILL: This is the default setting and permits the compiler to spill if required.</li>
<li>NO_SPILL: This disables spilling in the compiler. If the compiler is unable to allocate registers to the program without spills, compilation fails with the message "Could not meet spill constraints.".</li>
</ul>
<p>Example usage:</p>
<div class="fragment"><div class="line"><span class="comment">// Disable spilling in compiler.</span></div>
<div class="line">compileOptions.options.optionFlags.spillControl = <a class="code" href="nvn_tool___glslc_interface_8h.html#ae15c8aabee0d9fca45d4f92a5a972806a815d12a81f4716f95b52101406d6cdae">NO_SPILL</a>;</div>
</div><!-- fragment --><ul>
<li>Note:<ul>
<li>NO_SPILL is not supported on non-NX platforms and will be ignored.</li>
<li>Disabling spills could be bad for perf as the compiler will try and avoid spills by changing register usage which could have a negative impact on occupancy.</li>
<li>Disabling spills may also affect shaders which did not contain spills by default.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="nvn_glslc_guide_prioritize_consecutive_texture_instructions"></a>
11. Prioritize Consecutive Texture Instructions</h1>
<p>GLSLC provides an option, <a class="el" href="struct_g_l_s_l_coption_flags.html#a3dd4c4bf3bec3f5a51626cb78775190a" title="Optimize texture batches for intra-warp cache locality in compute shaders. ">GLSLCoptionFlags::prioritizeConsecutiveTextureInstructions</a>, to optimize texture batches. When this option is set, the compiler prevents insertion of non-texture instructions within a batch and allows a warp to execute all textures within the batch before yielding. This is expected to improve compute workloads which exhibit high intra-warp texture cache locality such as reduction filters and blurs.</p>
<ul>
<li>Limitations:<ul>
<li>This option applies to compute and fragment shaders.</li>
<li>Because this relies on runtime caching behavior, it may not always be beneficial.</li>
<li>For shaders with high inter-warp cache locality, this option may result in worse performance.</li>
<li>This optimization may also result in an increase in register pressure, which could hurt performance.</li>
<li>For fragment shaders, this option comes with the potential for an additional increase in latency.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="nvn_glslc_guide_sec_12"></a>
12. Vertex Culling Optimizations</h1>
<p>GLSLC has options to enable two vertex shader optimizations described below:</p>
<p><a href="#nvn_glslc_guide_warpculling">Vertex Warp Culling</a></p>
<p><a href="#nvn_glslc_guide_cbf">Cull-Before-Fetch</a></p>
<h2><a class="anchor" id="nvn_glslc_guide_warpculling"></a>
12.1. Vertex Warp Culling</h2>
<p>Vertex Warp culling is a hardware optimization which enables high throughput, opportunistic frustum culling by adding frustum-check-and-cull code to vertex shaders. It is opportunistic because all vertices in a warp need to be cullable for the batch to be considered cullable, otherwise no culling occurs.</p>
<p>This can improve performance in workloads where a lot of vertices fall outside the viewing frustum by:</p><ol type="1">
<li>avoiding lower throughput fixed function culling</li>
<li>lowering vertex shader latency by dynamically avoiding non-position output attribute generation and store operations whenever culling occurs.</li>
</ol>
<p>The performance overhead of the frustum check code in vertex shaders is negligible; the drawback is that the size of the compiled vertex shader will increase. If applications are not concerned with the size of the vertex shader binaries, it is recommended to enable the option.</p>
<p>To enable: Set the GLSLCoptions::enableWarpCulling flag to 1</p>
<blockquote class="doxtable">
<p><b>NOTE:</b> Warp Culling cannot be used together with <a href="#nvn_glslc_guide_cbf">Cull-Before-Fetch</a>. </p>
</blockquote>
<h2><a class="anchor" id="nvn_glslc_guide_cbf"></a>
12.2. Cull-Before-Fetch</h2>
<p>Cull-Before-Fetch (CBF) is a hardware optimization which allows the application to improve performance in workloads limited by vertex attribute fetches.</p>
<p>CBF generates two versions of the shader: an A and a B version. The driver will setup the hardware to run each version with the following rules:</p>
<ul>
<li>vertexA will only fetch the position attribute, and if the vertex is not visible it will bail out early, reducing the need for fetching other vertex attributes. If the primitive is visible it will go ahead and run vertexB next.</li>
<li>vertexB will contain code only for non-position output attributes.</li>
</ul>
<p>CBF is helpful when both of the following apply:</p>
<ol type="1">
<li>Significant number of vertices outside the viewing frustum.</li>
<li>Significant number of attributes per vertex.</li>
</ol>
<p>CBF occurs at the warp granularity, similar to <a href="#nvn_glslc_guide_warpculling">Vertex Warp Culling</a>. Only if all vertices of vertexA are cullable will vertexB be disabled for a warp.</p>
<p>CBF should be used carefully because it can significantly decrease performance when the two scenarios above do not apply, since we end up running the vertex shader twice (vertexA followed by vertexB).</p>
<p>To enable: Set the GLSLCoptions::enableCBF flag to 1</p>
<blockquote class="doxtable">
<p><b>NOTE:</b> Even though versions of the vertex shader are being compiled, the application will still see only one data and control section for a vertex shader. </p>
</blockquote>
<blockquote class="doxtable">
<p><b>NOTE:</b> CBF cannot be used together with <a href="#nvn_guide_warpculling">Vertex Warp Culling</a>. </p>
</blockquote>
<h1><a class="anchor" id="nvn_glslc_guide_sec_13"></a>
13. Floating-Point Math Rules</h1>
<p>NX supports most IEEE-754 single precision floating-point math rules and will produce infinity (+/- INF) and not-a-number (NaN) encodings in case of overflows and illegal floating-point operations respectively. No support is provided for floating-point exceptions or signaling NaNs. The results of floating-point arithmetic operations that produce extremely small "denormalized" values may be flushed to zero.</p>
<h2><a class="anchor" id="nvn_glslc_guide_sec_13_1"></a>
13.1. Implementation of pow(a, b)</h2>
<p>When either a or b are non-constant, non-literal values, the GLSL function pow(a,b) is implemented as 2^(b * log_2(abs(a))).</p>
<p>When both a and b are literal values, or if the compiler can replace both a and b with literal values during compilation, pow(a,b) is implemented as 2^(b * log_2(a)) and will produce NaN if a is negative.</p>
<p>In both cases, NaN will be produced if a==b==0</p>
<blockquote class="doxtable">
<p><b>NOTE:</b> GLSLC prior to package version 47 implemented all cases of pow(a,b) as 2^(b * log_2(a)) without taking the absolute value of a. </p>
</blockquote>
<h2><a class="anchor" id="nvn_glslc_guide_fastmath"></a>
13.2. Fast math</h2>
<p>Fast math includes optimizations on floating point operations which can improve performance but may not be IEEE compliant, such as reassociation and constant folding. The <a class="el" href="struct_g_l_s_l_coption_flags.html" title="Option flags that control compilation and GLSLC output. ">GLSLCoptionFlags</a> structure contains entries for enabling fast math for each shader stage. The defaults for fast math optimizations set by glslcGetDefaultOptions is different depending on the stage of the program. Fast math is enabled by default across stages but some aggressive optimizations are currently applied to only fragment shader as of today. In general, the kind of optimizations done when fastmath is enabled might change with future releases of compiler. If a shader is precision sensitive, especially vertex/geometry/tessellation shaders where a small precision diff can lead to image large differences, the user is advised to explicitly disable fast math.</p>
<h1><a class="anchor" id="nvn_glslc_guide_shader_reflection"></a>
14. Shader reflection</h1>
<p>GLSLC supports the ability to examine program variables, similar to OpenGL's program interface query support. A reflection section is available in the GLSLC output if requested via the GLSLCoption flag GLSLCoption::outputShaderReflection. The reflection section is always available as part of the GLSLCcompileObject::reflectionSection member. This is to allow applications that might not want to store the reflection info inside the serialized output but may still want to use it for other purposes. The GLSLCcompileObject::reflectionSection will be cleaned up during a call to GLSLCfinalize.</p>
<p>GLSLC currently has the ability to report information about uniforms, uniform blocks, program inputs and outputs, SSBOs, buffer variables, and transform feedback varyings. For a more full-featured example of how to use this feature, please see the GLSLC samples.</p>
<blockquote class="doxtable">
<p><b>Note</b>: Offsets specified in the header (such as <a class="el" href="struct_g_l_s_l_cprogram_reflection_header.html#a23a3fcd75086c2b537f992e212661622" title="Offset into data section for the string pool data. ">GLSLCprogramReflectionHeader::stringPoolOffset</a>) are relative to the data section, not the <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> section. </p>
</blockquote>
<p>An example snippit of code enumerating all uniform blocks in a compiled program:</p>
<div class="fragment"><div class="line"><span class="comment">// Request a reflection section.</span></div>
<div class="line">compileOptions.options.optionFlags.outputShaderReflection = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Compile the shaders.  Assume that compileObject is a previously initialized GLSLCcompileObject.</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="nvn_tool___glslc_interface_8h.html#ad0fd458cbbcd554a1dc81ac61fdcf7e3">glslcCompile</a>(&amp;compileObject)) {</div>
<div class="line">    <a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a> * output = compileObject.lastCompiledResults-&gt;glslcOutput;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Loop through the number of sections to look for a shader reflection section</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; output-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a6cbb6ec5e8a4ff04512fd1c442aa3d92">numSections</a>; ++i) {</div>
<div class="line">        <span class="comment">// Use the genericHeader when referencing a GLSLC section header of an unknown type.</span></div>
<div class="line">        <a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59">GLSLCsectionTypeEnum</a> type = output-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].genericHeader.common.<a class="code" href="struct_g_l_s_l_csection_header_common.html#a6a8aed7a5a7e82acff908d084fd85e4a">type</a>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Check if the section contains GPU code.</span></div>
<div class="line">        <span class="keywordflow">if</span> (type == <a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59a9af0dfcdde630017c24029fa35ed8849">GLSLC_SECTION_TYPE_REFLECTION</a>) {</div>
<div class="line">            <span class="keywordtype">void</span> * data = ((<span class="keywordtype">char</span> *)output) + (output-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].genericHeader.common.<a class="code" href="struct_g_l_s_l_csection_header_common.html#abb6e96b70bad30c94477317328d384d5">dataOffset</a>);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Get the reflection header</span></div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html">GLSLCprogramReflectionHeader</a> * reflectionHeader =</div>
<div class="line">                &amp;(output-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].programReflectionHeader);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// The string pool is a section of the data containing strings used for the name</span></div>
<div class="line">            <span class="comment">// entries for each variable.</span></div>
<div class="line">            <span class="comment">// NOTE: reflectionHeader-&gt;stringPoolOffset is an offset from the beginning of the data section,</span></div>
<div class="line">            <span class="comment">// not the GLSLCoutput section.</span></div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">char</span> *stringPool = (<span class="keyword">const</span> <span class="keywordtype">char</span>*)data + reflectionHeader-&gt;<a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a23a3fcd75086c2b537f992e212661622">stringPoolOffset</a>;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Offset into the uniform block portion of the data and get a pointer to the first block.</span></div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_cuniform_block_info.html">GLSLCuniformBlockInfo</a> * uniformBlock =</div>
<div class="line">                (<a class="code" href="struct_g_l_s_l_cuniform_block_info.html">GLSLCuniformBlockInfo</a> *)((<span class="keywordtype">char</span> *)data + reflectionHeader-&gt;<a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#ab7239cf2349bda4632d8382ffddcde85">uniformBlockOffset</a>);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Print the uniform block information for each block.</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; reflectionHeader-&gt;<a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a006944206bfbf2bbfb56c1dfb9dc7f96">numUniformBlocks</a>; ++j) {</div>
<div class="line">                printf(<span class="stringliteral">&quot;Information for uniform block %d:\n&quot;</span>, j);</div>
<div class="line">                printf(<span class="stringliteral">&quot;    Name: %s\n&quot;</span>, stringPool + uniformBlock-&gt;nameInfo.nameOffset);</div>
<div class="line">                printf(<span class="stringliteral">&quot;    Size: %d\n&quot;</span>, uniformBlock-&gt;size);</div>
<div class="line">                printf(<span class="stringliteral">&quot;    Num active variables in block: %d\n&quot;</span>, uniformBlock-&gt;numActiveVariables);</div>
<div class="line">                printf(<span class="stringliteral">&quot;    Stages block is referenced in (mask): 0%08x\n&quot;</span>, uniformBlock-&gt;stagesReferencedIn);</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jj = 0; jj &lt; GLSLC_NUM_SHADER_STAGES; ++jj) {</div>
<div class="line">                    printf(<span class="stringliteral">&quot;    Binding in stage %d: %d\n&quot;</span>, jj, uniformBlock-&gt;bindings[jj]); </div>
<div class="line">                }</div>
<div class="line">                <span class="comment">// Increment to the next uniform block.</span></div>
<div class="line">                uniformBlock++;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="nvn_glslc_glsl_differences"></a>
15. GLSL Differences</h1>
<p>GLSLC accepts a modified form of GLSL as input. GLSL up to 4.5 is supported. Some GLSL features are different than from the official specification due to NVN API restrictions and design considerations. The following is a list of these modifications:</p>
<ul>
<li>Uniforms outside of UBOs are not allowed, except for uniforms of image and sampler types.</li>
<li>Per-stage binding is allowed on UBOs, SSBOs, and uniforms of sampler and image types. See the <a href="#nvn_glslc_guide_uniforms">section on uniforms and bindings</a> for more information.</li>
<li>Limits on maximum bindings of UBOs, SSBOs, samplers and images in a single shader stage only apply to resources that are actually used and active in the shader. The "gl_Max*" GLSL constant built-ins will return the maximum limit on <em>declarations</em>, which will typically be very large, but the NVN API defines the actual limit on the number of UBOs, SSBOs, images and samplers that can be used in a single shader stage. The limit on <em>active</em> resources for a particular type should be queried through NVN's device properties. See the <a href="#nvn_glslc_guide_uniforms">section on uniforms and bindings</a> for more information on binding behavior.</li>
<li>The STD430 layout is allowed for UBOs.</li>
<li>GLSLC pre-defines macros (see the <a href="#nvn_glslc_guide_macros">section on macros</a> for more information).</li>
<li>GLSLC supports a GLSLC-only extension NV_desktop_lowp_mediump (see <a href="#nvn_glslc_fp16">the FP16 section</a> for more information).</li>
<li>The built-in gl_DepthRange is currently not supported, and will result in an error if used.</li>
<li>Pragmas for controlling GLSLC optimizations and compile options from within the shader.</li>
<li>Atomic counters based on atomic_uint are not supported. This implies the functionality provided by the specifications ARB_shader_atomic_counters and ARB_shader_atomic_counter_ops are not supported. Please see the NVN programming guide to determine what hardware support is required for NV_shader_atomic_int64 (and related extensions) functionality.</li>
</ul>
<h2><a class="anchor" id="nvn_glslc_guide_uniforms"></a>
15.1. Uniforms</h2>
<p>Regular uniforms (uniforms that are not part of an uniform block) are not supported by nvn except for image/sample variables. For uniform blocks and shader storage blocks, NVN follows the layout rules described in "ARB_uniform_buffer_object" with MAX_UNIFORM_BUFFER_BINDINGS set to 14. There are a few fundamental differences in how bindings are assigned to resources though, as detailed in the following section.</p>
<h3>Binding Behavior</h3>
<p>NVN supports per-stage bindings with respect to uniform blocks (UBOs) and shader storage buffers (SSBOs). Per-stage bindings mean that shader resources (images, textures, UBOs, SSBOs) can be assigned different bindings in each shader stage, either explicitly through the use of layout qualifiers, or implicitly by the compiler when no such layout qualifiers are used. Additionally, resources which are unused in shader stages will not be assigned bindings for those stages, even if the same block is used in other shader stages.</p>
<blockquote class="doxtable">
<p><b>Note</b>: It is the application's responsibility to always query the reflection information to determine if a resource is used/unused by a certain shader stage before binding. This is denoted in the variable <a class="el" href="struct_g_l_s_l_cuniform_block_info.html#a449b0310144f865d20c9152228c1f5c2" title="Stage mask representing which stages this variable is active in. ">GLSLCuniformBlockInfo::stagesReferencedIn</a>, and a "-1" for the per-stage binding entry in <a class="el" href="struct_g_l_s_l_cuniform_block_info.html#a3089f78f6431b069fca45643190b8f88" title="Bindings associated with this block in each shader stage, where array index n corresponds to NVNshade...">GLSLCuniformBlockInfo::bindings</a>. If the application wishes to assign resources to a known binding slot in order to not use reflection information at run-time, then explicit layout (binding) qualifiers in the shader will be required. </p>
</blockquote>
<p>The rules for uniform binding assignments are as follows:</p>
<ul>
<li>All resources (UBOs, SSBOs, images, samplers) may have different bindings dependening in each shader stage.</li>
<li>Any resources which are declared and used in a certain shader stage without an explicit layout binding qualifier will be assigned a per-stage binding slot by the compiler. This binding assignment may be different from the assignment of the same block in other shader stages.</li>
<li>Any resources which are declared and used in a certain shader stage with an explicit layout binding qualifier will be assigned the per-stage binding as specified by the shader. This binding assignment may be different from the assignment of the same block in other shader stages.</li>
<li>Any resources which are declared but unused in a certain shader stage will get a binding of "-1" assigned for that shader stage. Whether a resource is used in a specific stages must be determined through the GLSLC reflection information, in the variable <a class="el" href="struct_g_l_s_l_cuniform_block_info.html#a449b0310144f865d20c9152228c1f5c2" title="Stage mask representing which stages this variable is active in. ">GLSLCuniformBlockInfo::stagesReferencedIn</a>.</li>
</ul>
<p>The rules for per-stage binding reservations made by the compiler:</p>
<ul>
<li>Both used and unused resources with explicit layout binding qualifiers in a shader stage will reserve that binding slot for that stage. No other resources without explicit layout binding qualifiers will be assigned that same binding slot in the same stage.</li>
<li>Unused resources with no explicit layout binding qualifiers in a shader stage will not reserve any binding slot for that stage.</li>
<li>Used resources with no explicit layout binding qualifiers in a shader stage will be assigned an available unreserved slot by the compiler.</li>
<li>Reserved slots are per-stage, and reserved slots in one stage do not count towards the reservation of slots in other stages.</li>
</ul>
<h2><a class="anchor" id="nvn_glslc_guide_sec_15_2"></a>
15.2. Pragma directives</h2>
<p>GLSLC supports controlling various optimizations and options through the use of pragma directives within GLSL source. Pragma directives also have API option equivalents inside the <a class="el" href="struct_g_l_s_l_coption_flags.html" title="Option flags that control compilation and GLSLC output. ">GLSLCoptionFlags</a> structure. The usage of pragmas inside shader source will override any options set through the GLSLC API interface. Additionally, some pragmas may have dependencies on interface options.</p>
<p>Pragma directives and parameters are not case sensitive. Pragmas can only be applied to an entire shader, not to subsections. If a pragma directive for the same optimization is seen more than once in shader source, the last pragma to be used for the optimization will take effect.</p>
<p>The various pragmas available will be detailed in this section.</p>
<h3>Loop unrolling</h3>
<p>The loop unrolling pragma "unroll" can be used to direct the compiler how to perform loop unrolling. The pragma currently has three possible values: "none", "all", "default". "none" directs the compiler to not try and unroll any loops. "default" directs the compiler to apply the default unrolling behavior to loops based on the program's structure and heuristics. "all" directs the compiler to try and unroll every loop by surpressing performance heuristics. Even with "all", the compiler may not unroll every loop.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma unroll all</span></div>
</div><!-- fragment --><h3>Fast math</h3>
<p>See the section on fast math <a href="#nvn_glslc_guide_fastmath">section on fast math</a> for more information.</p>
<p>The pragma "fastmath" has two possible values: "true" and "false".</p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma fastmath true</span></div>
</div><!-- fragment --><h3>Optimization levels</h3>
<p>Optimization level with which to compile the shader. The "optlevel" pragma overrides other pragmas related to optimizations. For example, using a "\#pragma unroll all" directive with a "\#pragma optlevel none" will not work and no loops will be unrolled.</p>
<p>The pragma "optlevel" has two possible values: "none" which applies no optimizations, and "default" which applies the default optimizations.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma optlevel none</span></div>
</div><!-- fragment --><h3>Spill control</h3>
<p>Controls the amount of spilling in the shader. See <a href="#nvn_glslc_guide_register_spill_control">the section on spill control</a> for more information on spilling.</p>
<p>The #pragma "spillcontrol" currently has two values: "no_spill" which applies no spilling optimizations, and "default_spill" which applies the default spilling optimizations.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma spillcontrol no_spill</span></div>
</div><!-- fragment --><h3>Prioritize Consecutive Texture Instructions</h3>
<p>See <a href="#nvn_glslc_guide_prioritize_consecutive_texture_instructions">the section on prioritization of consecutive texture instructions</a> for more information on this feature.</p>
<p>The pragma "prioritizeConsecutiveTextureInstructions" has two possible values: "true" or "false".</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma prioritizeConsecutiveTextureInstructions false</span></div>
</div><!-- fragment --><h3>Discard Hoisting</h3>
<p>Scheduler hint to hoist discard instructions early. In shaders known to have high discard rate, this option can be enabled to ensure pixels are discarded as early as possible. This should be used in very limited cases as default scheduler behavior is considered optimal, and while it has shown gains in some shaders, this optimization may hurt performance in general due to a potential increase in latency.</p>
<p>The pragma "hoistDiscards" has two possible values: "true" or "false"</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma hoistDiscards true</span></div>
</div><!-- fragment --><h3>Coverage-to-color</h3>
<p>Enables a color output to be wriateable with the coverage value using NVN's coverage-to-color feature. Shaders only need to use this pragma if the color output is not written to in the fragment shader (even though the fragment's color will be overwritten with the coverage value by the hardware).</p>
<p>The pragma "coverageToColorTarget" value must be an integer between 0 and 7 inclusive.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="comment">// Enable color output 5 so that coveage can be written to it.</span></div>
<div class="line"><span class="preprocessor">#pragma coverageToColorTarget 5</span></div>
</div><!-- fragment --><blockquote class="doxtable">
<p>Note: See the NVN programming guide's section on coverage-to-color for advisories on performance when using the pragma. </p>
</blockquote>
<h2><a class="anchor" id="nvn_glslc_guide_glsl_extensions_supported"></a>
15.3. GLSL Extensions Supported</h2>
<p>The following are the supported GLSL extensions for NvnGlslc:</p>
<ul>
<li>GL_ARB_arrays_of_arrays</li>
<li>GL_ARB_bindless_texture</li>
<li>GL_ARB_compute_shader</li>
<li>GL_ARB_conservative_depth</li>
<li>GL_ARB_cull_distance</li>
<li>GL_ARB_derivative_control</li>
<li>GL_ARB_draw_buffers</li>
<li>GL_ARB_draw_instanced</li>
<li>GL_ARB_enhanced_layouts</li>
<li>GL_ARB_ES3_1_compatibility</li>
<li>GL_ARB_ES3_2_compatibility</li>
<li>GL_ARB_explicit_attrib_location</li>
<li>GL_ARB_explicit_uniform_location</li>
<li>GL_ARB_fragment_coord_conventions</li>
<li>GL_ARB_fragment_layer_viewport</li>
<li>GL_ARB_fragment_shader_interlock</li>
<li>GL_ARB_gpu_shader_fp64</li>
<li>GL_ARB_gpu_shader_int64</li>
<li>GL_ARB_gpu_shader5</li>
<li>GL_ARB_post_depth_coverage</li>
<li>GL_ARB_sample_shading</li>
<li>GL_ARB_separate_shader_objects</li>
<li>GL_ARB_shader_ballot</li>
<li>GL_ARB_shader_bit_encoding</li>
<li>GL_ARB_shader_clock</li>
<li>GL_ARB_shader_draw_parameters</li>
<li>GL_ARB_shader_group_vote</li>
<li>GL_ARB_shader_image_load_store</li>
<li>GL_ARB_shader_image_size</li>
<li>GL_ARB_shader_precision</li>
<li>GL_ARB_shader_storage_buffer_object</li>
<li>GL_ARB_shader_subroutine</li>
<li>GL_ARB_shader_texture_image_samples</li>
<li>GL_ARB_shader_texture_lod</li>
<li>GL_ARB_shader_viewport_layer_array</li>
<li>GL_ARB_shading_language_420pack</li>
<li>GL_ARB_shading_language_packing</li>
<li>GL_ARB_sparse_texture_clamp</li>
<li>GL_ARB_sparse_texture2</li>
<li>GL_ARB_tessellation_shader</li>
<li>GL_ARB_texture_cube_map_array</li>
<li>GL_ARB_texture_gather</li>
<li>GL_ARB_texture_multisample</li>
<li>GL_ARB_texture_query_levels</li>
<li>GL_ARB_texture_query_lod</li>
<li>GL_ARB_texture_rectangle</li>
<li>GL_ARB_uniform_buffer_object</li>
<li>GL_ARB_vertex_attrib_64bit</li>
<li>GL_ARB_viewport_array</li>
<li>GL_EXT_draw_buffers</li>
<li>GL_EXT_draw_instanced</li>
<li>GL_EXT_frag_depth</li>
<li>GL_EXT_shader_image_load_formatted</li>
<li>GL_EXT_shader_image_load_store</li>
<li>GL_EXT_sparse_texture2</li>
<li>GL_EXT_texture_buffer</li>
<li>GL_KHR_blend_equation_advanced</li>
<li>GL_NV_bindless_texture</li>
<li>GL_NV_draw_buffers</li>
<li>GL_NV_draw_instanced</li>
<li>GL_NV_explicit_attrib_location</li>
<li>GL_NV_fragment_shader_interlock</li>
<li>GL_NV_geometry_shader_passthrough</li>
<li>GL_NV_gpu_shader_fp64</li>
<li>GL_NV_gpu_shader5</li>
<li>GL_NV_sample_mask_override_coverage</li>
<li>GL_NV_shader_atomic_float</li>
<li>GL_NV_shader_atomic_float64</li>
<li>GL_NV_shader_atomic_fp16_vector</li>
<li>GL_NV_shader_atomic_int64</li>
<li>GL_NV_shader_buffer_load</li>
<li>GL_NV_shader_thread_group</li>
<li>GL_NV_shader_thread_shuffle</li>
<li>GL_NV_tessellation_shader</li>
<li>GL_NV_viewport_array</li>
<li>GL_NV_viewport_array2</li>
<li>GL_NV_desktop_lowp_mediump (NVN only, see <a href="#nvn_glslc_desktop_lowp_mediump">this section</a> for more information).</li>
</ul>
<blockquote class="doxtable">
<p>Note: Many extensions have functionality provided already subsumed within the GLSL 4.50 specification. </p>
</blockquote>
<p>The following are the supported GLES extensions for NvnGlslc (when using GLES mode to compile shaders):</p>
<ul>
<li>GL_EXT_blend_func_extended</li>
<li>GL_EXT_geometry_point_size</li>
<li>GL_EXT_geometry_shader</li>
<li>GL_EXT_gpu_shader5</li>
<li>GL_EXT_shader_implicit_conversions</li>
<li>GL_EXT_shader_integer_mix</li>
<li>GL_EXT_shader_io_blocks</li>
<li>GL_EXT_shader_non_constant_global_initializers</li>
<li>GL_EXT_shader_texture_lod</li>
<li>GL_EXT_shadow_samplers</li>
<li>GL_EXT_tessellation_point_size</li>
<li>GL_EXT_tessellation_shader</li>
<li>GL_NV_image_formats</li>
<li>GL_OES_geometry_shader</li>
<li>GL_OES_sample_variables</li>
<li>GL_OES_shader_image_atomic</li>
<li>GL_OES_shader_multisample_interpolation</li>
<li>GL_OES_standard_derivatives</li>
<li>GL_OES_tessellation_shader</li>
<li>GL_OES_texture_storage_multisample_2d_array</li>
</ul>
<blockquote class="doxtable">
<p>Note: Many extensions have functionality provided already subsumed within the GLSL ES 3.20 specification. </p>
</blockquote>
<h1><a class="anchor" id="nvn_glslc_guide_shader_specialization"></a>
16. Shader Specialization</h1>
<p>Beginning with version 12.0.0.2, GLSLC supports specialization of uniform values in shaders. The following is a list of non-sampler non-image uniforms that are specializable:</p>
<ul>
<li>Uniforms of basic types, including matrices.</li>
<li>Arrays of uniforms of basic types.</li>
<li>Uniforms contained in structs.</li>
</ul>
<h2><a class="anchor" id="nvn_glslc_guide_sec_16_1"></a>
16.1. Usage Model</h2>
<p>Specialization is achieved in a 2-stage process: compile the GLSLC inputs to an intermediate form, and then compile the intermediate form to machine code using uniform specialization. To accomplish this, the GLSLC API has added two functions: glslcCompilePreSpecialized and glslcCompileSpecialized. The overall flow of performing specialization can be seen below:</p>
<ol type="1">
<li>Initialize the compile object using glslcInitialize</li>
<li>Set options/input parameters</li>
<li>Call glslcCompilePreSpecialized to perform compilation to IR</li>
<li>Set up <a class="el" href="struct_g_l_s_l_cspecialization_uniform.html" title="Each element corresponds to a single uniform. ">GLSLCspecializationUniform</a> entries, utilize the GLSLCcompileObject::reflectionSection if needed</li>
<li>Create/initialize <a class="el" href="struct_g_l_s_l_cspecialization_set.html" title="Used to specify a set of uniforms to be specialized. ">GLSLCspecializationSet</a> and <a class="el" href="struct_g_l_s_l_cspecialization_batch.html" title="Used for &quot;batch&quot; mode processing, contains multiple specialization sets. ">GLSLCspecializationBatch</a> objects.</li>
<li>Call glslcCompileSpecialized</li>
<li>Use the set of GLSLCoutputs containing compiled specialized code.</li>
<li>For immediate indexed arrays or scalar uniforms, a failure to specialize will result in a compilation error. This error will be contained in the GLSLCcompileObject’s lastCompiledResults::compilationStatus::infoLog. For dynamically indexed arrays, the compiler is unable to determine if the application wanted the array to be specialized and therefore, this is signaled by a warning from GLSLC that specifies the UBO to which a potentially non-specialized dynamic indexed array belongs. In this case, the <a class="el" href="struct_g_l_s_l_ccompilation_status.html#aad451b051a1a9dfea1d75c0c8f95fba6" title="Indicates whether the compilation was successful or not. ">GLSLCcompilationStatus::success</a> flag will be 1, but the infoLog will contain the warning if any.</li>
</ol>
<h3>Specifying specialization values</h3>
<p>The <a class="el" href="struct_g_l_s_l_cspecialization_uniform.html" title="Each element corresponds to a single uniform. ">GLSLCspecializationUniform</a> structure contains entries that let applications specify the values for a single uniform or array of uniforms. The GLSLCspecializationUniform::uniformName parameter specifies the name of the uniform as it is in the shader. The naming conventions should follow the naming conventions of the reflection section information. The base name of the array can be specified for arrays of uniforms.</p>
<p>The <a class="el" href="struct_g_l_s_l_cspecialization_uniform.html#a1ef3404ed2eb660b125cf84201ec0973" title="Number of uniforms in the array. ">GLSLCspecializationUniform::numElements</a> should be set to the number of uniforms being specialized. For non-arrays, this value should be 1. For arrays, this value denotes the number of uniforms in the input array, and should match up with what's defined in the shader.</p>
<p>The <a class="el" href="struct_g_l_s_l_cspecialization_uniform.html#a08e7a735c1dc18c6ba868ffaac434386" title="Size of each uniform in the array in bytes. ">GLSLCspecializationUniform::elementSize</a> parameter denotes the size of the uniform, or in the case of arrays, the size of each uniform in the array. This size should correspond to the size indicated by either the reflection data or the std140 rules.</p>
<p>GLSLCspecializationUniform::values should be set to point to an array of input data, where the input data is formatted exactly how the shader expects (same input that be used in the NVN API). For instance, if using an array of 4 vec3's with a std140 layout, then the input would be a pointer to a float array with 4 elements where the size of each element is 16 (due to std140 rules). If std140 is not used, then layout information needs to be queried from the reflection information.</p>
<blockquote class="doxtable">
<p><b>Note</b>: The <a class="el" href="struct_g_l_s_l_cspecialization_uniform.html" title="Each element corresponds to a single uniform. ">GLSLCspecializationUniform</a> does not differentiate between arrays and single uniforms. The application needs to supply "1" as the <a class="el" href="struct_g_l_s_l_cspecialization_uniform.html#a1ef3404ed2eb660b125cf84201ec0973" title="Number of uniforms in the array. ">GLSLCspecializationUniform::numElements</a> parameter for non-arrays. GLSLC performs sanity check to ensure this input matches up with the reflection data. </p>
</blockquote>
<p>The <a class="el" href="struct_g_l_s_l_cspecialization_uniform.html" title="Each element corresponds to a single uniform. ">GLSLCspecializationUniform</a>'s should be formed as an array. Once all the <a class="el" href="struct_g_l_s_l_cspecialization_uniform.html" title="Each element corresponds to a single uniform. ">GLSLCspecializationUniform</a> structures desired for one compilation are filled in, an object <a class="el" href="struct_g_l_s_l_cspecialization_set.html" title="Used to specify a set of uniforms to be specialized. ">GLSLCspecializationSet</a> needs to be initialized. The parameter <a class="el" href="struct_g_l_s_l_cspecialization_set.html#a0624996cb1b0ae597a85094c96664f38" title="The number of uniforms in the array _uniforms. ">GLSLCspecializationSet::numUniforms</a> needs to corresponds to the number of <a class="el" href="struct_g_l_s_l_cspecialization_uniform.html" title="Each element corresponds to a single uniform. ">GLSLCspecializationUniform</a> being specialized, and GLSLCspecializationSet::uniforms needs to point to the array of <a class="el" href="struct_g_l_s_l_cspecialization_uniform.html" title="Each element corresponds to a single uniform. ">GLSLCspecializationUniform</a>.</p>
<p>GLSLC supports batch compilation, meaning multiple compiled results can be output with a single function call. The structure <a class="el" href="struct_g_l_s_l_cspecialization_batch.html" title="Used for &quot;batch&quot; mode processing, contains multiple specialization sets. ">GLSLCspecializationBatch</a> is the structure that needs to be initialized. The application should specify the number of <a class="el" href="struct_g_l_s_l_cspecialization_set.html" title="Used to specify a set of uniforms to be specialized. ">GLSLCspecializationSet</a> objects and also pass a pointer to an array where each entry corresponds to one of those sets.</p>
<h3>Performing specialization</h3>
<p>glslcCompilePreSpecialized compiles GLSL shaders down to IR (intermediate representation between GLSL and machine code from which machine code can be compiled) and is contained inside the <a class="el" href="struct_g_l_s_l_ccompile_object.html" title="The main object that holds input/output variables for compilation. ">GLSLCcompileObject</a>. The IR is contained inside the <a class="el" href="struct_g_l_s_l_ccompile_object.html" title="The main object that holds input/output variables for compilation. ">GLSLCcompileObject</a> and will be freed during a call to GLSLCfinalize. Additionally, the compile object member GLSLCcompileObject::reflectionSection will contain reflection data that can be used to query properties for setting specialization parameters.</p>
<p>GLSLCcompileSpecialized takes as input the precompiled compile object, along with a <a class="el" href="struct_g_l_s_l_cspecialization_batch.html" title="Used for &quot;batch&quot; mode processing, contains multiple specialization sets. ">GLSLCspecializationBatch</a> input. This function outputs an array of <em>n</em> GLSLCoutputs, where <em>n</em> corresponds to <a class="el" href="struct_g_l_s_l_cspecialization_batch.html#a0be46d42422ea32ebcc5e31ca3016484" title="Number of sets in the array entries ">GLSLCspecializationBatch::numEntries</a>, and each <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> corresponds to each of the <a class="el" href="struct_g_l_s_l_cspecialization_set.html" title="Used to specify a set of uniforms to be specialized. ">GLSLCspecializationSet</a> entries inside the input GLSLCspecializationBatch::entries array.</p>
<p>In order to allow reflection information to be obtained prior to specialization, after making a call to glslcPreSpecialized, the compile object's member GLSLCcompileObject::reflectionSection will point to a reflection section. This information is generated regardless of whether the option <a class="el" href="struct_g_l_s_l_coption_flags.html#a723afb9e18cdf4c92bfe315c94e37c96" title="Output shader reflection data. ">GLSLCoptionFlags::outputShaderReflection</a> is set to true or not and is independent of the <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> structure. Applications can query the information and set up the specialization parameters or use in other applications (such as a GUI) if required before compiling the specialized version of the machine code.</p>
<p>As an example, consider an application which wants to specialize two uniforms, <em>tc</em> and <em>uni2</em>.</p>
<div class="fragment"><div class="line"><span class="comment">// Example shaders used for specialization</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *vsshader =</div>
<div class="line">    <span class="stringliteral">&quot;#version 440\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;layout(location = 0) in vec3 position;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;layout(location = 1) in vec3 color;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;layout(std140) uniform Block { vec4 tc; vec3 uni2; };&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;out vec4 ocolor;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;out vec2 texCoords;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;void main() {\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;   gl_Position = vec4(position, 1.0) * tc;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;   ocolor = tc;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;   texCoords = tc.xy;\n&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;}&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *fsshader =</div>
<div class="line">    <span class="stringliteral">&quot;#version 440\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;in vec4 ocolor;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;in vec2 texCoords;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;out vec4 fcolor;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;layout(binding = 7) uniform sampler2D boundTex;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;void main() {\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;   fcolor = vec4(ocolor.xyz, 1.0);\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;   fcolor = fcolor + texture(boundTex, texCoords.xy);\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;}&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Specialize the variable &quot;tc&quot; to the value (0.0f, 1.0f, 2.0f, 3.0f)</span></div>
<div class="line"><a class="code" href="struct_g_l_s_l_cspecialization_uniform.html">GLSLCspecializationUniform</a> specUniforms[2];</div>
<div class="line"><span class="keywordtype">float</span> uniformVal1[4] = {0.0f, 1.0f, 2.0f, 3.0f};</div>
<div class="line">specUniforms[0].uniformName = <span class="stringliteral">&quot;tc&quot;</span>;</div>
<div class="line">specUniforms[0].values = (<span class="keywordtype">void</span> *)uniformVal1;</div>
<div class="line">specUniforms[0].<a class="code" href="struct_g_l_s_l_cspecialization_uniform.html#a1ef3404ed2eb660b125cf84201ec0973">numElements</a> = 1;</div>
<div class="line">specUniforms[0].<a class="code" href="struct_g_l_s_l_cspecialization_uniform.html#a08e7a735c1dc18c6ba868ffaac434386">elementSize</a> = <span class="keyword">sizeof</span>(float) * 4;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Specialize the uniform &quot;uni2&quot; to the value (7.0, 8.0, 0.0).</span></div>
<div class="line"><span class="keywordtype">float</span> uniformVal2[3] = {7.0f, 8.0f, 0.0f};</div>
<div class="line">specUniforms[1].uniformName = <span class="stringliteral">&quot;uni2&quot;</span>;</div>
<div class="line">specUniforms[1].values = (<span class="keywordtype">void</span> *)uniformVal2;</div>
<div class="line">specUniforms[1].<a class="code" href="struct_g_l_s_l_cspecialization_uniform.html#a1ef3404ed2eb660b125cf84201ec0973">numElements</a> = 1;</div>
<div class="line">specUniforms[1].<a class="code" href="struct_g_l_s_l_cspecialization_uniform.html#a08e7a735c1dc18c6ba868ffaac434386">elementSize</a> = <span class="keyword">sizeof</span>(float) * 3;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a single specialization set</span></div>
<div class="line"><a class="code" href="struct_g_l_s_l_cspecialization_set.html">GLSLCspecializationSet</a> specSet;</div>
<div class="line">specSet.<a class="code" href="struct_g_l_s_l_cspecialization_set.html#a0624996cb1b0ae597a85094c96664f38">numUniforms</a> = 2;</div>
<div class="line">specSet.uniforms = specUniforms;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a specialization batch which contains only one specialization set, meaning only one compilation will be performed.</span></div>
<div class="line"><a class="code" href="struct_g_l_s_l_cspecialization_batch.html">GLSLCspecializationBatch</a> specBatch;</div>
<div class="line">specBatch.entries = &amp;specSet;</div>
<div class="line">specBatch.<a class="code" href="struct_g_l_s_l_cspecialization_batch.html#a0be46d42422ea32ebcc5e31ca3016484">numEntries</a> = 1;</div>
<div class="line"></div>
<div class="line"><span class="comment">// First compile down to an intermediate representation.</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="nvn_tool___glslc_interface_8h.html#a8a7629609d27a49283b8cb9587dcca48">glslcCompilePreSpecialized</a>(compileObject) == 0) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Compilation failed.  Info log:\n%s\n&quot;</span>, compileObject.lastCompiledResults-&gt;compilationStatus-&gt;infoLog);</div>
<div class="line">    exit(1);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// At this point, the compileObject contains the intermediate compilation binary, as well as reflection results if needed.</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Call into the second stage which compiles from the intermediate representation to machine code, replacing the uniforms with</span></div>
<div class="line"><span class="comment">// the constant values denoted in the GLSLCspecializationUniforms.</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a> * <span class="keyword">const</span> * specOutputs = <a class="code" href="nvn_tool___glslc_interface_8h.html#a64bdf010fc635ccc01dc9f1625557da1">glslcCompileSpecialized</a>(compileObject, &amp;specBatch);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (!specOutputs) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Compilation failed.  Info log:\n%s\n&quot;</span>, compileObject.lastCompiledResults-&gt;compilationStatus-&gt;infoLog);</div>
<div class="line">    exit(1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>For an example that utilizes arrays,</p>
<div class="fragment"><div class="line"><span class="comment">// Example shaders.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *vsshader =</div>
<div class="line">    <span class="stringliteral">&quot;#version 440\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;layout(location = 0) in vec3 position;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;layout(location = 1) in vec3 color;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;layout(std140) uniform Block { vec3 uniarry[3]; };&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;out vec4 ocolor;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;out vec2 texCoords;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;void main() {\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;   gl_Position = vec4(position, 1.0) * uniarry[0].xyzz;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;   ocolor = uniarry[1].xyzz;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;   texCoords = uniarry[2].xy;\n&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;}&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *fsshader =</div>
<div class="line">    <span class="stringliteral">&quot;#version 440\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;in vec4 ocolor;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;in vec2 texCoords;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;out vec4 fcolor;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;layout(binding = 7) uniform sampler2D boundTex;\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;void main() {\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;   fcolor = vec4(ocolor.xyz, 1.0);\n&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;   fcolor = fcolor + texture(boundTex, texCoords.xy);\n&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;}&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="struct_g_l_s_l_cspecialization_uniform.html">GLSLCspecializationUniform</a> specUniform;</div>
<div class="line">    <span class="comment">// Note the below requires 4 floats per uniform in the array.  This corresponds to</span></div>
<div class="line">    <span class="comment">// padding rules as denoted by std140, and would be the buffer expected as input into NVN.</span></div>
<div class="line">    <span class="comment">// We create only one instance of a GLSLCspecializationUniform, but the data represents an array of vec3s.</span></div>
<div class="line">    <span class="keywordtype">float</span> uniformVal[3][4] = {{1.0f, 2.0f, 3.0f, 0.0f},</div>
<div class="line">                              {5.0f, 6.0f, 7.0f, 0.0f},</div>
<div class="line">                              {1.0f, 1.0f, 0.0f, 0.0f}};</div>
<div class="line">    specUniform.uniformName = <span class="stringliteral">&quot;uniarry&quot;</span>;</div>
<div class="line">    specUniform.values = (<span class="keywordtype">void</span> *)uniformVal;</div>
<div class="line">    specUniform.<a class="code" href="struct_g_l_s_l_cspecialization_uniform.html#a1ef3404ed2eb660b125cf84201ec0973">numElements</a> = 3;</div>
<div class="line">    specUniform.<a class="code" href="struct_g_l_s_l_cspecialization_uniform.html#a08e7a735c1dc18c6ba868ffaac434386">elementSize</a> = <span class="keyword">sizeof</span>(float) * 4;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="struct_g_l_s_l_cspecialization_set.html">GLSLCspecializationSet</a> specSet;</div>
<div class="line">    specSet.<a class="code" href="struct_g_l_s_l_cspecialization_set.html#a0624996cb1b0ae597a85094c96664f38">numUniforms</a> = 1;</div>
<div class="line">    specSet.uniforms = &amp;specUniform;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="struct_g_l_s_l_cspecialization_batch.html">GLSLCspecializationBatch</a> specBatch;</div>
<div class="line">    specBatch.entries = &amp;specSet;</div>
<div class="line">    specBatch.<a class="code" href="struct_g_l_s_l_cspecialization_batch.html#a0be46d42422ea32ebcc5e31ca3016484">numEntries</a> = 1;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="nvn_tool___glslc_interface_8h.html#a8a7629609d27a49283b8cb9587dcca48">glslcCompilePreSpecialized</a>(compileObject) == 0) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Compilation failed.  Info log:\n%s\n&quot;</span>, compileObject.lastCompiledResults-&gt;compilationStatus-&gt;infoLog);</div>
<div class="line">        exit(1);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a> * <span class="keyword">const</span> * specOutputs = <a class="code" href="nvn_tool___glslc_interface_8h.html#a64bdf010fc635ccc01dc9f1625557da1">glslcCompileSpecialized</a>(compileObject, &amp;specBatch);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (!specOutputs) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Compilation failed.  Info log:\n%s\n&quot;</span>, compileObject.lastCompiledResults-&gt;compilationStatus-&gt;infoLog);</div>
<div class="line">        exit(1);</div>
<div class="line">    }</div>
</div><!-- fragment --><h3>Compilation Errors</h3>
<p>There are sanity checks that are performed inside the glslcCompileSpecialized function to ensure that the input matches up to how the data is expected within the shader with respect to layout rules. These errors include:</p>
<ul>
<li>Specifying a uniform that doesn't exist or is inactive in the shader.</li>
<li>Specifying a GLSLCspecializationUniform::values of NULL.</li>
<li>Not specifying a name for the uniform to specialize.</li>
<li>Passing more than 1 for the <a class="el" href="struct_g_l_s_l_cspecialization_uniform.html#a1ef3404ed2eb660b125cf84201ec0973" title="Number of uniforms in the array. ">GLSLCspecializationUniform::numElements</a> parameter on non-array uniforms.</li>
<li>Specifying an incorrect <a class="el" href="struct_g_l_s_l_cspecialization_uniform.html#a1ef3404ed2eb660b125cf84201ec0973" title="Number of uniforms in the array. ">GLSLCspecializationUniform::numElements</a> for arrays with respect to the declared array in the shader.</li>
<li>Passing in an incorrect <a class="el" href="struct_g_l_s_l_cspecialization_uniform.html#a08e7a735c1dc18c6ba868ffaac434386" title="Size of each uniform in the array in bytes. ">GLSLCspecializationUniform::elementSize</a> and <a class="el" href="struct_g_l_s_l_cspecialization_uniform.html#a1ef3404ed2eb660b125cf84201ec0973" title="Number of uniforms in the array. ">GLSLCspecializationUniform::numElements</a> combination which leads to a total size which is different than what the uniform is backed by in the shader (use reflection info or std140 layout rules to determine this).</li>
</ul>
<p>In any of these error cases, glslcCompileSpecialized will return NULL and the error will be stored in the GLSLCcompileObject::lastCompiledResults::compilationStatus member.</p>
<h3>Limitations</h3>
<ul>
<li>Currently partial specialization is not handled for arrays of any type.</li>
<li>Arrays of uniform blocks or arrays of structs are not handled.</li>
<li>Dynamically indexed arrays in the shader may not be specialized.</li>
<li>Due to the difference in optimization behavior at optimization levels "none" and "default" there may be some shaders where the compiler can correctly specialize dynamically indexed uniforms at the “default” optimization level, but will fail to specialize when optimizations are disabled (i.e. optimization level “none”). If the compiler can not perform the specialization, an error will be emitted.</li>
</ul>
<h1><a class="anchor" id="nvn_glslc_guide_sec_17"></a>
17. Debug Information</h1>
<blockquote class="doxtable">
<p>** Note **: The use of any debugging flags when compiling shaders (i.e. "G0", "G1", "G2" debug levels) will cause extra information, such as GLSL source strings, to be emitted inside the debugging sections inside the <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a>. If there are intellectual property (IP) concerns with your shaders, please disable debugging when providing compiled <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> binaries outside of your company. </p>
</blockquote>
<blockquote class="doxtable">
<p>** Note **: "G2" level is not supported with optimizations turned on and the compiler will fall-back to "G1" level unless optimizations are turned off. </p>
</blockquote>
<p>GLSLC provides the ability to output debug information and interact with various development tools. <a class="el" href="struct_g_l_s_l_coption_flags.html#af2b81192a389ab5093f074ced7ceea29" title="Level of debug information to generate. ">GLSLCoptionFlags::outputDebugInfo</a> can be used to enable debug output from GLSLC for the requested debug level.</p>
<ul>
<li>GLSLC_DEBUG_LEVEL_NONE - No debug information will be produced. This is the default and should be used for production code.</li>
<li>GLSLC_DEBUG_LEVEL_G0 - The minimal amount of debug info for GLSL source debugging will be produced.</li>
<li>GLSLC_DEBUG_LEVEL_G1 - The minimal amount of debug info for GLSL profiling.</li>
<li>GLSLC_DEBUG_LEVEL_G2 - Full debug information.</li>
</ul>
<p>The debug information will be a separate section of the <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> with a header of type <a class="el" href="struct_g_l_s_l_cdebug_info_header.html" title="A debug section header. ">GLSLCdebugInfoHeader</a>. This can be extracted from the <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> similar to other sections of the binary. Please refer to the dev tools documentation on how the format of the binary is expected to be stored for more information.</p>
<p>The debug information emitted for each debug level is cumulative (i.e., debug level G*N* produces the same debug information as debug level G*N-1* plus some additional information).</p>
<h1><a class="anchor" id="nvn_glslc_guide_sec_18"></a>
18. Retrieving assembly output</h1>
<p>When shaders are compiled and linked successfully, GLSLC can output the resulting assembly code (SASS). The GLSLCoptions::outputAssembly flag must be enabled for this information to be generated. If enabled, the <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> structure will have a section of type GLSLC_SECTION_TYPE_ASM_DUMP for each shader stage. The section data will be a human-readable string containing formatted assembly code.</p>
<p>Example output from compiling a vertex shader:</p>
<pre>
            !!SPA5.3
            .THREAD_TYPE vertex
                 MOV32I      R0, 0xbf800000;                          # [000008]
                 AST         a[0x70], RZ;                             # [000010] POSITION_X
                 AST         a[0x74], RZ;                             # [000018] POSITION_Y
                 AST         a[0x7c], RZ;                             # [000028] POSITION_W
                 AST         a[0x78], R0;                             # [000030] POSITION_Z
                 EXIT;                                                # [000038]
    L0040:
                 BRA         L0040;                                   # [000048]
                 NOP;                                                 # [000050]
                 NOP;                                                 # [000058]
                 NOP;                                                 # [000068]
                 NOP;                                                 # [000070]
                 NOP;                                                 # [000078]
                 END
</pre><p>Example output from compiling a fragment shader:</p>
<pre></pre><pre>            !!SPA5.3
            .THREAD_TYPE pixel
                 MOV32I      R6, 0x3f800000;                          # [000008]
                 MOV32I      R7, 0x3f800000;                          # [000010]
                 MOV         R4, RZ;                                  # [000018]
                 MOV         R5, RZ;                                  # [000028]
                 TEXS.F16.NODEP.T R3, R1, R6, R6, 0xc, CUBE, RGBA;    # [000030]
                 TEXS.F16.NODEP.P R4, R2, R4, R5, 0x8, 2D, RGBA;      # [000038]
                 HMUL2.F32       R0, R2.H0_H0, R1.H0_H0;              # [000048]
                 HMUL2.F32       R1, R2.H1_H1, R1.H1_H1;              # [000050]
                 HMUL2.F32       R2, R4.H0_H0, R3.H0_H0;              # [000058]
                 HMUL2.F32       R3, R4.H1_H1, R3.H1_H1;              # [000068]
                 EXIT;                                                # [000070]
    L0078:
                 BRA             L0078;             # [000078]
            END
</pre><p>The output is a formatted view of the assembly instructions.</p>
<h2><a class="anchor" id="nvn_glslc_guide_sec_18_1"></a>
18.1. Constant Buffer Accesses</h2>
<p>The following section will describe how to interpret constant buffer accesses, such as uniform references, in the SASS dump. Assembly instructions may fetch values from a bound constant buffer in arithmetic or general load instructions. For example, the instruction:</p>
<pre>
            MOV             R4, c[0xa][0x0];                              # [000128]
</pre><p>moves data from a contant buffer into register R4. References to constant buffer memory in disassembled instructions are of the form "c[A][B]", where "c" indicates a reference to a constant buffer in GPU hardware. The first index ("[0xa]" in the above example) indicates which constant bank (buffer binding) the instruction is reading from. The second index ("[0x0]" in the above example) is the byte offset into the bank. There are a total of 18 constant banks available per shader stage. 4 banks are reserved by the compiler and NVN implementation for various purposes: internal data, such as driver-managed constants, shader constants, non-uniform buffer uniform data, or other non-user data. 14 banks are reserved for backing user-defined uniform buffers in the shaders, and these banks start with constant bank "c[0x3]".</p>
<p>The following table illustrates the constant bank layout:</p>
<table class="doxtable">
<tr>
<th>HW Constant bank </th><th>Purpose  </th></tr>
<tr>
<td>c[0x0] </td><td>Reserved for driver-managed constants </td></tr>
<tr>
<td>c[0x1] </td><td>Immediate constants in shader code, extracted by the compiler </td></tr>
<tr>
<td>c[0x2] </td><td>Bound resource uniforms (images and samplers) for the shader stage </td></tr>
<tr>
<td>c[0x3] through c[0x10] </td><td>User uniform buffer bindings 0 through 13 for the shader stage </td></tr>
<tr>
<td>c[0x11] </td><td>Reserved by the driver </td></tr>
</table>
<p>Note that the layout described in this section details binaries of GLSLC GPU code major version 1. If a new GPU code major version format is introduced, these layouts might change, but that would indicate a backwards incompatible break.</p>
<h3>Reserved Driver-Managed Constants</h3>
<p>The NVN driver binds an internal constant buffer to hardware constant bank #0, which holds driver-managed constant data. The constant buffer holds API state that needs to be fetched by compiler-generated shader code implementing various NVN API features. Among the data stored in this constant buffer are 16-byte descriptors for shader storage blocks, which are programmed via <a class="el" href="classnvn_1_1_command_buffer.html#a1e8f4df985fe6d64ede82ae19a5ee9d7" title="Bind a range of a Buffer object to use for random-access reads and writes in shaders. ">nvn::CommandBuffer::BindStorageBuffer</a>.</p>
<p>For graphics shaders, this internal constant buffer is shared by all shader stages. The shader storage block bindings for each shader stage can be found in the following locations:</p>
<table class="doxtable">
<tr>
<th>SSBO bindings </th><th>c[0x0] entries  </th></tr>
<tr>
<td>Vertex SSBO bindings 0 through 15 </td><td>c[0x0][0x110 through 0x20F] </td></tr>
<tr>
<td>Tess Control SSBO bindings 0 through 15 </td><td>c[0x0][0x210 through 0x30F] </td></tr>
<tr>
<td>Tess Eval SSBO bindings 0 through 15 </td><td>c[0x0][0x310 through 0x40F] </td></tr>
<tr>
<td>Geometry SSBO bindings 0 through 15 </td><td>c[0x0][0x410 through 0x50F] </td></tr>
<tr>
<td>Fragment SSBO bindings 0 through 15 </td><td>c[0x0][0x510 through 0x60F] </td></tr>
</table>
<p>A separate internal constant buffer is used for compute shaders. In addition to storing shader storage block bindings, this constant buffer also holds 16-byte descriptors for compute shader uniform buffer bindings. NX compute shader hardware only supports 8 total constant buffer bindings. Uniform buffer bindings #0 through #4 map directly to "c[0x3]" through "c[0x7]", while buffer bindings #5 through #13 are fetched from the internal constant buffer "c[0x0]" and emulated using global loads. If an array of uniform buffer bindings crosses the boundary between bindings #4 and #5 and an access to that array uses a non-constant buffer index, that access will use the internal constant buffer, regardless of the actual index.</p>
<table class="doxtable">
<tr>
<th>Compute API bindings </th><th>Constant buffer locations  </th></tr>
<tr>
<td>Uniform buffer bindings 0 through 4 (if non-emulated) </td><td>c[0x3] through c[0x7] </td></tr>
<tr>
<td>Uniform buffer bindings 0 through 13 (if emulated with global loads) </td><td>c[0x0][0x210 through 0x2F0]; 16 bytes each </td></tr>
<tr>
<td>SSBO bindings 0 through 15 </td><td>c[0x0][0x310 through 0x40F]; 16 bytes each </td></tr>
</table>
<h3>Bound Resource Uniforms</h3>
<p>GLSL shaders used by NVN can include sampler or image uniforms associated with API binding points which are not stored in user-defined uniform blocks. For example:</p>
<pre>
            layout(binding=4) uniform sampler2D smp;
</pre><p>declares a variable <em>smp</em> that is associated with API binding point #4 for the shader stage. Unlike OpenGL, NVN has separate API binding points for each shader stage. The handles used by these binding points are stored in a per-stage internal constant buffer bound to hardware constant bank #2 ("c[0x2]") at a pre-defined fixed offset based on the assigned binding for each uniform in the shader. Samplers, separate textures/samplers, and images are represented as 8 byte entries per binding.</p>
<p>The layout of bank c[0x2] is defined as follows:</p>
<table class="doxtable">
<tr>
<th>Byte range in c[0x2] </th><th>Usage  </th></tr>
<tr>
<td>c[0x2][&lt;0x0 through 0x1F &gt;] </td><td>Reserved for internal use </td></tr>
<tr>
<td>c[0x2][&lt;0x20 through 0x11F&gt;] </td><td>API combined texture/sampler bindings 0 through 31; 8 bytes each </td></tr>
<tr>
<td>c[0x2][&lt;0x120 through 0x15F&gt;] </td><td>API Image bindings 0 through 7; 8 bytes each </td></tr>
<tr>
<td>c[0x2][&lt;0x160 through 0x167&gt;] </td><td>Reserved for internal use </td></tr>
<tr>
<td>c[0x2][&lt;0x168 through 0x567&gt;] </td><td>API texture-only bindings 0 through 127; 8 bytes each </td></tr>
<tr>
<td>c[0x2][&lt;0x568 through 0x667&gt;] </td><td>API sampler-only bindings 0 through 31; 8 bytes each </td></tr>
</table>
<p>Note that texture and image instructions using bound resource uniforms might show up in the assembly as instructions referencing 4-byte immediate integer offsets instead of making explicit references to "c[0x2]"; the hardware is already programmed to reference constant bank #2 for pulling descriptors for these types of instructions, and the compiler might choose to optimize out intermediate loads from this constant bank. For example, in the instruction</p>
<pre>
         TEXS.NODEP.P    R2, R0, R4, R4, 0xe, 2D, RGBA;                # [000010]
</pre><p>the "0xe" (14) indicates that the hardware will fetch the texture or image descriptor at an offset of 14*4 = 56 bytes from the beginning of the bound resource uniform constant buffer. That would refer to combined texture/sampler binding #3.</p>
<p>Also note that while samplers and images are represented as 8-byte values, generated shader code may fetch bindings using 4-byte loads.</p>
<h3>Uniform Buffer Bindings</h3>
<p>Each uniform buffer binding in a shader stage corresponds to a single constant bank. For example, "c[0xa][0x0]" maps to the first byte of the uniform buffer binding #7 in the shader. If the user had defined a uniform bank in a GLSL shader with "layout(binding = 3)", then SASS instructions referencing that uniform buffer would contain "c[0x6]".</p>
<p>In order to determine byte offsets of members of a uniform block, developers will need to know the layout of the uniform block's data or use GLSLC reflection information to query offsets. Uniform buffers that use std140 or std430 layouts have an explicit pre-defined format for the uniform block data. Shaders that do not use one of these fixed layouts for a uniform buffer have the compiler assign an implementation-dependent layout. In the case std140 or std430 are not used, developers mapping uniform buffer uniforms in the shader to the byte offsets within the constant bank will need to use the <a href="#nvn_glslc_guide_shader_reflection">reflection section</a> to get the byte offsets for the desired uniforms. Byte offsets in the reflection section for uniform buffer uniforms map directly to the byte offsets into the corresponding constant bank.</p>
<h2><a class="anchor" id="nvn_glslc_guide_sec_18_2"></a>
18.2. Vertex attributes and Varyings</h2>
<p>When passing inputs and outputs between graphics shader stages, instructions refer to an attribute by a canonical "address" of the form "a[addr]", where <em>addr</em> is a byte offset into a logical structure containing all possible attributes. For example:</p>
<pre>
            IPA             R5, a[0x80], R4;                              # [0001b8] ATTR0
            IPA             R6, a[0x84], R4;                              # [0001c8] GENERIC_ATTRIBUTE_00_Y
            IPA             R7, a[0x88], R4;                              # [0001d0] GENERIC_ATTRIBUTE_00_Z
            IPA             R8, a[0x8c], R4;                              # [0001d8] GENERIC_ATTRIBUTE_00_W
</pre><p>interpolates (IPA) the four components of generic vector attribute 0, which has byte offsets in the range [0x80, 0x8F]. In GLSL shaders, a layout qualifier like:</p>
<pre>
            layout(location=4) in vec4 value;
</pre><p>will associate <em>value</em> with generic vector attribute 4, which has an associated offset of 0xC0.</p>
<p>The interface supports 32 generic vectors with offsets in the range [0x80, 0x27F]. The interface also supports various fixed-function attributes. For instructions using attributes, as in the example above, comments in the disassembled instructions identify the attributes accessed.</p>
<p>Note that these "byte offsets" are not actually used as offsets in memory; they are rather treated as canonical attribute numbers. NX hardware optimizes attribute passing so that unused or "dead" attributes are not passed between stages and do not consume storage or memory bandwidth.</p>
<h1><a class="anchor" id="nvn_glslc_fp16"></a>
19. FP16 Support</h1>
<p>The NX hardware is capable of performing certain operations at 16-bit floating point precision instead of 32-bit. This precision difference may help with throughput in some situations. In GLSL shaders, FP16 can be enabled by either using the float16_t types with the GL_NV_gpu_shader5 extension, or by using the mediump and lowp precision qualifiers along with the NVN-specific extension GL_NV_desktop_lowp_mediump. Mediump and lowp can be used with GL ES shaders without requiring the use of a separate extension.</p>
<h2><a class="anchor" id="nvn_glslc_desktop_lowp_mediump"></a>
19.1. GL_NV_desktop_lowp_mediump Extension Specification Version 1.0</h2>
<blockquote class="doxtable">
<p><b>Note</b>: This extension is not a public extension and is only enabled on NVN platforms. </p>
</blockquote>
<p>GL_NV_desktop_lowp_mediump is an OpenGL GLSL language extension written against OpenGL Shading Language GLSL version 4.5.</p>
<h3>Overview</h3>
<p>This extension enables usage qualifying certain data types with precision qualifiers lowp/mediump/highp which restricts their precision to limits stated further below and allows implementations to map them to other lower precision data types resulting in potential gain in performance . Shaders requiring use of this functionality should add </p><pre class="fragment">#extension : GL_NV_desktop_lowp_mediump : enable
</pre><h3>Storage &amp; Precision</h3>
<p><b>Floating Types</b></p>
<ul>
<li>Highp floating point values are stored in IEEE 754 single precision floating point format.</li>
<li>Mediump and lowp floating point values are stored in IEEE 754-2008 half precision floating point format (equivalent to float16_t type as defined in GL_NV_gpu_shader5)</li>
</ul>
<blockquote class="doxtable">
<p><b>Note</b> : NVN does not support FP16 data types at API level (unless using <em>NV_gpu_shader5</em>). Hence backing store for mediump/lowp floating values in SSBO/UBO will continue to be 32bits i.e IEEE 754 single precision format and will be converted to FP16 during reads and back to FP32 during writes. </p>
</blockquote>
<p><b>Integral Types</b></p>
<p>All integral types are assumed to be implemented as integers and so may not be emulated by floating point values.</p>
<ul>
<li>Highp signed integers are represented as twos-complement 32-bit signed integers. Highp unsigned integers are represented as unsigned 32-bit integers.</li>
<li>Mediump integers (signed and unsigned) must be represented as an integer with between 16 and 32 bits inclusive.</li>
<li>Lowp integers (signed and unsigned) must be represented as an integer with between 9 and 32 bits inclusive.</li>
</ul>
<table class="doxtable">
<tr>
<th>Qualifier </th><th>Floating<br />
Point Range </th><th>Floating Point Magnitude Range </th><th>Floating Point Precision </th><th>Integer Range, Signed </th><th>Integer Range, Unsigned  </th></tr>
<tr>
<td>highp </td><td>Subset of IEEE-754 (−2^128, 2^128) </td><td>Subset of IEEE 754 relative: 0.0,[ 2^-126,2^128) </td><td>Subset of IEEE 754 relative: 2^-24 </td><td>[−2^31, 2^31 -1] </td><td>[0 ,2^32 - 1] </td></tr>
<tr>
<td>mediump(minimum requirements) </td><td>(−2^14 , 2^14) </td><td>(2^−14 ,2^14) </td><td>Relative: 2^−10 </td><td>[−2^15, 2^15−1] </td><td>[0 , 2^16−1] </td></tr>
<tr>
<td>lowp(minimum requirements) </td><td>(−2, 2) </td><td>(2 ,2) </td><td>Absolute: 2^−8 </td><td>[−2^8, 2^8−1] </td><td>[0 , 2^9−1] </td></tr>
</table>
<h3>Conversion between precisions</h3>
<p>Within the same type, conversion from a lower to a higher precision must be exact. When converting from a higher precision to a lower precision, if the value is representable by the implementation of the target precision, the conversion must also be exact. If the value is not representable, the behavior is dependent on the type:</p>
<ul>
<li>For signed and unsigned integers, the value is truncated; bits in positions not present in the target precision are set to zero. (Positions start at zero and the least significant bit is considered to be position zero for this purpose.)</li>
<li>For floating point values, the value should either clamp to +INF or -INF, or to the maximum or minimum value that the implementation supports. While this behavior is implementation dependent, it should be consistent for a given implementation.</li>
</ul>
<h3>Precision qualifiers</h3>
<p>Any floating point, integer, opaque type declaration can have the type preceded by one of these precision qualifiers:</p>
<table class="doxtable">
<tr>
<th>Qualifier </th><th>Meaning  </th></tr>
<tr>
<td>highp </td><td>The variable satisfies the minimum requirements for highp described above. Highp variables have the maximum range and precision available but may cause operations to run more slowly on some implementations. </td></tr>
<tr>
<td>mediump </td><td>The variable satisfies the minimum requirements for mediump described above. Mediump variables may typically be used to store high dynamic range colors and low precision geometry. </td></tr>
<tr>
<td>lowp </td><td>The variable satisfies the minimum requirements for lowp described above. Lowp variables may typically be used to store 8-bit color values. </td></tr>
</table>
<p>Mapping for types is as follows:</p>
<table class="doxtable">
<tr>
<th>Qualifer </th><th>Type </th><th>Type </th><th>Type  </th></tr>
<tr>
<td>Qualifier Highp </td><td>float </td><td>uint </td><td>int </td></tr>
<tr>
<td>Resultant Type </td><td>float </td><td>uint </td><td>int </td></tr>
<tr>
<td></td><td></td><td></td><td></td></tr>
<tr>
<td>Qualifier mediump </td><td>float </td><td>uint </td><td>int </td></tr>
<tr>
<td>Resultant Type </td><td>float16_t </td><td>uint </td><td>int </td></tr>
<tr>
<td></td><td></td><td></td><td></td></tr>
<tr>
<td>Qualifier lowp </td><td>float </td><td>uint </td><td>int </td></tr>
<tr>
<td>Resultant Type </td><td>float16_t </td><td>uint </td><td>int </td></tr>
</table>
<blockquote class="doxtable">
<p><b>Note</b>: Refer to GL_NV_gpu_shader5 for float16_t details. </p>
</blockquote>
<p>Some declaration examples: </p><pre class="fragment">lowp float color;
out mediump vec2 P;
lowp ivec2 foo(lowp mat3);
highp mat4 m;
</pre><p>Literal constants do not have precision qualifiers. Neither do Boolean variables. Neither do constructors. For this paragraph, “operation” includes operators, built-in functions, and constructors, and “operand” includes function arguments and constructor arguments. The precision used to internally evaluate an operation, and the precision qualification subsequently associated with any resulting intermediate values, must be at least as high as the highest precision qualification of the operands consumed by the operation. In cases where operands do not have a precision qualifier, the precision qualification will come from the other operands. If no operands have a precision qualifier, then the precision qualifications of the operands of the next consuming operation in the expression will be used. This rule can be applied recursively until a precision qualified operand is found. If necessary, it will also include the precision qualification of lvalues for assignments, of the declared variable for initializers, of formal parameters for function call arguments, or of function return types for function return values. If the precision cannot be determined by this method e.g. if an entire expression is composed only of operands with no precision qualifier, and the result is not assigned or passed as an argument, then it is evaluated at the default precision of the type or greater. For texture sampling functions, the precision of the return type matches the precision of the sampler type.</p>
<blockquote class="doxtable">
<p><b>Note</b> : This is identical to ES 3.2 spec. </p>
</blockquote>
<p>Precision qualifiers will change the basic type of the variable if the base type is a floating point type and hence will also contribute to function overloading based on parameter types.</p>
<p>Where the precision of a constant integral or constant floating point expression is not specified, evaluation is performed at highp. This rule does not affect the precision qualification of the expression.</p>
<h3>Implicit conversion</h3>
<p>Following additional rules are added to implicit conversions (OpenGL Shading Language 4.5 Section 4.1.10)</p>
<table class="doxtable">
<tr>
<th>Type Of Conversion </th><th>Can be implicitly converted to  </th></tr>
<tr>
<td>mediump/lowp float </td><td>highp float </td></tr>
<tr>
<td>mediump/lowp vec2 </td><td>highp vec2 </td></tr>
<tr>
<td>mediump/lowp vec3 </td><td>highp vec3 </td></tr>
<tr>
<td>mediump/lowp vec4 </td><td>highp vec4 </td></tr>
</table>
<h3>Default Precision Qualifiers</h3>
<p>The precision statement </p><pre class="fragment">precision precision-qualifier type;
</pre><p>can be used to establish a default precision qualifier. The type field can be either int, float or any of the opaque types and the precision-qualifier can be lowp, mediump, or highp. Any other types or qualifiers will result in an error. If type is float, the directive applies to non-precision-qualified floating point type (scalar, vector, and matrix) declarations. If type is int, the directive applies to all non-precision-qualified integral type (scalar, vector, signed, and unsigned) declarations. This includes global variable declarations, function return declarations, function parameter declarations, and local variable declarations. Non-precision qualified declarations will use the precision qualifier specified in the most recent precision statement that is still in scope. The precision statement has the same scoping rules as variable declarations. If it is declared inside a compound statement, its effect stops at the end of the innermost statement it was declared in. Precision statements in nested scopes override precision statements in outer scopes. Multiple precision statements for the same basic type can appear inside the same scope, with later statements overriding earlier statements within that scope.</p>
<h3>Programming Notes</h3>
<p>Using global scope wide precision qualifiers of the form to generate FP16 math: “precision mediump float” is not recommended for vertex/geometry/tessellation shaders where higher precision of operations can matter significantly as compared to fragment programs writing color values quantized to precision of framebuffer</p>
<p>Mixing interface attribute types between shader stages with explicit NV_gpu_shader5 float16_t types on one side of the interface and mediump/lowp types on the other side of the interface could produce linker errors Inferring from implicit conversions rules from table above implicit conversion from uint to float16_t or uint to mediump float is disallowed. Explicit float cast is required to allow this.</p>
<p>Only a few hardware operations support fp16 precision. The compiler will generate code for necessary type conversions for operations where hardware only supports fp32 precision.</p>
<p>Doing a computation at fp16 precision can result in LSB differences w.r.t. value computed using fp32 operations. Make sure your application can tolerate them.</p>
<h3>Differences from ES</h3>
<p>ES mandates precision qualifiers do not change basic type of variable which makes for confusing semantics. Following are differences from ES</p>
<p>Mediump and lowp floating point values are stored in IEEE 754-2008 half precision floating point format (equivalent to float16_t type as defined in GL_NV_gpu_shader5)</p>
<p>Precision qualifiers will change the basic type of the variable if the base type is a floating point type and hence will also contribute to function overloading based on parameter types.</p>
<p>Some functions have predefined precisions. The precision is specified by the function signature, limited to following functions textureSize, textureQueryLOD, textureQueryLod, textureSamples, textureQueryLevels which always return highp irrespective of precision of the sampler.</p>
<h3>Usage Example</h3>
<pre class="fragment">#version 450
#extension GL_NV_desktop_lowp_mediump : enable

precision mediump float;
uniform block {
        float inp1; //mediump due to global precision declaration
        float inp2; //mediump due to global precision declaration
        highp float inp3; //highp overrides global declaration
};
out highp float op;
void main()
{
        highp float x = 2.0f;
        float temp; // mediump due to global precision declaration
        temp = inp1 * inp2; // multiply 2 fp16 floats
        x = temp * x; // Multiply at highest precision of operands i.e highp=F32
        op = x * inp3;
}
</pre><p>Resulting GLASM </p><pre class="fragment">!!NVfp5.0
OPTION NV_bindless_texture;
#vendor NVIDIA Corporation
#version 3.4.0.1
#profile gp5fp
#program main
#semantic block : BUFFER[0]
#var float inp1 : BUFFER[0] : buffer[0][0] : -1 : 1
#var float inp2 : BUFFER[0] : buffer[0][4] : -1 : 1
#var float inp3 : BUFFER[0] : buffer[0][8] : -1 : 1
#var float op : $vout.COL00 : COL0[0] : -1 : 1
CBUFFER buf0[] = { program.buffer[0] };
SHORT TEMP H0, H1;
TEMP R0;
OUTPUT result_color0 = result.color;
LDC.F32 R0.x, buf0[8]; // Backing store FP32 &amp; kept at F32
LDC.F32 H1.x, buf0[4]; // Backing store FP32, converted to FP16
LDC.F32 H0.x, buf0[0]; // Backing store FP32, converted to FP16
MUL.F16 H0.x, H0, H1;
MUL.F32 R0.x, H0, R0;
MUL.F32 result_color0.x, R0, {2, 0, 0, 0};
END
# 6 instructions, 1 R-regs
</pre><p>Resulting SASS </p><pre class="fragment">!!SPA5.3
        .THREAD_TYPE pixel
             MOV             R0, c[0x3][0x0]
             HMUL2.F32   R0, R0.F32, c[0x3][0x4]
             MOV             R1, RZ
             MOV             R2, RZ
             MOV             R3, RZ
             FMUL.FTZ.M2     R0, R0, c[0x3][0x8]
             EXIT
L0050:
             BRA             L0050
             NOP
             NOP
             NOP
             NOP
        END
</pre><h1><a class="anchor" id="nvn_glslc_guide_sec_20"></a>
20. Shader subroutine support</h1>
<p>Shader subroutine support in the NVN API as well as the GLSLC offline compiler matches subroutine support defined in the GLSL 4.00 specification and has similar API-level functionality to <a href="https://www.opengl.org/registry/specs/ARB/shader_subroutine.txt">the ARB_shader_subroutine OpenGL extension</a>.</p>
<p>Shader subroutine functionality allows an application to dynamically alter the code paths executed by a shader at run-time through the NVN API. Shaders can declare subroutine types that can be used by subroutine calls. Subroutine types are conceptually similar to C/C++ function pointer types. Shaders can also declare shader subroutine uniforms using one of the declared subroutine types. Subroutine uniforms are used by shader code similarly to a normal function call. Shader functions that can be assigned to subroutine uniforms are declared using the "subroutine" qualifier and one or more subroutine types. A call using a subroutine uniform in a shader will execute the subroutine function assigned to that uniform by the application.</p>
<p>One possible use of subroutines would have an application shader implement a variety of different lighting algorithms, to evaluate the color of an object based on different object or light properties. In this approach, each algorithm is implemented in a separate subroutine function, and all subroutine functions take the same parameters. The shader makes lighting function calls using a subroutine uniform whose value is selected in the NVN API based on the properties of the objects being rendered.</p>
<p>When GLSL shaders with subroutines are compiled, each subroutine function in a shader stage will get assigned a unique <em>index</em> value, and each subroutine uniform will get assigned a unique <em>location</em> value by the compiler. Explicit layout qualifiers can be used to explicitly control the assignment of index and locations in the shader, otherwise it is the application's responsibility to read the compiler-assigned index and location values from the compiler's reflection information.</p>
<p>For an overview of how to use subroutines via the NVN API, please refer to the shader subroutine section in the NVN programming guide. The rest of this section will focus on the syntax of subroutines as well as reflection data output produced by GLSLC.</p>
<blockquote class="doxtable">
<p><b>NOTE</b>: Performance statistics are not supported in the presence of shader subroutines. If performance statistics are requested for programs using subroutines, the program will be compiled, but a warning will be emitted by GLSLC and no perf stats section will be part of the GLSLC output. </p>
</blockquote>
<h2><a class="anchor" id="nvn_glslc_guide_sec_20_1"></a>
20.1. Syntax</h2>
<p>GLSL shaders using subroutines require 3 basic components: subroutine type declarations, subroutine definitions, and subroutine uniform declarations. Both subroutine functions and subroutine uniforms are declared with a subroutine type, and a subroutine uniform can only be bound to subroutine functions which are declared with the same subroutine type as the uniform.</p>
<h3>Subroutine types</h3>
<p>Subroutine types are defined with the <em>subroutine</em> keyword, and are similar to function prototypes in C-based languages.</p>
<p>The syntax for declaring a subroutine type is:</p>
<div class="fragment"><div class="line">subroutine returnType subroutineTypeName(type0 arg0, type1 arg1, ..., typen argn);</div>
</div><!-- fragment --><p>Similarly to function prototypes in C-based languages, the argument names are optional.</p>
<h3>Subroutines</h3>
<p>Subroutines are functions declared using the "subroutine" keyword, and they implement a specific subroutine type.</p>
<p>The syntax for defining a subroutine is:</p>
<div class="fragment"><div class="line">subroutine(subroutineTypeName0, ..., subroutineTypeNameN)</div>
<div class="line">returnType functionName(type0 arg0, type1 arg1, ..., typen argn)</div>
<div class="line">{ ... } <span class="comment">// function body</span></div>
</div><!-- fragment --><p>Note the type names are inside of the parenthesis after the "subroutine" keyword. A subroutine can be bound to a subroutine uniform declared with any of the types in the type list of the definition of the subroutine. The function parameters and return type must be the same as the types specified in the type list, otherwise an error is thrown. Function overloading for subroutines is not permitted (i.e. no two subroutines can have the same function name in a single shader stage).</p>
<p>GLSL shaders and applications use subroutine functions in one of two ways:</p>
<p>1) Bind the subroutine to a subroutine uniform through the NVN API and use the subroutine uniform in shader code to make a subroutine function call.</p>
<p>2) Call the subroutine function directly in shader code as if it were a non-subroutine function.</p>
<p>The rest of this section will focus on method 1) for actually using subroutine uniforms.</p>
<h3>Subroutine uniforms</h3>
<p>Subroutine uniforms provide the GLSL shader a method to actually call subroutine functions. Subroutine uniforms are defined per shader stage, and the NVN API to bind subroutine uniforms is also per shader stage.</p>
<p>The syntax for declaring a subroutine uniform is:</p>
<div class="fragment"><div class="line">subroutine uniform subroutineTypeName subroutineUniformName;</div>
</div><!-- fragment --><p>Any subroutine function can be bound to a subroutine uniform declared with of the subroutine function's types. Binding subroutine functions to subroutine uniforms is performed through the NVN API.</p>
<p>Subroutine uniforms can also be declared as arrays:</p>
<div class="fragment"><div class="line">subroutine uniform subroutineTypeName subroutineUniformName[arraySize];</div>
</div><!-- fragment --><p>Arrays are assigned contiguous locations from the first element of the array to the last element of the array.</p>
<h3>Layout qualifiers</h3>
<p>Locations and index values for subroutine uniforms and subroutines, respectively, can be explicitly controlled through layout qualifiers in the GLSL shader source.</p>
<p>An example of explicitly declaring a subroutine's index in the GLSL shader:</p>
<div class="fragment"><div class="line">layout (index = 4) subroutine (subroutineTypeName_T) <span class="keywordtype">float</span> function0(<span class="keywordtype">float</span> arg0);</div>
</div><!-- fragment --><p>That would assign the subroutine function named "function0" the index value 4.</p>
<p>An example of declaring a subroutine uniform location in the GLSL shader:</p>
<div class="fragment"><div class="line">layout(location = 5) subroutine uniform subroutineTypeName_T subroutineUniform;</div>
</div><!-- fragment --><p>That would assign the subroutine uniform named "subroutineUniform" to location 5.</p>
<blockquote class="doxtable">
<p><b>NOTE</b>: The total number of active uniform locations is the largest assigned index plus one. When setting subroutine uniforms for a range of consecutive locations including unused locations, the array of subroutine indices must be sized to include the unused locations, but the index values for such locations are ignored. Applications should avoid extraneous unused active uniform locations by assigning locations as close to zero as possible. In cases where the compiler assigns subroutine uniform locations, it will automatically assign locations as close to zero as possible. </p>
</blockquote>
<h3>Calling subroutine uniforms</h3>
<p>A subroutine uniform is used to call a subroutine function by simply using the subroutine uniform like a function. The application selects which function is actually called for each subroutine uniform reference by using the NVN API (see the NVN programming guide for more info).</p>
<p>An example shader utilizing 2 different subroutines of the same type with 2 different subroutine uniforms of the same type can be seen below:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 440</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Define a subroutine type</span></div>
<div class="line">subroutine vec4 subroutineType0 (vec4, <span class="keywordtype">float</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Define 2 subroutine functions of type subroutineType0.  The first function</span></div>
<div class="line"><span class="comment">// performs a scaling operation on the input vec4.  The second function performs</span></div>
<div class="line"><span class="comment">// an additive operation.</span></div>
<div class="line"></div>
<div class="line">layout (index = 0) subroutine(subroutineType0)</div>
<div class="line">vec4 scaleSubroutine (vec4 input, <span class="keywordtype">float</span> scaleAmt) {</div>
<div class="line">    <span class="keywordflow">return</span> input * scaleAmt;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">layout (index = 1) subroutine(subroutineType0)</div>
<div class="line">vec4 additionSubroutine (vec4 input, <span class="keywordtype">float</span> additionAmt) {</div>
<div class="line">    <span class="keywordflow">return</span> input + vec4(additionAmt);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Define a subroutine uniform of type subroutineType0</span></div>
<div class="line">layout (location = 0) subroutine uniform subroutineType0 performOperation0;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Define a subroutine uniform of type subroutineType0</span></div>
<div class="line">layout (location = 1) subroutine uniform subroutineType0 performOperation1;</div>
<div class="line"></div>
<div class="line">uniform Block {</div>
<div class="line">    <span class="keywordtype">float</span> operationAmt;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">in vec4 inColor;</div>
<div class="line">out vec4 outColor;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main() {</div>
<div class="line">    <span class="comment">// Call the subroutine uniforms.  This will either call either</span></div>
<div class="line">    <span class="comment">// scaleSubroutine or additionSbroutine depending on how the</span></div>
<div class="line">    <span class="comment">// application binds the two subroutine uniforms.</span></div>
<div class="line">    outColor = performOperation0(inColor, operationAmt) +</div>
<div class="line">               performOperation1(inColor, operationAmt);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="nvn_glslc_guide_sec_20_2"></a>
20.2. Linkage map</h2>
<p>In order for the NVN driver to associate subroutine uniforms with specific subroutine functions, the driver needs to patch up an internal jump table stored in constant GPU memory. This jump table contains entries for all subroutine uniform calls and contains values that shader instructions use to go to a specific subroutine block of code for execution. In order for the driver to patch this jump table, NVN needs to know how to map subroutine index values and subroutine uniform locations to the specific entries in the jump table at run-time. The data that NVN uses to find this mapping is called a <em>linkage map</em>.</p>
<p>GLSLC outputs linkage maps in the <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> binaries for each shader stage which uses subroutines. The linkage maps are opaque blocks of memory which the application should provide to the NVN driver at run-time before using the programs which contain shader stages with subroutines. This is done via the NVN API call nvnProgramSetSubroutineLinkage (see the NVN programming guide for more details).</p>
<p>The linkage map can be found by using the variables "subroutineLinkageMapOffset" and "subroutineLinkageMapSize" provided as output in GLSLCgpuCodeHeaders for program stages which use shader subroutines. The linkage map data block is in the data section of the GPU code data for that stage. The application uses these variables to retrieve the linkage map block similarly to how an application would retrieve the GPU program control and data sections for use with the NVN API. If subroutineLinkageMapSize == 0, then no subroutine linkage is associated with that shader stage (because no subroutines were used in the shader).</p>
<div class="fragment"><div class="line"><span class="comment">// Assume glslcOutput is a pointer to a GLSLCoutput block of memory from GLSLC.</span></div>
<div class="line"><span class="comment">// Assume stage is an NVNshaderStage that the application is searching for that</span></div>
<div class="line"><span class="comment">// was compiled with subroutines.</span></div>
<div class="line"><span class="keywordtype">void</span> * linkageMapData = NULL;</div>
<div class="line"><span class="keywordtype">int</span>    linkageMapSize = 0;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Loop over all sections of the GLSLCoutput.</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; glslcOutput-&gt;numSections; ++i) {</div>
<div class="line">    <span class="comment">// Linkage data comes with the GLSLCgpuCodeHeaders, so look for that.</span></div>
<div class="line">    <span class="keywordflow">if</span> (glslcOutput-&gt;headers[i].genericHeader.common.type ==</div>
<div class="line">        <a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59a332c55c4b44004865dda7d54c91df448">GLSLC_SECTION_TYPE_GPU_CODE</a>) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Get a pointer to the header.</span></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_cgpu_code_header.html">GLSLCgpuCodeHeader</a> *gpuCodeHeader =</div>
<div class="line">            (<span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_cgpu_code_header.html">GLSLCgpuCodeHeader</a> *)(&amp;glslcOutput-&gt;headers[i].gpuCodeHeader);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// This is not the stage we&#39;re looking for.</span></div>
<div class="line">        <span class="keywordflow">if</span> (gpuCodeHeader-&gt;<a class="code" href="struct_g_l_s_l_cgpu_code_header.html#ab1e6be676a326a7281e18ad3a4607ced">stage</a> != stage) {</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Get a pointer to the GPU code section&#39;s data block.  This data block also</span></div>
<div class="line">        <span class="comment">// constains control data and GPU code data.</span></div>
<div class="line">        <span class="keywordtype">char</span> * data = (<span class="keywordtype">char</span> *)glslcOutput + gpuCodeHeader-&gt;common.<a class="code" href="struct_g_l_s_l_csection_header_common.html#abb6e96b70bad30c94477317328d384d5">dataOffset</a>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Get the subroutine information.</span></div>
<div class="line">        if (gpuCodeHeader-&gt;<a class="code" href="struct_g_l_s_l_cgpu_code_header.html#a45f8174e850ec8ff2ffbb678032f6ec7">subroutineLinkageMapSize</a> == 0) {</div>
<div class="line">            <span class="comment">// No linkage map for this stage.</span></div>
<div class="line">            <span class="keywordflow">return</span> NULL;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Offset into the data block to get the linkage map info.</span></div>
<div class="line">        linkageMapData = data + gpuCodeHeader-&gt;<a class="code" href="struct_g_l_s_l_cgpu_code_header.html#a3691577caae8cb572efc2f9db9dc422c">subroutineLinkageMapOffset</a>;</div>
<div class="line">        linkageMapSize = gpuCodeHeader-&gt;<a class="code" href="struct_g_l_s_l_cgpu_code_header.html#a45f8174e850ec8ff2ffbb678032f6ec7">subroutineLinkageMapSize</a>;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>See the NVN programming guide for more information on how to use the linkage map.</p>
<h2><a class="anchor" id="nvn_glslc_guide_sec_20_3"></a>
20.3. Reflection Info</h2>
<p>GLSLC provides reflection functionality similar to what is provided by the program interface query extensions defined in <a href="https://www.opengl.org/registry/specs/ARB/shader_subroutine.txt">the ARB_shader_subroutine OpenGL extension</a> In particular, GLSLC outputs information about all subroutines and subroutine uniforms as well as which subroutines index values each subroutine uniform is compatible with. All reflection information is part of the GLSLC_SECTION_TYPE_REFLECTION sections of the <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a>.</p>
<p>Since subroutines and subroutine uniforms are part of per-stage interfaces, <a class="el" href="struct_g_l_s_l_csubroutine_info.html" title="An information data section corresponding to individual subroutines. ">GLSLCsubroutineInfo</a> and <a class="el" href="struct_g_l_s_l_csubroutine_uniform_info.html" title="An information data section corresponding to individual subroutine uniforms. ">GLSLCsubroutineUniformInfo</a> both contain "stage" members to identify the stage of the variable. This is different than the "stagesReferencedIn" mask used in other variables since different subroutines and subroutine uniforms are allowed to have the same name in different stages.</p>
<h3>Compatible subroutine indices.</h3>
<p>Each subroutine can be bound to a set of subroutines of the same subroutine type. The list of index values that are compatible with each subroutine are provided as part of the reflection section. The reflection variables <a class="el" href="struct_g_l_s_l_cprogram_reflection_header.html#ad6b0ae6b0c1f5d2faa2156882fa448bc" title="Offset into the data section to the start of the compatible index pool data. ">GLSLCprogramReflectionHeader::subroutineCompatibleIndexPoolOffset</a> and <a class="el" href="struct_g_l_s_l_cprogram_reflection_header.html#a02992b377c2a8a053792007e65a36645" title="Size of the pool (in bytes) containing index values for subroutine uniforms corresponding to the subr...">GLSLCprogramReflectionHeader::subroutineCompatibleIndexPoolSize</a> can be used to locate the block of memory containing indices for all subroutine uniforms' compatible subroutines.</p>
<p>An example on how to find the compatible subroutine index values for a single subroutine uniform can be seen below:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> * compatibleIndexPoolPtr = NULL;</div>
<div class="line"><span class="keywordtype">int</span> numCompatibleSubroutines = 0;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Find the compatible index pool.  Loop through all the sections in the GLSLCoutput,</span></div>
<div class="line"><span class="comment">// find the reflection section, get a pointer to the reflection data, then get a pointer</span></div>
<div class="line"><span class="comment">// to the compatible index pool.</span></div>
<div class="line"><span class="comment">// Assume &quot;subroutineUniformInfo&quot; is a GLSLCuniformInfo pointer previously set to the uniform info</span></div>
<div class="line"><span class="comment">// whose compatible subroutine index values we are looking for.</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; glslcOutput-&gt;numSections; ++i) {</div>
<div class="line">    <span class="keywordflow">if</span> (glslcOutput-&gt;headers[i].genericHeader.common.type ==</div>
<div class="line">        <a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59a9af0dfcdde630017c24029fa35ed8849">GLSLC_SECTION_TYPE_REFLECTION</a>) {</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html">GLSLCprogramReflectionHeader</a> * reflectionHeader =</div>
<div class="line">                            &amp;glslcOutput-&gt;headers[i].programReflectionHeader;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span> * reflectionData =</div>
<div class="line">                            (<span class="keyword">const</span> <span class="keywordtype">char</span>*)glslcOutput + reflectionHeader-&gt;common.<a class="code" href="struct_g_l_s_l_csection_header_common.html#abb6e96b70bad30c94477317328d384d5">dataOffset</a>;</div>
<div class="line"></div>
<div class="line">        compatibleIndexPoolPtr = reflectionData + reflectionHeader-&gt;<a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#ad6b0ae6b0c1f5d2faa2156882fa448bc">subroutineCompatibleIndexPoolOffset</a>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">numCompatibleSubroutines = subroutineUniformInfo-&gt;numCompatibleSubroutines;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> * compatibleIndicesPtr =</div>
<div class="line">            (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *)(compatibleIndexPoolPtr + subroutineUniformInfo-&gt;compatibleSubroutineInfoOffset);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Print every subroutine index compatible with this uniform.</span></div>
<div class="line">printf(<span class="stringliteral">&quot;The subroutine uniform at location %d is compatible with&quot;</span></div>
<div class="line">       <span class="stringliteral">&quot;these subroutine index values:\n&quot;</span>, subroutineUniformInfo-&gt;location);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numCompatibleSubroutines; ++i) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Subroutine index %d\n&quot;</span>, compatibleIndicesPtr[i]);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="nvn_glslc_guide_sec_21"></a>
21. SPIR-V support</h1>
<p>GLSLC is able to accept SPIR-V binaries as input. SPIR-V is an intermediate language representation of shader programs, and is maintained by Khronos. When using SPIR-V binaries as input into GLSLC, the compiled result will be a <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> with the same format as if it were compiled from GLSL programs. No additional API commands are required in order to use the binary with NVN.</p>
<p>GLSLC does not produce SPIR-V binaries, but rather SPIR-V binaries need to be produced by separate tools as appropriate, and the SPIR-V binaries need to follow the SPIR-V environment specification detailed in <a href="#nvn_glslc_guide_spirv_spec">this subsection</a>. SPIR-V does not need to be generated from GLSL, but can be generated from other source languages as long as the SPIR-V modules that are produced follow the rules in the specifiction.</p>
<h2><a class="anchor" id="nvn_glslc_guide_sec_21_1"></a>
21.1. Usage</h2>
<p>GLSLC provides an API for using SPIR-V binaries as input. The enumeration GLSLClanguageTypeEnum::GLSLC_LANGUAGE_SPIRV should be specified as part of the <a class="el" href="struct_g_l_s_l_coption_flags.html#ac8db49e611084ad2bf89db26904fe4d4" title="Specify the language of the input shaders. ">GLSLCoptionFlags::language</a> field.</p>
<p>The <a class="el" href="struct_g_l_s_l_cinput.html" title="A structure used as input into GLSLC functions. ">GLSLCinput</a> structure provides multiple entries related to using SPIR-V for input when using GLSLClanguageTypeEnum::GLSLC_LANGUAGE_SPIRV.</p>
<ul>
<li>GLSLCinput::sources - If <a class="el" href="struct_g_l_s_l_coption_flags.html#ac8db49e611084ad2bf89db26904fe4d4" title="Specify the language of the input shaders. ">GLSLCoptionFlags::language</a> is GLSLC_LANGUAGE_SPIRV, then GLSLC interprets each pointer to the input sources as a block of binary data containing a single SPIR-V module instead of character strings. For more information on what constitutes a valid SPIR-V module, see <a href="#nvn_glslc_guide_spirv_spec">this subsection</a>. Like GLSL compilation, the GLSLCinput::stages field indicates which shader stage each SPIR-V module corresponds to.</li>
<li>GLSLCinput::spirvEntryPointNames - This is optional (allowed to be NULL). Additionally, each entry is optional as well, but if GLSLCinput::spirvEntryPointNames is non-NULL, then each entry needs to have some value (NULL or otherwise). This is an array, with <a class="el" href="struct_g_l_s_l_cinput.html#a2dd94f2657ef155e688d6a9927c6c381" title="Number of entries in both the sources and stages arrays. ">GLSLCinput::count</a> entries, of NULL-terminated strings. Each string corresponds to the name of the entry point to select for compilation within the SPIR-V binary in the associated entry in GLSLCinput::sources. If this field is NULL, then the string "main" will be used as default. See the SPIR-V specification about what constitutes a valid entry point.</li>
<li>GLSLCinput::spirvModuleSizes - This must be non-NULL if compiling SPIR-V shaders. This is an array, with <a class="el" href="struct_g_l_s_l_cinput.html#a2dd94f2657ef155e688d6a9927c6c381" title="Number of entries in both the sources and stages arrays. ">GLSLCinput::count</a> entries, of unsigned 32-bit integers containing the size of the SPIR-V binary (in bytes) of the associated entry in the GLSLCinput::sources array.</li>
<li>GLSLCinput::spirvSpecInfo - This is optional (allowed to be NULL). This is an array, with <a class="el" href="struct_g_l_s_l_cinput.html#a2dd94f2657ef155e688d6a9927c6c381" title="Number of entries in both the sources and stages arrays. ">GLSLCinput::count</a> entries, of pointers to <a class="el" href="struct_g_l_s_l_cspirv_specialization_info.html" title="A structure used for specifying a shader stage&#39;s SPIR-V constant specialization data. ">GLSLCspirvSpecializationInfo</a> structures. These structures are used to specify SPIR-V specialization constants and their specialized values. This is different than the normal GLSLC specialization which can be done independently of the SPIR-V specialization. See the SPIR-V specification for more information about specialization constants. Unlike traditional GLSLC specialization, there is no way to obtain "batch" compiles. In other words, SPIR-V specialization allows for single compilation only with <a class="el" href="nvn_tool___glslc_interface_8h.html#ad0fd458cbbcd554a1dc81ac61fdcf7e3" title="Compile source shaders using a previously initialized GLSLCcompileObject. ">glslcCompile()</a>.</li>
</ul>
<h2><a class="anchor" id="nvn_glslc_guide_spirv_spec"></a>
21.2. SPIR-V execution environment and GLSLC SPIR-V specification</h2>
<p>Regardless of source language that the SPIR-V modules are generated from, SPIR-V producers that wish to generate SPIR-V modules valid with GLSLC for NVN must follow the SPIR-V execution environment specification defined in <a href="https://www.opengl.org/registry/specs/ARB/gl_spirv.txt">ARB_gl_spirv specification</a> (under the section listing additions for Appendex A.spv called "The OpenGL
SPIR-V Execution Environment") with the exceptions stated below:</p>
<ul>
<li>The UniformConstant storage class can not be used on individual variables at global scope unless they are of type OpTypeSampledImage or OpTypeImage (corresponding to GLSL's sampler and image types repsectively).</li>
<li>The "Binding" decoration for each resource type allows for per-stage bindings, where a "Binding" literal for a resource in one shader stage (i.e. SPIR-V module) does not take up binding points in other modules. Additionally, SPIR-V uniform resources in a single SPIR-V module will have the behavior as laid out in the <a href="#nvn_glslc_guide_uniforms">Uniforms</a> section of this document.</li>
<li>OpTypeSampler and OpTypeImage are allowed in the context of separate sampler/texture functionality.</li>
</ul>
<blockquote class="doxtable">
<p>Note: The GLSL-level correspondence of these exceptions can be found in <a href="#nvn_glslc_glsl_differences">this section</a>. Many GLSL differences listed in that section are also already subsumed in the <a href="https://www.opengl.org/registry/specs/ARB/gl_spirv.txt">ARB_gl_spirv specification</a> for the corresponding SPIR-V restrictions. </p>
</blockquote>
<h2><a class="anchor" id="nvn_glslc_guide_sec_21_3"></a>
21.3. Usage Example</h2>
<p>The following is a simple example of using SPIR-V binaries with GLSLC. We assume the binaries were generated by some tool and loaded into the application already via traditional file loading procedures.</p>
<div class="fragment"><div class="line"><span class="comment">// Assume a variable called &quot;compileObject&quot; which is a GLSLCcompileObject has already been</span></div>
<div class="line"><span class="comment">// initialized by the application.  Also assume the function LOAD_FILE_FROM_DISK</span></div>
<div class="line"><span class="comment">// is an application-defined function that reads a SPIR-V binary module from disk, outputs</span></div>
<div class="line"><span class="comment">// the size (in bytes) of that module into the second parameter as output, and returns a pointer</span></div>
<div class="line"><span class="comment">// to the binary loaded up into memory.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Variables to hold the SPIR-V module binary sizes (in bytes).</span></div>
<div class="line">uint32_t vertexSpirvModuleSize = 0;</div>
<div class="line">uint32_t fragmentSpirvModuleSize = 0;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Pointers to each of the SPIR-V module binaries loaded into application memory.</span></div>
<div class="line"><span class="comment">// Note - GLSLC does not produce SPIR-V modules, it only consumes them.  SPIR-V modules need to be</span></div>
<div class="line"><span class="comment">// constructed with separate tools as appropriate.</span></div>
<div class="line"><span class="keywordtype">void</span> * vertexSpirvModule   = LOAD_FILE_FROM_DISK(<span class="stringliteral">&quot;vert.spv&quot;</span>, &amp;vertexSpirvModuleSize);</div>
<div class="line"><span class="keywordtype">void</span> * fragmentSpirvModule = LOAD_FILE_FROM_DISK(<span class="stringliteral">&quot;frag.spv&quot;</span>, &amp;fragmentSpirvModuleSize);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> * spirvModules[2] = {</div>
<div class="line">    vertexSpirvModule,</div>
<div class="line">    fragmentSpirvModule</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">uint32_t spirvModuleSizes[2] = {</div>
<div class="line">    vertexSpirvModuleSize,</div>
<div class="line">    fragmentSpirvModuleSize</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Set up an array to select the entry points for each corresponding SPIR-V module.  The entry</span></div>
<div class="line"><span class="comment">// points below are only used as examples.  Additionally, any or all of these array entries can</span></div>
<div class="line"><span class="comment">// be NULL and the entry point &quot;main()&quot; would be chosen by default.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> * entryPoints[2] = {</div>
<div class="line">    <span class="stringliteral">&quot;main&quot;</span>,             <span class="comment">// For the vertex module, choose main() as the entry point.</span></div>
<div class="line">    <span class="stringliteral">&quot;multisample_main&quot;</span>, <span class="comment">// For the fragment module, choose multisample_main() as the entry point.</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Select SPIR-V as the input language.</span></div>
<div class="line">compileObject.<a class="code" href="struct_g_l_s_l_ccompile_object.html#a6cc042ea5fe41d3aa6c9fac773a447b8">options</a>.<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a class="code" href="struct_g_l_s_l_coption_flags.html#ac8db49e611084ad2bf89db26904fe4d4">language</a> = <a class="code" href="nvn_tool___glslc_interface_8h.html#a2d6ec24544353b8978008330e2a1f52ba7de6685da3123976fc56e312e02e92fd">GLSLC_LANGUAGE_SPIRV</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Set the sources to point to the array containing pointers to each of the</span></div>
<div class="line"><span class="comment">// stages&#39; SPIR-V modules</span></div>
<div class="line">compileObject.<a class="code" href="struct_g_l_s_l_ccompile_object.html#a1439e7a28e5232e1dc82924e8c4d063d">input</a>.sources = (<span class="keyword">const</span> <span class="keywordtype">char</span> **)spirvModules;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Specify the SPIR-V module binary sizes (in bytes).  This is required for SPIR-V input.</span></div>
<div class="line">compileObject.<a class="code" href="struct_g_l_s_l_ccompile_object.html#a1439e7a28e5232e1dc82924e8c4d063d">input</a>.spirvModuleSizes = spirvModuleSizes;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Specify the number of stages (SPIR-V modules) in the input arrays.  This is similar to GLSL input.</span></div>
<div class="line">compileObject.<a class="code" href="struct_g_l_s_l_ccompile_object.html#a1439e7a28e5232e1dc82924e8c4d063d">input</a>.<a class="code" href="struct_g_l_s_l_cinput.html#a2dd94f2657ef155e688d6a9927c6c381">count</a> = 2;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Tell GLSLC which entry points to select.  This value could be NULL as well, in which case</span></div>
<div class="line"><span class="comment">// &quot;main()&quot; would be selected as default for all the SPIR-V modules.</span></div>
<div class="line">compileObject.<a class="code" href="struct_g_l_s_l_ccompile_object.html#a1439e7a28e5232e1dc82924e8c4d063d">input</a>.spirvEntryPointNames = entryPoints;</div>
<div class="line"></div>
<div class="line"><span class="comment">// We choose not to specialize any SPIR-V specialization constants in this example.  Any</span></div>
<div class="line"><span class="comment">// specialization constants in the SPIR-V binary will have the initialization value assigned</span></div>
<div class="line"><span class="comment">// to it in the SPIR-V binary chosen as default.</span></div>
<div class="line">compileObject.<a class="code" href="struct_g_l_s_l_ccompile_object.html#a1439e7a28e5232e1dc82924e8c4d063d">input</a>.spirvSpecInfo = NULL;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Compile the SPIR-V modules and produce a GLSLCoutput structure.</span></div>
<div class="line"><a class="code" href="nvn_tool___glslc_interface_8h.html#ad0fd458cbbcd554a1dc81ac61fdcf7e3">glslcCompile</a>(&amp;compileObject);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Copy the compileObject.lastCompiledResults-&gt;glslcOutput to an application-allocated region of memory.</span></div>
<div class="line"><span class="comment">// All steps after this are the same as if using GLSL input.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Perform any additional processing of GLSLCoutput as normal.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Use generated binary as normal with NVN</span></div>
</div><!-- fragment --><h2><a class="anchor" id="nvn_glslc_guide_sec_21_4"></a>
21.4. Limitations</h2>
<p>Certain capabilities will not function with SPIR-V input. These are:</p>
<ul>
<li>Subroutines - SPIR-V does not support shader subroutines</li>
<li>#include support - Any #include support will need to be done at the source level by the SPIR-V producer itself.</li>
<li>Debug support - Support in future versions of GLSLC is TBD.</li>
<li>Resource limits - The HW limits of NX and NVN need to be enforced by any SPIR-V producer.</li>
<li>Reflection section - Reflection data for SPIR-V binaries will reflect the information contained in the binary itself. If certain reflection properties are not available in the SPIR-V module, then those properties will not be enumerated by GLSLC.</li>
<li>Some NV-only extension (such as NV_gpu_shader5) functionality don't have corresponding support in SPIR-V.</li>
</ul>
<h1><a class="anchor" id="nvn_glslc_guide_sec_22"></a>
22. Separate Sampler and Texture Uniforms</h1>
<p>Beginning with GLSLC API version 17.15, GLSLC can compile shaders that make use of separate sampler-only or texture-only uniforms. A separate sampler uniform contains only sampler information and no texture storage information. A separate texture uniform contains only texture storage information but no sampler information. These two handles can be combined within the shader to create a combined sampler/texture handle for use with texture lookups. The SPIR-V specification supports separate texture and separate sampler uniform types. GLSL supported by NVN does not have bound sampler-only or texture-only uniform types, but the feature can still be used with GLSL shaders via bindless integer handles (see subsequent sub-sections of this chapter).</p>
<p>The SPIR-V specification supports texture-only types (OpTypeImage) and sampler-only types (OpTypeSampler). If GLSLC compiles a SPIR-V binary using one of these types, then the output reflection section will have entries for these uniforms. Separate sampler and texture uniforms are reported the same way as combined texture/sampler uniforms or image uniforms. The uniform's GLSLCpiqUniformKind::kind value will be set to the new GLSLC_PIQ_UNIFORM_KIND_TEXTURE enum for separate texture-only uniforms, or for separate sampler-only uniforms the value will be set to GLSLC_PIQ_UNIFORM_KIND_SAMPLER. The GLSLCuniform::type value of GLSLC_PIQ_TYPE_SAMPLER will indicate the sampler is a separate sampler-only uniform.</p>
<blockquote class="doxtable">
<p>Note: Some tools that provide GLSL to SPIR-V conversion capabilities provide support for bound separate samplers and textures in the GLSL shader via the KHR_vulkan_glsl extension. Usage of such conversion tools is outside the scope of this document, but any well-formed SPIR-V binary can be used as input to GLSLC, provided that the binary only uses NVN-supported features. For information on which SPIR-V features are acceptable, see <a href="#nvn_glslc_guide_spirv_spec">the section discussing the SPIR-V execution environment</a>. </p>
</blockquote>
<h2><a class="anchor" id="nvn_glslc_guide_sec_22_1"></a>
22.1. Limits</h2>
<p>GLSLC supports up to 32 separate sampler uniforms and up to 128 separate texture uniforms per stage. This is in addition to the existing 32 combined sampler/texture uniforms and 8 image uniforms per stage.</p>
<p>For information on how to bind to and execute programs that use separate sampler and texture uniforms, see the NVN Programming Guide.</p>
<h2><a class="anchor" id="nvn_glslc_guide_sec_22_2"></a>
22.2. Bindless Separate Sampler and Texture Handles</h2>
<p>Shaders can be written to use separate sampler and texture handles inside uniform buffers instead of as bound uniforms. This can be accomplished in shader code by defining the sampler-only and texture-only handles in a uniform buffer in the shader, and then combining them for texture operations using a bitwise OR of the two handles.</p>
<p>For example, the following shader using combined texture/sampler bindless handles: </p><pre class="fragment">#version 440
#extension GL_NV_gpu_shader5 : enable

uniform buf {
    // Contains a combined sampler/texture handle
    uint64_t sampTexHandle;
};

out vec4 col;

void main()
{
  // Uses the sampler2D constructor to create a sampler.
  col = texture2D(sampler2D(sampTexHandle), vec2(0.5, 0.5));
}
</pre><p>can be re-written to use separate sampler-only and texture-only handles: </p><pre class="fragment">#version 440
#extension GL_NV_gpu_shader5 : enable

uniform buf {
    // Contains a separate sampler-only handle.
    uint64_t sampHandle;

    // Contains a separate texture-only handle.
    uint64_t texHandle;
};

out vec4 col;

void main()
{
  // Combine the sampler-only and texture-only handle to use in a sampler2D constructor.
  uint64_t sampTexHandle = sampHandle | texHandle;

  // Use the combined handle.
  col = texture2D(sampler2D(sampTexHandle), vec2(0.5, 0.5));
}
</pre><p>The application would need to make sure that the memory backing the uniform buffer contains the sampler-only and texture-only handles. The application can obtain such handles via the NVN API functions nvnDeviceGetSeparateSamplerHandle and nvnDeviceGetSeparateTextureHandle. See the NVN Programming Guide for more information about these API functions and types.</p>
<h1><a class="anchor" id="nvn_glslc_guide_sec_23"></a>
23. Comparing compiled programs for functional equality</h1>
<p>Sometimes it might be desirable to compare two compiled programs' GPU code to determine if, regardless of difference of input options / shader source, the programs have the same compiled code. The application can compare the control subsections and data subsections to determine if two programs are functionally equivalent. Most of the bytes should be the same, but there are a few bytes which may be different between two compiles which do not functionally contribute to the compiled code. Applications can safely ignore these bytes in the control subsection when comparing for functional equality:</p>
<table class="doxtable">
<tr>
<th>Ignorable bytes </th><th>Description  </th></tr>
<tr>
<td>1896 through 1911 </td><td>Build ID </td></tr>
<tr>
<td>1912 through 1919 </td><td>Debug data hash </td></tr>
<tr>
<td>2000 through 2007 </td><td>Source hash (i.e. GLSL source or SPIR-V binary) </td></tr>
<tr>
<td>2008 through 2015 </td><td>GLASM hash </td></tr>
<tr>
<td>2016 through 2023 </td><td>Microcode hash </td></tr>
</table>
<p>Note that even though two compiled programs might be functionally equivalent, the debug data from one program will most likely not be valid with the other program. Other sections, such as reflection information, might be different as well even though the compiled code is the same.</p>
<h2><a class="anchor" id="nvn_glslc_guide_sec_23_1"></a>
23.1. Specialized fat binaries</h2>
<p>When shader specialization is used, multiple binaries produced from the same shader source could have very similar control sections. Control sections basically consist of two opaque parts: meta-information for setting up the GPU hardware, and "fat binary" information for re-creating the program on the Windows platform for the target GPU at run-time. When using "fat binaries" (i.e. the <a class="el" href="struct_g_l_s_l_coption_flags.html#acb869c3adcd98163305142fba3d84e2b" title="Controls whether the resulting output contains a GPU program that is a thin binary (only contains pro...">GLSLCoptionFlags::outputThinGpuBinaries</a> <em>not</em> enabled), each program still includes a full control section for each shader stage even though the "common" part may be the same as the other programs in the same specialization batch. In order to save space on disk when storing fat binaries using such specialization, applications could detect when the "common" part of the control section is identical between programs (or nearly identical if taking the above debug information into account), and only store one copy of the "common" part plus <em>N</em> copies of the "fat binary" parts (where <em>N</em> is the number of control sections produced from the same GLSL source) in order to save space on disk. These control sections can then be reassembled with their constituent "fat binary" parts prior to an nvnProgramSetShaders call.</p>
<p>There are entries in the binary control section which can help applications to manipulate these sections for "fat binaries" as it sees fit. For "thin binaries", these entries are irrelevant. The data for these entries is obtained by taking an "offset" parameter which represents the number of bytes from the beginning of the control section the data resides, and a "size" parameter which represents the size in bytes of the data. The byte offsets of these "offset" and "size" parameters into the control section for each piece of data are listed below:</p>
<table class="doxtable">
<tr>
<th>Data </th><th>Offset bytes </th><th>Size bytes  </th></tr>
<tr>
<td>Assembly </td><td>20 through 23 </td><td>24 through 27 </td></tr>
<tr>
<td>Assembly locals </td><td>32 through 35 </td><td>28 through 31 </td></tr>
<tr>
<td>Specialization </td><td>1776 through 1779 </td><td>1780 through 1783 </td></tr>
<tr>
<td>Pragmas </td><td>1992 through 1995 </td><td>1996 through 1999 </td></tr>
<tr>
<td>64-bit uniforms </td><td>2024 through 2027 </td><td>2028 through 2031 </td></tr>
</table>
<p>For example, an application can determine where the specialization parameter data resides inside a fat binary's control section by reading the 4-byte value starting at byte 1776 in the control section.</p>
<p>Applications should not try to extract any data if using thin binaries.</p>
<h1><a class="anchor" id="nvn_glslc_guide_sec_24"></a>
24. GLASM internal limits</h1>
<p>GLSLC internally uses GLASM as an intermediate representation when compiling from either GLSL or SPIR-V before going to microcode. There are internal limits imposed by the compiler (either due to HW constraints or implementation-dependent factors) which may cause errors if input source shaders causes the compiler to produce intermediate GLASM which exceeds these limits. Although these limits don't have a 1:1 correspondence to GLSL, and hitting these limits is rare in practice, knowing the limits is useful for debugging potential related errors that the compiler might report.</p>
<p>The GLASM limits that the compiler currently imposes which might be hit when compiling from GLSL or SPIR-V shaders are:</p>
<table class="doxtable">
<tr>
<th>Variable type </th><th>Limit </th><th>Description  </th></tr>
<tr>
<td>Instructions </td><td>131072 in all stages </td><td>Maximum GLASM instructions per shader stage </td></tr>
<tr>
<td>Max temp count </td><td>4096 in all stages </td><td>Maximum number of GLASM temporaries per shader stage </td></tr>
<tr>
<td>Max param count </td><td>1024 in all stages </td><td>Maximum number of program parameters per shader stage </td></tr>
<tr>
<td>Max address registers </td><td>2 in vertex stage, 1 in fragment stage, 0 in all other stages </td><td>Maximum number of program address registers per shader stage </td></tr>
<tr>
<td>Attributes </td><td>16 in graphics stages, 4 in compute </td><td>Maximum number of program attributes per shader stage </td></tr>
<tr>
<td>Call depth </td><td>32 in all stages </td><td>Maximum call stack depth per shader stage </td></tr>
<tr>
<td>If depth </td><td>1024 in all stages </td><td>Maximum nested if conditionals per shader stage </td></tr>
<tr>
<td>Loop depth </td><td>1024 in all stages </td><td>Maximum nested loops per shader stage </td></tr>
<tr>
<td>Local parameters </td><td>1024 in vertex and fragment stages, 512 in all other stages </td><td>Maximum number of program local parameters per shader stage </td></tr>
<tr>
<td>Environment parameters </td><td>256 in all stages </td><td>Maximum number of program environment parameters per shader stage </td></tr>
</table>
<p>How the compiler translates GLSL and SPIR-V shaders to intermediate GLASM variables listed in the table is an internal implementation detail.</p>
<p>For more information on these variable types, consult OpenGL's ARB_vertex_program and ARB_fragment_program specifications.</p>
<blockquote class="doxtable">
<p>Note: In practice, it is rare and unexpected to see shaders which cause us to hit these limits. Some of these limits are based on implementation-dependent factors and might be increased or eliminated in future versions of GLSLC. </p>
</blockquote>
<h1><a class="anchor" id="nvn_glslc_guide_knownissues"></a>
25. Known Issues</h1>
<p>Please consult the GLSLC release notes for all known issues corresponding to the version of GLSLC being used.</p>
<h1><a class="anchor" id="nvn_glslc_guide_terminology"></a>
26. Terminology</h1>
<table class="doxtable">
<tr>
<th>Term </th><th>Description  </th></tr>
<tr>
<td>Fat binary </td><td>The GPU code section of the <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> structure which can be used directoy on all NVN platforms without modification. </td></tr>
<tr>
<td>GPU code section </td><td>Section of the <a class="el" href="struct_g_l_s_l_coutput.html" title="Main GLSLC output structure. ">GLSLCoutput</a> structure containing the control and data sections to use with the NVN API for importing shader code. </td></tr>
</table>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
