<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>NintendoSDK API Reference: nn::lmem 名前空間</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>総合概要</span></a></li>
      <li><a href="pages.html"><span>諸情報</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li class="current"><a href="namespaces.html"><span>名前空間</span></a></li>
      <li><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>名前空間一覧</span></a></li>
      <li><a href="namespacemembers.html"><span>名前空間メンバ</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1lmem.html">lmem</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">クラス</a> &#124;
<a href="#typedef-members">型定義</a> &#124;
<a href="#enum-members">列挙型</a> &#124;
<a href="#var-members">変数</a>  </div>
  <div class="headertitle">
<div class="title">nn::lmem 名前空間</div>  </div>
</div><!--header-->
<div class="contents">

<p>Cafe SDK, CTR-SDK と同等機能を持つ動的メモリ確保ライブラリの名前空間です。  
<a href="#details">[詳解]</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
クラス</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1lmem_1_1_frame_heap_state.html">FrameHeapState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">フレームヒープの状態を保存する構造体です。  <a href="structnn_1_1lmem_1_1_frame_heap_state.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1lmem_1_1_memory_range.html">MemoryRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ領域の範囲を表す構造体です。  <a href="structnn_1_1lmem_1_1_memory_range.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
型定義</h2></td></tr>
<tr class="memitem:a26608eb2d71f7595fca7793432c30f6f"><td class="memItemLeft" align="right" valign="top">typedef detail::HeapHead&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a26608eb2d71f7595fca7793432c30f6f">HeapCommonHead</a></td></tr>
<tr class="memdesc:a26608eb2d71f7595fca7793432c30f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ヒープ共通ヘッダです。  <a href="#a26608eb2d71f7595fca7793432c30f6f">[詳解]</a><br /></td></tr>
<tr class="separator:a26608eb2d71f7595fca7793432c30f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab893a05f9834a881447ea604c7d60400"><td class="memItemLeft" align="right" valign="top">typedef struct detail::HeapHead *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a></td></tr>
<tr class="memdesc:ab893a05f9834a881447ea604c7d60400"><td class="mdescLeft">&#160;</td><td class="mdescRight">ヒープ共通ハンドルです。  <a href="#ab893a05f9834a881447ea604c7d60400">[詳解]</a><br /></td></tr>
<tr class="separator:ab893a05f9834a881447ea604c7d60400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f98df324bfdc3ff6e67337aa06232ef"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a0f98df324bfdc3ff6e67337aa06232ef">HeapVisitor</a>) (void *pBlock, <a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, uintptr_t userParam)</td></tr>
<tr class="memdesc:a0f98df324bfdc3ff6e67337aa06232ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリブロックを巡るときに呼び出されるコールバック関数の型です。  <a href="#a0f98df324bfdc3ff6e67337aa06232ef">[詳解]</a><br /></td></tr>
<tr class="separator:a0f98df324bfdc3ff6e67337aa06232ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
列挙型</h2></td></tr>
<tr class="memitem:a18e9eac338e3880aeee1459519b00886"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a18e9eac338e3880aeee1459519b00886">AdjustMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a18e9eac338e3880aeee1459519b00886a5c25952febdf7156503bf7dd70f1e703">AdjustMode_Tail</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a18e9eac338e3880aeee1459519b00886a5c7383dad293f4b1c10380b8a41f59d1">AdjustMode_Head</a> = -1
<br />
 }<tr class="memdesc:a18e9eac338e3880aeee1459519b00886"><td class="mdescLeft">&#160;</td><td class="mdescRight">ヒープ領域を縮小する種別を表す定数です。  <a href="namespacenn_1_1lmem.html#a18e9eac338e3880aeee1459519b00886">[詳解]</a><br /></td></tr>
<tr class="separator:a18e9eac338e3880aeee1459519b00886"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a4302ad21b1a099adf611aa15400cd06b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a4302ad21b1a099adf611aa15400cd06b">AllocationDirection</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a4302ad21b1a099adf611aa15400cd06ba7f33d3263e63f24f45a768189a9ee8e9">AllocationDirection_Front</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a4302ad21b1a099adf611aa15400cd06babe4b1359d27860a53a1ad5e1b3b628c8">AllocationDirection_Rear</a> = 1
<br />
 }<tr class="memdesc:a4302ad21b1a099adf611aa15400cd06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリブロック確保の方向を指定するための定数です。  <a href="namespacenn_1_1lmem.html#a4302ad21b1a099adf611aa15400cd06b">[詳解]</a><br /></td></tr>
<tr class="separator:a4302ad21b1a099adf611aa15400cd06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a4a7319ff4369a7278582dd53a1129f73"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a4a7319ff4369a7278582dd53a1129f73">AllocationMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a4a7319ff4369a7278582dd53a1129f73a101b6b812bb866cd80f042ef3ff95168">AllocationMode_FirstFit</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a4a7319ff4369a7278582dd53a1129f73ae6e6a0e6cddfc1146e912f4017c1c161">AllocationMode_BestFit</a> = 1
<br />
 }<tr class="memdesc:a4a7319ff4369a7278582dd53a1129f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリブロック確保のモードです。  <a href="namespacenn_1_1lmem.html#a4a7319ff4369a7278582dd53a1129f73">[詳解]</a><br /></td></tr>
<tr class="separator:a4a7319ff4369a7278582dd53a1129f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a5200a4ef197dbd700f31a3111eacf5b2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a5200a4ef197dbd700f31a3111eacf5b2">CreationOption</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a5200a4ef197dbd700f31a3111eacf5b2a30c3b2cd8b36e40049c5c88b7c47a45f">CreationOption_NoOption</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a5200a4ef197dbd700f31a3111eacf5b2a00853f3b9861cc1c8c36508a2d4c8b4a">CreationOption_ZeroClear</a> = (1 &lt;&lt; 0), 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a5200a4ef197dbd700f31a3111eacf5b2a74d1c66b53b6339b870393957e6d1a83">CreationOption_DebugFill</a> = (1 &lt;&lt; 1), 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a5200a4ef197dbd700f31a3111eacf5b2a59bbf55542967a55d01a7257c1131735">CreationOption_ThreadSafe</a> = (1 &lt;&lt; 2)
<br />
 }<tr class="memdesc:a5200a4ef197dbd700f31a3111eacf5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">ヒープ作成時のオプションを表す定数です。  <a href="namespacenn_1_1lmem.html#a5200a4ef197dbd700f31a3111eacf5b2">[詳解]</a><br /></td></tr>
<tr class="separator:a5200a4ef197dbd700f31a3111eacf5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ab3db4663e81681986f86c9cd7cb4cae9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#ab3db4663e81681986f86c9cd7cb4cae9">ErrorOption</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#ab3db4663e81681986f86c9cd7cb4cae9aa196d3e16ed8b40056ee88759da8c581">ErrorOption_NoOption</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#ab3db4663e81681986f86c9cd7cb4cae9ad3c0eafafaf1f86fe048b63e495b5ada">ErrorOption_Print</a> = (1 &lt;&lt; 0)
<br />
 }<tr class="memdesc:ab3db4663e81681986f86c9cd7cb4cae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">エラーに関するオプションを表す定数です。  <a href="namespacenn_1_1lmem.html#ab3db4663e81681986f86c9cd7cb4cae9">[詳解]</a><br /></td></tr>
<tr class="separator:ab3db4663e81681986f86c9cd7cb4cae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a9e4483dceb5521988f7c9afb0e32da8d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8d">FillType</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8dabf82da361e5cf28b646fb212d043d675">FillType_Unallocated</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8da530964fed21e85308d519e88654526bc">FillType_Allocate</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8da8bf8579aec1f8bef0015b939eca65c6a">FillType_Free</a>
<br />
 }<tr class="memdesc:a9e4483dceb5521988f7c9afb0e32da8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ヒープをフィルする種別を表す定数です。  <a href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8d">[詳解]</a><br /></td></tr>
<tr class="separator:a9e4483dceb5521988f7c9afb0e32da8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a0d378823d086c69e88ee7465eb246b3f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a0d378823d086c69e88ee7465eb246b3f">FreeMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a0d378823d086c69e88ee7465eb246b3fa30222a68322eef67b45eb8274a9696a8">FreeMode_Front</a> = (1 &lt;&lt; 0), 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a0d378823d086c69e88ee7465eb246b3fa75d4886d4d122c1c366f8351404a91fd">FreeMode_Rear</a> = (1 &lt;&lt; 1), 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#a0d378823d086c69e88ee7465eb246b3faeb0b94c8ebeb50ebe978d075b8bdcf2b">FreeMode_All</a> = (FreeMode_Front | FreeMode_Rear)
<br />
 }<tr class="memdesc:a0d378823d086c69e88ee7465eb246b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリブロックを解放する方法を指定するための定数です。  <a href="namespacenn_1_1lmem.html#a0d378823d086c69e88ee7465eb246b3f">[詳解]</a><br /></td></tr>
<tr class="separator:a0d378823d086c69e88ee7465eb246b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:abd1164e3a948696645a06c70e009f8c2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#abd1164e3a948696645a06c70e009f8c2">InfoPlacement</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#abd1164e3a948696645a06c70e009f8c2ace7eca4a020808cce9d41929c2776f92">InfoPlacement_Head</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1lmem.html#abd1164e3a948696645a06c70e009f8c2a0443b9a0d25f781bb734f60972c021db">InfoPlacement_Tail</a>
<br />
 }<tr class="memdesc:abd1164e3a948696645a06c70e009f8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">ヒープ共通ヘッダ（ヒープの管理領域）を配置する場所を決める定数です。  <a href="namespacenn_1_1lmem.html#abd1164e3a948696645a06c70e009f8c2">[詳解]</a><br /></td></tr>
<tr class="separator:abd1164e3a948696645a06c70e009f8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
関数</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">ヒープ共通 API</div></td></tr>
<tr class="memitem:aacdf9e8d0b3673ee2041a93353f4b3cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#aacdf9e8d0b3673ee2041a93353f4b3cb">SetFillValue</a> (<a class="el" href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8d">FillType</a> type, Bit32 value) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aacdf9e8d0b3673ee2041a93353f4b3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">ヒープをフィルする種別毎にフィルする値を設定します。  <a href="#aacdf9e8d0b3673ee2041a93353f4b3cb">[詳解]</a><br /></td></tr>
<tr class="separator:aacdf9e8d0b3673ee2041a93353f4b3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af868f872b74bcd1bf22d414f7f31af5e"><td class="memItemLeft" align="right" valign="top">Bit32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#af868f872b74bcd1bf22d414f7f31af5e">GetFillValue</a> (const <a class="el" href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8d">FillType</a> type) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af868f872b74bcd1bf22d414f7f31af5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ヒープをフィルする値を取得します。  <a href="#af868f872b74bcd1bf22d414f7f31af5e">[詳解]</a><br /></td></tr>
<tr class="separator:af868f872b74bcd1bf22d414f7f31af5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e599544385b8f298f4a6303fd7d5d67"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a2e599544385b8f298f4a6303fd7d5d67">GetTotalSize</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2e599544385b8f298f4a6303fd7d5d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">ヒープが利用しているメモリ領域のサイズを取得します。  <a href="#a2e599544385b8f298f4a6303fd7d5d67">[詳解]</a><br /></td></tr>
<tr class="separator:a2e599544385b8f298f4a6303fd7d5d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64dd4f95c8fc55068b221d18fc1ffe4b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a64dd4f95c8fc55068b221d18fc1ffe4b">GetStartAddress</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a64dd4f95c8fc55068b221d18fc1ffe4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ヒープが利用しているメモリ領域の先頭アドレスを返します。  <a href="#a64dd4f95c8fc55068b221d18fc1ffe4b">[詳解]</a><br /></td></tr>
<tr class="separator:a64dd4f95c8fc55068b221d18fc1ffe4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8cf0f54fa6ba157762657ef1f6e103"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a4f8cf0f54fa6ba157762657ef1f6e103">HasAddress</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, void *address) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4f8cf0f54fa6ba157762657ef1f6e103"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定したアドレスがヒープに含まれているか調べます。  <a href="#a4f8cf0f54fa6ba157762657ef1f6e103">[詳解]</a><br /></td></tr>
<tr class="separator:a4f8cf0f54fa6ba157762657ef1f6e103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">拡張ヒープ - ヒープ領域操作 API</div></td></tr>
<tr class="memitem:a3d46d370c3b53aed4a127962761ed0fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc">CreateExpHeap</a> (void *startAddress, size_t size, int option) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3d46d370c3b53aed4a127962761ed0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">拡張ヒープを作成します。  <a href="#a3d46d370c3b53aed4a127962761ed0fc">[詳解]</a><br /></td></tr>
<tr class="separator:a3d46d370c3b53aed4a127962761ed0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f5ea9ad1df5559ac024fee0564744a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#af8f5ea9ad1df5559ac024fee0564744a">DestroyExpHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af8f5ea9ad1df5559ac024fee0564744a"><td class="mdescLeft">&#160;</td><td class="mdescRight">拡張ヒープを破棄します。  <a href="#af8f5ea9ad1df5559ac024fee0564744a">[詳解]</a><br /></td></tr>
<tr class="separator:af8f5ea9ad1df5559ac024fee0564744a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b21c96cee5ec4ae3bb5048fdb483666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1lmem_1_1_memory_range.html">MemoryRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a3b21c96cee5ec4ae3bb5048fdb483666">AdjustExpHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3b21c96cee5ec4ae3bb5048fdb483666"><td class="mdescLeft">&#160;</td><td class="mdescRight">ヒープ領域の後方にある空き領域を開放し、使用するメモリを縮小します。  <a href="#a3b21c96cee5ec4ae3bb5048fdb483666">[詳解]</a><br /></td></tr>
<tr class="separator:a3b21c96cee5ec4ae3bb5048fdb483666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">拡張ヒープ - メモリブロック操作 API</div></td></tr>
<tr class="memitem:a96055cfc77bfd3eac47da134a3746aa9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a96055cfc77bfd3eac47da134a3746aa9">AllocateFromExpHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a96055cfc77bfd3eac47da134a3746aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ領域を確保します。  <a href="#a96055cfc77bfd3eac47da134a3746aa9">[詳解]</a><br /></td></tr>
<tr class="separator:a96055cfc77bfd3eac47da134a3746aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c4062e0fa7e47cc9a604681317525a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a64c4062e0fa7e47cc9a604681317525a">AllocateFromExpHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, size_t size, int alignment) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a64c4062e0fa7e47cc9a604681317525a"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定したアラインメントでメモリ領域を確保します。  <a href="#a64c4062e0fa7e47cc9a604681317525a">[詳解]</a><br /></td></tr>
<tr class="separator:a64c4062e0fa7e47cc9a604681317525a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b756491ff15ef5937719943d7146a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#aa8b756491ff15ef5937719943d7146a5">FreeToExpHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, void *pBlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa8b756491ff15ef5937719943d7146a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ領域を解放します。  <a href="#aa8b756491ff15ef5937719943d7146a5">[詳解]</a><br /></td></tr>
<tr class="separator:aa8b756491ff15ef5937719943d7146a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacfd64bdeac5be2b33f2f5f79656379"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#adacfd64bdeac5be2b33f2f5f79656379">ResizeExpHeapBlock</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, void *pBlock, size_t newSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adacfd64bdeac5be2b33f2f5f79656379"><td class="mdescLeft">&#160;</td><td class="mdescRight">拡張ヒープから確保したメモリブロックのサイズを変更します。  <a href="#adacfd64bdeac5be2b33f2f5f79656379">[詳解]</a><br /></td></tr>
<tr class="separator:adacfd64bdeac5be2b33f2f5f79656379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">拡張ヒープ - ヒープ情報設定・取得 API</div></td></tr>
<tr class="memitem:aaecc883dba00f234bd0d3e123d1365d2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#aaecc883dba00f234bd0d3e123d1365d2">GetExpHeapTotalFreeSize</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aaecc883dba00f234bd0d3e123d1365d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">空きメモリサイズを取得します。  <a href="#aaecc883dba00f234bd0d3e123d1365d2">[詳解]</a><br /></td></tr>
<tr class="separator:aaecc883dba00f234bd0d3e123d1365d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a9bfe39ef9ba8ac6500bcd39defde8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a65a9bfe39ef9ba8ac6500bcd39defde8">GetExpHeapAllocatableSize</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, int alignment) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a65a9bfe39ef9ba8ac6500bcd39defde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">確保可能なメモリブロックのサイズを取得します。  <a href="#a65a9bfe39ef9ba8ac6500bcd39defde8">[詳解]</a><br /></td></tr>
<tr class="separator:a65a9bfe39ef9ba8ac6500bcd39defde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0215a6fd274ee1b7f82356aca8ff4ac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a0215a6fd274ee1b7f82356aca8ff4ac7">SetExpHeapAllocationMode</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, <a class="el" href="namespacenn_1_1lmem.html#a4a7319ff4369a7278582dd53a1129f73">AllocationMode</a> allocationMode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0215a6fd274ee1b7f82356aca8ff4ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ確保時のモードを設定します。  <a href="#a0215a6fd274ee1b7f82356aca8ff4ac7">[詳解]</a><br /></td></tr>
<tr class="separator:a0215a6fd274ee1b7f82356aca8ff4ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7958c3154e912e2f1d4df040a03dccb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1lmem.html#a4a7319ff4369a7278582dd53a1129f73">AllocationMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a7958c3154e912e2f1d4df040a03dccb7">GetExpHeapAllocationMode</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7958c3154e912e2f1d4df040a03dccb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ確保時のモードを取得します。  <a href="#a7958c3154e912e2f1d4df040a03dccb7">[詳解]</a><br /></td></tr>
<tr class="separator:a7958c3154e912e2f1d4df040a03dccb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a7f1f27f38901e2dcedd42ca0ab2ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a48a7f1f27f38901e2dcedd42ca0ab2ab">SetExpHeapUseMarginOfAlignment</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, bool reuse) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a48a7f1f27f38901e2dcedd42ca0ab2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ確保の際に、アラインメントによって発生した断片化領域を再利用するかどうかを設定します。  <a href="#a48a7f1f27f38901e2dcedd42ca0ab2ab">[詳解]</a><br /></td></tr>
<tr class="separator:a48a7f1f27f38901e2dcedd42ca0ab2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b29bb41e1795da84b1f8ec5544a594a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a6b29bb41e1795da84b1f8ec5544a594a">GetExpHeapUseMarginOfAlignment</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6b29bb41e1795da84b1f8ec5544a594a"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ確保の際にアラインメントによって発生した断片化領域を再利用するかどうかを取得します。  <a href="#a6b29bb41e1795da84b1f8ec5544a594a">[詳解]</a><br /></td></tr>
<tr class="separator:a6b29bb41e1795da84b1f8ec5544a594a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5de7bf254d6a4182e9c4070a94e1b9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#ab5de7bf254d6a4182e9c4070a94e1b9c">SetExpHeapGroupId</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, Bit16 groupId) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab5de7bf254d6a4182e9c4070a94e1b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ確保時のグループ ID を設定します。  <a href="#ab5de7bf254d6a4182e9c4070a94e1b9c">[詳解]</a><br /></td></tr>
<tr class="separator:ab5de7bf254d6a4182e9c4070a94e1b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd47c4651a7f6385ba616a076d0a1457"><td class="memItemLeft" align="right" valign="top">Bit16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#afd47c4651a7f6385ba616a076d0a1457">GetExpHeapGroupId</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afd47c4651a7f6385ba616a076d0a1457"><td class="mdescLeft">&#160;</td><td class="mdescRight">グループ ID を取得します。  <a href="#afd47c4651a7f6385ba616a076d0a1457">[詳解]</a><br /></td></tr>
<tr class="separator:afd47c4651a7f6385ba616a076d0a1457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c92d4f94738d803197c67a268c1705"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#aa4c92d4f94738d803197c67a268c1705">GetExpHeapBlockSize</a> (const void *pBlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa4c92d4f94738d803197c67a268c1705"><td class="mdescLeft">&#160;</td><td class="mdescRight">確保したメモリブロックのサイズを取得します。  <a href="#aa4c92d4f94738d803197c67a268c1705">[詳解]</a><br /></td></tr>
<tr class="separator:aa4c92d4f94738d803197c67a268c1705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb1220e2063a1660e5e1c1ca8f87d94"><td class="memItemLeft" align="right" valign="top">Bit16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a3fb1220e2063a1660e5e1c1ca8f87d94">GetExpHeapGroupIdOfBlock</a> (const void *pBlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3fb1220e2063a1660e5e1c1ca8f87d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">確保したメモリブロックのグループ ID を取得します。  <a href="#a3fb1220e2063a1660e5e1c1ca8f87d94">[詳解]</a><br /></td></tr>
<tr class="separator:a3fb1220e2063a1660e5e1c1ca8f87d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7e706930f05cd5e4e17f2eb2f30ade"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1lmem.html#a4302ad21b1a099adf611aa15400cd06b">AllocationDirection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a8f7e706930f05cd5e4e17f2eb2f30ade">GetExpHeapAllocationDirectionOfBlock</a> (const void *pBlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8f7e706930f05cd5e4e17f2eb2f30ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">確保したメモリブロックのメモリ確保の方向を取得します。  <a href="#a8f7e706930f05cd5e4e17f2eb2f30ade">[詳解]</a><br /></td></tr>
<tr class="separator:a8f7e706930f05cd5e4e17f2eb2f30ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">拡張ヒープ - デバッグ用 API</div></td></tr>
<tr class="memitem:a04838ca06b67385b6eb99e63684444a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a04838ca06b67385b6eb99e63684444a9">CheckExpHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, int option) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a04838ca06b67385b6eb99e63684444a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">拡張ヒープが破壊されていないかどうかをチェックします。（デバッグ用）  <a href="#a04838ca06b67385b6eb99e63684444a9">[詳解]</a><br /></td></tr>
<tr class="separator:a04838ca06b67385b6eb99e63684444a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761bf1d98698d5fd19019e748f4d0ecf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a761bf1d98698d5fd19019e748f4d0ecf">CheckExpHeapBlock</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, const void *pBlock, int option) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a761bf1d98698d5fd19019e748f4d0ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">拡張ヒープから確保したメモリブロックのチェックを行います。（デバッグ用）  <a href="#a761bf1d98698d5fd19019e748f4d0ecf">[詳解]</a><br /></td></tr>
<tr class="separator:a761bf1d98698d5fd19019e748f4d0ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59c5a804990cae8619eab581b693ace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#ae59c5a804990cae8619eab581b693ace">VisitExpHeapAllBlocks</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, <a class="el" href="namespacenn_1_1lmem.html#a0f98df324bfdc3ff6e67337aa06232ef">HeapVisitor</a> visitor, uintptr_t userParam) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae59c5a804990cae8619eab581b693ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">確保した全てのメモリブロックに対し、ユーザが指定した関数 visitor を呼びます。（デバッグ用）  <a href="#ae59c5a804990cae8619eab581b693ace">[詳解]</a><br /></td></tr>
<tr class="separator:ae59c5a804990cae8619eab581b693ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba05f8df1e914f5748889a52daf7ec7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a3ba05f8df1e914f5748889a52daf7ec7">DumpExpHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3ba05f8df1e914f5748889a52daf7ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">拡張ヒープの内部の情報を表示します。（デバッグ用）  <a href="#a3ba05f8df1e914f5748889a52daf7ec7">[詳解]</a><br /></td></tr>
<tr class="separator:a3ba05f8df1e914f5748889a52daf7ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">フレームヒープ - ヒープ領域操作 API</div></td></tr>
<tr class="memitem:a90727fbcf266c220ae9409106a467a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49">CreateFrameHeap</a> (void *startAddress, size_t size, int option) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a90727fbcf266c220ae9409106a467a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">フレームヒープを作成します。  <a href="#a90727fbcf266c220ae9409106a467a49">[詳解]</a><br /></td></tr>
<tr class="separator:a90727fbcf266c220ae9409106a467a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd38b1a1f739530aa18143e8d7dfc4ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#acd38b1a1f739530aa18143e8d7dfc4ee">CreateFrameHeap</a> (void *startAddress, size_t size, int option, <a class="el" href="namespacenn_1_1lmem.html#a26608eb2d71f7595fca7793432c30f6f">HeapCommonHead</a> *pHeapHead) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acd38b1a1f739530aa18143e8d7dfc4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">フレームヒープを作成します。  <a href="#acd38b1a1f739530aa18143e8d7dfc4ee">[詳解]</a><br /></td></tr>
<tr class="separator:acd38b1a1f739530aa18143e8d7dfc4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcec58c14f1288a97cc8853c65215ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a5fcec58c14f1288a97cc8853c65215ad">DestroyFrameHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5fcec58c14f1288a97cc8853c65215ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">フレームヒープを破棄します。  <a href="#a5fcec58c14f1288a97cc8853c65215ad">[詳解]</a><br /></td></tr>
<tr class="separator:a5fcec58c14f1288a97cc8853c65215ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2530fa487300d192b1d7ed6ed33d1a4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1lmem_1_1_memory_range.html">MemoryRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a2530fa487300d192b1d7ed6ed33d1a4a">AdjustFrameHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, <a class="el" href="namespacenn_1_1lmem.html#a18e9eac338e3880aeee1459519b00886">AdjustMode</a> adjustMode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2530fa487300d192b1d7ed6ed33d1a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">ヒープの空き領域を解放し、使用するメモリを縮小します。  <a href="#a2530fa487300d192b1d7ed6ed33d1a4a">[詳解]</a><br /></td></tr>
<tr class="separator:a2530fa487300d192b1d7ed6ed33d1a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">フレームヒープ - メモリブロック操作 API</div></td></tr>
<tr class="memitem:a7c6889dbc9c14c96fdc10f89b69a3c96"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a7c6889dbc9c14c96fdc10f89b69a3c96">AllocateFromFrameHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7c6889dbc9c14c96fdc10f89b69a3c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ領域を確保します。  <a href="#a7c6889dbc9c14c96fdc10f89b69a3c96">[詳解]</a><br /></td></tr>
<tr class="separator:a7c6889dbc9c14c96fdc10f89b69a3c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490bafe2b4b3cbbae2990949be3824d5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a490bafe2b4b3cbbae2990949be3824d5">AllocateFromFrameHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, size_t size, int alignment) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a490bafe2b4b3cbbae2990949be3824d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定したアライメントでメモリ領域を確保します。  <a href="#a490bafe2b4b3cbbae2990949be3824d5">[詳解]</a><br /></td></tr>
<tr class="separator:a490bafe2b4b3cbbae2990949be3824d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7c2693342c1151c427651a6323969a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a2c7c2693342c1151c427651a6323969a">FreeToFrameHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, <a class="el" href="namespacenn_1_1lmem.html#a0d378823d086c69e88ee7465eb246b3f">FreeMode</a> mode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2c7c2693342c1151c427651a6323969a"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ領域を解放します。  <a href="#a2c7c2693342c1151c427651a6323969a">[詳解]</a><br /></td></tr>
<tr class="separator:a2c7c2693342c1151c427651a6323969a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6f50b6ef046e66428d0c4978a2e3d4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a4c6f50b6ef046e66428d0c4978a2e3d4">ResizeFrameHeapBlock</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, void *pBlock, size_t newSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4c6f50b6ef046e66428d0c4978a2e3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">フレームヒープから最後に確保したメモリブロックのサイズを変更します。  <a href="#a4c6f50b6ef046e66428d0c4978a2e3d4">[詳解]</a><br /></td></tr>
<tr class="separator:a4c6f50b6ef046e66428d0c4978a2e3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">フレームヒープ - ヒープ情報設定・取得 API</div></td></tr>
<tr class="memitem:abf40e7cffb9c7527baa746570b6de07e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#abf40e7cffb9c7527baa746570b6de07e">GetFrameHeapAllocatableSize</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, int alignment) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abf40e7cffb9c7527baa746570b6de07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">確保可能なメモリブロックのサイズを取得します。  <a href="#abf40e7cffb9c7527baa746570b6de07e">[詳解]</a><br /></td></tr>
<tr class="separator:abf40e7cffb9c7527baa746570b6de07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd347d006c6676ca3c2c652b56b5540a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1lmem_1_1_frame_heap_state.html">FrameHeapState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#abd347d006c6676ca3c2c652b56b5540a">GetFrameHeapState</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abd347d006c6676ca3c2c652b56b5540a"><td class="mdescLeft">&#160;</td><td class="mdescRight">フレームヒープの状態を取得します。  <a href="#abd347d006c6676ca3c2c652b56b5540a">[詳解]</a><br /></td></tr>
<tr class="separator:abd347d006c6676ca3c2c652b56b5540a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb70197d0fac93ff1c51605de577c0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#acdb70197d0fac93ff1c51605de577c0e">RestoreFrameHeapState</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, const <a class="el" href="structnn_1_1lmem_1_1_frame_heap_state.html">FrameHeapState</a> &amp;state) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acdb70197d0fac93ff1c51605de577c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">フレームヒープの状態を復元します。  <a href="#acdb70197d0fac93ff1c51605de577c0e">[詳解]</a><br /></td></tr>
<tr class="separator:acdb70197d0fac93ff1c51605de577c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">フレームヒープ - デバッグ用 API</div></td></tr>
<tr class="memitem:adb56e12364c2c984f7e41fd745b5251e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#adb56e12364c2c984f7e41fd745b5251e">DumpFrameHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adb56e12364c2c984f7e41fd745b5251e"><td class="mdescLeft">&#160;</td><td class="mdescRight">フレームヒープの内部の情報を表示します。（デバッグ用）  <a href="#adb56e12364c2c984f7e41fd745b5251e">[詳解]</a><br /></td></tr>
<tr class="separator:adb56e12364c2c984f7e41fd745b5251e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ユニットヒープ - ヒープ領域操作 API</div></td></tr>
<tr class="memitem:a7d3359350e669a5fcc493ce5df5d010c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c">CreateUnitHeap</a> (void *startAddress, size_t size, size_t unitSize, int option) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7d3359350e669a5fcc493ce5df5d010c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユニットヒープを作成します。  <a href="#a7d3359350e669a5fcc493ce5df5d010c">[詳解]</a><br /></td></tr>
<tr class="separator:a7d3359350e669a5fcc493ce5df5d010c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e408afe1b891b1827d340897319386"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a37e408afe1b891b1827d340897319386">CreateUnitHeap</a> (void *startAddress, size_t size, size_t unitSize, int option, int alignment, <a class="el" href="namespacenn_1_1lmem.html#abd1164e3a948696645a06c70e009f8c2">InfoPlacement</a> placement) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a37e408afe1b891b1827d340897319386"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユニットヒープを作成します。  <a href="#a37e408afe1b891b1827d340897319386">[詳解]</a><br /></td></tr>
<tr class="separator:a37e408afe1b891b1827d340897319386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a0b4af7e50ed9ce91b68df40225bdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a48a0b4af7e50ed9ce91b68df40225bdf">CreateUnitHeap</a> (void *startAddress, size_t size, size_t unitSize, int option, int alignment, <a class="el" href="namespacenn_1_1lmem.html#a26608eb2d71f7595fca7793432c30f6f">HeapCommonHead</a> *pHeapHead) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a48a0b4af7e50ed9ce91b68df40225bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユニットヒープを作成します。  <a href="#a48a0b4af7e50ed9ce91b68df40225bdf">[詳解]</a><br /></td></tr>
<tr class="separator:a48a0b4af7e50ed9ce91b68df40225bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e9905bd641416421fb108f487b5d4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a03e9905bd641416421fb108f487b5d4f">DestroyUnitHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a03e9905bd641416421fb108f487b5d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユニットヒープを破棄します。  <a href="#a03e9905bd641416421fb108f487b5d4f">[詳解]</a><br /></td></tr>
<tr class="separator:a03e9905bd641416421fb108f487b5d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca8ffeb524244ca4f9968d116817257"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a4ca8ffeb524244ca4f9968d116817257">InvalidateUnitHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4ca8ffeb524244ca4f9968d116817257"><td class="mdescLeft">&#160;</td><td class="mdescRight">ヒープを無効化します。  <a href="#a4ca8ffeb524244ca4f9968d116817257">[詳解]</a><br /></td></tr>
<tr class="separator:a4ca8ffeb524244ca4f9968d116817257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64765b319b7e98292e4ce5f70dbce73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#ac64765b319b7e98292e4ce5f70dbce73">ExtendUnitHeapArea</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac64765b319b7e98292e4ce5f70dbce73"><td class="mdescLeft">&#160;</td><td class="mdescRight">ヒープとして与えられた領域を拡張します。  <a href="#ac64765b319b7e98292e4ce5f70dbce73">[詳解]</a><br /></td></tr>
<tr class="separator:ac64765b319b7e98292e4ce5f70dbce73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ユニットヒープ - メモリブロック操作 API</div></td></tr>
<tr class="memitem:a1d1eec8ea87ca5a847eae04fb21c7a36"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a1d1eec8ea87ca5a847eae04fb21c7a36">AllocateFromUnitHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1d1eec8ea87ca5a847eae04fb21c7a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ領域を確保します。  <a href="#a1d1eec8ea87ca5a847eae04fb21c7a36">[詳解]</a><br /></td></tr>
<tr class="separator:a1d1eec8ea87ca5a847eae04fb21c7a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab190d0a00216c4d8cd2e3134680d3a45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#ab190d0a00216c4d8cd2e3134680d3a45">FreeToUnitHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, void *pBlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab190d0a00216c4d8cd2e3134680d3a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ領域を解放します。  <a href="#ab190d0a00216c4d8cd2e3134680d3a45">[詳解]</a><br /></td></tr>
<tr class="separator:ab190d0a00216c4d8cd2e3134680d3a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ユニットヒープ - ヒープ情報設定・取得 API</div></td></tr>
<tr class="memitem:a4f73af475a54358322fe7b3c8bf78ef6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a4f73af475a54358322fe7b3c8bf78ef6">GetUnitHeapUnitSize</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4f73af475a54358322fe7b3c8bf78ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユニットヒープのユニットサイズを取得します。  <a href="#a4f73af475a54358322fe7b3c8bf78ef6">[詳解]</a><br /></td></tr>
<tr class="separator:a4f73af475a54358322fe7b3c8bf78ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2b6be8b9c2077fec92fb19c5e8aeb1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#abe2b6be8b9c2077fec92fb19c5e8aeb1">GetUnitHeapAllocatableCount</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abe2b6be8b9c2077fec92fb19c5e8aeb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">空きユニットの数を取得します。  <a href="#abe2b6be8b9c2077fec92fb19c5e8aeb1">[詳解]</a><br /></td></tr>
<tr class="separator:abe2b6be8b9c2077fec92fb19c5e8aeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1ae99b4baab79444c503a383345154"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#aaa1ae99b4baab79444c503a383345154">GetUnitHeapAllocatedCount</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aaa1ae99b4baab79444c503a383345154"><td class="mdescLeft">&#160;</td><td class="mdescRight">現在このヒープから確保されているユニットの数を取得します。  <a href="#aaa1ae99b4baab79444c503a383345154">[詳解]</a><br /></td></tr>
<tr class="separator:aaa1ae99b4baab79444c503a383345154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a08003a1b715eded61e040c3cd087a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a8a08003a1b715eded61e040c3cd087a9">GetUnitHeapAlignment</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8a08003a1b715eded61e040c3cd087a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユニットのアライメントを取得します。  <a href="#a8a08003a1b715eded61e040c3cd087a9">[詳解]</a><br /></td></tr>
<tr class="separator:a8a08003a1b715eded61e040c3cd087a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac10912318a3d5f45687fa1885c89be"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a8ac10912318a3d5f45687fa1885c89be">GetRequiredUnitHeapSize</a> (size_t unitSize, int unitNum, int alignment, bool hasHeadInternally) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8ac10912318a3d5f45687fa1885c89be"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定したユニットサイズとアライメントのブロックを指定数を管理できるだけのヒープメモリのサイズを取得します。  <a href="#a8ac10912318a3d5f45687fa1885c89be">[詳解]</a><br /></td></tr>
<tr class="separator:a8ac10912318a3d5f45687fa1885c89be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ユニットヒープ - デバッグ用 API</div></td></tr>
<tr class="memitem:a1deefa949a2c36e348db0fe808cad2de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a1deefa949a2c36e348db0fe808cad2de">DumpUnitHeap</a> (<a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1deefa949a2c36e348db0fe808cad2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユニットヒープの内部の情報を表示します。（デバッグ用）  <a href="#a1deefa949a2c36e348db0fe808cad2de">[詳解]</a><br /></td></tr>
<tr class="separator:a1deefa949a2c36e348db0fe808cad2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
変数</h2></td></tr>
<tr class="memitem:a9b73760b843761bad7afb25be502c4b0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1lmem.html#a9b73760b843761bad7afb25be502c4b0">DefaultAlignment</a> = 8</td></tr>
<tr class="memdesc:a9b73760b843761bad7afb25be502c4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ確保の際のデフォルトアラインメントです。  <a href="#a9b73760b843761bad7afb25be502c4b0">[詳解]</a><br /></td></tr>
<tr class="separator:a9b73760b843761bad7afb25be502c4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p>Cafe SDK, CTR-SDK と同等機能を持つ動的メモリ確保ライブラリの名前空間です。 </p>
<p><b>詳細</b> <br />
 Cafe SDK, CTR-SDK と同等機能を持つヒープは、この名前空間に用意されます。<br />
 Cafe SDK と CTR-SDK にない、新しく用意されたヒープは <a class="el" href="namespacenn_1_1mem.html" title="高速に確保・解放が可能な動的メモリ確保ライブラリの名前空間です。 ">nn::mem</a> 名前空間に配置されます。 </p>
</div><h2 class="groupheader">型定義詳解</h2>
<a class="anchor" id="ab893a05f9834a881447ea604c7d60400"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct detail::HeapHead* <a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">nn::lmem::HeapHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ヒープ共通ハンドルです。 </p>
<p><b>詳細</b> <br />
 ヒープのハンドルを表す型です。 </p>

</div>
</div>
<a class="anchor" id="a26608eb2d71f7595fca7793432c30f6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef detail::HeapHead <a class="el" href="namespacenn_1_1lmem.html#a26608eb2d71f7595fca7793432c30f6f">nn::lmem::HeapCommonHead</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ヒープ共通ヘッダです。 </p>
<p><b>詳細</b> <br />
 ヒープの管理領域です。<br />
 ヒープではヒープ共通ヘッダが必ず作成されます。<br />
 ヒープ領域内にヒープ共通ヘッダ領域を作成したくない場合は、この型を別領域に確保しヒープ作成時に渡すことで、ヒープ領域内にヘッダが作成されなくなります。 </p>

</div>
</div>
<a class="anchor" id="a0f98df324bfdc3ff6e67337aa06232ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* nn::lmem::HeapVisitor) (void *pBlock, <a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> heapHandle, uintptr_t userParam)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリブロックを巡るときに呼び出されるコールバック関数の型です。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>メモリブロックへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>メモリブロックを持つヒープ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userParam</td><td>ユーザー用パラメータ</td></tr>
  </table>
  </dd>
</dl>
<p><b>詳細</b> <br />
 <a class="el" href="namespacenn_1_1lmem.html#ae59c5a804990cae8619eab581b693ace" title="確保した全てのメモリブロックに対し、ユーザが指定した関数 visitor を呼びます。（デバッグ用） ...">VisitExpHeapAllBlocks()</a> 関数で利用されます。 </p>

</div>
</div>
<h2 class="groupheader">列挙型詳解</h2>
<a class="anchor" id="a5200a4ef197dbd700f31a3111eacf5b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1lmem.html#a5200a4ef197dbd700f31a3111eacf5b2">nn::lmem::CreationOption</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ヒープ作成時のオプションを表す定数です。 </p>
<p><b>詳細</b> <br />
 拡張ヒープ、フレームヒープ、ユニットヒープそれぞれのヒープ作成関数（Create***Heap）のオプションとして指定されます。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a5200a4ef197dbd700f31a3111eacf5b2a30c3b2cd8b36e40049c5c88b7c47a45f"></a>CreationOption_NoOption&#160;</td><td class="fielddoc">
<p>オプションを指定しません </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5200a4ef197dbd700f31a3111eacf5b2a00853f3b9861cc1c8c36508a2d4c8b4a"></a>CreationOption_ZeroClear&#160;</td><td class="fielddoc">
<p>メモリ確保時にメモリを 0 でフィルします。このオプションはデバッグ用で、製品版のコードでは無効になります </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5200a4ef197dbd700f31a3111eacf5b2a74d1c66b53b6339b870393957e6d1a83"></a>CreationOption_DebugFill&#160;</td><td class="fielddoc">
<p>ヒープ作成時、メモリ確保、メモリ解放時にメモリを特定の値でフィルします。詳細については各ヒープのヒープ作成 API の仕様を参照してください。このオプションはデバッグ用で、製品版のコードでは無効になります </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5200a4ef197dbd700f31a3111eacf5b2a59bbf55542967a55d01a7257c1131735"></a>CreationOption_ThreadSafe&#160;</td><td class="fielddoc">
<p>スレッド間の排他制御を有効にします </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ab3db4663e81681986f86c9cd7cb4cae9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1lmem.html#ab3db4663e81681986f86c9cd7cb4cae9">nn::lmem::ErrorOption</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>エラーに関するオプションを表す定数です。 </p>
<p><b>詳細</b> <br />
 エラー出力の有無を指定できます。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="ab3db4663e81681986f86c9cd7cb4cae9aa196d3e16ed8b40056ee88759da8c581"></a>ErrorOption_NoOption&#160;</td><td class="fielddoc">
<p>オプションを指定しません </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab3db4663e81681986f86c9cd7cb4cae9ad3c0eafafaf1f86fe048b63e495b5ada"></a>ErrorOption_Print&#160;</td><td class="fielddoc">
<p>エラー出力を有効にします </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a9e4483dceb5521988f7c9afb0e32da8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8d">nn::lmem::FillType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ヒープをフィルする種別を表す定数です。 </p>
<p><b>詳細</b> <br />
 メモリをフィルするタイミングを表します。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a9e4483dceb5521988f7c9afb0e32da8dabf82da361e5cf28b646fb212d043d675"></a>FillType_Unallocated&#160;</td><td class="fielddoc">
<p>未使用のメモリにフィルします（ヒープ作成時にフィルします） </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9e4483dceb5521988f7c9afb0e32da8da530964fed21e85308d519e88654526bc"></a>FillType_Allocate&#160;</td><td class="fielddoc">
<p>メモリを確保する際にフィルします </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9e4483dceb5521988f7c9afb0e32da8da8bf8579aec1f8bef0015b939eca65c6a"></a>FillType_Free&#160;</td><td class="fielddoc">
<p>メモリを解放する際にフィルします </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a18e9eac338e3880aeee1459519b00886"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1lmem.html#a18e9eac338e3880aeee1459519b00886">nn::lmem::AdjustMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ヒープ領域を縮小する種別を表す定数です。 </p>
<p><b>詳細</b> <br />
 ヒープ領域を縮小する方向を指定できます。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a18e9eac338e3880aeee1459519b00886a5c25952febdf7156503bf7dd70f1e703"></a>AdjustMode_Tail&#160;</td><td class="fielddoc">
<p>ヒープのメモリ領域を末尾から先頭に向かって縮めます </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a18e9eac338e3880aeee1459519b00886a5c7383dad293f4b1c10380b8a41f59d1"></a>AdjustMode_Head&#160;</td><td class="fielddoc">
<p>ヒープのメモリ領域を先頭から末尾に向かって縮めます </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a4a7319ff4369a7278582dd53a1129f73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1lmem.html#a4a7319ff4369a7278582dd53a1129f73">nn::lmem::AllocationMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリブロック確保のモードです。 </p>
<p><b>詳細</b> <br />
 メモリブロック確保の際にどのような方法でブロックを見つけるか決定します。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a4a7319ff4369a7278582dd53a1129f73a101b6b812bb866cd80f042ef3ff95168"></a>AllocationMode_FirstFit&#160;</td><td class="fielddoc">
<p>確保しようとしているメモリブロックのサイズ以上の大きさを持つ、最初に見つかった空き領域からメモリブロックを確保します </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4a7319ff4369a7278582dd53a1129f73ae6e6a0e6cddfc1146e912f4017c1c161"></a>AllocationMode_BestFit&#160;</td><td class="fielddoc">
<p>確保しようとしているメモリブロックのサイズに一番近いサイズの空き領域を探し、その空き領域からメモリブロックを確保します </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a4302ad21b1a099adf611aa15400cd06b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1lmem.html#a4302ad21b1a099adf611aa15400cd06b">nn::lmem::AllocationDirection</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリブロック確保の方向を指定するための定数です。 </p>
<p><b>詳細</b> <br />
 メモリブロック確保は、ヒープの前方からか、後方からか選択できます。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a4302ad21b1a099adf611aa15400cd06ba7f33d3263e63f24f45a768189a9ee8e9"></a>AllocationDirection_Front&#160;</td><td class="fielddoc">
<p>メモリブロックの確保時に、ヒープの空き領域の前方から確保します </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4302ad21b1a099adf611aa15400cd06babe4b1359d27860a53a1ad5e1b3b628c8"></a>AllocationDirection_Rear&#160;</td><td class="fielddoc">
<p>メモリブロックの確保時に、ヒープの空き領域の後方から確保します </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a0d378823d086c69e88ee7465eb246b3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1lmem.html#a0d378823d086c69e88ee7465eb246b3f">nn::lmem::FreeMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリブロックを解放する方法を指定するための定数です。 </p>
<p><b>詳細</b> <br />
 どちらの方向から確保されたメモリブロックを解放するか指定できます。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a0d378823d086c69e88ee7465eb246b3fa30222a68322eef67b45eb8274a9696a8"></a>FreeMode_Front&#160;</td><td class="fielddoc">
<p>ヒープの前方から確保されているメモリブロックを全て解放します </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0d378823d086c69e88ee7465eb246b3fa75d4886d4d122c1c366f8351404a91fd"></a>FreeMode_Rear&#160;</td><td class="fielddoc">
<p>ヒープの後方から確保されているメモリブロックを全て解放します </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0d378823d086c69e88ee7465eb246b3faeb0b94c8ebeb50ebe978d075b8bdcf2b"></a>FreeMode_All&#160;</td><td class="fielddoc">
<p>ヒープ内の全てのメモリブロックを解放します </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="abd1164e3a948696645a06c70e009f8c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1lmem.html#abd1164e3a948696645a06c70e009f8c2">nn::lmem::InfoPlacement</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ヒープ共通ヘッダ（ヒープの管理領域）を配置する場所を決める定数です。 </p>
<p><b>詳細</b> <br />
 ヒープの管理領域をメモリ領域の先頭、もしくは末尾に配置するか指定できます。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="abd1164e3a948696645a06c70e009f8c2ace7eca4a020808cce9d41929c2776f92"></a>InfoPlacement_Head&#160;</td><td class="fielddoc">
<p>ヒープの管理領域をメモリ領域の先頭に配置します </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abd1164e3a948696645a06c70e009f8c2a0443b9a0d25f781bb734f60972c021db"></a>InfoPlacement_Tail&#160;</td><td class="fielddoc">
<p>ヒープの管理領域をメモリ領域の末尾に配置します </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a class="anchor" id="aacdf9e8d0b3673ee2041a93353f4b3cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::SetFillValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8d">FillType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bit32&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ヒープをフィルする種別毎にフィルする値を設定します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ヒープをフィルする種別 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>ヒープをフィルする値</td></tr>
  </table>
  </dd>
</dl>
<p><b>詳細</b> <br />
 フィルは指定された 32bit 値、 4 バイト単位で行われます。<br />
 フィルする値は全てのヒープで共通の値が利用されます。<br />
 <br />
 本 API はスレッドセーフではありません。<br />
 本 API を呼び出す場合は、他のヒープ API を同時に呼び出さないでください。 </p>

</div>
</div>
<a class="anchor" id="af868f872b74bcd1bf22d414f7f31af5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bit32 nn::lmem::GetFillValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1lmem.html#a9e4483dceb5521988f7c9afb0e32da8d">FillType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ヒープをフィルする値を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>ヒープをフィルする種別 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>指定したフィルの種別で使われる値が返ります。</dd></dl>
<p><b>詳細</b> <br />
 FillType 列挙型を指定し、フィルが行われる際にどのような値がフィルされるのか取得します。<br />
 <br />
 本 API はスレッドセーフではありません。<br />
 本 API を呼び出す場合は、 <a class="el" href="namespacenn_1_1lmem.html#aacdf9e8d0b3673ee2041a93353f4b3cb" title="ヒープをフィルする種別毎にフィルする値を設定します。 ">SetFillValue()</a> 関数を同時に呼び出さないでください。 </p>

</div>
</div>
<a class="anchor" id="a2e599544385b8f298f4a6303fd7d5d67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::lmem::GetTotalSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ヒープが利用しているメモリ領域のサイズを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ヒープが利用しているメモリ領域のサイズ(バイト)を返します。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値がヒープが利用しているメモリ領域のサイズ(バイト)となります。</dd></dl>
<p><b>詳細</b> <br />
 ヒープハンドルから、ヒープが利用しているメモリ領域のサイズを取得します。<br />
 ヒープの管理領域がヒープ領域内に作成されている場合は、それも含みます。<br />
 <br />
 ヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a64dd4f95c8fc55068b221d18fc1ffe4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::lmem::GetStartAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ヒープが利用しているメモリ領域の先頭アドレスを返します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ヒープが利用しているメモリ領域のの先頭アドレスを返します。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値がヒープが利用しているメモリ領域の先頭アドレスとなります。</dd></dl>
<p><b>詳細</b> <br />
 ヒープハンドルから、ヒープが利用しているメモリ領域の先頭アドレスを取得します。<br />
 <br />
 ヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a4f8cf0f54fa6ba157762657ef1f6e103"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::lmem::HasAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定したアドレスがヒープに含まれているか調べます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>調べる対象のアドレス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>指定したアドレスがヒープ領域内なら、 true を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>指定したアドレスがヒープ領域内なら、 true が返ります。</dd></dl>
<p><b>詳細</b> <br />
 指定したアドレスがヒープに含まれているか調べます。<br />
 <br />
 ヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a3d46d370c3b53aed4a127962761ed0fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> nn::lmem::CreateExpHeap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>拡張ヒープを作成します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddress</td><td>ヒープに割り当てるメモリブロックの先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>ヒープに割り当てるメモリブロックのサイズ（バイト） </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>デバッグ用オプション（CreationOption列挙型）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>関数が成功すると拡張ヒープのハンドルのポインタが返ります。失敗すると NULL が返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>startAddress は非 NULL である必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>指定したメモリブロックに拡張ヒープが作成されます。</dd></dl>
<p><b>詳細</b> <br />
 ヒープ作成時にはヒープの管理領域（ヒープ共通ヘッダ）も作成されます。<br />
 ヒープ管理領域は、ヒープ内部に作成されます。<br />
 そのため、 size で指定したサイズからヒープ管理領域 ( <a class="el" href="namespacenn_1_1lmem.html#a26608eb2d71f7595fca7793432c30f6f" title="ヒープ共通ヘッダです。 ">nn::lmem::HeapCommonHead</a> 構造体) のサイズを引いた領域が、フレームヒープで利用可能な領域となります。<br />
 <br />
 メモリ確保の際、確保のモードはデフォルトでは AllocationMode_FirstFit が利用されます。<br />
 確保のモードは <a class="el" href="namespacenn_1_1lmem.html#a0215a6fd274ee1b7f82356aca8ff4ac7" title="メモリ確保時のモードを設定します。 ">SetExpHeapAllocationMode()</a> 関数を利用することで変更できます。<br />
 <br />
 option では CreationOption 列挙型での指定が可能です。複数の CreationOption 列挙型を OR 指定することも可能です。<br />
 option に CreationOption_NoOption を指定すると、オプションは無効となります。<br />
 option に CreationOption_ZeroClear を指定すると、このヒープで確保したメモリが 0 でクリアされます。<br />
 option に CreationOption_DebugFill を指定すると、ヒープ作成時、メモリ確保、メモリ解放時にメモリを特定の値でフィルします。<br />
 CreationOption_DebugFill オプションでフィルする値はデフォルトでは以下のようになっています。<br />
 </p><ul>
<li>ヒープ作成時：0xC3C3C3C3 </li>
<li>メモリ確保時：0xF3F3F3F3 </li>
<li>メモリ解放時：0xD3D3D3D3 CreationOption_ZeroClear と CreationOption_DebugFill を OR 指定した場合、ヒープ作成時とメモリ解放時は CreationOption_DebugFill の値でフィルされ、メモリ確保時はメモリが 0 でクリアされます。<br />
 この値は <a class="el" href="namespacenn_1_1lmem.html#aacdf9e8d0b3673ee2041a93353f4b3cb" title="ヒープをフィルする種別毎にフィルする値を設定します。 ">SetFillValue()</a> 関数を利用することで変更できます。<br />
 <br />
 option に CreationOption_ThreadSafe を指定すると、マルチスレッド時の排他制御を有効にします。<br />
 <br />
 本 API はスレッドセーフではありません。 </li>
</ul>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_movie_decoder_player_8cpp-example.html#a0">MovieDecoderPlayer.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af8f5ea9ad1df5559ac024fee0564744a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::DestroyExpHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>拡張ヒープを破棄します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>指定した拡張ヒープが破棄されます。</dd></dl>
<p><b>詳細</b> <br />
 ヒープハンドルで指定されたヒープを破棄します。<br />
 本 API はスレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a3b21c96cee5ec4ae3bb5048fdb483666"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1lmem_1_1_memory_range.html">MemoryRange</a> nn::lmem::AdjustExpHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ヒープ領域の後方にある空き領域を開放し、使用するメモリを縮小します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ヒープが縮小されることにより空いたメモリ領域の範囲を返します。<br />
 縮小できない場合の戻り値の <a class="el" href="structnn_1_1lmem_1_1_memory_range.html" title="メモリ領域の範囲を表す構造体です。 ">MemoryRange</a> の size は 0 になります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>拡張ヒープが戻り値で示される分だけ縮小されます。</dd></dl>
<p><b>詳細</b> <br />
 ヒープ領域の後ろから確保されたメモリブロックが存在している場合、この関数は失敗します。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a96055cfc77bfd3eac47da134a3746aa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::lmem::AllocateFromExpHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリ領域を確保します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>確保するメモリのサイズ（バイト）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>関数が成功すると確保したメモリ領域の先頭へのポインタ、失敗すると NULL ポインタが返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値が示すポインタから size バイトのメモリ領域が確保されます。</dd></dl>
<p><b>詳細</b> <br />
 拡張ヒープでメモリを確保します。<br />
 アライメントは DefaultAlignment が利用されます。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_movie_decoder_player_8cpp-example.html#a2">MovieDecoderPlayer.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a64c4062e0fa7e47cc9a604681317525a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::lmem::AllocateFromExpHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定したアラインメントでメモリ領域を確保します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>確保するメモリのサイズ（バイト） </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>確保するメモリのアラインメント</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>関数が成功すると確保したメモリ領域の先頭へのポインタ、失敗すると NULL ポインタが返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数で事前に初期化されている必要があります。<br />
 アライメントには正または負の 2 のべき乗が指定されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値が示すポインタから size バイトのメモリ領域が確保されます。</dd></dl>
<p><b>詳細</b> <br />
 拡張ヒープでメモリを確保します。<br />
 アライメントには正または負の 2 のべき乗を指定してください。<br />
 アライメントに負の値を指定すると、ヒープの後方からメモリの確保を行います。<br />
 <br />
 アライメントによって発生したメモリの隙間は、デフォルトでは再利用されない設定になっています。<br />
 <a class="el" href="namespacenn_1_1lmem.html#a48a7f1f27f38901e2dcedd42ca0ab2ab" title="メモリ確保の際に、アラインメントによって発生した断片化領域を再利用するかどうかを設定します。 ...">SetExpHeapUseMarginOfAlignment()</a> 関数を使用して、このアライメントの隙間を空き領域として再利用する設定に変更できます。<br />
 ただし、 32 を超える値または -32 を下回る値をアライメント値として指定してメモリを確保すると、メモリブロック間に隙間が生じたときに小さな空きブロックが登録され、パフォーマンスに影響を与える可能性がありますのでご注意ください。 また、128 を超える値または -128 を下回る値をアライメント値として指定した場合、空き領域はSetExpHeapUseMarginOfAlignment() 関数の設定に関係なく、自動的に再利用されます。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="aa8b756491ff15ef5937719943d7146a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::FreeToExpHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリ領域を解放します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>解放するするメモリブロックの先頭アドレス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>指定したメモリ領域が解放されます。</dd></dl>
<p><b>詳細</b> <br />
 拡張ヒープで確保したメモリ領域を解放します。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_movie_decoder_player_8cpp-example.html#a4">MovieDecoderPlayer.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="adacfd64bdeac5be2b33f2f5f79656379"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::lmem::ResizeExpHeapBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>拡張ヒープから確保したメモリブロックのサイズを変更します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>サイズを変更するメモリブロックの先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newSize</td><td>変更後のメモリブロックのサイズ（バイト）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>関数が成功すると、変更後のメモリブロックのサイズ(バイト)を返します。 関数が失敗すると、0 を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>引数 pBlock で指定したメモリブロックのサイズが newSize になります。</dd></dl>
<p><b>詳細</b> <br />
 メモリブロックを現在の大きさより大きくするとき、メモリブロックの後方にサイズを拡張するのに十分な空き領域が存在する必要があります。十分な空き領域が存在しない場合は、関数は失敗し 0 を返します。メモリブロックのサイズを大きくすることができた場合、メモリブロックの大きさが要求したサイズよりも大きくなる場合があります。<br />
 メモリブロックを今の大きさより小さくするとき、小さくするサイズが数バイト程度と少ない場合は空き領域が作成できず、縮小できない場合があります。その場合は、現在のメモリブロックのサイズが返されます。<br />
 <br />
 本 API は C 言語標準ライブラリの realloc 関数のように、サイズを変更したメモリブロックを新たなアドレスに割り当てるものではありません。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="aaecc883dba00f234bd0d3e123d1365d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::lmem::GetExpHeapTotalFreeSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>空きメモリサイズを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>拡張ヒープの空きメモリの合計サイズ(バイト)を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値が拡張ヒープの空きメモリの合計サイズ(バイト)となります。</dd></dl>
<p><b>詳細</b> <br />
 拡張ヒープの空きメモリの合計サイズ(バイト)を取得します。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a65a9bfe39ef9ba8ac6500bcd39defde8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::lmem::GetExpHeapAllocatableSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>確保可能なメモリブロックのサイズを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>アラインメント</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>拡張ヒープの空き領域から確保可能なメモリブロックの最大サイズ(バイト)を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数で事前に初期化されている必要があります。<br />
 アライメントには正の 2 のべき乗が指定されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値が拡張ヒープの空き領域から確保可能なメモリブロックの最大サイズ(バイト)となります。</dd></dl>
<p><b>詳細</b> <br />
 拡張ヒープで確保可能なメモリブロックのサイズを取得します。<br />
 アライメントには正の 2 のべき乗を指定してください。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a0215a6fd274ee1b7f82356aca8ff4ac7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::SetExpHeapAllocationMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#a4a7319ff4369a7278582dd53a1129f73">AllocationMode</a>&#160;</td>
          <td class="paramname"><em>allocationMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリ確保時のモードを設定します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocationMode</td><td>メモリ確保時のモード</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>拡張ヒープにメモリ確保時のモードが設定されます。</dd></dl>
<p><b>詳細</b> <br />
 デフォルトでは AllocationMode_FirstFit が指定されています。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a7958c3154e912e2f1d4df040a03dccb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1lmem.html#a4a7319ff4369a7278582dd53a1129f73">AllocationMode</a> nn::lmem::GetExpHeapAllocationMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリ確保時のモードを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>拡張ヒープのメモリ確保時のモードを返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値が拡張ヒープのメモリ確保時のモードとなります。</dd></dl>
<p><b>詳細</b> <br />
 <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a48a7f1f27f38901e2dcedd42ca0ab2ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::SetExpHeapUseMarginOfAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reuse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリ確保の際に、アラインメントによって発生した断片化領域を再利用するかどうかを設定します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reuse</td><td>アラインメントの際に発生する隙間の領域を再利用の有無</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>拡張ヒープに指定した設定が反映されます。</dd></dl>
<p><b>詳細</b> <br />
 デフォルトでは false に設定されています。<br />
 true に設定した場合には小さなメモリ領域が有効に使用できる可能性がありますが、大量のフリーブロックが生成されメモリ確保時のパフォーマンスが悪化する危険性があります。<br />
 ただし、128 バイト以上の比較的大きなアライメントの断片化領域は、本関数の設定に関係なく自動的に再利用されます。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a6b29bb41e1795da84b1f8ec5544a594a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::lmem::GetExpHeapUseMarginOfAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリ確保の際にアラインメントによって発生した断片化領域を再利用するかどうかを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>アラインメントの際に発生する隙間の領域の再利用をする場合は true、しない場合は false が返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値として拡張ヒープがアラインメントの際に発生する隙間の領域を再利用するかどうかが返ります。</dd></dl>
<p><b>詳細</b> <br />
 デフォルトでは false に設定されています。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="ab5de7bf254d6a4182e9c4070a94e1b9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::SetExpHeapGroupId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bit16&#160;</td>
          <td class="paramname"><em>groupId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリ確保時のグループ ID を設定します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">groupId</td><td>グループ ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数で事前に初期化されている必要があります。<br />
 groupId には 0 から 255 までの正の整数を指定する必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>拡張ヒープにグループ ID が設定されます。</dd></dl>
<p><b>詳細</b> <br />
 拡張ヒープのグループ ID を設定します。<br />
 <a class="el" href="namespacenn_1_1lmem.html#a96055cfc77bfd3eac47da134a3746aa9" title="メモリ領域を確保します。 ">AllocateFromExpHeap()</a> 関数でメモリを確保する際に、各メモリブロックにも拡張ヒープのグループ ID と同様の値が設定されます。<br />
 拡張ヒープに設定されたグループ ID は <a class="el" href="namespacenn_1_1lmem.html#afd47c4651a7f6385ba616a076d0a1457" title="グループ ID を取得します。 ">GetExpHeapGroupId()</a> 関数で、各メモリブロックに設定されたグループ ID は <a class="el" href="namespacenn_1_1lmem.html#a3fb1220e2063a1660e5e1c1ca8f87d94" title="確保したメモリブロックのグループ ID を取得します。 ">GetExpHeapGroupIdOfBlock()</a> 関数で確認することができます。<br />
 グループ ID のデフォルト値は 0 です。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="afd47c4651a7f6385ba616a076d0a1457"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bit16 nn::lmem::GetExpHeapGroupId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>グループ ID を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>拡張ヒープのグループ ID が返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値が拡張ヒープのグループ ID となります。</dd></dl>
<p><b>詳細</b> <br />
 各メモリブロックに設定されたグループ ID は <a class="el" href="namespacenn_1_1lmem.html#a3fb1220e2063a1660e5e1c1ca8f87d94" title="確保したメモリブロックのグループ ID を取得します。 ">GetExpHeapGroupIdOfBlock()</a> 関数で確認することができます。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="aa4c92d4f94738d803197c67a268c1705"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::lmem::GetExpHeapBlockSize </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pBlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>確保したメモリブロックのサイズを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>メモリブロックの先頭アドレス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>拡張ヒープから確保したメモリブロックのサイズを返します。ここで返される値は、アラインメントなどの制約により、確保時のサイズより大きい値を返すことがあります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 pBlock で指定するメモリブロックが拡張ヒープによって確保されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値が拡張ヒープから確保したメモリブロックのサイズとなります。</dd></dl>
<p><b>詳細</b> <br />
 拡張ヒープから確保したメモリブロックのサイズを取得します。<br />
 <br />
 本 API はスレッドセーフではありません。<br />
 本 API を呼び出す場合は、pBlock の領域を含むヒープに対して、以下の API を同時に呼び出さないでください。 </p><ul>
<li><a class="el" href="namespacenn_1_1lmem.html#af8f5ea9ad1df5559ac024fee0564744a" title="拡張ヒープを破棄します。 ">DestroyExpHeap()</a> </li>
<li><a class="el" href="namespacenn_1_1lmem.html#aa8b756491ff15ef5937719943d7146a5" title="メモリ領域を解放します。 ">FreeToExpHeap()</a> </li>
<li><a class="el" href="namespacenn_1_1lmem.html#adacfd64bdeac5be2b33f2f5f79656379" title="拡張ヒープから確保したメモリブロックのサイズを変更します。 ">ResizeExpHeapBlock()</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="a3fb1220e2063a1660e5e1c1ca8f87d94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bit16 nn::lmem::GetExpHeapGroupIdOfBlock </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pBlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>確保したメモリブロックのグループ ID を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>メモリブロックの先頭アドレス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>拡張ヒープから確保したメモリブロックのグループ ID を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 pBlock で指定するメモリブロックが拡張ヒープによって確保されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値が拡張ヒープから確保したメモリブロックのグループ ID となります。</dd></dl>
<p><b>詳細</b> <br />
 拡張ヒープから確保したメモリブロックのグループ ID を取得します。<br />
 <br />
 本 API はスレッドセーフではありません。<br />
 本 API を呼び出す場合は、pBlock の領域を含むヒープに対して、以下の API を同時に呼び出さないでください。 </p><ul>
<li><a class="el" href="namespacenn_1_1lmem.html#af8f5ea9ad1df5559ac024fee0564744a" title="拡張ヒープを破棄します。 ">DestroyExpHeap()</a> </li>
<li><a class="el" href="namespacenn_1_1lmem.html#ab5de7bf254d6a4182e9c4070a94e1b9c" title="メモリ確保時のグループ ID を設定します。 ">SetExpHeapGroupId()</a> </li>
<li><a class="el" href="namespacenn_1_1lmem.html#aa8b756491ff15ef5937719943d7146a5" title="メモリ領域を解放します。 ">FreeToExpHeap()</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="a8f7e706930f05cd5e4e17f2eb2f30ade"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1lmem.html#a4302ad21b1a099adf611aa15400cd06b">AllocationDirection</a> nn::lmem::GetExpHeapAllocationDirectionOfBlock </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pBlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>確保したメモリブロックのメモリ確保の方向を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>メモリブロックの先頭アドレス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>拡張ヒープから確保したメモリブロックのメモリ確保の方向を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 pBlock で指定するメモリブロックが拡張ヒープによって確保されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値が拡張ヒープから確保したメモリブロックのメモリ確保の方向となります。</dd></dl>
<p><b>詳細</b> <br />
 拡張ヒープから確保したメモリブロックのメモリ確保の方向を取得します。<br />
 <br />
 本 API はスレッドセーフではありません。<br />
 本 API を呼び出す場合は、pBlock の領域を含むヒープに対して、以下の API を同時に呼び出さないでください。 </p><ul>
<li><a class="el" href="namespacenn_1_1lmem.html#af8f5ea9ad1df5559ac024fee0564744a" title="拡張ヒープを破棄します。 ">DestroyExpHeap()</a> </li>
<li><a class="el" href="namespacenn_1_1lmem.html#aa8b756491ff15ef5937719943d7146a5" title="メモリ領域を解放します。 ">FreeToExpHeap()</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="a04838ca06b67385b6eb99e63684444a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::lmem::CheckExpHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>拡張ヒープが破壊されていないかどうかをチェックします。（デバッグ用） </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>オプション（ErrorOption列挙型）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>チェックが成功すると true、失敗するとは false を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値にチェックの結果が返ります。</dd></dl>
<p><b>詳細</b> <br />
 option に ErrorOption_Print を指定すると、チェック結果のエラー出力が有効になります。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a761bf1d98698d5fd19019e748f4d0ecf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::lmem::CheckExpHeapBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>拡張ヒープから確保したメモリブロックのチェックを行います。（デバッグ用） </p>
<p>option に ErrorOption_Print を指定すると、チェック結果のエラー出力が有効になります。</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>メモリブロックの先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>オプション（ErrorOption列挙型）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>チェックが成功すると true、失敗すると false を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値にチェックの結果が返ります。</dd></dl>
<p><b>詳細</b> <br />
 option に ErrorOption_Print を指定すると、チェック結果のエラー出力が有効になります。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="ae59c5a804990cae8619eab581b693ace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::VisitExpHeapAllBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#a0f98df324bfdc3ff6e67337aa06232ef">HeapVisitor</a>&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>userParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>確保した全てのメモリブロックに対し、ユーザが指定した関数 visitor を呼びます。（デバッグ用） </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">visitor</td><td>各メモリブロックに対して呼ぶ関数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userParam</td><td>visitor 関数に渡す引数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>各メモリブロックに対して指定した関数が実行されます。</dd></dl>
<p><b>詳細</b> <br />
 拡張ヒープから割り当てられたメモリブロック全てに対して、ユーザが指定した関数を呼ばせます。<br />
 visitor 関数で呼ばれるメモリブロックの順番は、確保した順番になります。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a3ba05f8df1e914f5748889a52daf7ec7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::DumpExpHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>拡張ヒープの内部の情報を表示します。（デバッグ用） </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>拡張ヒープの内部の情報が出力されます。</dd></dl>
<p><b>詳細</b> <br />
 拡張ヒープの以下の情報をダンプします。<br />
 </p><ul>
<li>各ブロックが前から確保されているか後ろから確保されているか </li>
<li>各ブロックのアドレス </li>
<li>各ブロックのサイズ </li>
<li>各ブロックのグループ ID </li>
<li>各ブロックのアライメント </li>
<li>各ブロックが指す次のブロックのアドレス </li>
<li>各ブロックが指す前のブロックのアドレス </li>
<li>ヒープ全体のサイズ </li>
<li>ヒープの使用済み領域のサイズ <br />
 <a class="el" href="namespacenn_1_1lmem.html#a3d46d370c3b53aed4a127962761ed0fc" title="拡張ヒープを作成します。 ">CreateExpHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </li>
</ul>

</div>
</div>
<a class="anchor" id="a90727fbcf266c220ae9409106a467a49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> nn::lmem::CreateFrameHeap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>フレームヒープを作成します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddress</td><td>ヒープに割り当てるメモリブロックの先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>ヒープに割り当てるメモリブロックのサイズ（バイト） </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>デバッグ用オプション（CreationOption列挙型）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>関数が成功するとフレームヒープハンドルのポインタが返ります。失敗すると NULL が返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>startAddress は非 NULL である必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>指定したメモリブロックにフレームヒープが作成されます。</dd></dl>
<p><b>詳細</b> <br />
 ヒープ作成時にはヒープの管理領域（ヒープ共通ヘッダ）も作成されます。<br />
 ヒープ管理領域は、ヒープ内部に作成されます。<br />
 そのため、 size で指定したサイズからヒープ管理領域 ( <a class="el" href="namespacenn_1_1lmem.html#a26608eb2d71f7595fca7793432c30f6f" title="ヒープ共通ヘッダです。 ">nn::lmem::HeapCommonHead</a> 構造体) のサイズを引いた領域が、フレームヒープで利用可能な領域となります。<br />
 <br />
 option では CreationOption 列挙型での指定が可能です。複数の CreationOption 列挙型を OR 指定することも可能です。<br />
 option に CreationOption_NoOption を指定すると、オプションは無効となります。<br />
 option に CreationOption_ZeroClear を指定すると、このヒープで確保したメモリが 0 でクリアされます。<br />
 option に CreationOption_DebugFill を指定すると、ヒープ作成時、メモリ確保、メモリ解放時にメモリを特定の値でフィルします。<br />
 CreationOption_DebugFill オプションでフィルする値はデフォルトでは以下のようになっています。<br />
 </p><ul>
<li>ヒープ作成時：0xC3C3C3C3 </li>
<li>メモリ確保時：0xF3F3F3F3 </li>
<li>メモリ解放時：0xD3D3D3D3 CreationOption_ZeroClear と CreationOption_DebugFill を OR 指定した場合、ヒープ作成時とメモリ解放時は CreationOption_DebugFill の値でフィルされ、メモリ確保時はメモリが 0 でクリアされます。<br />
 この値は <a class="el" href="namespacenn_1_1lmem.html#aacdf9e8d0b3673ee2041a93353f4b3cb" title="ヒープをフィルする種別毎にフィルする値を設定します。 ">SetFillValue()</a> 関数を利用することで変更できます。<br />
 <br />
 option に CreationOption_ThreadSafe を指定すると、マルチスレッド時の排他制御を有効にします。<br />
 <br />
 本 API はスレッドセーフではありません。 </li>
</ul>

</div>
</div>
<a class="anchor" id="acd38b1a1f739530aa18143e8d7dfc4ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> nn::lmem::CreateFrameHeap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#a26608eb2d71f7595fca7793432c30f6f">HeapCommonHead</a> *&#160;</td>
          <td class="paramname"><em>pHeapHead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>フレームヒープを作成します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddress</td><td>ヒープに割り当てるメモリブロックの先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>ヒープに割り当てるメモリブロックのサイズ（バイト） </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>デバッグ用オプション（CreationOption列挙型） </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pHeapHead</td><td>ヒープ共通ヘッダ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>関数が成功するとフレームヒープハンドルのポインタが返ります。失敗すると NULL が返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>startAddress は非 NULL である必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>指定したメモリブロックにフレームヒープが作成されます。</dd></dl>
<p><b>詳細</b> <br />
 ヒープ管理領域として、引数 pHeapHead で渡された領域を使用します。<br />
 <br />
 option では CreationOption 列挙型での指定が可能です。複数の CreationOption 列挙型を OR 指定することも可能です。<br />
 option に CreationOption_NoOption を指定すると、オプションは無効となります。<br />
 option に CreationOption_ZeroClear を指定すると、このヒープで確保したメモリが 0 でクリアされます。<br />
 option に CreationOption_DebugFill を指定すると、ヒープ作成時、メモリ確保、メモリ解放時にメモリを特定の値でフィルします。<br />
 CreationOption_DebugFill オプションでフィルする値はデフォルトでは以下のようになっています。<br />
 </p><ul>
<li>ヒープ作成時：0xC3C3C3C3 </li>
<li>メモリ確保時：0xF3F3F3F3 </li>
<li>メモリ解放時：0xD3D3D3D3 CreationOption_ZeroClear と CreationOption_DebugFill を OR 指定した場合、ヒープ作成時とメモリ解放時は CreationOption_DebugFill の値でフィルされ、メモリ確保時はメモリが 0 でクリアされます。<br />
 この値は <a class="el" href="namespacenn_1_1lmem.html#aacdf9e8d0b3673ee2041a93353f4b3cb" title="ヒープをフィルする種別毎にフィルする値を設定します。 ">SetFillValue()</a> 関数を利用することで変更できます。<br />
 <br />
 option に CreationOption_ThreadSafe を指定すると、マルチスレッド時の排他制御を有効にします。<br />
 <br />
 本 API はスレッドセーフではありません。 </li>
</ul>

</div>
</div>
<a class="anchor" id="a5fcec58c14f1288a97cc8853c65215ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::DestroyFrameHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>フレームヒープを破棄します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>指定したフレームヒープが破棄されます。</dd></dl>
<p><b>詳細</b> <br />
 ヒープハンドルで指定されたヒープを破棄します。<br />
 <br />
 本 API はスレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a2530fa487300d192b1d7ed6ed33d1a4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1lmem_1_1_memory_range.html">MemoryRange</a> nn::lmem::AdjustFrameHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#a18e9eac338e3880aeee1459519b00886">AdjustMode</a>&#160;</td>
          <td class="paramname"><em>adjustMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ヒープの空き領域を解放し、使用するメモリを縮小します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">adjustMode</td><td>末尾から縮小するか、先頭から縮小するかを指定します。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ヒープが縮小されることにより空いたメモリ領域の範囲を返します。<br />
 縮小できない場合の戻り値の <a class="el" href="structnn_1_1lmem_1_1_memory_range.html" title="メモリ領域の範囲を表す構造体です。 ">MemoryRange</a> の size は 0 になります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>フレームヒープが戻り値で示される分だけ縮小されます。</dd></dl>
<p><b>詳細</b> <br />
 フレームヒープの空き領域を開放し、フレームヒープが使用するメモリを縮小します。<br />
 AdjustMode で AdjustMode_Head を指定しており、かつ <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数を用いてヒープを作成する際にヒープ共通ヘッダをヒープ領域内に作成している場合は、本関数は失敗し 0 が返却されます。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a7c6889dbc9c14c96fdc10f89b69a3c96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::lmem::AllocateFromFrameHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリ領域を確保します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>確保するメモリのサイズ（バイト）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>関数が成功すると確保したメモリ領域の先頭へのポインタ、失敗すると NULL ポインタが返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値が示すポインタから size バイトのメモリ領域が確保されます。</dd></dl>
<p><b>詳細</b> <br />
 フレームヒープでメモリを確保します。<br />
 アライメントは DefaultAlignment が利用されます。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a490bafe2b4b3cbbae2990949be3824d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::lmem::AllocateFromFrameHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定したアライメントでメモリ領域を確保します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>確保するメモリのサイズ（バイト） </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>確保するメモリのアラインメント</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>関数が成功すると確保したメモリ領域の先頭へのポインタ、失敗すると NULL ポインタが返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数で事前に初期化されている必要があります。<br />
 アライメントには正または負の 2 のべき乗が指定されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値が示すポインタから size バイトのメモリ領域が確保されます。</dd></dl>
<p><b>詳細</b> <br />
 フレームヒープでメモリを確保します。<br />
 アライメントには正または負の 2 のべき乗を指定してください<br />
 アライメントに負の値を指定すると、ヒープの後方からメモリの確保を行います。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a2c7c2693342c1151c427651a6323969a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::FreeToFrameHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#a0d378823d086c69e88ee7465eb246b3f">FreeMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリ領域を解放します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>メモリブロックの解放方法</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>指定した方法でメモリ領域が解放されます。</dd></dl>
<p><b>詳細</b> <br />
 フレームヒープで確保したメモリ領域を解放します。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a4c6f50b6ef046e66428d0c4978a2e3d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::lmem::ResizeFrameHeapBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>フレームヒープから最後に確保したメモリブロックのサイズを変更します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>サイズを変更するメモリブロックの先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newSize</td><td>変更後のメモリブロックのサイズ（バイト）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>関数が成功すると、変更後のメモリブロックのサイズ(バイト)を返します。 関数が失敗すると、0 を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>引数 pBlock で指定したメモリブロックのサイズが newSize になります。</dd></dl>
<p><b>詳細</b> <br />
 フレームヒープから最後に確保したメモリブロックのサイズを変更します。<br />
 前方から確保したメモリブロックに対してのみ使用できます。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="abf40e7cffb9c7527baa746570b6de07e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::lmem::GetFrameHeapAllocatableSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>確保可能なメモリブロックのサイズを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>アラインメント</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>フレームヒープの空き領域から確保可能なメモリブロックの最大サイズ(バイト)を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数で事前に初期化されている必要があります。<br />
 アライメントには正の 2 のべき乗が指定されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値が拡張ヒープの空き領域から確保可能なメモリブロックの最大サイズ(バイト)となります。</dd></dl>
<p><b>詳細</b> <br />
 フレームヒープで確保可能なメモリブロックのサイズを取得します。<br />
 アライメントには正の 2 のべき乗を指定してください。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="abd347d006c6676ca3c2c652b56b5540a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1lmem_1_1_frame_heap_state.html">FrameHeapState</a> nn::lmem::GetFrameHeapState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>フレームヒープの状態を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>現在のフレームヒープの状態を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値が現在のヒープの状態を表す <a class="el" href="structnn_1_1lmem_1_1_frame_heap_state.html" title="フレームヒープの状態を保存する構造体です。 ">FrameHeapState</a> 構造体となります。</dd></dl>
<p><b>詳細</b> <br />
 現在のフレームヒープの状態を返します。<br />
 ここで得た <a class="el" href="structnn_1_1lmem_1_1_frame_heap_state.html" title="フレームヒープの状態を保存する構造体です。 ">FrameHeapState</a> 構造体を <a class="el" href="namespacenn_1_1lmem.html#acdb70197d0fac93ff1c51605de577c0e" title="フレームヒープの状態を復元します。 ">RestoreFrameHeapState()</a> 関数に引数として与えることで、現在のフレームヒープの状態を復元することができます。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="acdb70197d0fac93ff1c51605de577c0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::RestoreFrameHeapState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1lmem_1_1_frame_heap_state.html">FrameHeapState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>フレームヒープの状態を復元します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>復元したいフレームヒープの状態</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数で事前に初期化されている必要があります。<br />
 復元したい pState の状態から本関数を呼ぶまでの間、 <a class="el" href="namespacenn_1_1lmem.html#a2c7c2693342c1151c427651a6323969a" title="メモリ領域を解放します。 ">FreeToFrameHeap()</a> 関数が一度も呼ばれていない必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>フレームヒープが pState の状態に戻ります。</dd></dl>
<p><b>詳細</b> <br />
 pState を元にフレームヒープの状態を復元します。<br />
 <a class="el" href="namespacenn_1_1lmem.html#a2c7c2693342c1151c427651a6323969a" title="メモリ領域を解放します。 ">FreeToFrameHeap()</a> 関数を呼んでメモリを解放してしまった場合、解放前の状態に復元することはできません。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="adb56e12364c2c984f7e41fd745b5251e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::DumpFrameHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>フレームヒープの内部の情報を表示します。（デバッグ用） </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>フレームヒープの内部の情報が出力されます。</dd></dl>
<p><b>詳細</b> <br />
 フレームヒープの以下の情報をダンプします。<br />
 </p><ul>
<li>前方から確保されているメモリ領域のアドレス範囲 </li>
<li>後方から確保されているメモリ領域のアドレス範囲 </li>
<li>ヒープ全体のサイズ </li>
<li>ヒープの使用済み領域のサイズ <br />
 <a class="el" href="namespacenn_1_1lmem.html#a90727fbcf266c220ae9409106a467a49" title="フレームヒープを作成します。 ">CreateFrameHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </li>
</ul>

</div>
</div>
<a class="anchor" id="a7d3359350e669a5fcc493ce5df5d010c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> nn::lmem::CreateUnitHeap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unitSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユニットヒープを作成します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddress</td><td>ヒープに割り当てるメモリブロックの先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>ヒープに割り当てるメモリブロックのサイズ（バイト） </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitSize</td><td>1つのメモリブロック（ユニット）のサイズ（バイト） </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>デバッグ用オプション（CreationOption列挙型）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>関数が成功するとユニットヒープハンドルのポインタが返ります。失敗すると NULL が返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>startAddress は非 NULL である必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>指定したメモリブロックにユニットヒープが作成されます。</dd></dl>
<p><b>詳細</b> <br />
 ヒープ作成時にはヒープの管理領域（ヒープ共通ヘッダ）も作成されます。<br />
 ヒープ管理領域は、ヒープ内部に作成されます。<br />
 そのため、 size で指定したサイズからヒープ管理領域 ( <a class="el" href="namespacenn_1_1lmem.html#a26608eb2d71f7595fca7793432c30f6f" title="ヒープ共通ヘッダです。 ">nn::lmem::HeapCommonHead</a> 構造体) のサイズを引いた領域が、ユニットヒープで利用可能な領域となります。<br />
 <br />
 ヒープ管理領域はヒープの先頭に作成され、アライメントは DefaultAlignment が利用されます。<br />
 <br />
 option では CreationOption 列挙型での指定が可能です。複数の CreationOption 列挙型を OR 指定することも可能です。<br />
 option に CreationOption_NoOption を指定すると、オプションは無効となります。<br />
 option に CreationOption_ZeroClear を指定すると、このヒープで確保したメモリが 0 でクリアされます。<br />
 option に CreationOption_DebugFill を指定すると、ヒープ作成時、メモリ確保、メモリ解放時にメモリを特定の値でフィルします。<br />
 CreationOption_DebugFill オプションでフィルする値はデフォルトでは以下のようになっています。<br />
 </p><ul>
<li>ヒープ作成時：0xC3C3C3C3 </li>
<li>メモリ確保時：0xF3F3F3F3 </li>
<li>メモリ解放時：0xD3D3D3D3 CreationOption_ZeroClear と CreationOption_DebugFill を OR 指定した場合、ヒープ作成時とメモリ解放時は CreationOption_DebugFill の値でフィルされ、メモリ確保時はメモリが 0 でクリアされます。<br />
 この値は <a class="el" href="namespacenn_1_1lmem.html#aacdf9e8d0b3673ee2041a93353f4b3cb" title="ヒープをフィルする種別毎にフィルする値を設定します。 ">SetFillValue()</a> 関数を利用することで変更できます。<br />
 内部アルゴリズム上、メモリブロックの先頭からポインタサイズ分はヒープ作成時とメモリ解放時にフィルされません。<br />
 <br />
 option に CreationOption_ThreadSafe を指定すると、マルチスレッド時の排他制御を有効にします。<br />
 <br />
 本 API はスレッドセーフではありません。 </li>
</ul>

</div>
</div>
<a class="anchor" id="a37e408afe1b891b1827d340897319386"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> nn::lmem::CreateUnitHeap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unitSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#abd1164e3a948696645a06c70e009f8c2">InfoPlacement</a>&#160;</td>
          <td class="paramname"><em>placement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユニットヒープを作成します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddress</td><td>ヒープに割り当てるメモリブロックの先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>ヒープに割り当てるメモリブロックのサイズ（バイト） </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitSize</td><td>一つのメモリブロック（ユニット）のサイズ（バイト） </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>デバッグ用オプション（CreationOption列挙型） </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>メモリブロックのアライメント </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">placement</td><td>ヒープの管理領域（ヒープ共通ヘッダ）を配置する位置</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>関数が成功するとユニットヒープハンドルのポインタが返ります。失敗すると NULL が返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>startAddress は非 NULL である必要があります。<br />
 アライメントには 2 のべき乗が指定されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>指定したメモリブロックにユニットヒープが作成されます。</dd></dl>
<p><b>詳細</b> <br />
 ヒープ作成時にはヒープの管理領域（ヒープ共通ヘッダ）も作成されます。<br />
 ヒープ管理領域は、ヒープ内部に作成されます。<br />
 そのため、 size で指定したサイズからヒープ管理領域 (HeapCommonHead) のサイズを引いた領域が、ユニットヒープで利用可能な領域となります。<br />
 <br />
 アライメントには 2 のべき乗を指定してください。<br />
 <br />
 option では CreationOption 列挙型での指定が可能です。複数の CreationOption 列挙型を OR 指定することも可能です。<br />
 option に CreationOption_NoOption を指定すると、オプションは無効となります。<br />
 option に CreationOption_ZeroClear を指定すると、このヒープで確保したメモリが 0 でクリアされます。<br />
 option に CreationOption_DebugFill を指定すると、ヒープ作成時、メモリ確保、メモリ解放時にメモリを特定の値でフィルします。<br />
 CreationOption_DebugFill オプションでフィルする値はデフォルトでは以下のようになっています。<br />
 </p><ul>
<li>ヒープ作成時：0xC3C3C3C3 </li>
<li>メモリ確保時：0xF3F3F3F3 </li>
<li>メモリ解放時：0xD3D3D3D3 CreationOption_ZeroClear と CreationOption_DebugFill を OR 指定した場合、ヒープ作成時とメモリ解放時は CreationOption_DebugFill の値でフィルされ、メモリ確保時はメモリが 0 でクリアされます。<br />
 この値は <a class="el" href="namespacenn_1_1lmem.html#aacdf9e8d0b3673ee2041a93353f4b3cb" title="ヒープをフィルする種別毎にフィルする値を設定します。 ">SetFillValue()</a> 関数を利用することで変更できます。<br />
 内部アルゴリズム上、メモリブロックの先頭からポインタサイズ分はヒープ作成時とメモリ解放時にフィルされません。<br />
 <br />
 option に CreationOption_ThreadSafe を指定すると、マルチスレッド時の排他制御を有効にします。<br />
 <br />
 本 API はスレッドセーフではありません。 </li>
</ul>

</div>
</div>
<a class="anchor" id="a48a0b4af7e50ed9ce91b68df40225bdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a> nn::lmem::CreateUnitHeap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unitSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#a26608eb2d71f7595fca7793432c30f6f">HeapCommonHead</a> *&#160;</td>
          <td class="paramname"><em>pHeapHead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユニットヒープを作成します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddress</td><td>ヒープに割り当てるメモリブロックの先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>ヒープに割り当てるメモリブロックのサイズ（バイト） </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitSize</td><td>一つのメモリブロック（ユニット）のサイズ（バイト） </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>デバッグ用オプション（CreationOption列挙型） </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>メモリブロックのアライメント </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pHeapHead</td><td>ヒープ共通ヘッダ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>関数が成功するとユニットヒープハンドルのポインタが返ります。失敗すると NULL が返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>startAddress は非 NULL である必要があります。<br />
 アライメントには 2 のべき乗が指定されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>指定したメモリブロックにユニットヒープが作成されます。</dd></dl>
<p><b>詳細</b> <br />
 ヒープ管理領域として、引数 pHeapHead で渡された領域を使用します。<br />
 <br />
 アライメントには 2 のべき乗を指定してください。<br />
 <br />
 option では CreationOption 列挙型での指定が可能です。複数の CreationOption 列挙型を OR 指定することも可能です。<br />
 option に CreationOption_NoOption を指定すると、オプションは無効となります。<br />
 option に CreationOption_ZeroClear を指定すると、このヒープで確保したメモリが 0 でクリアされます。<br />
 option に CreationOption_DebugFill を指定すると、ヒープ作成時、メモリ確保、メモリ解放時にメモリを特定の値でフィルします。<br />
 CreationOption_DebugFill オプションでフィルする値はデフォルトでは以下のようになっています。<br />
 </p><ul>
<li>ヒープ作成時：0xC3C3C3C3 </li>
<li>メモリ確保時：0xF3F3F3F3 </li>
<li>メモリ解放時：0xD3D3D3D3 CreationOption_ZeroClear と CreationOption_DebugFill を OR 指定した場合、ヒープ作成時とメモリ解放時は CreationOption_DebugFill の値でフィルされ、メモリ確保時はメモリが 0 でクリアされます。<br />
 この値は <a class="el" href="namespacenn_1_1lmem.html#aacdf9e8d0b3673ee2041a93353f4b3cb" title="ヒープをフィルする種別毎にフィルする値を設定します。 ">SetFillValue()</a> 関数を利用することで変更できます。<br />
 内部アルゴリズム上、メモリブロックの先頭からポインタサイズ分はヒープ作成時とメモリ解放時にフィルされません。<br />
 <br />
 option に CreationOption_ThreadSafe を指定すると、マルチスレッド時の排他制御を有効にします。<br />
 <br />
 本 API はスレッドセーフではありません。 </li>
</ul>

</div>
</div>
<a class="anchor" id="a03e9905bd641416421fb108f487b5d4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::DestroyUnitHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユニットヒープを破棄します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="ユニットヒープを作成します。 ">CreateUnitHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>指定したユニットヒープが破棄されます。</dd></dl>
<p><b>詳細</b> <br />
 ヒープハンドルで指定されたヒープを破棄します。<br />
 <br />
 本 API はスレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a4ca8ffeb524244ca4f9968d116817257"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::InvalidateUnitHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ヒープを無効化します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="ユニットヒープを作成します。 ">CreateUnitHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>指定したユニットヒープが無効化されます。</dd></dl>
<p><b>詳細</b> <br />
 この関数を呼んだ後は Finalize 以外の操作をヒープに対して行うことができなくなります。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="ユニットヒープを作成します。 ">CreateUnitHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="ac64765b319b7e98292e4ce5f70dbce73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::ExtendUnitHeapArea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ヒープとして与えられた領域を拡張します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>拡張サイズ。Initialize 時に指定したユニットサイズの倍数である必要があります。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="ユニットヒープを作成します。 ">CreateUnitHeap()</a> 関数で事前に初期化されている必要があります。</dd></dl>
<p><b>詳細</b> <br />
 ヒープサイズを後方に伸長しユニットを増加させます。 </p>

</div>
</div>
<a class="anchor" id="a1d1eec8ea87ca5a847eae04fb21c7a36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::lmem::AllocateFromUnitHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリ領域を確保します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>関数が成功すると確保したメモリ領域の先頭へのポインタ、失敗すると NULL ポインタが返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="ユニットヒープを作成します。 ">CreateUnitHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値が示すポインタからメモリ領域が確保されます。</dd></dl>
<p><b>詳細</b> <br />
 ユニットヒープでメモリを確保します。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="ユニットヒープを作成します。 ">CreateUnitHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="ab190d0a00216c4d8cd2e3134680d3a45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::FreeToUnitHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリ領域を解放します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlock</td><td>解放するするメモリブロック（ユニット）の先頭アドレス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="ユニットヒープを作成します。 ">CreateUnitHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>指定したメモリ領域が解放されます。</dd></dl>
<p><b>詳細</b> <br />
 ユニットヒープで確保したメモリ領域を解放します。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="ユニットヒープを作成します。 ">CreateUnitHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a4f73af475a54358322fe7b3c8bf78ef6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::lmem::GetUnitHeapUnitSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユニットヒープのユニットサイズを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ユニットヒープの1つのメモリブロック（ユニット）のサイズを返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="ユニットヒープを作成します。 ">CreateUnitHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値がユニットヒープのユニットサイズになります。</dd></dl>
<p><b>詳細</b> <br />
 ユニットヒープの1つのメモリブロック（ユニット）のサイズを取得します。<br />
 <br />
 本 API はスレッドセーフです。 </p>

</div>
</div>
<a class="anchor" id="abe2b6be8b9c2077fec92fb19c5e8aeb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::lmem::GetUnitHeapAllocatableCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>空きユニットの数を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>確保されていないユニットの数を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="ユニットヒープを作成します。 ">CreateUnitHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値がユニットヒープの空きユニット数になります。</dd></dl>
<p><b>詳細</b> <br />
 ユニットヒープのユニットのうち、確保されていないユニットの数を取得します。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="ユニットヒープを作成します。 ">CreateUnitHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="aaa1ae99b4baab79444c503a383345154"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::lmem::GetUnitHeapAllocatedCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>現在このヒープから確保されているユニットの数を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>確保されているユニットの数を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="ユニットヒープを作成します。 ">CreateUnitHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値がユニットヒープの確保ユニット数になります。</dd></dl>
<p><b>詳細</b> <br />
 ユニットヒープのユニットのうち、確保されているユニットの数を取得します。<br />
 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="ユニットヒープを作成します。 ">CreateUnitHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a8a08003a1b715eded61e040c3cd087a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::lmem::GetUnitHeapAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユニットのアライメントを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ユニットのアライメントを返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="ユニットヒープを作成します。 ">CreateUnitHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>戻り値がユニットのアライメントになります。</dd></dl>
<p><b>詳細</b> <br />
 ユニットヒープの各メモリブロック（ユニット）のアライメントを取得します。<br />
 <br />
 本 API はスレッドセーフです。 </p>

</div>
</div>
<a class="anchor" id="a8ac10912318a3d5f45687fa1885c89be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::lmem::GetRequiredUnitHeapSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unitSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>unitNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hasHeadInternally</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定したユニットサイズとアライメントのブロックを指定数を管理できるだけのヒープメモリのサイズを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">unitSize</td><td>ユニットのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitNum</td><td>ユニット数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>アライメント </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hasHeadInternally</td><td>ヒープの管理領域をヒープ内部に持つか</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>指定した条件で必要なメモリサイズを返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>アライメントには 2 のべき乗が指定されている必要があります。</dd></dl>
<p><b>詳細</b> <br />
 引数で与えた条件を元に、その条件が満たされるユニットヒープを作成するために必要なメモリサイズを計算し、取得します。<br />
 アライメントには 2 のべき乗を指定してください。<br />
 <a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="ユニットヒープを作成します。 ">CreateUnitHeap()</a> 関数でユニットヒープを作成する際に、ヒープの管理領域をヒープ内部に作成する場合は hasHeadInternally に true を指定してください。<br />
 ヒープの管理領域をヒープ外に確保する場合は、 hasHeadInternally に false を指定してください。<br />
 <br />
 本 API はスレッドセーフです。 </p>

</div>
</div>
<a class="anchor" id="a1deefa949a2c36e348db0fe808cad2de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::lmem::DumpUnitHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1lmem.html#ab893a05f9834a881447ea604c7d60400">HeapHandle</a>&#160;</td>
          <td class="paramname"><em>heapHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユニットヒープの内部の情報を表示します。（デバッグ用） </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heapHandle</td><td>ヒープハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>引数 heapHandle が <a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="ユニットヒープを作成します。 ">CreateUnitHeap()</a> 関数で事前に初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>ユニットヒープの内部の情報が出力されます。</dd></dl>
<p><b>詳細</b> <br />
 ユニットヒープの以下の情報をダンプします。<br />
 </p><ul>
<li>各ユニットのアドレス範囲とサイズ </li>
<li>ヒープ全体のアドレス範囲とサイズ </li>
<li>ヒープの使用済み領域のサイズと使用比率 <br />
 <a class="el" href="namespacenn_1_1lmem.html#a7d3359350e669a5fcc493ce5df5d010c" title="ユニットヒープを作成します。 ">CreateUnitHeap()</a> 関数でのヒープ作成時に CreationOption_ThreadSafe をオプションに指定して作成されたヒープの場合、本 API はスレッドセーフになります。<br />
 そうでない場合、同一の heapHandle で扱われるヒープに対して行う操作は、スレッドセーフではありません。 </li>
</ul>

</div>
</div>
<h2 class="groupheader">変数詳解</h2>
<a class="anchor" id="a9b73760b843761bad7afb25be502c4b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int nn::lmem::DefaultAlignment = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリ確保の際のデフォルトアラインメントです。 </p>
<p><b>詳細</b> <br />
 メモリ確保の際にデフォルトで指定されるアライメントです。 </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
