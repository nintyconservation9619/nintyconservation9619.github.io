<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>NintendoSDK API Reference: nn::fs 名前空間</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>総合概要</span></a></li>
      <li><a href="pages.html"><span>諸情報</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li class="current"><a href="namespaces.html"><span>名前空間</span></a></li>
      <li><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>名前空間一覧</span></a></li>
      <li><a href="namespacemembers.html"><span>名前空間メンバ</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1fs.html">fs</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">クラス</a> &#124;
<a href="#typedef-members">型定義</a> &#124;
<a href="#enum-members">列挙型</a> &#124;
<a href="#var-members">変数</a>  </div>
  <div class="headertitle">
<div class="title">nn::fs 名前空間</div>  </div>
</div><!--header-->
<div class="contents">

<p>ファイルシステムライブラリの名前空間です。  
<a href="#details">[詳解]</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
クラス</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1fs_1_1_cache_storage_info.html">CacheStorageInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">キャッシュストレージの情報を表す構造体です。  <a href="structnn_1_1fs_1_1_cache_storage_info.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1fs_1_1_cache_storage_list_handle.html">CacheStorageListHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">キャッシュストレージリストを取得するためのハンドルです。  <a href="structnn_1_1fs_1_1_cache_storage_list_handle.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1fs_1_1_directory_entry.html">DirectoryEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ディレクトリエントリを表す構造体です  <a href="structnn_1_1fs_1_1_directory_entry.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1fs_1_1_directory_handle.html">DirectoryHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ディレクトリを扱うためのハンドルです。  <a href="structnn_1_1fs_1_1_directory_handle.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルを扱うためのハンドルです。  <a href="structnn_1_1fs_1_1_file_handle.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1fs_1_1_file_time_stamp.html">FileTimeStamp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルのタイムスタンプ情報を定義した構造体です  <a href="structnn_1_1fs_1_1_file_time_stamp.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1fs_1_1_read_option.html">ReadOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイル読み込み時のオプション指定子です。  <a href="structnn_1_1fs_1_1_read_option.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_allocation_memory_failed.html">ResultAllocationMemoryFailed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: メモリ不足) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_allocation_memory_failed.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_already_exists.html">ResultAlreadyExists</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: 同名のファイルまたはディレクトリが既に存在する) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_already_exists.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_data_corrupted.html">ResultDataCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: データ壊れや改竄の検知) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_data_corrupted.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_deferred_process_retry_failure.html">ResultDeferredProcessRetryFailure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: アクセスエラーが発生し遅延した処理の解決に失敗) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_deferred_process_retry_failure.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_directory_not_empty.html">ResultDirectoryNotEmpty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: 対象のディレクトリ内にエントリがある) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_directory_not_empty.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_directory_status_changed.html">ResultDirectoryStatusChanged</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: ディレクトリ列挙中にディレクトリの状態が変わった) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_directory_status_changed.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_game_card_access_failed.html">ResultGameCardAccessFailed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: ゲームカードへのアクセスに失敗) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_game_card_access_failed.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_game_card_card_access_failure.html">ResultGameCardCardAccessFailure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: GameCard - ゲームカードへのアクセスエラー) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_game_card_card_access_failure.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_game_card_initialize_asic_failure.html">ResultGameCardInitializeAsicFailure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: GameCard - ASIC 初期化エラー) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_game_card_initialize_asic_failure.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_game_card_logo_data_corrupted.html">ResultGameCardLogoDataCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: ゲームカード上のロゴデータのデータ壊れや改竄の検知) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_game_card_logo_data_corrupted.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_handled_by_all_process.html">ResultHandledByAllProcess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: どのプロセスからでもハンドリングされるべきエラー) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_handled_by_all_process.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_handled_by_system_process.html">ResultHandledBySystemProcess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: システムプロセスのみハンドリングするエラー) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_handled_by_system_process.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_host_entry_corrupted.html">ResultHostEntryCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: ホストのエントリが壊れている) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_host_entry_corrupted.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_host_file_corrupted.html">ResultHostFileCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: ホストのファイルが壊れている) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_host_file_corrupted.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_host_file_data_corrupted.html">ResultHostFileDataCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: ホストのデータが壊れている) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_host_file_data_corrupted.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_host_file_system_corrupted.html">ResultHostFileSystemCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: ホストファイルシステムのデータ壊れや改竄の検知) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_host_file_system_corrupted.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_invalid_host_handle.html">ResultInvalidHostHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: ホストのハンドルが不正) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_invalid_host_handle.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_invalid_rom_host_handle.html">ResultInvalidRomHostHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: ホストのハンドルが不正) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_invalid_rom_host_handle.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_invalid_save_data_host_handle.html">ResultInvalidSaveDataHostHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: ホストのハンドルが不正) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_invalid_save_data_host_handle.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_mmc_access_failed.html">ResultMmcAccessFailed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: 本体保存メモリーへのアクセスに失敗) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_mmc_access_failed.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html">ResultMountNameAlreadyExists</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: マウント名が既に存在している) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_mount_name_already_exists.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_not_implemented.html">ResultNotImplemented</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: 未実装の操作) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_not_implemented.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_out_of_range.html">ResultOutOfRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: 操作範囲が領域外) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_out_of_range.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_partition_not_found.html">ResultPartitionNotFound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: 対象のパーティションが見つからない) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_partition_not_found.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_path_already_exists.html">ResultPathAlreadyExists</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: 対象が既に存在している) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_path_already_exists.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html">ResultPathNotFound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: 指定されたパスに対象が見つからない) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_path_not_found.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_rom_host_entry_corrupted.html">ResultRomHostEntryCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: ホストのエントリが壊れている) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_rom_host_entry_corrupted.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_rom_host_file_corrupted.html">ResultRomHostFileCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: ホストのファイルが壊れている) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_rom_host_file_corrupted.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_rom_host_file_data_corrupted.html">ResultRomHostFileDataCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: ホストのデータが壊れている) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_rom_host_file_data_corrupted.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_rom_host_file_system_corrupted.html">ResultRomHostFileSystemCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: ホストファイルシステムのデータ壊れや改竄の検知) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_rom_host_file_system_corrupted.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_save_data_host_entry_corrupted.html">ResultSaveDataHostEntryCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: ホストのエントリが壊れている) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_save_data_host_entry_corrupted.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_save_data_host_file_corrupted.html">ResultSaveDataHostFileCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: ホストのファイルが壊れている) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_save_data_host_file_corrupted.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_save_data_host_file_data_corrupted.html">ResultSaveDataHostFileDataCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: ホストのデータが壊れている) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_save_data_host_file_data_corrupted.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_save_data_host_file_system_corrupted.html">ResultSaveDataHostFileSystemCorrupted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: ホストファイルシステムのデータ壊れや改竄の検知) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_save_data_host_file_system_corrupted.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_sd_card_access_failed.html">ResultSdCardAccessFailed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: SD カードへのアクセスに失敗) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_sd_card_access_failed.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html">ResultTargetLocked</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: 対象がロックされている) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_target_locked.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_target_not_found.html">ResultTargetNotFound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: 対象が見つからない) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_target_not_found.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_unexpected.html">ResultUnexpected</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: 不明な失敗) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_unexpected.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_unsupported_sdk_version.html">ResultUnsupportedSdkVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: サポートされていない SDK バージョン) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_unsupported_sdk_version.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_unsupported_version.html">ResultUnsupportedVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: バージョンが新し過ぎる) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_unsupported_version.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough.html">ResultUsableSpaceNotEnough</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: 空き容量が不足) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_usable_space_not_enough.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough_for_cache_storage.html">ResultUsableSpaceNotEnoughForCacheStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: キャッシュストレージを作成するための空き容量が不足) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_usable_space_not_enough_for_cache_storage.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough_for_save_data.html">ResultUsableSpaceNotEnoughForSaveData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (fs: セーブデータを作成するための空き容量が不足) を表すクラスです。  <a href="classnn_1_1fs_1_1_result_usable_space_not_enough_for_save_data.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1fs_1_1_write_option.html">WriteOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイル書き込み時のオプション指定子です。  <a href="structnn_1_1fs_1_1_write_option.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
型定義</h2></td></tr>
<tr class="memitem:a9860dee956c54cadf027c37d54adeb28"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a9860dee956c54cadf027c37d54adeb28">AllocateFunction</a>) (size_t)</td></tr>
<tr class="memdesc:a9860dee956c54cadf027c37d54adeb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ確保用の関数ポインタです。  <a href="#a9860dee956c54cadf027c37d54adeb28">[詳解]</a><br /></td></tr>
<tr class="separator:a9860dee956c54cadf027c37d54adeb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c75b075241d17f1b52cd9eefa851aa"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a07c75b075241d17f1b52cd9eefa851aa">DeallocateFunction</a>) (void *, size_t)</td></tr>
<tr class="memdesc:a07c75b075241d17f1b52cd9eefa851aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ解放用の関数ポインタです。  <a href="#a07c75b075241d17f1b52cd9eefa851aa">[詳解]</a><br /></td></tr>
<tr class="separator:a07c75b075241d17f1b52cd9eefa851aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
列挙型</h2></td></tr>
<tr class="memitem:a5fc46cd05067c210b62e96f903a2fe85"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a5fc46cd05067c210b62e96f903a2fe85">DirectoryEntryType</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a5fc46cd05067c210b62e96f903a2fe85a2824a031f5834c762620e321ac8933c6">DirectoryEntryType_Directory</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a5fc46cd05067c210b62e96f903a2fe85a194470d850d5968a491fd9ef6145d5a0">DirectoryEntryType_File</a>
<br />
 }<tr class="memdesc:a5fc46cd05067c210b62e96f903a2fe85"><td class="mdescLeft">&#160;</td><td class="mdescRight">ディレクトリエントリの種類を表す列挙型です  <a href="namespacenn_1_1fs.html#a5fc46cd05067c210b62e96f903a2fe85">[詳解]</a><br /></td></tr>
<tr class="separator:a5fc46cd05067c210b62e96f903a2fe85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a34bc03cdbe641524cab284a7fe7ba705"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a34bc03cdbe641524cab284a7fe7ba705">OpenDirectoryMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a34bc03cdbe641524cab284a7fe7ba705a6cabc455dd34f3d7562137ea63a5daab">OpenDirectoryMode_Directory</a> = 1 &lt;&lt; 0, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a34bc03cdbe641524cab284a7fe7ba705a560a621c8b1cb6f228ea202b9efd7432">OpenDirectoryMode_File</a> = 1 &lt;&lt; 1, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a34bc03cdbe641524cab284a7fe7ba705a1769c5d739757a86e8f98bddbc3ee9c5">OpenDirectoryMode_All</a> = OpenDirectoryMode_Directory | OpenDirectoryMode_File
<br />
 }<tr class="memdesc:a34bc03cdbe641524cab284a7fe7ba705"><td class="mdescLeft">&#160;</td><td class="mdescRight">ディレクトリオープン時のモードを指定するフラグです  <a href="namespacenn_1_1fs.html#a34bc03cdbe641524cab284a7fe7ba705">[詳解]</a><br /></td></tr>
<tr class="separator:a34bc03cdbe641524cab284a7fe7ba705"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a4c97b79cce78a95c2333dbc9053b9393"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393">OpenMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393afde4472d2b455879cad02aade386ac0d">OpenMode_Read</a> = 1 &lt;&lt; 0, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393a0ee257dbba840301b0e656f6d1345c03">OpenMode_Write</a> = 1 &lt;&lt; 1, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393aac1149600d18adbb26a1ae87de7096c1">OpenMode_AllowAppend</a> = 1 &lt;&lt; 2
<br />
 }<tr class="memdesc:a4c97b79cce78a95c2333dbc9053b9393"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルオープン時のモードを指定するフラグです  <a href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393">[詳解]</a><br /></td></tr>
<tr class="separator:a4c97b79cce78a95c2333dbc9053b9393"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a2e4a9f55e854a9755c9264838caa97d3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3">Priority</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3a0fa1620fa464966eddf7e9a82a0eef91">Priority_Realtime</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3a3fe1f52283573973940fa566d116289e">Priority_Normal</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3aa4c563bb69a4dfd6ac970ba42def209a">Priority_Low</a>
<br />
 }<tr class="memdesc:a2e4a9f55e854a9755c9264838caa97d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">アクセス優先度です。  <a href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3">[詳解]</a><br /></td></tr>
<tr class="separator:a2e4a9f55e854a9755c9264838caa97d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:afb4fdd50e0892400c07232f714caa14d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#afb4fdd50e0892400c07232f714caa14d">WriteOptionFlag</a> { <a class="el" href="namespacenn_1_1fs.html#afb4fdd50e0892400c07232f714caa14da2956e16dac576b2b7eff3142e18ac2c0">WriteOptionFlag_Flush</a> = 1 &lt;&lt; 0
 }<tr class="memdesc:afb4fdd50e0892400c07232f714caa14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイル書き込み時のオプション指定フラグです。  <a href="namespacenn_1_1fs.html#afb4fdd50e0892400c07232f714caa14d">[詳解]</a><br /></td></tr>
<tr class="separator:afb4fdd50e0892400c07232f714caa14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
関数</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">キャッシュストレージ関連 API</div></td></tr>
<tr class="memitem:a38a958348ad64793a93e82a5a556d7b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a38a958348ad64793a93e82a5a556d7b4">MountCacheStorage</a> (const char *name) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a38a958348ad64793a93e82a5a556d7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">キャッシュストレージをマウントします。  <a href="#a38a958348ad64793a93e82a5a556d7b4">[詳解]</a><br /></td></tr>
<tr class="separator:a38a958348ad64793a93e82a5a556d7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab217b088ff86a675d869cc9fb38390ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ab217b088ff86a675d869cc9fb38390ac">MountCacheStorage</a> (const char *name, int index) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab217b088ff86a675d869cc9fb38390ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">インデックスを指定してキャッシュストレージをマウントします。  <a href="#ab217b088ff86a675d869cc9fb38390ac">[詳解]</a><br /></td></tr>
<tr class="separator:ab217b088ff86a675d869cc9fb38390ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ディレクトリ関連 API</div></td></tr>
<tr class="memitem:af1ecb9478fe0f9dee627b65111cdbe29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#af1ecb9478fe0f9dee627b65111cdbe29">ReadDirectory</a> (int64_t *outValue, <a class="el" href="structnn_1_1fs_1_1_directory_entry.html">DirectoryEntry</a> *entryBuffer, <a class="el" href="structnn_1_1fs_1_1_directory_handle.html">DirectoryHandle</a> handle, int64_t entryBufferCount) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af1ecb9478fe0f9dee627b65111cdbe29"><td class="mdescLeft">&#160;</td><td class="mdescRight">ディレクトリの子エントリを列挙します。  <a href="#af1ecb9478fe0f9dee627b65111cdbe29">[詳解]</a><br /></td></tr>
<tr class="separator:af1ecb9478fe0f9dee627b65111cdbe29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a54b0d39dfd293b11cd1c0073aafb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#aa6a54b0d39dfd293b11cd1c0073aafb1">GetDirectoryEntryCount</a> (int64_t *outValue, <a class="el" href="structnn_1_1fs_1_1_directory_handle.html">DirectoryHandle</a> handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa6a54b0d39dfd293b11cd1c0073aafb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ディレクトリの子エントリの個数を取得します。  <a href="#aa6a54b0d39dfd293b11cd1c0073aafb1">[詳解]</a><br /></td></tr>
<tr class="separator:aa6a54b0d39dfd293b11cd1c0073aafb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d0fa5050c0f77a0a6f14a0b78f9b58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#af8d0fa5050c0f77a0a6f14a0b78f9b58">CloseDirectory</a> (<a class="el" href="structnn_1_1fs_1_1_directory_handle.html">DirectoryHandle</a> handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af8d0fa5050c0f77a0a6f14a0b78f9b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">ディレクトリをクローズします。  <a href="#af8d0fa5050c0f77a0a6f14a0b78f9b58">[詳解]</a><br /></td></tr>
<tr class="separator:af8d0fa5050c0f77a0a6f14a0b78f9b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae21d0f79e4d074e120c814a8936a42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#acae21d0f79e4d074e120c814a8936a42">OpenDirectory</a> (<a class="el" href="structnn_1_1fs_1_1_directory_handle.html">DirectoryHandle</a> *outValue, const char *path, int mode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acae21d0f79e4d074e120c814a8936a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">ディレクトリをオープンします。  <a href="#acae21d0f79e4d074e120c814a8936a42">[詳解]</a><br /></td></tr>
<tr class="separator:acae21d0f79e4d074e120c814a8936a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ファイル関連 API</div></td></tr>
<tr class="memitem:a81801a404563984f8c6cc1483cc6d730"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a81801a404563984f8c6cc1483cc6d730">ReadFile</a> (<a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle, int64_t offset, void *buffer, size_t size, const <a class="el" href="structnn_1_1fs_1_1_read_option.html">ReadOption</a> &amp;option) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a81801a404563984f8c6cc1483cc6d730"><td class="mdescLeft">&#160;</td><td class="mdescRight">サイズが既知であるファイルの内容を、指定されたメモリへ読み込みます。  <a href="#a81801a404563984f8c6cc1483cc6d730">[詳解]</a><br /></td></tr>
<tr class="separator:a81801a404563984f8c6cc1483cc6d730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b280140b3e9d7eb83af3e807e4c0c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a90b280140b3e9d7eb83af3e807e4c0c3">ReadFile</a> (<a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle, int64_t offset, void *buffer, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a90b280140b3e9d7eb83af3e807e4c0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">サイズが既知であるファイルの内容を、指定されたメモリへオプションなしで読み込みます。  <a href="#a90b280140b3e9d7eb83af3e807e4c0c3">[詳解]</a><br /></td></tr>
<tr class="separator:a90b280140b3e9d7eb83af3e807e4c0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57d27066c8c88b6bf354fcfb3a8f394"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#aa57d27066c8c88b6bf354fcfb3a8f394">ReadFile</a> (size_t *outValue, <a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle, int64_t offset, void *buffer, size_t size, const <a class="el" href="structnn_1_1fs_1_1_read_option.html">ReadOption</a> &amp;option) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa57d27066c8c88b6bf354fcfb3a8f394"><td class="mdescLeft">&#160;</td><td class="mdescRight">サイズが不明なファイルの内容を、指定されたメモリへ読み込みます。  <a href="#aa57d27066c8c88b6bf354fcfb3a8f394">[詳解]</a><br /></td></tr>
<tr class="separator:aa57d27066c8c88b6bf354fcfb3a8f394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433a913ce9dd7154b430118e99b4867b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a433a913ce9dd7154b430118e99b4867b">ReadFile</a> (size_t *outValue, <a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle, int64_t offset, void *buffer, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a433a913ce9dd7154b430118e99b4867b"><td class="mdescLeft">&#160;</td><td class="mdescRight">サイズが不明なファイルの内容を、指定されたメモリへオプションなしで読み込みます。  <a href="#a433a913ce9dd7154b430118e99b4867b">[詳解]</a><br /></td></tr>
<tr class="separator:a433a913ce9dd7154b430118e99b4867b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4351ff3a319e9a63093324a669492ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ab4351ff3a319e9a63093324a669492ab">WriteFile</a> (<a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle, int64_t offset, const void *buffer, size_t size, const <a class="el" href="structnn_1_1fs_1_1_write_option.html">WriteOption</a> &amp;option) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab4351ff3a319e9a63093324a669492ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルへ指定されたメモリの内容を書き込みます。  <a href="#ab4351ff3a319e9a63093324a669492ab">[詳解]</a><br /></td></tr>
<tr class="separator:ab4351ff3a319e9a63093324a669492ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543a813b9e0c46a2d6ccb24d7c863a76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a543a813b9e0c46a2d6ccb24d7c863a76">FlushFile</a> (<a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a543a813b9e0c46a2d6ccb24d7c863a76"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacenn_1_1fs.html#ab4351ff3a319e9a63093324a669492ab" title="ファイルへ指定されたメモリの内容を書き込みます。 ">WriteFile()</a> で指定した内容を、確実に書き込まれた状態にします。  <a href="#a543a813b9e0c46a2d6ccb24d7c863a76">[詳解]</a><br /></td></tr>
<tr class="separator:a543a813b9e0c46a2d6ccb24d7c863a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab469b77c1d8c44eaedb9b6d658aba6c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ab469b77c1d8c44eaedb9b6d658aba6c6">SetFileSize</a> (<a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle, int64_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab469b77c1d8c44eaedb9b6d658aba6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルのサイズを変更します。  <a href="#ab469b77c1d8c44eaedb9b6d658aba6c6">[詳解]</a><br /></td></tr>
<tr class="separator:ab469b77c1d8c44eaedb9b6d658aba6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba29e01d386e809349d60eccdb15ff21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#aba29e01d386e809349d60eccdb15ff21">GetFileSize</a> (int64_t *outValue, <a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aba29e01d386e809349d60eccdb15ff21"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルのサイズを取得します。  <a href="#aba29e01d386e809349d60eccdb15ff21">[詳解]</a><br /></td></tr>
<tr class="separator:aba29e01d386e809349d60eccdb15ff21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2805c57e6c7c5ec8fbc7d30e7137deae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a2805c57e6c7c5ec8fbc7d30e7137deae">GetFileOpenMode</a> (<a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2805c57e6c7c5ec8fbc7d30e7137deae"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルオープン時に指定したモードを取得します。  <a href="#a2805c57e6c7c5ec8fbc7d30e7137deae">[詳解]</a><br /></td></tr>
<tr class="separator:a2805c57e6c7c5ec8fbc7d30e7137deae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bd9e828751bd4f953acfa765278f84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ac8bd9e828751bd4f953acfa765278f84">CloseFile</a> (<a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac8bd9e828751bd4f953acfa765278f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルをクローズします。  <a href="#ac8bd9e828751bd4f953acfa765278f84">[詳解]</a><br /></td></tr>
<tr class="separator:ac8bd9e828751bd4f953acfa765278f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2b5b30657b1ffaf1dec49bfb36462b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a0f2b5b30657b1ffaf1dec49bfb36462b">OpenFile</a> (<a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> *outValue, const char *path, int mode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0f2b5b30657b1ffaf1dec49bfb36462b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルをオープンします。  <a href="#a0f2b5b30657b1ffaf1dec49bfb36462b">[詳解]</a><br /></td></tr>
<tr class="separator:a0f2b5b30657b1ffaf1dec49bfb36462b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ファイルシステム関連 API</div></td></tr>
<tr class="memitem:a3e89c4d57cc8379265894ff7f3e98b2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a3e89c4d57cc8379265894ff7f3e98b2c">CreateFile</a> (const char *path, int64_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3e89c4d57cc8379265894ff7f3e98b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルを作成します。  <a href="#a3e89c4d57cc8379265894ff7f3e98b2c">[詳解]</a><br /></td></tr>
<tr class="separator:a3e89c4d57cc8379265894ff7f3e98b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812ac4964fb5564467c5475c1b9fb16b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a812ac4964fb5564467c5475c1b9fb16b">DeleteFile</a> (const char *path) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a812ac4964fb5564467c5475c1b9fb16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルを削除します。  <a href="#a812ac4964fb5564467c5475c1b9fb16b">[詳解]</a><br /></td></tr>
<tr class="separator:a812ac4964fb5564467c5475c1b9fb16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09dbc3816b9e95562081f9411711c4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ad09dbc3816b9e95562081f9411711c4a">CreateDirectory</a> (const char *path) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad09dbc3816b9e95562081f9411711c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">ディレクトリを作成します。  <a href="#ad09dbc3816b9e95562081f9411711c4a">[詳解]</a><br /></td></tr>
<tr class="separator:ad09dbc3816b9e95562081f9411711c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e072fc4b9bd6a36b6902b117ba85d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a40e072fc4b9bd6a36b6902b117ba85d0">DeleteDirectory</a> (const char *path) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a40e072fc4b9bd6a36b6902b117ba85d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">ディレクトリを削除します。  <a href="#a40e072fc4b9bd6a36b6902b117ba85d0">[詳解]</a><br /></td></tr>
<tr class="separator:a40e072fc4b9bd6a36b6902b117ba85d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c41cd88ca1bd0cace5a443f4bc3efd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ad6c41cd88ca1bd0cace5a443f4bc3efd">DeleteDirectoryRecursively</a> (const char *path) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad6c41cd88ca1bd0cace5a443f4bc3efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">子エントリも含め、ディレクトリを再帰的に削除します。  <a href="#ad6c41cd88ca1bd0cace5a443f4bc3efd">[詳解]</a><br /></td></tr>
<tr class="separator:ad6c41cd88ca1bd0cace5a443f4bc3efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52b7fdae71cfa75a6c45552c4195b87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ae52b7fdae71cfa75a6c45552c4195b87">CleanDirectoryRecursively</a> (const char *path) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae52b7fdae71cfa75a6c45552c4195b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">ディレクトリに含まれる全ての子エントリを再帰的に削除します。  <a href="#ae52b7fdae71cfa75a6c45552c4195b87">[詳解]</a><br /></td></tr>
<tr class="separator:ae52b7fdae71cfa75a6c45552c4195b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1a2e4d197a78400b604debc9c7c4ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#aaa1a2e4d197a78400b604debc9c7c4ea">RenameFile</a> (const char *currentPath, const char *newPath) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aaa1a2e4d197a78400b604debc9c7c4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイル名を変更します。ファイルの移動も可能です。  <a href="#aaa1a2e4d197a78400b604debc9c7c4ea">[詳解]</a><br /></td></tr>
<tr class="separator:aaa1a2e4d197a78400b604debc9c7c4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394c7c7cce23b0a368e83d115baafe17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a394c7c7cce23b0a368e83d115baafe17">RenameDirectory</a> (const char *currentPath, const char *newPath) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a394c7c7cce23b0a368e83d115baafe17"><td class="mdescLeft">&#160;</td><td class="mdescRight">ディレクトリ名を変更します。ディレクトリの移動も可能です。  <a href="#a394c7c7cce23b0a368e83d115baafe17">[詳解]</a><br /></td></tr>
<tr class="separator:a394c7c7cce23b0a368e83d115baafe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf6e2f2c5a0c4e404ba3dd782cc98bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a5cf6e2f2c5a0c4e404ba3dd782cc98bc">GetEntryType</a> (<a class="el" href="namespacenn_1_1fs.html#a5fc46cd05067c210b62e96f903a2fe85">DirectoryEntryType</a> *outValue, const char *path) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5cf6e2f2c5a0c4e404ba3dd782cc98bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">エントリの種類を取得します。  <a href="#a5cf6e2f2c5a0c4e404ba3dd782cc98bc">[詳解]</a><br /></td></tr>
<tr class="separator:a5cf6e2f2c5a0c4e404ba3dd782cc98bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac021c163ba94a44a2b53cb848c462930"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ac021c163ba94a44a2b53cb848c462930">SetAllocator</a> (<a class="el" href="namespacenn_1_1fs.html#a9860dee956c54cadf027c37d54adeb28">AllocateFunction</a> alloc, <a class="el" href="namespacenn_1_1fs.html#a07c75b075241d17f1b52cd9eefa851aa">DeallocateFunction</a> dealloc) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac021c163ba94a44a2b53cb848c462930"><td class="mdescLeft">&#160;</td><td class="mdescRight">fs ライブラリが使用するメモリアロケータを設定します。  <a href="#ac021c163ba94a44a2b53cb848c462930">[詳解]</a><br /></td></tr>
<tr class="separator:ac021c163ba94a44a2b53cb848c462930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a95249afd4a87a55d319dfecb0466c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ac8a95249afd4a87a55d319dfecb0466c">Unmount</a> (const char *name) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac8a95249afd4a87a55d319dfecb0466c"><td class="mdescLeft">&#160;</td><td class="mdescRight">マウント済みのファイルシステムをアンマウントし、リソースを解放します。  <a href="#ac8a95249afd4a87a55d319dfecb0466c">[詳解]</a><br /></td></tr>
<tr class="separator:ac8a95249afd4a87a55d319dfecb0466c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ホスト PC 関連 API</div></td></tr>
<tr class="memitem:a1b85bf3f3cf038cb67a991a3e3304751"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a1b85bf3f3cf038cb67a991a3e3304751">MountHost</a> (const char *name, const char *rootPath) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1b85bf3f3cf038cb67a991a3e3304751"><td class="mdescLeft">&#160;</td><td class="mdescRight">ホスト PC 上ファイルシステムの指定されたディレクトリをファイルシステムとしてマウントし、操作できるようにします。  <a href="#a1b85bf3f3cf038cb67a991a3e3304751">[詳解]</a><br /></td></tr>
<tr class="separator:a1b85bf3f3cf038cb67a991a3e3304751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea39d2487ac28bc767cd699eeeebe11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11">MountHostRoot</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2ea39d2487ac28bc767cd699eeeebe11"><td class="mdescLeft">&#160;</td><td class="mdescRight">ホスト PC 上のファイルシステムをマウントし、Windows 上のパスと同じパスで操作できるようにします。  <a href="#a2ea39d2487ac28bc767cd699eeeebe11">[詳解]</a><br /></td></tr>
<tr class="separator:a2ea39d2487ac28bc767cd699eeeebe11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5d6e6459dca7d8274564bcfc5de757"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ade5d6e6459dca7d8274564bcfc5de757">UnmountHostRoot</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ade5d6e6459dca7d8274564bcfc5de757"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11" title="ホスト PC 上のファイルシステムをマウントし、Windows 上のパスと同じパスで操作できるようにします。 ...">MountHostRoot()</a> でマウントしたファイルシステムをアンマウントし、リソースを解放します。  <a href="#ade5d6e6459dca7d8274564bcfc5de757">[詳解]</a><br /></td></tr>
<tr class="separator:ade5d6e6459dca7d8274564bcfc5de757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">アクセス優先度 関連 API</div></td></tr>
<tr class="memitem:a3280722d232526f011908c2e7e50400d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a3280722d232526f011908c2e7e50400d">SetPriorityOnCurrentThread</a> (<a class="el" href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3">Priority</a> priority) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3280722d232526f011908c2e7e50400d"><td class="mdescLeft">&#160;</td><td class="mdescRight">アクセス優先度を設定します。  <a href="#a3280722d232526f011908c2e7e50400d">[詳解]</a><br /></td></tr>
<tr class="separator:a3280722d232526f011908c2e7e50400d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0bae7e05be65b11e83a5a63640680f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3">Priority</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a1b0bae7e05be65b11e83a5a63640680f">GetPriorityOnCurrentThread</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1b0bae7e05be65b11e83a5a63640680f"><td class="mdescLeft">&#160;</td><td class="mdescRight">アクセス優先度を取得します。  <a href="#a1b0bae7e05be65b11e83a5a63640680f">[詳解]</a><br /></td></tr>
<tr class="separator:a1b0bae7e05be65b11e83a5a63640680f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">リソースデータ（ROM）関連 API</div></td></tr>
<tr class="memitem:a5df6e3385c795a5bd046790ef7f17f2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a5df6e3385c795a5bd046790ef7f17f2d">QueryMountRomCacheSize</a> (size_t *pOutValue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5df6e3385c795a5bd046790ef7f17f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacenn_1_1fs.html#a2e453fe1fbf8f818dc45bbd2897105cd" title="リソースデータ（ROM）をマウントします。 ">nn::fs::MountRom</a> のファイルシステムキャッシュに必要なサイズを取得します。  <a href="#a5df6e3385c795a5bd046790ef7f17f2d">[詳解]</a><br /></td></tr>
<tr class="separator:a5df6e3385c795a5bd046790ef7f17f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e453fe1fbf8f818dc45bbd2897105cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a2e453fe1fbf8f818dc45bbd2897105cd">MountRom</a> (const char *name, void *pFileSystemCacheBuffer, size_t fileSystemCacheBufferSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2e453fe1fbf8f818dc45bbd2897105cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">リソースデータ（ROM）をマウントします。  <a href="#a2e453fe1fbf8f818dc45bbd2897105cd">[詳解]</a><br /></td></tr>
<tr class="separator:a2e453fe1fbf8f818dc45bbd2897105cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">デバッグ用途 API</div></td></tr>
<tr class="memitem:a7a6592b4b0351945aa259359dcb464cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a7a6592b4b0351945aa259359dcb464cd">CanMountRomForDebug</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7a6592b4b0351945aa259359dcb464cd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacenn_1_1fs.html#a2e453fe1fbf8f818dc45bbd2897105cd" title="リソースデータ（ROM）をマウントします。 ">nn::fs::MountRom()</a> が実行可能かどうかを取得します。  <a href="#a7a6592b4b0351945aa259359dcb464cd">[詳解]</a><br /></td></tr>
<tr class="separator:a7a6592b4b0351945aa259359dcb464cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767e38eb403bd2ebb4374c5214dc0e95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a767e38eb403bd2ebb4374c5214dc0e95">MountSaveDataForDebug</a> (const char *name) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a767e38eb403bd2ebb4374c5214dc0e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">デバッグ用セーブデータをマウントします。  <a href="#a767e38eb403bd2ebb4374c5214dc0e95">[詳解]</a><br /></td></tr>
<tr class="separator:a767e38eb403bd2ebb4374c5214dc0e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196ef874060b922b93756ddff212fefa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a196ef874060b922b93756ddff212fefa">MountSdCardForDebug</a> (const char *name) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a196ef874060b922b93756ddff212fefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">SD カードを扱うファイルシステムを指定したマウント名でマウントします。  <a href="#a196ef874060b922b93756ddff212fefa">[詳解]</a><br /></td></tr>
<tr class="separator:a196ef874060b922b93756ddff212fefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329828b4375a88fa6567f6a74f207fac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a329828b4375a88fa6567f6a74f207fac">GetFileTimeStampForDebug</a> (<a class="el" href="structnn_1_1fs_1_1_file_time_stamp.html">FileTimeStamp</a> *outTimeStamp, const char *path) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a329828b4375a88fa6567f6a74f207fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">対象のパスのファイルのタイムスタンプを取得します。  <a href="#a329828b4375a88fa6567f6a74f207fac">[詳解]</a><br /></td></tr>
<tr class="separator:a329828b4375a88fa6567f6a74f207fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">セーブデータ関連 API</div></td></tr>
<tr class="memitem:a90c27aaf70aec66968715663cd8c5415"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a90c27aaf70aec66968715663cd8c5415">SetSaveDataRootPath</a> (const char *rootPath) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a90c27aaf70aec66968715663cd8c5415"><td class="mdescLeft">&#160;</td><td class="mdescRight">セーブデータの配置場所として利用するホスト PC 上のパスを設定します。  <a href="#a90c27aaf70aec66968715663cd8c5415">[詳解]</a><br /></td></tr>
<tr class="separator:a90c27aaf70aec66968715663cd8c5415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f48fe542ce22263e1399e3b50190e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ae5f48fe542ce22263e1399e3b50190e8">EnsureSaveData</a> (const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;user) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae5f48fe542ce22263e1399e3b50190e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">セーブデータを作成します。  <a href="#ae5f48fe542ce22263e1399e3b50190e8">[詳解]</a><br /></td></tr>
<tr class="separator:ae5f48fe542ce22263e1399e3b50190e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbda9f24e47b02bb74da4558bbd0760"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#afdbda9f24e47b02bb74da4558bbd0760">MountSaveData</a> (const char *name, const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;user) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afdbda9f24e47b02bb74da4558bbd0760"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザーを指定してセーブデータをマウントします。  <a href="#afdbda9f24e47b02bb74da4558bbd0760">[詳解]</a><br /></td></tr>
<tr class="separator:afdbda9f24e47b02bb74da4558bbd0760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5b846d93790ec79b2d6fee53e97db9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#adf5b846d93790ec79b2d6fee53e97db9">MountSaveDataReadOnly</a> (const char *name, const <a class="el" href="structnn_1_1_application_id.html">nn::ApplicationId</a> applicationId, const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;user) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adf5b846d93790ec79b2d6fee53e97db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザーを指定してアプリケーション ID に対応するアプリケーションのセーブデータを読み込み専用でマウントします。  <a href="#adf5b846d93790ec79b2d6fee53e97db9">[詳解]</a><br /></td></tr>
<tr class="separator:adf5b846d93790ec79b2d6fee53e97db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed0c325479ee3b3fd508ed3696394f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a7ed0c325479ee3b3fd508ed3696394f2">IsSaveDataExisting</a> (const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;user) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7ed0c325479ee3b3fd508ed3696394f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定したユーザーアカウントセーブデータが存在するかどうかを取得します。  <a href="#a7ed0c325479ee3b3fd508ed3696394f2">[詳解]</a><br /></td></tr>
<tr class="separator:a7ed0c325479ee3b3fd508ed3696394f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b9a47a0c5c176a39f0cf240a91f31c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a28b9a47a0c5c176a39f0cf240a91f31c">IsSaveDataExisting</a> (const <a class="el" href="structnn_1_1_application_id.html">nn::ApplicationId</a> applicationId, const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;user) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a28b9a47a0c5c176a39f0cf240a91f31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定したアプリケーション ID に対応するユーザーアカウントセーブデータが存在するかどうかを取得します。  <a href="#a28b9a47a0c5c176a39f0cf240a91f31c">[詳解]</a><br /></td></tr>
<tr class="separator:a28b9a47a0c5c176a39f0cf240a91f31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83b2cf5e8413aa2833c8df5d2771bf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ab83b2cf5e8413aa2833c8df5d2771bf9">ExtendSaveData</a> (const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;user, int64_t saveDataSize, int64_t saveDataJournalSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab83b2cf5e8413aa2833c8df5d2771bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">セーブデータを拡張します。  <a href="#ab83b2cf5e8413aa2833c8df5d2771bf9">[詳解]</a><br /></td></tr>
<tr class="separator:ab83b2cf5e8413aa2833c8df5d2771bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a313238d8b1826e81fe12bad80f82f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a92a313238d8b1826e81fe12bad80f82f">GetSaveDataSize</a> (int64_t *outSaveDataSize, int64_t *outSaveDataJournalSize, const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;user) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a92a313238d8b1826e81fe12bad80f82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">セーブデータの現在のサイズを取得します。  <a href="#a92a313238d8b1826e81fe12bad80f82f">[詳解]</a><br /></td></tr>
<tr class="separator:a92a313238d8b1826e81fe12bad80f82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">セーブデータトランザクション管理 API</div></td></tr>
<tr class="memitem:ac2f25cffd056f24d6facfda13f977fa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ac2f25cffd056f24d6facfda13f977fa6">CommitSaveData</a> (const char *name) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac2f25cffd056f24d6facfda13f977fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">このAPIの利用は非推奨です。代替APIや利用条件の有無については詳細を確認してください。  <a href="#ac2f25cffd056f24d6facfda13f977fa6">[詳解]</a><br /></td></tr>
<tr class="separator:ac2f25cffd056f24d6facfda13f977fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">一時ストレージ関連 API</div></td></tr>
<tr class="memitem:a8191828699cf3d29befe8dbd710db421"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a8191828699cf3d29befe8dbd710db421">MountTemporaryStorage</a> (const char *name) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8191828699cf3d29befe8dbd710db421"><td class="mdescLeft">&#160;</td><td class="mdescRight">一時ストレージをマウントします。  <a href="#a8191828699cf3d29befe8dbd710db421">[詳解]</a><br /></td></tr>
<tr class="separator:a8191828699cf3d29befe8dbd710db421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">トランザクション管理 API</div></td></tr>
<tr class="memitem:ab534529ae3c325863fe1eb34bd03c872"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ab534529ae3c325863fe1eb34bd03c872">Commit</a> (const char *name) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab534529ae3c325863fe1eb34bd03c872"><td class="mdescLeft">&#160;</td><td class="mdescRight">ジャーナリング機能が有効なファイルシステムに対する更新内容をコミットします。  <a href="#ab534529ae3c325863fe1eb34bd03c872">[詳解]</a><br /></td></tr>
<tr class="separator:ab534529ae3c325863fe1eb34bd03c872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">インデックス付きキャッシュストレージ関連 API</div></td></tr>
<tr class="memitem:af3735c46a459dbf4ba3d6de862b611d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#af3735c46a459dbf4ba3d6de862b611d4">CreateCacheStorage</a> (int index, int64_t cacheStorageSize, int64_t cacheStorageJournalSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af3735c46a459dbf4ba3d6de862b611d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">キャッシュストレージを作成します。  <a href="#af3735c46a459dbf4ba3d6de862b611d4">[詳解]</a><br /></td></tr>
<tr class="separator:af3735c46a459dbf4ba3d6de862b611d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af995ec08995ebe685afd6c13a648a692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#af995ec08995ebe685afd6c13a648a692">GetCacheStorageSize</a> (int64_t *outCacheStorageSize, int64_t *outCacheStorageJournalSize, int index) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af995ec08995ebe685afd6c13a648a692"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたインデックスのキャッシュストレージのサイズを取得します。  <a href="#af995ec08995ebe685afd6c13a648a692">[詳解]</a><br /></td></tr>
<tr class="separator:af995ec08995ebe685afd6c13a648a692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2bd15a53fcc2a6c8895de9c264ab86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#adf2bd15a53fcc2a6c8895de9c264ab86">DeleteCacheStorage</a> (int index) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adf2bd15a53fcc2a6c8895de9c264ab86"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたインデックスのキャッシュストレージを削除します。  <a href="#adf2bd15a53fcc2a6c8895de9c264ab86">[詳解]</a><br /></td></tr>
<tr class="separator:adf2bd15a53fcc2a6c8895de9c264ab86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeabd5e452034e8f7db0d8580952a5dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#adeabd5e452034e8f7db0d8580952a5dd">OpenCacheStorageList</a> (<a class="el" href="structnn_1_1fs_1_1_cache_storage_list_handle.html">CacheStorageListHandle</a> *outValue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adeabd5e452034e8f7db0d8580952a5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">キャッシュストレージリストをオープンします。  <a href="#adeabd5e452034e8f7db0d8580952a5dd">[詳解]</a><br /></td></tr>
<tr class="separator:adeabd5e452034e8f7db0d8580952a5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d272600ab91d4e735bbb40d8845e938"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a4d272600ab91d4e735bbb40d8845e938">ReadCacheStorageList</a> (int *outValue, <a class="el" href="structnn_1_1fs_1_1_cache_storage_info.html">CacheStorageInfo</a> *infoBuffer, <a class="el" href="structnn_1_1fs_1_1_cache_storage_list_handle.html">CacheStorageListHandle</a> handle, int infoBufferCount) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4d272600ab91d4e735bbb40d8845e938"><td class="mdescLeft">&#160;</td><td class="mdescRight">キャッシュストレージを列挙します。  <a href="#a4d272600ab91d4e735bbb40d8845e938">[詳解]</a><br /></td></tr>
<tr class="separator:a4d272600ab91d4e735bbb40d8845e938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c1f6d8788be687eb914f53f723fba7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#a92c1f6d8788be687eb914f53f723fba7">CloseCacheStorageList</a> (<a class="el" href="structnn_1_1fs_1_1_cache_storage_list_handle.html">CacheStorageListHandle</a> handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a92c1f6d8788be687eb914f53f723fba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">キャッシュストレージリストをクローズします。  <a href="#a92c1f6d8788be687eb914f53f723fba7">[詳解]</a><br /></td></tr>
<tr class="separator:a92c1f6d8788be687eb914f53f723fba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">追加コンテンツ関連 API</div></td></tr>
<tr class="memitem:afcb1fa310028d36752df80ff69beec4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#afcb1fa310028d36752df80ff69beec4c">QueryMountAddOnContentCacheSize</a> (size_t *pOutValue, <a class="el" href="namespacenn_1_1aoc.html#a034a2abde78298e64250210a18f400ba">nn::aoc::AddOnContentIndex</a> targetIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afcb1fa310028d36752df80ff69beec4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">MountAddOnContent のファイルシステムキャッシュに必要なサイズを取得します。  <a href="#afcb1fa310028d36752df80ff69beec4c">[詳解]</a><br /></td></tr>
<tr class="separator:afcb1fa310028d36752df80ff69beec4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92caf5815857651653369e760f85a66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ad92caf5815857651653369e760f85a66">MountAddOnContent</a> (const char *name, <a class="el" href="namespacenn_1_1aoc.html#a034a2abde78298e64250210a18f400ba">nn::aoc::AddOnContentIndex</a> targetIndex, void *pFileSystemCacheBuffer, size_t fileSystemCacheBufferSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad92caf5815857651653369e760f85a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">追加コンテンツを扱う読み込み専用のファイルシステムをマウントします。  <a href="#ad92caf5815857651653369e760f85a66">[詳解]</a><br /></td></tr>
<tr class="separator:ad92caf5815857651653369e760f85a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
変数</h2></td></tr>
<tr class="memitem:ad6358a9db10c5b1d1424035a63a72079"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6358a9db10c5b1d1424035a63a72079"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ad6358a9db10c5b1d1424035a63a72079">EntryNameLengthMax</a> = 768</td></tr>
<tr class="memdesc:ad6358a9db10c5b1d1424035a63a72079"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルシステム内での最大エントリ名長です <br /></td></tr>
<tr class="separator:ad6358a9db10c5b1d1424035a63a72079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53025357244b131b50269c199fd64fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae53025357244b131b50269c199fd64fb"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#ae53025357244b131b50269c199fd64fb">MountNameLengthMax</a> = 15</td></tr>
<tr class="memdesc:ae53025357244b131b50269c199fd64fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">マウント時に指定する名前の最大サイズ（単位は Byte 数）です。終端の NULL 文字を含みません。 <br /></td></tr>
<tr class="separator:ae53025357244b131b50269c199fd64fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec0be52744559b8df1c4e5289cc9d65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaec0be52744559b8df1c4e5289cc9d65"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1fs.html#aaec0be52744559b8df1c4e5289cc9d65">SaveDataExtensionUnitSize</a> = 1 * 1024 * 1024</td></tr>
<tr class="memdesc:aaec0be52744559b8df1c4e5289cc9d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">セーブデータ拡張で指定できる単位サイズです。 <br /></td></tr>
<tr class="separator:aaec0be52744559b8df1c4e5289cc9d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p>ファイルシステムライブラリの名前空間です。 </p>
<h3>機能概要</h3>
<p>FS ライブラリでは、セーブデータやホスト PC 上ファイルシステムなど、様々なファイルシステムに対して操作を行う手段を提供します。<br />
 ディレクトリを開くなどの基本的な機能は各種ファイルシステムで共通ですが、ファイルシステム固有の機能や制限などもあり、これらはファイルシステムの属性として別途定義されます。<br />
 </p><h4>共通の事前条件</h4>
<p>ファイル、ディレクトリに対して操作を行う関数については、対象のファイル、ディレクトリを表すハンドルが正常に取得されている必要があります。<br />
 また特に記載のない限り、ポインタ引数は有効なメモリを指している必要があります。<br />
 </p><h4><a class="el" href="classnn_1_1_result.html" title="処理の結果を汎用的に表す型です。 ">Result</a> について</h4>
<p>マウント対象のファイルシステムの種類によっては、fs 以外の <a class="el" href="classnn_1_1_result.html" title="処理の結果を汎用的に表す型です。 ">Result</a> も返る可能性があります。<br />
 </p><h4><a class="anchor" id="memory_allocation"></a>メモリ確保について</h4>
<p>戻り値一覧に <a class="el" href="classnn_1_1fs_1_1_result_allocation_memory_failed.html" title="エラー Result (fs: メモリ不足) を表すクラスです。 ">ResultAllocationMemoryFailed</a> が挙げられている API ( Mount 系 API, <a class="el" href="namespacenn_1_1fs.html#a0f2b5b30657b1ffaf1dec49bfb36462b" title="ファイルをオープンします。 ">OpenFile()</a>, <a class="el" href="namespacenn_1_1fs.html#acae21d0f79e4d074e120c814a8936a42" title="ディレクトリをオープンします。 ">OpenDirectory()</a> ) は内部でメモリ確保を行います。 デフォルトではメモリ確保に malloc(), free() が使用されます。 malloc(), free() については <a class="el" href="namespacenn_1_1init.html#a216ae7a5ca53a1c1e6dc0514f7283974" title="メモリアロケータを初期化します。 ">nn::init::InitializeAllocator()</a> も併せて参照してください。 <br />
 <a class="el" href="namespacenn_1_1fs.html#ac021c163ba94a44a2b53cb848c462930" title="fs ライブラリが使用するメモリアロケータを設定します。 ">nn::fs::SetAllocator()</a> をあらかじめ呼び出すことで、メモリ確保に使用されるアロケータを指定することができます。 設定するアロケータは 8 バイトアライメントのアドレスを返す必要があります。 <br />
 確保されたメモリは、対応する解放 API ( <a class="el" href="namespacenn_1_1fs.html#ac8a95249afd4a87a55d319dfecb0466c" title="マウント済みのファイルシステムをアンマウントし、リソースを解放します。 ">Unmount()</a>, <a class="el" href="namespacenn_1_1fs.html#ac8bd9e828751bd4f953acfa765278f84" title="ファイルをクローズします。 ">CloseFile()</a>, <a class="el" href="namespacenn_1_1fs.html#af8d0fa5050c0f77a0a6f14a0b78f9b58" title="ディレクトリをクローズします。 ">CloseDirectory()</a> ) を呼び出すことで解放されます。 ファイルおよびディレクトリが一つも開かれておらず、ファイルシステムが一つもマウントされていない状態では、 アロケータからは一切のメモリが確保されていない状態になること（確保されたメモリがすべて解放されていること）が保証されます。 <br />
 メモリ使用量の目安は以下の通りです。これらの値は暫定のものであり、将来的に増減する可能性があります。<br />
</p><table class="doxtable">
<tr>
<th>API </th><th>メモリ使用量の目安  </th></tr>
<tr>
<td>Mount 系関数 </td><td>同時マウント数 × 5 KB 程度 </td></tr>
<tr>
<td>OpenFile </td><td>同時オープン数 × 100 B 程度 </td></tr>
<tr>
<td>OpenDirectory </td><td>同時オープン数 × 2 KB 程度 </td></tr>
</table>
<p><br />
 ライブラリのような不特定のプログラムから参照される可能性がある関数群でファイルシステムの機能を利用する場合には、 <a class="el" href="namespacenn_1_1fs.html#ac021c163ba94a44a2b53cb848c462930" title="fs ライブラリが使用するメモリアロケータを設定します。 ">nn::fs::SetAllocator()</a> で事前に指定したアロケータまたは malloc() で十分なメモリが確保できる必要があることを関数群の利用者に対して明示してください。</p>
<h4>スレッドセーフ性について</h4>
<p>FS ライブラリの API には、複数同時呼び出しが可能なものと、そうではなく排他制御が必要なものがあります。<br />
 <br />
 ファイルシステム関連 API 及び <a class="el" href="namespacenn_1_1fs.html#a0f2b5b30657b1ffaf1dec49bfb36462b" title="ファイルをオープンします。 ">OpenFile()</a>、 <a class="el" href="namespacenn_1_1fs.html#acae21d0f79e4d074e120c814a8936a42" title="ディレクトリをオープンします。 ">OpenDirectory()</a> は、複数同時に呼び出された場合でも正しく動作します。<br />
 ファイル関連 API、ディレクトリ関連 API のうち、ハンドルを指定して操作を行う API については、以下の表の通りです。<br />
 </p><table class="doxtable">
<tr>
<th>API の種類 </th><th>同一のハンドルが対象 </th><th>別々のハンドルが対象  </th></tr>
<tr>
<td>ファイル関連 API で、読み込み操作のみを行うもの (<a class="el" href="namespacenn_1_1fs.html#a81801a404563984f8c6cc1483cc6d730" title="サイズが既知であるファイルの内容を、指定されたメモリへ読み込みます。 ">ReadFile()</a>, <a class="el" href="namespacenn_1_1fs.html#aba29e01d386e809349d60eccdb15ff21" title="ファイルのサイズを取得します。 ">GetFileSize()</a>, <a class="el" href="namespacenn_1_1fs.html#a2805c57e6c7c5ec8fbc7d30e7137deae" title="ファイルオープン時に指定したモードを取得します。 ">GetFileOpenMode()</a>) </td><td>複数同時呼び出しが可能 </td><td>複数同時呼び出しが可能 </td></tr>
<tr>
<td>ファイル関連 API で、読み込み以外の操作も行うもの (<a class="el" href="namespacenn_1_1fs.html#a0f2b5b30657b1ffaf1dec49bfb36462b" title="ファイルをオープンします。 ">OpenFile()</a> と上記 API 以外) </td><td>排他的な呼び出しが必要 </td><td>複数同時呼び出しが可能 </td></tr>
<tr>
<td>ディレクトリ関連 API (<a class="el" href="namespacenn_1_1fs.html#acae21d0f79e4d074e120c814a8936a42" title="ディレクトリをオープンします。 ">OpenDirectory()</a>, <a class="el" href="namespacenn_1_1fs.html#aa6a54b0d39dfd293b11cd1c0073aafb1" title="ディレクトリの子エントリの個数を取得します。 ">GetDirectoryEntryCount()</a> 以外) </td><td>排他的な呼び出しが必要 </td><td>複数同時呼び出しが可能 </td></tr>
</table>
<p>上記以外のその他の API の呼び出しや、複数同時呼び出しが可能な API とそうでない API を組み合わせた呼び出しは、特に明記されていない限り排他的に行う必要があります。<br />
 例えば、同一のハンドルに対して複数のスレッドで排他せずに <a class="el" href="namespacenn_1_1fs.html#ab4351ff3a319e9a63093324a669492ab" title="ファイルへ指定されたメモリの内容を書き込みます。 ">WriteFile()</a> や <a class="el" href="namespacenn_1_1fs.html#a81801a404563984f8c6cc1483cc6d730" title="サイズが既知であるファイルの内容を、指定されたメモリへ読み込みます。 ">ReadFile()</a> を行うと、タイミングに依存して <a class="el" href="namespacenn_1_1fs.html#a81801a404563984f8c6cc1483cc6d730" title="サイズが既知であるファイルの内容を、指定されたメモリへ読み込みます。 ">ReadFile()</a> で得られるデータが変わります。 例えば、同一のハンドルに対して複数のスレッドで排他せずに <a class="el" href="namespacenn_1_1fs.html#af1ecb9478fe0f9dee627b65111cdbe29" title="ディレクトリの子エントリを列挙します。 ">ReadDirectory()</a> を行うと、それぞれのスレッドのディレクトリ列挙処理が衝突するため、挙動は保証されません。<br />
</p><div id="dynsection-NX" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-NX-trigger" src="closed.png"/>
  <b>（NXプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-NX-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-NX-content" class="dyncontent" style="display:none;"> 本体保存メモリー、ゲームカード、SD カードへの通信経路はそれぞれ一つのため、 アプリケーションから同じ記録メディアに配置されるデータを複数同時にアクセスしても内部的な処理はブロッキングされます。<br />
 パフォーマンスの最適化方法は、NintendoSDK ドキュメントの FS ライブラリ <a href="../../Package/contents/Pages/Page_185130689.html">パフォーマンス</a> を参照してください。<br />
</div> <h3>用語</h3>
<h4>ファイルシステム</h4>
<p>FS ライブラリにおける、操作対象の基本単位で、ディレクトリやファイルが格納されたものです。<br />
 ファイルシステムをマウントすることで、そのファイルシステムが所有するディレクトリ、ファイルに対して操作を行うことが可能になります。<br />
 </p><h4>エントリ</h4>
<p>ディレクトリとファイルを総称したものです。<br />
 </p><h4><a class="anchor" id="mount_name"></a>マウント名</h4>
<p>ファイルシステムを利用するためにマウントした際に、識別子としてユーザーが与える文字列です。<br />
 マウント操作の後は、マウント名を使用してファイルシステムを指定してアクセスします。<br />
 以下の全ての条件を満たしているマウント名を有効なマウント名とします<br />
</p><ul>
<li>終端の NULL 文字を含めず 1 バイト以上 <a class="el" href="namespacenn_1_1fs.html#ae53025357244b131b50269c199fd64fb" title="マウント時に指定する名前の最大サイズ（単位は Byte 数）です。終端の NULL 文字を含みません。 ...">nn::fs::MountNameLengthMax</a> バイト以下の文字列である。</li>
<li>'@' 以外の文字で始まる。</li>
<li>':' および '/' を含まない。</li>
<li>マウントしている他のファイルシステムのマウント名に使用されていない。</li>
<li>アルファベット一文字でない。</li>
</ul>
<p>マウント名を指定する API には有効なマウント名を渡す必要があります。<br />
 エンコーディングは UTF-8 です。<br />
 </p><h4><a class="anchor" id="entry_path"></a>パス</h4>
<p>エントリを一意に定めるための識別子です。<br />
 FS ライブラリでは文字列を使用します。<br />
 例： "MountName:/path/to/file" <br />
 以下の全ての条件を満たしているパスを有効なパスとします。<br />
</p><ul>
<li>「マウント名 + ":/"」または「マウント名 + ":\"」で始まる。</li>
<li>マウント名が有効なマウント名である。</li>
<li>マウント名がマウント済みのものである。</li>
<li>ディレクトリの区切り文字が '/' または '\'。</li>
<li>エントリ名に '&lt;'、'&gt;'、'*'、'?'、':'、'|' を使用していない。</li>
<li>文字列長が 260 文字以下である。</li>
<li>終端の NULL 文字を含めず 1 バイト以上 <a class="el" href="namespacenn_1_1fs.html#ad6358a9db10c5b1d1424035a63a72079" title="ファイルシステム内での最大エントリ名長です ">nn::fs::EntryNameLengthMax</a> バイト以下の文字列である。</li>
</ul>
<p>パスを指定する API には有効なパスを渡す必要があります。<br />
 エンコーディングは UTF-8 です。<br />
 ホスト PC 上のパスを表す場合でも、同じ区切り文字・エンコーディングを使用します。<br />
</p><div id="dynsection-NX" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-NX-trigger" src="closed.png"/>
  <b>（NXプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-NX-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-NX-content" class="dyncontent" style="display:none;"> SD カードファイルシステムで使用するパスには特有の制約があります。NintendoSDK ドキュメントの <a href="../../Package/contents/Pages/Page_112886110.html">SD カード</a> を参照してください。<br />
</div> <h3>現在サポートされているファイルシステム</h3>
<p>各ファイルシステムの詳細は NintendoSDK ドキュメントの FS ライブラリ <a href="../../Package/contents/Pages/Page_107320200.html">機能説明</a> を参照してください。</p><ul>
<li>ROM ファイルシステム<br />
 リソースデータを扱う読み取り専用のファイルシステムです。</li>
<li>セーブデータファイルシステム<br />
 セーブデータを扱うファイルシステムです。</li>
<li>ホストファイルシステム<br />
 ホスト PC 上のファイルシステムを操作できるファイルシステムです。<br />
 開発時のみ使用することができます。</li>
</ul>
<div id="dynsection-NX" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-NX-trigger" src="closed.png"/>
  <b>（NXプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-NX-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-NX-content" class="dyncontent" style="display:none;"><ul>
<li>追加コンテンツファイルシステム<br />
 追加コンテンツを扱う読み込み専用のファイルシステムです。</li>
<li>一時ストレージファイルシステム<br />
 アプリケーションが一時的にファイルを保存するためのファイルシステムです。<br />
 一時ストレージを利用するには事前の申請が必要です。</li>
<li>キャッシュストレージファイルシステム<br />
 アプリケーションが再生成・再取得可能なデータを保存するためのファイルシステムです。<br />
 キャッシュストレージを利用するには事前の申請が必要です。</li>
<li>SD カードファイルシステム<br />
 SD カード 上のファイルシステムを操作できるファイルシステムです。<br />
 開発時のみ使用することができます。</li>
</ul>
</div><div id="dynsection-NX-content" class="dyncontent" style="display:none;"></div> </div><h2 class="groupheader">型定義詳解</h2>
<a class="anchor" id="a9860dee956c54cadf027c37d54adeb28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* nn::fs::AllocateFunction) (size_t)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリ確保用の関数ポインタです。 </p>
<p><b>詳細</b> <br />
 <a class="el" href="namespacenn_1_1fs.html#ac021c163ba94a44a2b53cb848c462930" title="fs ライブラリが使用するメモリアロケータを設定します。 ">SetAllocator()</a> に指定します。 </p>

</div>
</div>
<a class="anchor" id="a07c75b075241d17f1b52cd9eefa851aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* nn::fs::DeallocateFunction) (void *, size_t)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリ解放用の関数ポインタです。 </p>
<p><b>詳細</b> <br />
 <a class="el" href="namespacenn_1_1fs.html#ac021c163ba94a44a2b53cb848c462930" title="fs ライブラリが使用するメモリアロケータを設定します。 ">SetAllocator()</a> に指定します。 </p>

</div>
</div>
<h2 class="groupheader">列挙型詳解</h2>
<a class="anchor" id="afb4fdd50e0892400c07232f714caa14d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1fs.html#afb4fdd50e0892400c07232f714caa14d">nn::fs::WriteOptionFlag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイル書き込み時のオプション指定フラグです。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="afb4fdd50e0892400c07232f714caa14da2956e16dac576b2b7eff3142e18ac2c0"></a>WriteOptionFlag_Flush&#160;</td><td class="fielddoc">
<p>書き込みと同時にフラッシュする場合に指定します </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a4c97b79cce78a95c2333dbc9053b9393"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393">nn::fs::OpenMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイルオープン時のモードを指定するフラグです </p>
<p><b>詳細</b> <br />
 ファイルを開く際のモードを指定します。 必要に応じてビットごとの OR で複数指定してください。 読み込みモードのみでの共有は可能ですが、書き込み操作ありでの共有はできません。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a4c97b79cce78a95c2333dbc9053b9393afde4472d2b455879cad02aade386ac0d"></a>OpenMode_Read&#160;</td><td class="fielddoc">
<p>読み込みモードを指定します </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4c97b79cce78a95c2333dbc9053b9393a0ee257dbba840301b0e656f6d1345c03"></a>OpenMode_Write&#160;</td><td class="fielddoc">
<p>書き込みモードを指定します </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4c97b79cce78a95c2333dbc9053b9393aac1149600d18adbb26a1ae87de7096c1"></a>OpenMode_AllowAppend&#160;</td><td class="fielddoc">
<p>追記書き込み操作を許可します </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a34bc03cdbe641524cab284a7fe7ba705"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1fs.html#a34bc03cdbe641524cab284a7fe7ba705">nn::fs::OpenDirectoryMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ディレクトリオープン時のモードを指定するフラグです </p>
<p><b>詳細</b> <br />
 ディレクトリ開く際のモードを指定します。 指定された種類の子エントリのみが、 <a class="el" href="namespacenn_1_1fs.html#af1ecb9478fe0f9dee627b65111cdbe29" title="ディレクトリの子エントリを列挙します。 ">ReadDirectory()</a> などで列挙の対象となります。 ビットごとの OR で複数指定することも可能です。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a34bc03cdbe641524cab284a7fe7ba705a6cabc455dd34f3d7562137ea63a5daab"></a>OpenDirectoryMode_Directory&#160;</td><td class="fielddoc">
<p>子ディレクトリのみ列挙します </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a34bc03cdbe641524cab284a7fe7ba705a560a621c8b1cb6f228ea202b9efd7432"></a>OpenDirectoryMode_File&#160;</td><td class="fielddoc">
<p>子ファイルのみ列挙します </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a34bc03cdbe641524cab284a7fe7ba705a1769c5d739757a86e8f98bddbc3ee9c5"></a>OpenDirectoryMode_All&#160;</td><td class="fielddoc">
<p>全ての子エントリを列挙します </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a5fc46cd05067c210b62e96f903a2fe85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1fs.html#a5fc46cd05067c210b62e96f903a2fe85">nn::fs::DirectoryEntryType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ディレクトリエントリの種類を表す列挙型です </p>
<p><b>詳細</b> <br />
 ディレクトリエントリが、ファイルなのかディレクトリなのかを識別します。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a5fc46cd05067c210b62e96f903a2fe85a2824a031f5834c762620e321ac8933c6"></a>DirectoryEntryType_Directory&#160;</td><td class="fielddoc">
<p>ディレクトリです </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5fc46cd05067c210b62e96f903a2fe85a194470d850d5968a491fd9ef6145d5a0"></a>DirectoryEntryType_File&#160;</td><td class="fielddoc">
<p>ファイルです </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a2e4a9f55e854a9755c9264838caa97d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3">nn::fs::Priority</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>アクセス優先度です。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a2e4a9f55e854a9755c9264838caa97d3a0fa1620fa464966eddf7e9a82a0eef91"></a>Priority_Realtime&#160;</td><td class="fielddoc">
<p>リアルタイム処理に適した高優先度でアクセスすることを指定します。 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2e4a9f55e854a9755c9264838caa97d3a3fe1f52283573973940fa566d116289e"></a>Priority_Normal&#160;</td><td class="fielddoc">
<p>通常優先度でアクセスすることを指定します。 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2e4a9f55e854a9755c9264838caa97d3aa4c563bb69a4dfd6ac970ba42def209a"></a>Priority_Low&#160;</td><td class="fielddoc">
<p>低優先度でアクセスすることを指定します。 </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a class="anchor" id="a38a958348ad64793a93e82a5a556d7b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountCacheStorage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>キャッシュストレージをマウントします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>マウント名</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000021">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>name が <a class="el" href="namespacenn_1_1fs.html#mount_name">有効なマウント名 </a> である。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 キャッシュストレージを利用するには事前の申請が必要です。<br />
 詳細は NintendoSDK ドキュメントの <a href="../../Package/contents/Pages/Page_224957652.html">キャッシュストレージ</a> を参照してください。 </p>

</div>
</div>
<a class="anchor" id="ab217b088ff86a675d869cc9fb38390ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountCacheStorage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>インデックスを指定してキャッシュストレージをマウントします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>マウント名 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>マウントしたいキャッシュストレージのインデックス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000022">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_not_found.html" title="エラー Result (fs: 対象が見つからない) を表すクラスです。 ">ResultTargetNotFound</a></b> 指定したインデックスのキャッシュストレージが存在していない</p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>name が <a class="el" href="namespacenn_1_1fs.html#mount_name">有効なマウント名 </a> である。</li>
<li>指定したインデックスのキャッシュストレージが存在している</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 キャッシュストレージを利用するには事前の申請が必要です。<br />
 詳細は NintendoSDK ドキュメントの <a href="../../Package/contents/Pages/Page_276903214.html">インデックス付きキャッシュストレージ</a> を参照してください。<br />
</p>

</div>
</div>
<a class="anchor" id="af1ecb9478fe0f9dee627b65111cdbe29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::ReadDirectory </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_directory_entry.html">DirectoryEntry</a> *&#160;</td>
          <td class="paramname"><em>entryBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_directory_handle.html">DirectoryHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>entryBufferCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ディレクトリの子エントリを列挙します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>格納された子エントリの個数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entryBuffer</td><td>子エントリの格納先バッファ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>ディレクトリのハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entryBufferCount</td><td>entryBuffer の要素数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000023">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>entryBuffer の長さが entryBufferCount 以上である。</li>
<li>entryBufferCount &gt;= 0</li>
<li>handle が有効なハンドルである。</li>
<li>outValue が有効なメモリを指している。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 handle で表されるディレクトリ直下にあるディレクトリエントリを、最大 entryBufferCount 個まで entryBuffer に格納し、格納した個数を outValue に出力します。<br />
 列挙されるエントリの種別は、ディレクトリオープン時に option 引数で指定されたものになります。<br />
 列挙されるエントリの順番は未定義です。<br />
 同じハンドルに対して複数回呼ばれた場合は、前回列挙したエントリの直後から列挙し、最後のエントリを列挙した時点で返ります。<br />
 それ以降同じハンドルに対してこの関数を呼んだ場合、outValue = 0 で返ります。<br />
 オープン中のディレクトリに対してエントリを作成、削除した場合の挙動は不定です。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_codec_opus_codec_processing_time_8cpp-example.html#a92">CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_fs_host_8cpp-example.html#a12">FsHost.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa6a54b0d39dfd293b11cd1c0073aafb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::GetDirectoryEntryCount </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_directory_handle.html">DirectoryHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ディレクトリの子エントリの個数を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>子エントリの個数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>ディレクトリのハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000024">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>handle が有効なハンドルである。</li>
<li>outValue が有効なメモリを指している。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 handle で表されるディレクトリ内のエントリ数を outValue に取得します。<br />
 ディレクトリオープン時に option フラグで指定された種類の子エントリの個数が返されます。<br />
 ハンドルの状態は変更されません。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_codec_opus_codec_processing_time_8cpp-example.html#a90">CodecOpusCodecProcessingTime.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af8d0fa5050c0f77a0a6f14a0b78f9b58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::CloseDirectory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_directory_handle.html">DirectoryHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ディレクトリをクローズします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>クローズするディレクトリのハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>なし</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>handle が有効なハンドルである。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 handle で表されるディレクトリをクローズし、リソースを解放します。<br />
</p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_codec_opus_codec_processing_time_8cpp-example.html#a95">CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_fs_host_8cpp-example.html#a14">FsHost.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a81801a404563984f8c6cc1483cc6d730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::ReadFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1fs_1_1_read_option.html">ReadOption</a> &amp;&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>サイズが既知であるファイルの内容を、指定されたメモリへ読み込みます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>ファイルのハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>読み込みを開始するファイル先頭からのオフセット </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>読み込みデータの格納先バッファ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>読み込むバイトサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>読み込みオプション</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000025">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>対象のファイルを、OpenMode_Read を含んだモードで開いている。</li>
<li>handle が有効なハンドルである。</li>
<li>buffer が有効なメモリを指している。</li>
<li>size が buffer のサイズ以下である。</li>
<li>offset &gt;= 0</li>
<li>offset + size &lt;= ファイルサイズ</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 buffer から始まるメモリに、handle で表されるファイルの先頭から offset バイト目の位置から size バイトだけデータを読み込みます。<br />
 読み込むデータのサイズが既知の場合、本関数を使用することを推奨します。<br />
 サイズが不明な場合は、読み込んだデータのサイズを出力引数として持つオーバーロードされた <a class="el" href="namespacenn_1_1fs.html#a81801a404563984f8c6cc1483cc6d730" title="サイズが既知であるファイルの内容を、指定されたメモリへ読み込みます。 ">ReadFile()</a> を使用してください。<br />
</p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_aoc_season_pass_delivery_8cpp-example.html#a14">AocSeasonPassDelivery.cpp</a>, <a class="el" href="_aoc_season_pass_sales_start_8cpp-example.html#a14">AocSeasonPassSalesStart.cpp</a>, <a class="el" href="_aoc_simple_8cpp-example.html#a14">AocSimple.cpp</a>, <a class="el" href="_asset_file_loading_helper_8cpp-example.html#a8">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_atk_addon_sound_archive_8cpp-example.html#a32">AtkAddonSoundArchive.cpp</a>, <a class="el" href="_atk_group_8cpp-example.html#a23">AtkGroup.cpp</a>, <a class="el" href="_audio_cpu_renderer_8cpp-example.html#a14">AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_8cpp-example.html#a14">AudioDevice.cpp</a>, <a class="el" href="_audio_effect_8cpp-example.html#a21">AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_8cpp-example.html#a19">AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_8cpp-example.html#a44">AudioMemoryPool.cpp</a>, <a class="el" href="_audio_performance_metrics_8cpp-example.html#a14">AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_8cpp-example.html#a13">AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_8cpp-example.html#a14">AudioSink.cpp</a>, <a class="el" href="_audio_splitter_8cpp-example.html#a12">AudioSplitter.cpp</a>, <a class="el" href="_codec_aac_decoder_8cpp-example.html#a14">CodecAacDecoder.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_8cpp-example.html#a6">CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_8cpp-example.html#a12">CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_8cpp-example.html#a12">CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_8cpp-example.html#a12">CodecOpusMultiStreamDecoder.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a73">FontDemo/Main.cpp</a>, <a class="el" href="_fontll_save_to_jpeg_8cpp-example.html#a45">FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_host_8cpp-example.html#a25">FsHost.cpp</a>, <a class="el" href="_fs_rom_8cpp-example.html#a10">FsRom.cpp</a>, <a class="el" href="_fs_save_data_8cpp-example.html#a25">FsSaveData.cpp</a>, <a class="el" href="_fs_save_data_for_debug_8cpp-example.html#a16">FsSaveDataForDebug.cpp</a>, <a class="el" href="_gfx_primitive_renderer_8cpp-example.html#a9">GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_gfx_simple_8cpp-example.html#a9">GfxSimple.cpp</a>, <a class="el" href="_gfx_simple_compute_8cpp-example.html#a41">GfxSimpleCompute.cpp</a>, <a class="el" href="_hid_controller_sequence__main_8cpp-example.html#a49">HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_vibration_player_8cpp-example.html#a10">HidVibrationPlayer.cpp</a>, <a class="el" href="_mii_compressed_texture_8cpp-example.html#a170">MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_8cpp-example.html#a172">MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_8cpp-example.html#a171">MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_8cpp-example.html#a54">MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_8cpp-example.html#a51">MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_8cpp-example.html#a182">MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_8cpp-example.html#a167">MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_8cpp-example.html#a26">MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_8cpp-example.html#a172">MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_8cpp-example.html#a168">MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_8cpp-example.html#a27">MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_8cpp-example.html#a27">MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_8cpp-example.html#a29">MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_8cpp-example.html#a168">MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_8cpp-example.html#a27">MiiTransparentAdjuster.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a6">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a98">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a66">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a123">NvnTutorial11.cpp</a>, <a class="el" href="_ro_static_application_8cpp-example.html#a8">RoStaticApplication.cpp</a>, <a class="el" href="_simple_8cpp-example.html#a13">Simple.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a36">Ui2dDemo/Main.cpp</a>, <a class="el" href="_vfx_binary_segmentation_2main_8cpp-example.html#a29">VfxBinarySegmentation/main.cpp</a>, <a class="el" href="_vfx_custom_shader_2main_8cpp-example.html#a14">VfxCustomShader/main.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a11">VfxManualEmitterSet/main.cpp</a>, <a class="el" href="_vfx_simple_2main_8cpp-example.html#a29">VfxSimple/main.cpp</a>, <a class="el" href="_vk_simple_8cpp-example.html#a18">VkSimple.cpp</a> (計58項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="a90b280140b3e9d7eb83af3e807e4c0c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::ReadFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>サイズが既知であるファイルの内容を、指定されたメモリへオプションなしで読み込みます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>ファイルのハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>読み込みを開始するファイル先頭からのオフセット </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>読み込みデータの格納先バッファ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>読み込むバイトサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000026">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>対象のファイルを、OpenMode_Read を含んだモードで開いている。</li>
<li>handle が有効なハンドルである。</li>
<li>buffer が有効なメモリを指している。</li>
<li>size が buffer のサイズ以下である。</li>
<li>offset &gt;= 0</li>
<li>offset + size &lt;= ファイルサイズ</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 buffer から始まるメモリに、handle で表されるファイルの先頭から offset バイト目の位置から size バイトだけデータを読み込みます。<br />
 読み込むデータのサイズが既知の場合、本関数を使用することを推奨します。<br />
 サイズが不明な場合は、読み込んだデータのサイズを出力引数として持つオーバーロードされた <a class="el" href="namespacenn_1_1fs.html#a81801a404563984f8c6cc1483cc6d730" title="サイズが既知であるファイルの内容を、指定されたメモリへ読み込みます。 ">ReadFile()</a> を使用してください。 </p>

</div>
</div>
<a class="anchor" id="aa57d27066c8c88b6bf354fcfb3a8f394"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::ReadFile </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1fs_1_1_read_option.html">ReadOption</a> &amp;&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>サイズが不明なファイルの内容を、指定されたメモリへ読み込みます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>読み込んだデータのバイトサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>ファイルのハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>読み込みを開始するファイル先頭からのオフセット </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>読み込みデータの格納先バッファ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>読み込むバイトサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>読み込みオプション</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000027">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>対象のファイルを、OpenMode_Read を含んだモードで開いている。</li>
<li>outValue が有効なメモリを指している。</li>
<li>handle が有効なハンドルである。</li>
<li>buffer が有効なメモリを指している。</li>
<li>size が buffer のサイズ以下である。</li>
<li>offset &gt;= 0</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 buffer から始まるメモリに、handle で表されるファイルの先頭から offset バイト目の位置から size バイトだけデータを読み込みます。<br />
 offset + size がファイルサイズを超えている場合はファイルの末尾までデータを読み込みます。<br />
 読み込んだデータのバイト数を outValue に出力します。<br />
</p>

</div>
</div>
<a class="anchor" id="a433a913ce9dd7154b430118e99b4867b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::ReadFile </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>サイズが不明なファイルの内容を、指定されたメモリへオプションなしで読み込みます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>読み込んだデータのバイトサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>ファイルのハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>読み込みを開始するファイル先頭からのオフセット </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>読み込みデータの格納先バッファ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>読み込むバイトサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000028">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>対象のファイルを、OpenMode_Read を含んだモードで開いている。</li>
<li>outValue が有効なメモリを指している。</li>
<li>handle が有効なハンドルである。</li>
<li>buffer が有効なメモリを指している。</li>
<li>size が buffer のサイズ以下である。</li>
<li>offset &gt;= 0</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 buffer から始まるメモリに、handle で表されるファイルの先頭から offset バイト目の位置から size バイトだけデータを読み込みます。<br />
 offset + size がファイルサイズを超えている場合はファイルの末尾までデータを読み込みます。<br />
 読み込んだデータのバイト数を outValue に出力します。<br />
 <a class="el" href="structnn_1_1fs_1_1_read_option.html" title="ファイル読み込み時のオプション指定子です。 ">ReadOption</a> への指定が不要なオーバーロード関数です。<br />
</p>

</div>
</div>
<a class="anchor" id="ab4351ff3a319e9a63093324a669492ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::WriteFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1fs_1_1_write_option.html">WriteOption</a> &amp;&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイルへ指定されたメモリの内容を書き込みます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>ファイルのハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>書き込みを開始するファイル先頭からのオフセット </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>書き込むデータ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>書き込むバイトサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>書き込みオプション</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000029">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough.html" title="エラー Result (fs: 空き容量が不足) を表すクラスです。 ">ResultUsableSpaceNotEnough</a></b> 空き容量が不足しています。 </p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>対象のファイルを、OpenMode_Write を含んだモードで開いている。</li>
<li>(offset + size &lt;= ファイルサイズ) || (対象のファイルを、OpenMode_AllowAppend を含んだモードで開いている)</li>
<li>handle が有効なハンドルである。</li>
<li>buffer が有効なメモリを指している。</li>
<li>offset &gt;= 0</li>
<li>size が buffer のサイズ以下である。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 handle で表されるファイルの先頭から offset バイト目の位置に、buffer から始まる内容を size バイトだけ書き込みます。<br />
 容量が足りなかった場合には、何も書き込まずに ResultNotEnoughSpace が返ります。<br />
 option.flush = true で実行し書き込みが成功した場合、同時に <a class="el" href="namespacenn_1_1fs.html#a543a813b9e0c46a2d6ccb24d7c863a76" title="WriteFile() で指定した内容を、確実に書き込まれた状態にします。 ">nn::fs::FlushFile()</a> も実行されます。<br />
 size に 0 を指定した場合には、ファイルへの書き込みおよびファイルのサイズの拡張は行われません。 この場合でも、option.flush = true であれば <a class="el" href="namespacenn_1_1fs.html#a543a813b9e0c46a2d6ccb24d7c863a76" title="WriteFile() で指定した内容を、確実に書き込まれた状態にします。 ">nn::fs::FlushFile()</a> は実行されます。<br />
 <a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough.html" title="エラー Result (fs: 空き容量が不足) を表すクラスです。 ">ResultUsableSpaceNotEnough</a> で失敗した場合、ファイルサイズが大きくなっている可能性があります。また、書き込もうとした範囲の内容は保証されません。<br />
 同一ハンドルに対する本 API と他のファイル操作 API の呼び出しは排他的に行う必要があります。<br />
</p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_fontll_save_to_jpeg_8cpp-example.html#a33">FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_host_8cpp-example.html#a20">FsHost.cpp</a>, <a class="el" href="_fs_save_data_8cpp-example.html#a20">FsSaveData.cpp</a>, <a class="el" href="_fs_save_data_for_debug_8cpp-example.html#a11">FsSaveDataForDebug.cpp</a>, <a class="el" href="_fs_sd_card_for_debug_8cpp-example.html#a15">FsSdCardForDebug.cpp</a>, <a class="el" href="_simple_8cpp-example.html#a8">Simple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a543a813b9e0c46a2d6ccb24d7c863a76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::FlushFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacenn_1_1fs.html#ab4351ff3a319e9a63093324a669492ab" title="ファイルへ指定されたメモリの内容を書き込みます。 ">WriteFile()</a> で指定した内容を、確実に書き込まれた状態にします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>ファイルのハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000030">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>対象のファイルを、OpenMode_Write を含んだモードで開いている。</li>
<li>handle が有効なハンドルである。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 handle で表されるファイルに今まで書き込まれてきた内容を、確実に書き込まれた状態にします。<br />
 同一ハンドルに対する本 API と他のファイル操作 API の呼び出しは排他的に行う必要があります。<br />
</p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_fs_host_8cpp-example.html#a22">FsHost.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab469b77c1d8c44eaedb9b6d658aba6c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::SetFileSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイルのサイズを変更します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>ファイルのハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>変更後のファイルサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000031">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough.html" title="エラー Result (fs: 空き容量が不足) を表すクラスです。 ">ResultUsableSpaceNotEnough</a></b> 空き容量が不足しています。 </p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>対象のファイルを、OpenMode_Write を含んだモードで開いている。</li>
<li>handle が有効なハンドルである。</li>
<li>size &gt;= 0</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 handle で表されるファイルのサイズを size バイトに変更します。<br />
 変更後に <a class="el" href="namespacenn_1_1fs.html#a543a813b9e0c46a2d6ccb24d7c863a76" title="WriteFile() で指定した内容を、確実に書き込まれた状態にします。 ">FlushFile()</a> を呼ぶ必要はありません。<br />
 返り値が <a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough.html" title="エラー Result (fs: 空き容量が不足) を表すクラスです。 ">ResultUsableSpaceNotEnough</a> となった場合、ファイルサイズは呼び出し前と変わりません<br />
 同一ハンドルに対する本 API と他のファイル操作 API の呼び出しは排他的に行う必要があります。<br />
</p>

</div>
</div>
<a class="anchor" id="aba29e01d386e809349d60eccdb15ff21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::GetFileSize </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイルのサイズを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>ファイルサイズの格納先 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>ファイルのハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000032">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>handle が有効なハンドルである。</li>
<li>outValue が有効なメモリを指している。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 handle で表されるファイルのバイトサイズを outValue に取得します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a7">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_atk_addon_sound_archive_8cpp-example.html#a30">AtkAddonSoundArchive.cpp</a>, <a class="el" href="_atk_group_8cpp-example.html#a22">AtkGroup.cpp</a>, <a class="el" href="_audio_cpu_renderer_8cpp-example.html#a13">AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_8cpp-example.html#a13">AudioDevice.cpp</a>, <a class="el" href="_audio_effect_8cpp-example.html#a19">AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_8cpp-example.html#a17">AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_8cpp-example.html#a43">AudioMemoryPool.cpp</a>, <a class="el" href="_audio_performance_metrics_8cpp-example.html#a11">AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_8cpp-example.html#a12">AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_8cpp-example.html#a11">AudioSink.cpp</a>, <a class="el" href="_audio_splitter_8cpp-example.html#a9">AudioSplitter.cpp</a>, <a class="el" href="_codec_aac_decoder_8cpp-example.html#a12">CodecAacDecoder.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_8cpp-example.html#a4">CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_8cpp-example.html#a11">CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_8cpp-example.html#a10">CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_8cpp-example.html#a11">CodecOpusMultiStreamDecoder.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a71">FontDemo/Main.cpp</a>, <a class="el" href="_fontll_save_to_jpeg_8cpp-example.html#a44">FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_host_8cpp-example.html#a23">FsHost.cpp</a>, <a class="el" href="_fs_sd_card_for_debug_8cpp-example.html#a13">FsSdCardForDebug.cpp</a>, <a class="el" href="_gfx_primitive_renderer_8cpp-example.html#a7">GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_gfx_simple_8cpp-example.html#a7">GfxSimple.cpp</a>, <a class="el" href="_gfx_simple_compute_8cpp-example.html#a42">GfxSimpleCompute.cpp</a>, <a class="el" href="_hid_controller_sequence__main_8cpp-example.html#a47">HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_vibration_player_8cpp-example.html#a9">HidVibrationPlayer.cpp</a>, <a class="el" href="_libcurl_speed_test_8cpp-example.html#a10">LibcurlSpeedTest.cpp</a>, <a class="el" href="_mii_compressed_texture_8cpp-example.html#a180">MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_8cpp-example.html#a192">MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_8cpp-example.html#a181">MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_8cpp-example.html#a63">MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_8cpp-example.html#a60">MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_8cpp-example.html#a192">MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_8cpp-example.html#a177">MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_8cpp-example.html#a24">MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_8cpp-example.html#a182">MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_8cpp-example.html#a178">MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_8cpp-example.html#a25">MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_8cpp-example.html#a25">MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_8cpp-example.html#a27">MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_8cpp-example.html#a178">MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_8cpp-example.html#a25">MiiTransparentAdjuster.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a5">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a97">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a65">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a122">NvnTutorial11.cpp</a>, <a class="el" href="_ro_static_application_8cpp-example.html#a6">RoStaticApplication.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a35">Ui2dDemo/Main.cpp</a>, <a class="el" href="_vfx_binary_segmentation_2main_8cpp-example.html#a26">VfxBinarySegmentation/main.cpp</a>, <a class="el" href="_vfx_custom_shader_2main_8cpp-example.html#a10">VfxCustomShader/main.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a8">VfxManualEmitterSet/main.cpp</a>, <a class="el" href="_vfx_simple_2main_8cpp-example.html#a26">VfxSimple/main.cpp</a>, <a class="el" href="_vk_simple_8cpp-example.html#a17">VkSimple.cpp</a> (計53項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="a2805c57e6c7c5ec8fbc7d30e7137deae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::fs::GetFileOpenMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイルオープン時に指定したモードを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>ファイルのハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ファイルオープン時に指定したモード（OpenMode 型の要素、またはそのビット和）が返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>handle が有効なハンドルである。 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac8bd9e828751bd4f953acfa765278f84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::CloseFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイルをクローズします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>クローズするファイルのハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>なし</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>handle が有効なハンドルである。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 handle で表されるファイルをクローズし、リソースを解放します。<br />
 このハンドルに対する最後の書き込みが成功したにもかかわらず <a class="el" href="namespacenn_1_1fs.html#a543a813b9e0c46a2d6ccb24d7c863a76" title="WriteFile() で指定した内容を、確実に書き込まれた状態にします。 ">FlushFile()</a> が呼ばれていない場合、プログラムを停止して、ログを出力します。<br />
 記録メディアの抜けなどにより書き込み操作が失敗する場合には、 <a class="el" href="namespacenn_1_1fs.html#a543a813b9e0c46a2d6ccb24d7c863a76" title="WriteFile() で指定した内容を、確実に書き込まれた状態にします。 ">FlushFile()</a> が呼ばれていなくてもクローズできます。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_aoc_season_pass_delivery_8cpp-example.html#a15">AocSeasonPassDelivery.cpp</a>, <a class="el" href="_aoc_season_pass_sales_start_8cpp-example.html#a15">AocSeasonPassSalesStart.cpp</a>, <a class="el" href="_aoc_simple_8cpp-example.html#a15">AocSimple.cpp</a>, <a class="el" href="_asset_file_loading_helper_8cpp-example.html#a15">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_atk_addon_sound_archive_8cpp-example.html#a33">AtkAddonSoundArchive.cpp</a>, <a class="el" href="_atk_group_8cpp-example.html#a24">AtkGroup.cpp</a>, <a class="el" href="_audio_cpu_renderer_8cpp-example.html#a15">AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_8cpp-example.html#a15">AudioDevice.cpp</a>, <a class="el" href="_audio_effect_8cpp-example.html#a22">AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_8cpp-example.html#a20">AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_8cpp-example.html#a47">AudioMemoryPool.cpp</a>, <a class="el" href="_audio_performance_metrics_8cpp-example.html#a15">AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_8cpp-example.html#a14">AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_8cpp-example.html#a15">AudioSink.cpp</a>, <a class="el" href="_audio_splitter_8cpp-example.html#a14">AudioSplitter.cpp</a>, <a class="el" href="_codec_aac_decoder_8cpp-example.html#a15">CodecAacDecoder.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_8cpp-example.html#a7">CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_8cpp-example.html#a13">CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_8cpp-example.html#a13">CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_8cpp-example.html#a13">CodecOpusMultiStreamDecoder.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a74">FontDemo/Main.cpp</a>, <a class="el" href="_fontll_save_to_jpeg_8cpp-example.html#a36">FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_host_8cpp-example.html#a26">FsHost.cpp</a>, <a class="el" href="_fs_rom_8cpp-example.html#a11">FsRom.cpp</a>, <a class="el" href="_fs_save_data_8cpp-example.html#a23">FsSaveData.cpp</a>, <a class="el" href="_fs_save_data_for_debug_8cpp-example.html#a14">FsSaveDataForDebug.cpp</a>, <a class="el" href="_fs_sd_card_for_debug_8cpp-example.html#a18">FsSdCardForDebug.cpp</a>, <a class="el" href="_fs_set_allocator_8cpp-example.html#a13">FsSetAllocator.cpp</a>, <a class="el" href="_gfx_primitive_renderer_8cpp-example.html#a13">GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_gfx_simple_8cpp-example.html#a13">GfxSimple.cpp</a>, <a class="el" href="_gfx_simple_compute_8cpp-example.html#a43">GfxSimpleCompute.cpp</a>, <a class="el" href="_hid_controller_sequence__main_8cpp-example.html#a51">HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_vibration_player_8cpp-example.html#a11">HidVibrationPlayer.cpp</a>, <a class="el" href="_mii_compressed_texture_8cpp-example.html#a171">MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_8cpp-example.html#a173">MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_8cpp-example.html#a172">MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_8cpp-example.html#a55">MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_8cpp-example.html#a52">MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_8cpp-example.html#a183">MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_8cpp-example.html#a168">MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_8cpp-example.html#a32">MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_8cpp-example.html#a173">MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_8cpp-example.html#a169">MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_8cpp-example.html#a33">MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_8cpp-example.html#a33">MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_8cpp-example.html#a35">MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_8cpp-example.html#a169">MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_8cpp-example.html#a33">MiiTransparentAdjuster.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a38">MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a42">MoviePlayerSimple.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a13">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a106">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a80">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a124">NvnTutorial11.cpp</a>, <a class="el" href="_ro_static_application_8cpp-example.html#a10">RoStaticApplication.cpp</a>, <a class="el" href="_simple_8cpp-example.html#a11">Simple.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a37">Ui2dDemo/Main.cpp</a>, <a class="el" href="_vfx_binary_segmentation_2main_8cpp-example.html#a28">VfxBinarySegmentation/main.cpp</a>, <a class="el" href="_vfx_custom_shader_2main_8cpp-example.html#a13">VfxCustomShader/main.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a10">VfxManualEmitterSet/main.cpp</a>, <a class="el" href="_vfx_simple_2main_8cpp-example.html#a28">VfxSimple/main.cpp</a>, <a class="el" href="_vk_simple_8cpp-example.html#a19">VkSimple.cpp</a> (計62項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="a3e89c4d57cc8379265894ff7f3e98b2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::CreateFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイルを作成します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>新規に作成するファイルのパス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>新規に作成するファイルのサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000033">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="エラー Result (fs: 指定されたパスに対象が見つからない) を表すクラスです。 ">ResultPathNotFound</a></b> パスに含まれるディレクトリが存在しません。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_path_already_exists.html" title="エラー Result (fs: 対象が既に存在している) を表すクラスです。 ">ResultPathAlreadyExists</a></b> 対象ファイルはすでに存在しています。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough.html" title="エラー Result (fs: 空き容量が不足) を表すクラスです。 ">ResultUsableSpaceNotEnough</a></b> 空き容量が不足しています。 </p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>path が <a class="el" href="namespacenn_1_1fs.html#entry_path">有効なパス </a> である。</li>
<li>path に含まれているマウント名が、書き込み可能なファイルシステムのものである。</li>
<li>size &gt;= 0</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 path で表される位置に、size バイトのファイルを新たに作成します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_fontll_save_to_jpeg_8cpp-example.html#a29">FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_host_8cpp-example.html#a7">FsHost.cpp</a>, <a class="el" href="_fs_save_data_8cpp-example.html#a16">FsSaveData.cpp</a>, <a class="el" href="_fs_save_data_for_debug_8cpp-example.html#a6">FsSaveDataForDebug.cpp</a>, <a class="el" href="_fs_sd_card_for_debug_8cpp-example.html#a7">FsSdCardForDebug.cpp</a>, <a class="el" href="_fs_set_allocator_8cpp-example.html#a8">FsSetAllocator.cpp</a>, <a class="el" href="_simple_8cpp-example.html#a4">Simple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a812ac4964fb5564467c5475c1b9fb16b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::DeleteFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイルを削除します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>削除するファイルのパス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000034">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="エラー Result (fs: 指定されたパスに対象が見つからない) を表すクラスです。 ">ResultPathNotFound</a></b> 対象ファイルが存在しません。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="エラー Result (fs: 対象がロックされている) を表すクラスです。 ">ResultTargetLocked</a></b> 対象ファイルが開かれているため削除できません。 </p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>path が <a class="el" href="namespacenn_1_1fs.html#entry_path">有効なパス </a> である。</li>
<li>path に含まれているマウント名が、書き込み可能なファイルシステムのものである。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 path で表されるファイルを削除します。<br />
 対象のファイルが他から開かれている場合は失敗します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_fontll_save_to_jpeg_8cpp-example.html#a27">FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_host_8cpp-example.html#a29">FsHost.cpp</a>, <a class="el" href="_fs_set_allocator_8cpp-example.html#a14">FsSetAllocator.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad09dbc3816b9e95562081f9411711c4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::CreateDirectory </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ディレクトリを作成します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>新規に作成するディレクトリのパス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000035">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="エラー Result (fs: 指定されたパスに対象が見つからない) を表すクラスです。 ">ResultPathNotFound</a></b> パスに含まれるディレクトリが存在しません。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_path_already_exists.html" title="エラー Result (fs: 対象が既に存在している) を表すクラスです。 ">ResultPathAlreadyExists</a></b> 対象ディレクトリはすでに存在しています。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough.html" title="エラー Result (fs: 空き容量が不足) を表すクラスです。 ">ResultUsableSpaceNotEnough</a></b> 空き容量が不足しています。 </p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>path が <a class="el" href="namespacenn_1_1fs.html#entry_path">有効なパス </a> である。</li>
<li>path に含まれているマウント名が、書き込み可能なファイルシステムのものである。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 path で表される位置にディレクトリを新たに作成します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_fs_host_8cpp-example.html#a6">FsHost.cpp</a>, <a class="el" href="_intermediate_file_manager_8cpp-example.html#a19">IntermediateFileManager.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a40e072fc4b9bd6a36b6902b117ba85d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::DeleteDirectory </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ディレクトリを削除します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>削除するディレクトリのパス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000036">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="エラー Result (fs: 指定されたパスに対象が見つからない) を表すクラスです。 ">ResultPathNotFound</a></b> 対象ディレクトリが存在しません。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_directory_not_empty.html" title="エラー Result (fs: 対象のディレクトリ内にエントリがある) を表すクラスです。 ">ResultDirectoryNotEmpty</a></b> ディレクトリに子エントリが存在するので削除できません。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="エラー Result (fs: 対象がロックされている) を表すクラスです。 ">ResultTargetLocked</a></b> 対象ディレクトリが開かれているため削除できません。 子エントリが開かれているため削除できません。 </p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>path が <a class="el" href="namespacenn_1_1fs.html#entry_path">有効なパス </a> である。</li>
<li>path に含まれているマウント名が、書き込み可能なファイルシステムのものである。</li>
<li>path で表されるディレクトリがルートディレクトリでない。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 path で表されるディレクトリを削除します。<br />
 子エントリが存在するディレクトリを削除することはできません。<br />
 また、対象のディレクトリが他から開かれている場合は失敗します。<br />
</p>

</div>
</div>
<a class="anchor" id="ad6c41cd88ca1bd0cace5a443f4bc3efd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::DeleteDirectoryRecursively </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>子エントリも含め、ディレクトリを再帰的に削除します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>削除するディレクトリのパス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000037">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="エラー Result (fs: 指定されたパスに対象が見つからない) を表すクラスです。 ">ResultPathNotFound</a></b> 対象ディレクトリが存在しません。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="エラー Result (fs: 対象がロックされている) を表すクラスです。 ">ResultTargetLocked</a></b> 対象ディレクトリが開かれているため削除できません。 子エントリが開かれているため削除できません。 </p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>path が <a class="el" href="namespacenn_1_1fs.html#entry_path">有効なパス </a> である。</li>
<li>path に含まれているマウント名が、書き込み可能なファイルシステムのものである。</li>
<li>path で表されるディレクトリがルートディレクトリでない。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 path で表されるディレクトリを再帰的に削除します。<br />
 <br />
 削除対象が他から開かれている場合は失敗します。<br />
 処理の途中で失敗した場合でも、それまでに削除されたエントリは削除されたままとなります。<br />
 処理の途中で失敗した場合、どのエントリが削除され、どのエントリが削除されないかは不定です。<br />
 本関数はスタックの最大使用量が固定であるため、子階層の深さを問わず使用することができます。<br />
 <br />
 path で表されるディレクトリ自身も削除されます。<br />
 path で表されるディレクトリを削除せず、その子エントリのみを削除するためには <a class="el" href="namespacenn_1_1fs.html#ae52b7fdae71cfa75a6c45552c4195b87" title="ディレクトリに含まれる全ての子エントリを再帰的に削除します。 ">CleanDirectoryRecursively()</a> を使用します。<br />
</p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_fs_host_8cpp-example.html#a27">FsHost.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ae52b7fdae71cfa75a6c45552c4195b87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::CleanDirectoryRecursively </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ディレクトリに含まれる全ての子エントリを再帰的に削除します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>子エントリを削除するディレクトリのパス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000038">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="エラー Result (fs: 指定されたパスに対象が見つからない) を表すクラスです。 ">ResultPathNotFound</a></b> 対象ディレクトリが存在しません。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="エラー Result (fs: 対象がロックされている) を表すクラスです。 ">ResultTargetLocked</a></b> 子エントリが開かれているため削除できません。 </p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>path が <a class="el" href="namespacenn_1_1fs.html#entry_path">有効なパス </a> である。</li>
<li>path に含まれているマウント名が、書き込み可能なファイルシステムのものである。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 path で表されるディレクトリに含まれる全ての子エントリを再帰的に削除します。<br />
 <br />
 削除対象が他から開かれている場合は失敗します。<br />
 処理の途中で失敗した場合でも、それまでに削除されたエントリは削除されたままとなります。<br />
 処理の途中で失敗した場合、どのエントリが削除され、どのエントリが削除されないかは不定です。<br />
 本関数はスタックの最大使用量が固定であるため、子階層の深さを問わず使用することができます。<br />
 <br />
 path で表されるディレクトリ自身は削除されません。<br />
 path で表されるディレクトリとその子エントリの両方を削除するためには <a class="el" href="namespacenn_1_1fs.html#ad6c41cd88ca1bd0cace5a443f4bc3efd" title="子エントリも含め、ディレクトリを再帰的に削除します。 ">DeleteDirectoryRecursively()</a> を使用します。<br />
</p>

</div>
</div>
<a class="anchor" id="aaa1a2e4d197a78400b604debc9c7c4ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::RenameFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>currentPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイル名を変更します。ファイルの移動も可能です。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currentPath</td><td>変更元のファイルパス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPath</td><td>変更先のファイルパス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000039">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="エラー Result (fs: 指定されたパスに対象が見つからない) を表すクラスです。 ">ResultPathNotFound</a></b> リネーム元ファイルが存在しません。 リネーム先のパスに含まれるディレクトリが存在しません。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_path_already_exists.html" title="エラー Result (fs: 対象が既に存在している) を表すクラスです。 ">ResultPathAlreadyExists</a></b> リネーム先ファイルがすでに存在しています。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="エラー Result (fs: 対象がロックされている) を表すクラスです。 ">ResultTargetLocked</a></b> リネーム元ファイルが開かれているのでリネームできません。 </p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>currentPath, newPath が <a class="el" href="namespacenn_1_1fs.html#entry_path">有効なパス </a> である。</li>
<li>currentPath, newPath に含まれているマウント名が、同じファイルシステムを指している。</li>
<li>currentPath, newPath に含まれているマウント名が、書き込み可能なファイルシステムのものである。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 currentPath で表されるファイルの名前を newPath に変更します。<br />
 ファイルが開かれている場合には移動できません。<br />
</p>

</div>
</div>
<a class="anchor" id="a394c7c7cce23b0a368e83d115baafe17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::RenameDirectory </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>currentPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ディレクトリ名を変更します。ディレクトリの移動も可能です。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currentPath</td><td>変更元のディレクトリパス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPath</td><td>変更先のディレクトリパス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000040">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="エラー Result (fs: 指定されたパスに対象が見つからない) を表すクラスです。 ">ResultPathNotFound</a></b> リネーム元ディレクトリが存在しません。 リネーム先のパスに含まれるディレクトリが存在しません。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_path_already_exists.html" title="エラー Result (fs: 対象が既に存在している) を表すクラスです。 ">ResultPathAlreadyExists</a></b> リネーム先ディレクトリがすでに存在しています。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="エラー Result (fs: 対象がロックされている) を表すクラスです。 ">ResultTargetLocked</a></b> リネーム元のディレクトリが開かれているのでリネームできません。 </p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>currentPath, newPath が <a class="el" href="namespacenn_1_1fs.html#entry_path">有効なパス </a> である。</li>
<li>currentPath, newPath に含まれているマウント名が、同じファイルシステムを指している。</li>
<li>currentPath, newPath に含まれているマウント名が、書き込み可能なファイルシステムのものである。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 currentPath で表されるディレクトリの名前を newPath に変更します。<br />
 子エントリのパスも同時に変更されます。<br />
 <br />
 移動先に同名のエントリがある場合、移動は失敗します。<br />
 従って、ディレクトリの併合操作として利用することはできません。<br />
</p>

</div>
</div>
<a class="anchor" id="a5cf6e2f2c5a0c4e404ba3dd782cc98bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::GetEntryType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1fs.html#a5fc46cd05067c210b62e96f903a2fe85">DirectoryEntryType</a> *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>エントリの種類を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>ディレクトリエントリの種類 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>対象エントリのパス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000041">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="エラー Result (fs: 指定されたパスに対象が見つからない) を表すクラスです。 ">ResultPathNotFound</a></b> 対象エントリが存在しません。 </p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>outValue が有効なメモリを指している。</li>
<li>path が <a class="el" href="namespacenn_1_1fs.html#entry_path">有効なパス </a> である。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 対象のパスのディレクトリエントリの種類を取得します。<br />
 <br />
 ファイルやディレクトリの存在を確認する API としても使用可能です。<br />
 対象のパスにエントリが存在しなかった場合は、ResultPathNotFound が返ります。<br />
 この際の outValue の値は不定です。<br />
</p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_fs_save_data_8cpp-example.html#a14">FsSaveData.cpp</a>, <a class="el" href="_fs_save_data_for_debug_8cpp-example.html#a5">FsSaveDataForDebug.cpp</a>, <a class="el" href="_fs_sd_card_for_debug_8cpp-example.html#a5">FsSdCardForDebug.cpp</a>, <a class="el" href="_simple_8cpp-example.html#a2">Simple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a0f2b5b30657b1ffaf1dec49bfb36462b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::OpenFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_handle.html">FileHandle</a> *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイルをオープンします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>ファイルのハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>オープンするファイルのパス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>ファイルへのアクセスモード（OpenMode 型の要素、またはそのビット和）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000042">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="エラー Result (fs: 指定されたパスに対象が見つからない) を表すクラスです。 ">ResultPathNotFound</a></b> 対象ファイルが存在しません。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="エラー Result (fs: 対象がロックされている) を表すクラスです。 ">ResultTargetLocked</a></b> 対象ファイルがすでに OpenMode_Write を指定して開かれているので、開けません。 対象ファイルが開かれているので、OpenMode_Write を指定して開けません。 </p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>outValue が有効なメモリを指している。</li>
<li>path が <a class="el" href="namespacenn_1_1fs.html#entry_path">有効なパス </a> である。</li>
<li>mode が <a class="el" href="namespacenn_1_1fs.html#a4c97b79cce78a95c2333dbc9053b9393" title="ファイルオープン時のモードを指定するフラグです ">nn::fs::OpenMode</a> の要素、またはそのビット和である。</li>
<li>mode が OpenMode_Read と OpenMode_Write のうち少なくとも 1 つを含んでいる。</li>
<li>mode が OpenMode_Write を含んでいる場合、ファイルシステムが書き込み可能である。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 path で表されるファイルを開き、対応するハンドルを outValue に出力します。<br />
 読み込み、書き込みモードは mode で指定されます。<br />
 元のファイルのサイズを拡張するような書き込みを行う場合は、OpenMode_Write だけでなく OpenMode_AllowAppend を指定する必要があります。<br />
 開かれたファイルは、そのハンドルが閉じられるまで削除やリネームを行うことはできなくなります。<br />
 同一ファイルを複数同時に開くことは、OpenMode_Read で開かれたファイルを OpenMode_Read で開くときに限り可能です。<br />
 それ以外の条件で同一ファイルを複数同時に開こうとした場合は <a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="エラー Result (fs: 対象がロックされている) を表すクラスです。 ">ResultTargetLocked</a> が返ります。<br />
 同一のファイル及び同一のファイルシステムに対する複数同時呼び出しが可能です。<br />
</p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_aoc_season_pass_delivery_8cpp-example.html#a12">AocSeasonPassDelivery.cpp</a>, <a class="el" href="_aoc_season_pass_sales_start_8cpp-example.html#a12">AocSeasonPassSalesStart.cpp</a>, <a class="el" href="_aoc_simple_8cpp-example.html#a12">AocSimple.cpp</a>, <a class="el" href="_asset_file_loading_helper_8cpp-example.html#a4">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_atk_addon_sound_archive_8cpp-example.html#a27">AtkAddonSoundArchive.cpp</a>, <a class="el" href="_atk_group_8cpp-example.html#a19">AtkGroup.cpp</a>, <a class="el" href="_audio_cpu_renderer_8cpp-example.html#a8">AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_8cpp-example.html#a8">AudioDevice.cpp</a>, <a class="el" href="_audio_effect_8cpp-example.html#a14">AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_8cpp-example.html#a12">AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_8cpp-example.html#a41">AudioMemoryPool.cpp</a>, <a class="el" href="_audio_performance_metrics_8cpp-example.html#a6">AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_8cpp-example.html#a8">AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_8cpp-example.html#a6">AudioSink.cpp</a>, <a class="el" href="_audio_splitter_8cpp-example.html#a5">AudioSplitter.cpp</a>, <a class="el" href="_codec_aac_decoder_8cpp-example.html#a10">CodecAacDecoder.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_8cpp-example.html#a2">CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_8cpp-example.html#a9">CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_8cpp-example.html#a8">CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_8cpp-example.html#a9">CodecOpusMultiStreamDecoder.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a68">FontDemo/Main.cpp</a>, <a class="el" href="_fontll_save_to_jpeg_8cpp-example.html#a31">FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_host_8cpp-example.html#a16">FsHost.cpp</a>, <a class="el" href="_fs_rom_8cpp-example.html#a8">FsRom.cpp</a>, <a class="el" href="_fs_save_data_8cpp-example.html#a18">FsSaveData.cpp</a>, <a class="el" href="_fs_save_data_for_debug_8cpp-example.html#a9">FsSaveDataForDebug.cpp</a>, <a class="el" href="_fs_sd_card_for_debug_8cpp-example.html#a10">FsSdCardForDebug.cpp</a>, <a class="el" href="_fs_set_allocator_8cpp-example.html#a11">FsSetAllocator.cpp</a>, <a class="el" href="_gfx_primitive_renderer_8cpp-example.html#a3">GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_gfx_simple_8cpp-example.html#a3">GfxSimple.cpp</a>, <a class="el" href="_gfx_simple_compute_8cpp-example.html#a36">GfxSimpleCompute.cpp</a>, <a class="el" href="_hid_controller_sequence__main_8cpp-example.html#a44">HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_vibration_player_8cpp-example.html#a5">HidVibrationPlayer.cpp</a>, <a class="el" href="_mii_compressed_texture_8cpp-example.html#a168">MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_8cpp-example.html#a166">MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_8cpp-example.html#a169">MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_8cpp-example.html#a52">MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_8cpp-example.html#a49">MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_8cpp-example.html#a180">MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_8cpp-example.html#a165">MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_8cpp-example.html#a21">MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_8cpp-example.html#a170">MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_8cpp-example.html#a166">MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_8cpp-example.html#a22">MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_8cpp-example.html#a22">MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_8cpp-example.html#a24">MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_8cpp-example.html#a166">MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_8cpp-example.html#a22">MiiTransparentAdjuster.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a35">MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a39">MoviePlayerSimple.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a2">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a95">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a63">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a120">NvnTutorial11.cpp</a>, <a class="el" href="_ro_static_application_8cpp-example.html#a2">RoStaticApplication.cpp</a>, <a class="el" href="_simple_8cpp-example.html#a6">Simple.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a32">Ui2dDemo/Main.cpp</a>, <a class="el" href="_vfx_binary_segmentation_2main_8cpp-example.html#a23">VfxBinarySegmentation/main.cpp</a>, <a class="el" href="_vfx_custom_shader_2main_8cpp-example.html#a7">VfxCustomShader/main.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a5">VfxManualEmitterSet/main.cpp</a>, <a class="el" href="_vfx_simple_2main_8cpp-example.html#a23">VfxSimple/main.cpp</a>, <a class="el" href="_vk_simple_8cpp-example.html#a15">VkSimple.cpp</a> (計62項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="acae21d0f79e4d074e120c814a8936a42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::OpenDirectory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_directory_handle.html">DirectoryHandle</a> *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ディレクトリをオープンします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>ディレクトリのハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>オープンするディレクトリのパス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>列挙する対象（OpenDirectoryMode 型の要素、またはそのビット和）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000043">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="エラー Result (fs: 指定されたパスに対象が見つからない) を表すクラスです。 ">ResultPathNotFound</a></b> 対象ディレクトリが存在しません。 </p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>outValue が有効なメモリを指している。</li>
<li>path が <a class="el" href="namespacenn_1_1fs.html#entry_path">有効なパス </a> である。</li>
<li>mode は <a class="el" href="namespacenn_1_1fs.html#a34bc03cdbe641524cab284a7fe7ba705" title="ディレクトリオープン時のモードを指定するフラグです ">nn::fs::OpenDirectoryMode</a> の要素である。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 path で表されるディレクトリを開き、対応するハンドルを outValue に出力します。<br />
 mode で指定された種類の子エントリのみが ReadDirectory 関数などで列挙されます。<br />
 同一のディレクトリ及び同一のファイルシステムに対する複数同時呼び出しが可能です。<br />
</p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_codec_opus_codec_processing_time_8cpp-example.html#a88">CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_fs_host_8cpp-example.html#a9">FsHost.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1b85bf3f3cf038cb67a991a3e3304751"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountHost </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rootPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ホスト PC 上ファイルシステムの指定されたディレクトリをファイルシステムとしてマウントし、操作できるようにします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>このファイルシステムを表すマウント名 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rootPath</td><td>name に紐付けられるホスト PC 上のパス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000044">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="エラー Result (fs: 指定されたパスに対象が見つからない) を表すクラスです。 ">ResultPathNotFound</a></b> rootPath で表されるディレクトリが存在しません。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_target_not_found.html" title="エラー Result (fs: 対象が見つからない) を表すクラスです。 ">ResultTargetNotFound</a></b> ホスト PC に接続できませんでした。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="エラー Result (fs: マウント名が既に存在している) を表すクラスです。 ">ResultMountNameAlreadyExists</a></b> name で表されるファイルシステムが既に存在しています。 </p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>name が <a class="el" href="namespacenn_1_1fs.html#mount_name">有効なマウント名 </a> である。</li>
<li>rootPath がホスト PC 上に存在するディレクトリへの絶対パスである。</li>
<li>rootPath のディレクトリの区切り文字が '/' または '\' である。</li>
<li>rootPath が 終端の NULL 文字を含めず 1 バイト以上 <a class="el" href="namespacenn_1_1fs.html#ad6358a9db10c5b1d1424035a63a72079" title="ファイルシステム内での最大エントリ名長です ">nn::fs::EntryNameLengthMax</a> バイト以下の文字列である。</li>
<li>ホスト PC と接続されている。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 ホスト PC 上のファイルシステムをマウントし、操作できるようにします。<br />
 この関数を呼んだあとは、各関数のパス引数の先頭に (name): を付加することで、ホスト PC 上のファイルシステムにアクセスします。<br />
 実際にアクセスされるホスト PC 上でのパスは、rootPath からの相対パスとなります。<br />
 たとえば、MountHost("host", "D:/tmp"); DeleteFile("host:/file"); と実行すると、<br />
 ホスト PC 上の D:/tmp/file が削除されます。<br />
 <br />
 name にアルファベット一文字を指定することはできません。<br />
 これは <a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11" title="ホスト PC 上のファイルシステムをマウントし、Windows 上のパスと同じパスで操作できるようにします。 ...">MountHostRoot()</a> を実行した場合、ホスト PC 上の絶対パスを使用することができるようになりますが、<br />
 この際に使用される Windows のドライブレターと重複するためです。<br />
 <br />
 本関数は暫定的に fs ライブラリが提供しています。<br />
 本来は htc ライブラリのリソースを確保する必要があるため、htc ライブラリが提供する予定です。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_fontll_save_to_jpeg_8cpp-example.html#a41">FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_host_8cpp-example.html#a3">FsHost.cpp</a>, <a class="el" href="_image_jpeg_encoding_8cpp-example.html#a38">ImageJpegEncoding.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a2ea39d2487ac28bc767cd699eeeebe11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountHostRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ホスト PC 上のファイルシステムをマウントし、Windows 上のパスと同じパスで操作できるようにします。 </p>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000045">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_target_not_found.html" title="エラー Result (fs: 対象が見つからない) を表すクラスです。 ">ResultTargetNotFound</a></b> ホスト PC に接続できませんでした。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="エラー Result (fs: マウント名が既に存在している) を表すクラスです。 ">ResultMountNameAlreadyExists</a></b> ホスト PC 上のファイルシステムは既に存在しています。 </p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>ホスト PC と接続されている。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 ホスト PC 上のファイルシステムをマウントし、操作できるようにします。<br />
 この関数を呼んだあとは、ホスト PC 上の絶対ファイルパスをそのまま使用できるようになります。<br />
 他のファイルシステムとは異なり、本関数でマウントを行った場合は <a class="el" href="namespacenn_1_1fs.html#ade5d6e6459dca7d8274564bcfc5de757" title="MountHostRoot() でマウントしたファイルシステムをアンマウントし、リソースを解放します。 ...">UnmountHostRoot()</a> を呼んでアンマウントを行ってください。<br />
 <br />
 本関数は暫定的に fs ライブラリが提供しています。<br />
 本来は htc ライブラリのリソースを確保する必要があるため、htc ライブラリが提供する予定です。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_atk_viewer_8cpp-example.html#a8">AtkViewer.cpp</a>, <a class="el" href="_fs_host_8cpp-example.html#a30">FsHost.cpp</a>, <a class="el" href="_fs_set_allocator_8cpp-example.html#a5">FsSetAllocator.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a32">MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a46">MoviePlayerSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ade5d6e6459dca7d8274564bcfc5de757"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::UnmountHostRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11" title="ホスト PC 上のファイルシステムをマウントし、Windows 上のパスと同じパスで操作できるようにします。 ...">MountHostRoot()</a> でマウントしたファイルシステムをアンマウントし、リソースを解放します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>なし</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li><a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11" title="ホスト PC 上のファイルシステムをマウントし、Windows 上のパスと同じパスで操作できるようにします。 ...">MountHostRoot()</a> でマウント済みである。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 <a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11" title="ホスト PC 上のファイルシステムをマウントし、Windows 上のパスと同じパスで操作できるようにします。 ...">MountHostRoot()</a> でマウントしていたファイルシステムをアンマウントしてリソースを解放します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_atk_viewer_8cpp-example.html#a12">AtkViewer.cpp</a>, <a class="el" href="_fs_host_8cpp-example.html#a31">FsHost.cpp</a>, <a class="el" href="_fs_set_allocator_8cpp-example.html#a15">FsSetAllocator.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a40">MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a48">MoviePlayerSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac021c163ba94a44a2b53cb848c462930"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::SetAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1fs.html#a9860dee956c54cadf027c37d54adeb28">AllocateFunction</a>&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1fs.html#a07c75b075241d17f1b52cd9eefa851aa">DeallocateFunction</a>&#160;</td>
          <td class="paramname"><em>dealloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fs ライブラリが使用するメモリアロケータを設定します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>メモリを確保する関数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dealloc</td><td>メモリを開放する関数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>プログラムの中で本 API を一度も呼び出していない。</li>
<li>プログラムの中でメモリ確保を伴う FS ライブラリの API を一度も呼び出していない。</li>
<li>alloc != nullptr &amp;&amp; dealloc != nullptr</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 FS ライブラリで使用するメモリのアロケータに alloc, dealloc を設定します。<br />
 alloc には 8 バイトアライメントのアドレスを返すアロケータを設定してください。<br />
 <br />
 本関数を呼ばずに、メモリ確保を伴う FS ライブラリの API を呼び出した場合、malloc(), free() を使用するデフォルトのアロケータがメモリ確保に使用されます。 デフォルトのアロケータが一度でも使用された後は、本関数を呼び出すことはできません。 <br />
 本関数を複数回呼ぶことはできません。そのため、プログラムのメイン関数でのみ呼ぶことを強く推奨します。<br />
 <br />
 <a class="el" href="namespacenn_1_1fs.html#memory_allocation">メモリ確保について </a> も併せて参照してください。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_cpu_renderer_8cpp-example.html#a17">AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_8cpp-example.html#a18">AudioDevice.cpp</a>, <a class="el" href="_audio_effect_8cpp-example.html#a24">AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_8cpp-example.html#a22">AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_8cpp-example.html#a3">AudioMemoryPool.cpp</a>, <a class="el" href="_audio_out_8cpp-example.html#a37">AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_8cpp-example.html#a37">AudioOutWithResampler.cpp</a>, <a class="el" href="_audio_performance_metrics_8cpp-example.html#a18">AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_8cpp-example.html#a17">AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_8cpp-example.html#a18">AudioSink.cpp</a>, <a class="el" href="_audio_splitter_8cpp-example.html#a15">AudioSplitter.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a81">FontDemo/Main.cpp</a>, <a class="el" href="_fontll_save_to_jpeg_8cpp-example.html#a38">FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_set_allocator_8cpp-example.html#a4">FsSetAllocator.cpp</a>, <a class="el" href="_image_jpeg_decoding_8cpp-example.html#a31">ImageJpegDecoding.cpp</a>, <a class="el" href="_image_jpeg_encoding_8cpp-example.html#a36">ImageJpegEncoding.cpp</a>, <a class="el" href="_mii_compressed_texture_8cpp-example.html#a158">MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_8cpp-example.html#a156">MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_8cpp-example.html#a159">MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_8cpp-example.html#a38">MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_8cpp-example.html#a35">MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_8cpp-example.html#a170">MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_8cpp-example.html#a155">MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_8cpp-example.html#a339">MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_8cpp-example.html#a160">MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_8cpp-example.html#a156">MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_8cpp-example.html#a243">MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_8cpp-example.html#a243">MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_8cpp-example.html#a245">MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_8cpp-example.html#a156">MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_8cpp-example.html#a243">MiiTransparentAdjuster.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a9">MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a1">MoviePlayerSimple.cpp</a>, <a class="el" href="_ngc_simple_8cpp-example.html#a28">NgcSimple.cpp</a>, <a class="el" href="_spy_audio_8cpp-example.html#a31">SpyAudio.cpp</a>, <a class="el" href="_tutorial_base_class_8_nx_8cpp-example.html#a27">TutorialBaseClass.Nx.cpp</a>, <a class="el" href="_tutorial_base_class_8_windows_8cpp-example.html#a19">TutorialBaseClass.Windows.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a92">Ui2dDemo/Main.cpp</a>, <a class="el" href="_vfx_binary_segmentation_2main_8cpp-example.html#a57">VfxBinarySegmentation/main.cpp</a>, <a class="el" href="_vfx_custom_shader_2main_8cpp-example.html#a79">VfxCustomShader/main.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a69">VfxManualEmitterSet/main.cpp</a>, <a class="el" href="_vfx_simple_2main_8cpp-example.html#a134">VfxSimple/main.cpp</a>, <a class="el" href="_web_demo__main_8cpp-example.html#a3">WebDemo_Main.cpp</a> (計43項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac8a95249afd4a87a55d319dfecb0466c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::Unmount </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>マウント済みのファイルシステムをアンマウントし、リソースを解放します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>マウント時に指定したマウント名</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>なし</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>name で表されるマウント名が、マウント済みのものである。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 マウントしていたファイルシステムをアンマウントしてリソースを解放します。<br />
 <a class="el" href="namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11" title="ホスト PC 上のファイルシステムをマウントし、Windows 上のパスと同じパスで操作できるようにします。 ...">MountHostRoot()</a> でマウントしたファイルシステムを除き、<br />
 どのファイルシステムに対してもこの関数でアンマウントを行うことになります。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_aoc_season_pass_delivery_8cpp-example.html#a17">AocSeasonPassDelivery.cpp</a>, <a class="el" href="_aoc_season_pass_sales_start_8cpp-example.html#a16">AocSeasonPassSalesStart.cpp</a>, <a class="el" href="_aoc_simple_8cpp-example.html#a16">AocSimple.cpp</a>, <a class="el" href="_audio_cpu_renderer_8cpp-example.html#a21">AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_8cpp-example.html#a22">AudioDevice.cpp</a>, <a class="el" href="_audio_effect_8cpp-example.html#a28">AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_8cpp-example.html#a26">AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_8cpp-example.html#a8">AudioMemoryPool.cpp</a>, <a class="el" href="_audio_performance_metrics_8cpp-example.html#a22">AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_8cpp-example.html#a20">AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_8cpp-example.html#a22">AudioSink.cpp</a>, <a class="el" href="_audio_splitter_8cpp-example.html#a19">AudioSplitter.cpp</a>, <a class="el" href="_codec_aac_decoder_8cpp-example.html#a4">CodecAacDecoder.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_8cpp-example.html#a18">CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_8cpp-example.html#a5">CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_8cpp-example.html#a4">CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_8cpp-example.html#a5">CodecOpusMultiStreamDecoder.cpp</a>, <a class="el" href="_demo1_2_demo1_8cpp-example.html#a17">Demo1/Demo1.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a109">FontDemo/Main.cpp</a>, <a class="el" href="_fontll_save_to_jpeg_8cpp-example.html#a58">FontllSaveToJpeg.cpp</a>, <a class="el" href="_fs_host_8cpp-example.html#a28">FsHost.cpp</a>, <a class="el" href="_fs_rom_8cpp-example.html#a12">FsRom.cpp</a>, <a class="el" href="_fs_save_data_8cpp-example.html#a28">FsSaveData.cpp</a>, <a class="el" href="_fs_save_data_for_debug_8cpp-example.html#a19">FsSaveDataForDebug.cpp</a>, <a class="el" href="_fs_sd_card_for_debug_8cpp-example.html#a19">FsSdCardForDebug.cpp</a>, <a class="el" href="_gfx_primitive_renderer_8cpp-example.html#a209">GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_gfx_simple_8cpp-example.html#a278">GfxSimple.cpp</a>, <a class="el" href="_gfx_simple_compute_8cpp-example.html#a97">GfxSimpleCompute.cpp</a>, <a class="el" href="_hid_controller_sequence__main_8cpp-example.html#a65">HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_vibration_player_8cpp-example.html#a17">HidVibrationPlayer.cpp</a>, <a class="el" href="_image_jpeg_decoding_8cpp-example.html#a36">ImageJpegDecoding.cpp</a>, <a class="el" href="_image_jpeg_encoding_8cpp-example.html#a39">ImageJpegEncoding.cpp</a>, <a class="el" href="_mii_compressed_texture_8cpp-example.html#a161">MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_8cpp-example.html#a159">MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_8cpp-example.html#a162">MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_8cpp-example.html#a45">MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_8cpp-example.html#a42">MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_8cpp-example.html#a173">MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_8cpp-example.html#a158">MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_8cpp-example.html#a342">MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_8cpp-example.html#a163">MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_8cpp-example.html#a159">MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_8cpp-example.html#a246">MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_8cpp-example.html#a246">MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_8cpp-example.html#a248">MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_8cpp-example.html#a159">MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_8cpp-example.html#a246">MiiTransparentAdjuster.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a39">MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a47">MoviePlayerSimple.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a100">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a109">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a88">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a107">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a69">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a69">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a81">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a69">NvnTutorial11.cpp</a>, <a class="el" href="_ro_static_application_8cpp-example.html#a27">RoStaticApplication.cpp</a>, <a class="el" href="_simple_8cpp-example.html#a16">Simple.cpp</a>, <a class="el" href="_spy_audio_8cpp-example.html#a36">SpyAudio.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a153">Ui2dDemo/Main.cpp</a>, <a class="el" href="_vfx_binary_segmentation_2main_8cpp-example.html#a131">VfxBinarySegmentation/main.cpp</a>, <a class="el" href="_vfx_custom_shader_2main_8cpp-example.html#a151">VfxCustomShader/main.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a117">VfxManualEmitterSet/main.cpp</a>, <a class="el" href="_vfx_simple_2main_8cpp-example.html#a176">VfxSimple/main.cpp</a>, <a class="el" href="_web_demo__main_8cpp-example.html#a8">WebDemo_Main.cpp</a> (計66項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="a3280722d232526f011908c2e7e50400d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::SetPriorityOnCurrentThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3">Priority</a>&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>アクセス優先度を設定します。 </p>
<p><b>詳細</b> <br />
 現在のスレッドにおけるアクセス優先度を設定します。<br />
 詳細は NintendoSDK ドキュメントの <a href="../../Package/contents/Pages/Page_277373520.html">アクセス優先度</a> を参照してください。<br />
 </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>アクセス優先度</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>なし </dd></dl>

</div>
</div>
<a class="anchor" id="a1b0bae7e05be65b11e83a5a63640680f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1fs.html#a2e4a9f55e854a9755c9264838caa97d3">Priority</a> nn::fs::GetPriorityOnCurrentThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>アクセス優先度を取得します。 </p>
<p><b>詳細</b> <br />
 現在のスレッドにおけるアクセス優先度を取得します。<br />
 詳細は NintendoSDK ドキュメントの <a href="../../Package/contents/Pages/Page_277373520.html">アクセス優先度</a> を参照してください。<br />
 </p><dl class="section return"><dt>戻り値</dt><dd>アクセス優先度 </dd></dl>

</div>
</div>
<a class="anchor" id="a5df6e3385c795a5bd046790ef7f17f2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::QueryMountRomCacheSize </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacenn_1_1fs.html#a2e453fe1fbf8f818dc45bbd2897105cd" title="リソースデータ（ROM）をマウントします。 ">nn::fs::MountRom</a> のファイルシステムキャッシュに必要なサイズを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>ファイルシステムキャッシュに必要なサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000046">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 </dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>pOutValue が有効なメモリを指している。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
</p><div id="dynsection-Windows" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-Windows-trigger" src="closed.png"/>
  <b>（Windowsプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-Windows-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-Windows-content" class="dyncontent" style="display:none;"> Windows 環境では、リソースデータ（ROM）の内容によらず、固定値が取得されます。 </div> <div id="dynsection-NX" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-NX-trigger" src="closed.png"/>
  <b>（NXプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-NX-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-NX-content" class="dyncontent" style="display:none;"> NX 環境で Raw 形式 (nspd) でアプリケーションを起動した場合は、リソースデータ（ROM）の内容によらず、固定値が取得されます。<br />
最終的な NX アプリケーションに必要なキャッシュバッファのサイズは、NSP 形式でアプリケーションを起動したときに取得される値です。 </div> <dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_cpu_renderer_8cpp-example.html#a19">AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_8cpp-example.html#a20">AudioDevice.cpp</a>, <a class="el" href="_audio_effect_8cpp-example.html#a26">AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_8cpp-example.html#a24">AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_8cpp-example.html#a5">AudioMemoryPool.cpp</a>, <a class="el" href="_audio_performance_metrics_8cpp-example.html#a20">AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_8cpp-example.html#a18">AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_8cpp-example.html#a20">AudioSink.cpp</a>, <a class="el" href="_audio_splitter_8cpp-example.html#a17">AudioSplitter.cpp</a>, <a class="el" href="_breakpad_simple_8cpp-example.html#a3">BreakpadSimple.cpp</a>, <a class="el" href="_codec_aac_decoder_8cpp-example.html#a1">CodecAacDecoder.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_8cpp-example.html#a16">CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_8cpp-example.html#a2">CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_8cpp-example.html#a2">CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_8cpp-example.html#a2">CodecOpusMultiStreamDecoder.cpp</a>, <a class="el" href="_demo1_2_demo1_8cpp-example.html#a11">Demo1/Demo1.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a82">FontDemo/Main.cpp</a>, <a class="el" href="_fs_rom_8cpp-example.html#a3">FsRom.cpp</a>, <a class="el" href="_gfx_primitive_renderer_8cpp-example.html#a205">GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_gfx_simple_8cpp-example.html#a262">GfxSimple.cpp</a>, <a class="el" href="_gfx_simple_compute_8cpp-example.html#a75">GfxSimpleCompute.cpp</a>, <a class="el" href="_hid_controller_sequence__main_8cpp-example.html#a52">HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_vibration_player_8cpp-example.html#a13">HidVibrationPlayer.cpp</a>, <a class="el" href="_image_jpeg_decoding_8cpp-example.html#a33">ImageJpegDecoding.cpp</a>, <a class="el" href="_mii_compressed_texture_8cpp-example.html#a159">MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_8cpp-example.html#a157">MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_8cpp-example.html#a160">MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_8cpp-example.html#a39">MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_8cpp-example.html#a36">MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_8cpp-example.html#a171">MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_8cpp-example.html#a156">MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_8cpp-example.html#a340">MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_8cpp-example.html#a161">MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_8cpp-example.html#a157">MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_8cpp-example.html#a244">MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_8cpp-example.html#a244">MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_8cpp-example.html#a246">MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_8cpp-example.html#a157">MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_8cpp-example.html#a244">MiiTransparentAdjuster.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a92">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a98">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a80">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a89">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a59">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a59">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a56">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a61">NvnTutorial11.cpp</a>, <a class="el" href="_ro_static_application_8cpp-example.html#a15">RoStaticApplication.cpp</a>, <a class="el" href="_spy_audio_8cpp-example.html#a33">SpyAudio.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a93">Ui2dDemo/Main.cpp</a>, <a class="el" href="_vfx_binary_segmentation_2main_8cpp-example.html#a58">VfxBinarySegmentation/main.cpp</a>, <a class="el" href="_vfx_custom_shader_2main_8cpp-example.html#a104">VfxCustomShader/main.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a94">VfxManualEmitterSet/main.cpp</a>, <a class="el" href="_vfx_simple_2main_8cpp-example.html#a157">VfxSimple/main.cpp</a>, <a class="el" href="_vk_simple_8cpp-example.html#a25">VkSimple.cpp</a>, <a class="el" href="_web_demo__main_8cpp-example.html#a4">WebDemo_Main.cpp</a> (計56項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="a2e453fe1fbf8f818dc45bbd2897105cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountRom </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pFileSystemCacheBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fileSystemCacheBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>リソースデータ（ROM）をマウントします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>マウント名 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFileSystemCacheBuffer</td><td>ファイルシステムキャッシュのバッファ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileSystemCacheBufferSize</td><td>バッファのサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000047">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="エラー Result (fs: マウント名が既に存在している) を表すクラスです。 ">ResultMountNameAlreadyExists</a></b> name で表されるファイルシステムが既に存在しています。 </p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>name が <a class="el" href="namespacenn_1_1fs.html#mount_name">有効なマウント名 </a> である。</li>
<li>対象のリソースデータ（ROM）が存在する。</li>
<li>pFileSystemCacheBuffer が有効なメモリを指している。</li>
<li>fileSystemCacheBufferSize が <a class="el" href="namespacenn_1_1fs.html#a5df6e3385c795a5bd046790ef7f17f2d" title="nn::fs::MountRom のファイルシステムキャッシュに必要なサイズを取得します。 ">QueryMountRomCacheSize(size_t* pOutValue)</a> で取得できるサイズ以上</li>
<li>マウント済みのリソースデータ（ROM）の数が 9 個以下である。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 リソースデータ（ROM）を扱う読み込み専用の ROM ファイルシステムをマウント名 name でマウントします。<br />
 異なるマウント名を指定して本関数を複数回呼び出し、多重にマウントすることは非推奨です。<br />
 多重にマウントする場合はそれぞれに異なるキャッシュバッファを指定する必要があります。<br />
 リソースデータ（ROM）の指定や配置については NintendoSDK ドキュメントの <a href="../../Package/contents/Pages/Page_107320203.html">リソースデータ（ROM）</a> を参照してください。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_cpu_renderer_8cpp-example.html#a20">AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_8cpp-example.html#a21">AudioDevice.cpp</a>, <a class="el" href="_audio_effect_8cpp-example.html#a27">AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_8cpp-example.html#a25">AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_8cpp-example.html#a7">AudioMemoryPool.cpp</a>, <a class="el" href="_audio_performance_metrics_8cpp-example.html#a21">AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_8cpp-example.html#a19">AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_8cpp-example.html#a21">AudioSink.cpp</a>, <a class="el" href="_audio_splitter_8cpp-example.html#a18">AudioSplitter.cpp</a>, <a class="el" href="_breakpad_simple_8cpp-example.html#a5">BreakpadSimple.cpp</a>, <a class="el" href="_codec_aac_decoder_8cpp-example.html#a3">CodecAacDecoder.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_8cpp-example.html#a17">CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_8cpp-example.html#a4">CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_8cpp-example.html#a3">CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_8cpp-example.html#a4">CodecOpusMultiStreamDecoder.cpp</a>, <a class="el" href="_demo1_2_demo1_8cpp-example.html#a14">Demo1/Demo1.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a84">FontDemo/Main.cpp</a>, <a class="el" href="_fs_rom_8cpp-example.html#a5">FsRom.cpp</a>, <a class="el" href="_gfx_primitive_renderer_8cpp-example.html#a208">GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_gfx_simple_8cpp-example.html#a263">GfxSimple.cpp</a>, <a class="el" href="_gfx_simple_compute_8cpp-example.html#a76">GfxSimpleCompute.cpp</a>, <a class="el" href="_hid_controller_sequence__main_8cpp-example.html#a55">HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_vibration_player_8cpp-example.html#a15">HidVibrationPlayer.cpp</a>, <a class="el" href="_image_jpeg_decoding_8cpp-example.html#a35">ImageJpegDecoding.cpp</a>, <a class="el" href="_mii_compressed_texture_8cpp-example.html#a160">MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_8cpp-example.html#a158">MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_8cpp-example.html#a161">MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_8cpp-example.html#a43">MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_8cpp-example.html#a40">MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_8cpp-example.html#a172">MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_8cpp-example.html#a157">MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_8cpp-example.html#a341">MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_8cpp-example.html#a162">MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_8cpp-example.html#a158">MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_8cpp-example.html#a245">MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_8cpp-example.html#a245">MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_8cpp-example.html#a247">MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_8cpp-example.html#a158">MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_8cpp-example.html#a245">MiiTransparentAdjuster.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a95">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a101">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a83">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a92">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a62">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a62">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a59">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a64">NvnTutorial11.cpp</a>, <a class="el" href="_ro_static_application_8cpp-example.html#a17">RoStaticApplication.cpp</a>, <a class="el" href="_spy_audio_8cpp-example.html#a35">SpyAudio.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a95">Ui2dDemo/Main.cpp</a>, <a class="el" href="_vfx_binary_segmentation_2main_8cpp-example.html#a61">VfxBinarySegmentation/main.cpp</a>, <a class="el" href="_vfx_custom_shader_2main_8cpp-example.html#a107">VfxCustomShader/main.cpp</a>, <a class="el" href="_vfx_manual_emitter_set_2main_8cpp-example.html#a97">VfxManualEmitterSet/main.cpp</a>, <a class="el" href="_vfx_simple_2main_8cpp-example.html#a160">VfxSimple/main.cpp</a>, <a class="el" href="_vk_simple_8cpp-example.html#a27">VkSimple.cpp</a>, <a class="el" href="_web_demo__main_8cpp-example.html#a6">WebDemo_Main.cpp</a> (計56項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="a7a6592b4b0351945aa259359dcb464cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::fs::CanMountRomForDebug </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacenn_1_1fs.html#a2e453fe1fbf8f818dc45bbd2897105cd" title="リソースデータ（ROM）をマウントします。 ">nn::fs::MountRom()</a> が実行可能かどうかを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000048">戻り値一覧:</a></b></dt><dd><p class="startdd"><b>true</b> <a class="el" href="namespacenn_1_1fs.html#a2e453fe1fbf8f818dc45bbd2897105cd" title="リソースデータ（ROM）をマウントします。 ">MountRom()</a> が実行可能です。 <br />
 </p>
<p class="enddd"><b>false</b> <a class="el" href="namespacenn_1_1fs.html#a2e453fe1fbf8f818dc45bbd2897105cd" title="リソースデータ（ROM）をマウントします。 ">MountRom()</a> が実行できません。</p>
</dd></dl>
<p><b>詳細</b> <br />
 この API はデバッグ用途に限り使用可能です。 </p>

</div>
</div>
<a class="anchor" id="a90c27aaf70aec66968715663cd8c5415"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::SetSaveDataRootPath </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rootPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>セーブデータの配置場所として利用するホスト PC 上のパスを設定します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rootPath</td><td>セーブデータの配置場所とする、ホスト PC 上のディレクトリパス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>なし</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>rootPath がホスト PC 上に存在するディレクトリへの絶対パスである。</li>
<li>rootPath のディレクトリの区切り文字が '/' または '\' である。</li>
<li>rootPath が 終端の NULL 文字を含めず 1 バイト以上 <a class="el" href="namespacenn_1_1fs.html#ad6358a9db10c5b1d1424035a63a72079" title="ファイルシステム内での最大エントリ名長です ">nn::fs::EntryNameLengthMax</a> バイト以下の文字列である。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 この API はデバッグ用途に限り使用可能です。<br />
 セーブデータのマウント処理の前に実行する必要があります。<br />
 詳細は NintendoSDK ドキュメントの <a href="../../Package/contents/Pages/Page_107320205.html">セーブデータ</a> を参照してください。 </p>

</div>
</div>
<a class="anchor" id="a767e38eb403bd2ebb4374c5214dc0e95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountSaveDataForDebug </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>デバッグ用セーブデータをマウントします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>マウント名</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000049">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="エラー Result (fs: 対象がロックされている) を表すクラスです。 ">ResultTargetLocked</a></b> セーブデータが使用中です。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="エラー Result (fs: マウント名が既に存在している) を表すクラスです。 ">ResultMountNameAlreadyExists</a></b> name で表されるファイルシステムが既に存在しています。</p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>name が <a class="el" href="namespacenn_1_1fs.html#mount_name">有効なマウント名 </a> である。</li>
<li>対象のセーブデータが存在する。</li>
<li>マウント済みのセーブデータの数が 9 個以下である。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 この API はデバッグ用途に限り使用可能です。<br />
 セーブデータをマウント名 name でマウントします。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_fs_save_data_for_debug_8cpp-example.html#a3">FsSaveDataForDebug.cpp</a>, <a class="el" href="_simple_8cpp-example.html#a0">Simple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac2f25cffd056f24d6facfda13f977fa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::CommitSaveData </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>このAPIの利用は非推奨です。代替APIや利用条件の有無については詳細を確認してください。 </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">非推奨:</a></b></dt><dd></dd></dl>
<p>セーブデータの更新をコミットします。</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>セーブデータをマウントするときに指定したマウント名</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000050">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>name がセーブデータをマウントするときに指定したマウント名である。</li>
<li>name マウント内のファイルが OpenMode_Write を含むモードで開かれていない。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 セーブデータへの更新内容をコミットします。<br />
 この関数を呼ばないままアンマウントしたり、プログラムが停止した場合、<br />
 セーブデータは前回コミットが成功した時点の内容に巻き戻ります。<br />
 この関数の実行中にプログラムが停止した場合のセーブデータの内容は、<br />
 「前回コミットが成功した時点の内容」か「全ての更新が反映された内容」のいずれかになり、<br />
 破損したり中途半端な内容になることはありません。<br />
 この関数は非推奨です。 <a class="el" href="namespacenn_1_1fs.html#ab534529ae3c325863fe1eb34bd03c872" title="ジャーナリング機能が有効なファイルシステムに対する更新内容をコミットします。 ">nn::fs::Commit()</a> を使用してください。 </p>

</div>
</div>
<a class="anchor" id="a196ef874060b922b93756ddff212fefa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountSdCardForDebug </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SD カードを扱うファイルシステムを指定したマウント名でマウントします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>マウント名</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000051">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="エラー Result (fs: マウント名が既に存在している) を表すクラスです。 ">ResultMountNameAlreadyExists</a></b> name で表されるファイルシステムが既に存在しています。 </p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>name が <a class="el" href="namespacenn_1_1fs.html#mount_name">有効なマウント名 </a> である。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 この API はデバッグ用途に限り使用可能です。<br />
 SD カードスロットが存在しない環境で呼び出した場合、代替領域がマウントされます。<br />
 詳細は NintendoSDK ドキュメントの <a href="../../Package/contents/Pages/Page_112886110.html">SD カード</a> を参照してください。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_fs_sd_card_for_debug_8cpp-example.html#a3">FsSdCardForDebug.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a28">MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a43">MoviePlayerSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8191828699cf3d29befe8dbd710db421"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountTemporaryStorage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>一時ストレージをマウントします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>マウント名</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000052">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>name が <a class="el" href="namespacenn_1_1fs.html#mount_name">有効なマウント名 </a> である。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 一時ストレージを利用するには事前の申請が必要です。<br />
 詳細は NintendoSDK ドキュメントの <a href="../../Package/contents/Pages/Page_224955140.html">一時ストレージ</a> を参照してください。 </p>

</div>
</div>
<a class="anchor" id="ab534529ae3c325863fe1eb34bd03c872"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::Commit </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ジャーナリング機能が有効なファイルシステムに対する更新内容をコミットします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>ファイルシステムをマウントするときに指定したマウント名</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000053">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>name がファイルシステムをマウントするときに指定したマウント名である。</li>
<li>name マウント内のファイルが OpenMode_Write を含むモードで開かれていない。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 マウント名で指定されたファイルシステムに対する更新内容をコミットします。<br />
 ジャーナリング機能が有効なファイルシステムに対してこの関数を呼ばないままアンマウントしたり、プログラムが停止した場合、<br />
 データの内容は前回コミットが成功した時点に巻き戻ります。<br />
 この関数の実行中にプログラムが停止した場合のデータの内容は、<br />
 「前回コミットが成功した時点の内容」か「全ての更新が反映された内容」のいずれかになり、<br />
 破損したり中途半端な内容になることはありません。<br />
 ジャーナリング機能が有効でないファイルシステムに対してこの関数を呼ぶ必要はありません。<br />
 各ファイルシステムにおいてジャーナリング機能が有効かどうかは NintendoSDK ドキュメントの各ファイルシステムの <a href="../../Package/contents/Pages/Page_107320200.html">機能説明</a> を参照してください。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_fs_save_data_8cpp-example.html#a27">FsSaveData.cpp</a>, <a class="el" href="_fs_save_data_for_debug_8cpp-example.html#a18">FsSaveDataForDebug.cpp</a>, <a class="el" href="_simple_8cpp-example.html#a15">Simple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af3735c46a459dbf4ba3d6de862b611d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::CreateCacheStorage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>cacheStorageSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>cacheStorageJournalSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>キャッシュストレージを作成します。 </p>
<p><b>詳細</b> <br />
 指定されたサイズのキャッシュストレージを作成します。<br />
 空き容量が不足している場合、システムが容量確保のためのUIやエラービューアを自動で表示します。<br />
 詳細は NintendoSDK ドキュメントの <a href="../../Package/contents/Pages/Page_276903214.html">インデックス付きキャッシュストレージ</a> を参照してください。<br />
 </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>キャッシュストレージのインデックス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cacheStorageSize</td><td>作成するキャッシュストレージのデータ保存領域のサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cacheStorageJournalSize</td><td>作成するキャッシュストレージのジャーナリング領域のサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>nmeta ファイルの NintendoSdkMeta/Application/CacheStorageDataAndJournalSizeMax にキャッシュストレージの最大サイズが記載されている</li>
<li>nmeta ファイルの NintendoSdkMeta/Application/CacheStorageIndexMax にインデックスの最大値が記載されている</li>
<li>cacheStorageSize + cacheStorageJournalSize &lt;= CacheStorageDataAndJournalSizeMax</li>
<li>index &lt;= CacheStorageIndexMax</li>
<li>同インデックスのキャッシュストレージが存在しない</li>
<li>同インデックスのキャッシュストレージをマウントしていない</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>データ保存領域 &gt;= cacheStorageSize かつ ジャーナリング領域 &gt;= cacheStorageJournalSize で指定したインデックスのキャッシュストレージが存在する</li>
</ul>
</dd></dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000054">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough_for_cache_storage.html" title="エラー Result (fs: キャッシュストレージを作成するための空き容量が不足) を表すクラスです。 ...">ResultUsableSpaceNotEnoughForCacheStorage</a></b> 空き容量が不足しています。 </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="af995ec08995ebe685afd6c13a648a692"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::GetCacheStorageSize </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outCacheStorageSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outCacheStorageJournalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定されたインデックスのキャッシュストレージのサイズを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outCacheStorageSize</td><td>キャッシュストレージのサイズ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outCacheStorageJournalSize</td><td>キャッシュストレージのジャーナリング領域のサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>サイズを取得したいキャッシュストレージのインデックス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>指定されたインデックスのキャッシュストレージが存在する</li>
</ul>
</dd></dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000055">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 </dd></dl>

</div>
</div>
<a class="anchor" id="adf2bd15a53fcc2a6c8895de9c264ab86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::DeleteCacheStorage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定されたインデックスのキャッシュストレージを削除します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>削除したいキャッシュストレージのインデックス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>指定されたインデックスのキャッシュストレージが存在する</li>
<li>指定されたインデックスのキャッシュストレージをマウントしていない</li>
</ul>
</dd></dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000056">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 </dd></dl>

</div>
</div>
<a class="anchor" id="adeabd5e452034e8f7db0d8580952a5dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::OpenCacheStorageList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_cache_storage_list_handle.html">CacheStorageListHandle</a> *&#160;</td>
          <td class="paramname"><em>outValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>キャッシュストレージリストをオープンします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>キャッシュストレージリストのハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>outValue が有効なメモリを指している。</li>
</ul>
</dd></dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000057">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 </dd></dl>

</div>
</div>
<a class="anchor" id="a4d272600ab91d4e735bbb40d8845e938"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::ReadCacheStorageList </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_cache_storage_info.html">CacheStorageInfo</a> *&#160;</td>
          <td class="paramname"><em>infoBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_cache_storage_list_handle.html">CacheStorageListHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>infoBufferCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>キャッシュストレージを列挙します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>キャッシュストレージの個数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infoBuffer</td><td><a class="el" href="structnn_1_1fs_1_1_cache_storage_info.html" title="キャッシュストレージの情報を表す構造体です。 ">CacheStorageInfo</a> の格納先バッファ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>キャッシュストレージリストのハンドル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infoBufferCount</td><td>infoBuffer の要素数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>infoBuffer の長さが infoBufferCount 以上である。</li>
<li>infoBufferCount &gt;= 0</li>
<li>handle が有効なハンドルである。</li>
<li>outValue が有効なメモリを指している。</li>
</ul>
</dd></dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000058">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 </dd></dl>

</div>
</div>
<a class="anchor" id="a92c1f6d8788be687eb914f53f723fba7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::fs::CloseCacheStorageList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_cache_storage_list_handle.html">CacheStorageListHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>キャッシュストレージリストをクローズします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>キャッシュストレージリストのハンドル</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 </p><dl class="retval"><dt><b><a class="el" href="retval.html#_retval000059">戻り値一覧:</a></b></dt><dd><b>なし</b> </dd></dl>

</div>
</div>
<a class="anchor" id="ae5f48fe542ce22263e1399e3b50190e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::EnsureSaveData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>セーブデータを作成します。 </p>
<p><b>詳細</b> <br />
 user に紐づくユーザーアカウントセーブデータ、およびアプリケーションに必要な他のセーブデータを作成します。<br />
 既にセーブデータが存在する場合、何もせず <a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a> を返します。<br />
 user 以外のユーザーアカウントに紐づくユーザーアカウントセーブデータは作成しません。<br />
 空き容量が不足している場合、システムが容量確保のためのUIやエラービューアを自動で表示します。<br />
 詳細は NintendoSDK ドキュメントの <a href="../../Package/contents/Pages/Page_107320205.html">セーブデータ</a> を参照してください。</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>対象のユーザーを指す Uid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000060">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough.html" title="エラー Result (fs: 空き容量が不足) を表すクラスです。 ">ResultUsableSpaceNotEnough</a></b> 空き容量が不足しています。</p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li><a class="el" href="namespacenn_1_1account.html#ac5870470963c9923c63f76e03c8c024e" title="アカウントシステムの利用を開始します。 ">nn::account::Initialize()</a> でアカウントシステムのライブラリが初期化済みである。</li>
<li>static_cast&lt;bool&gt;(user) == true</li>
<li>user が指すユーザーアカウントが存在する。 </li>
</ul>
</dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_account_application_8cpp-example.html#a9">AccountApplication.cpp</a>, <a class="el" href="_fs_save_data_8cpp-example.html#a10">FsSaveData.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="afdbda9f24e47b02bb74da4558bbd0760"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountSaveData </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユーザーを指定してセーブデータをマウントします。 </p>
<p><b>詳細</b> <br />
 指定したユーザーのセーブデータをマウント名 name でマウントします。</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>マウント名 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>対象のユーザーを指す Uid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000061">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="エラー Result (fs: 対象がロックされている) を表すクラスです。 ">ResultTargetLocked</a></b> セーブデータが使用中です。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="エラー Result (fs: マウント名が既に存在している) を表すクラスです。 ">ResultMountNameAlreadyExists</a></b> name で表されるファイルシステムが既に存在しています。</p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>name が <a class="el" href="namespacenn_1_1fs.html#mount_name">有効なマウント名 </a> である。</li>
<li><a class="el" href="namespacenn_1_1account.html#ac5870470963c9923c63f76e03c8c024e" title="アカウントシステムの利用を開始します。 ">nn::account::Initialize()</a> でアカウントシステムのライブラリが初期化済みである。</li>
<li>static_cast&lt;bool&gt;(user) == true</li>
<li>user が指すユーザーアカウントが存在する。</li>
<li>対象のセーブデータが存在する。</li>
<li>マウント済みのセーブデータの数が 9 個以下である。 </li>
</ul>
</dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_fs_save_data_8cpp-example.html#a12">FsSaveData.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="adf5b846d93790ec79b2d6fee53e97db9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountSaveDataReadOnly </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1_application_id.html">nn::ApplicationId</a>&#160;</td>
          <td class="paramname"><em>applicationId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユーザーを指定してアプリケーション ID に対応するアプリケーションのセーブデータを読み込み専用でマウントします。 </p>
<p><b>詳細</b> <br />
 指定したアプリケーション ID およびユーザーに対応するセーブデータをマウント名 name で読み込み専用としてマウントします。 マウントしたセーブデータに対して書き込み操作を行うと abort します。 書き込み可能な状態でマウントする必要がある場合は、任天堂の窓口までご相談ください。</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>マウント名 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">applicationId</td><td>対象のアプリケーション ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>対象のユーザーを指す Uid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000062">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="エラー Result (fs: 対象がロックされている) を表すクラスです。 ">ResultTargetLocked</a></b> セーブデータが使用中です。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_mount_name_already_exists.html" title="エラー Result (fs: マウント名が既に存在している) を表すクラスです。 ">ResultMountNameAlreadyExists</a></b> name で表されるファイルシステムが既に存在しています。</p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>name が <a class="el" href="namespacenn_1_1fs.html#mount_name">有効なマウント名 </a> である。</li>
<li><a class="el" href="namespacenn_1_1account.html#ac5870470963c9923c63f76e03c8c024e" title="アカウントシステムの利用を開始します。 ">nn::account::Initialize()</a> でアカウントシステムのライブラリが初期化済みである。</li>
<li>static_cast&lt;bool&gt;(user) == true</li>
<li>user が指すユーザーアカウントが存在する。</li>
<li>対象のセーブデータが存在する。</li>
<li>マウント済みのセーブデータの数が 9 個以下である。 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a7ed0c325479ee3b3fd508ed3696394f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::fs::IsSaveDataExisting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定したユーザーアカウントセーブデータが存在するかどうかを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>対象のユーザーを指す Uid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>存在すれば true が返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li><a class="el" href="namespacenn_1_1account.html#ac5870470963c9923c63f76e03c8c024e" title="アカウントシステムの利用を開始します。 ">nn::account::Initialize()</a> でアカウントシステムのライブラリが初期化済みである。</li>
<li>user が有効なユーザーアカウントである。 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a28b9a47a0c5c176a39f0cf240a91f31c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::fs::IsSaveDataExisting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1_application_id.html">nn::ApplicationId</a>&#160;</td>
          <td class="paramname"><em>applicationId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定したアプリケーション ID に対応するユーザーアカウントセーブデータが存在するかどうかを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">applicationId</td><td>対象のアプリケーション ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>対象のユーザーを指す Uid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>存在すれば true が返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li><a class="el" href="namespacenn_1_1account.html#ac5870470963c9923c63f76e03c8c024e" title="アカウントシステムの利用を開始します。 ">nn::account::Initialize()</a> でアカウントシステムのライブラリが初期化済みである。</li>
<li>user が有効なユーザーアカウントである。 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab83b2cf5e8413aa2833c8df5d2771bf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::ExtendSaveData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>saveDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>saveDataJournalSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>セーブデータを拡張します。 </p>
<p><b>詳細</b> <br />
 user に紐づくユーザーアカウントセーブデータのサイズを拡張します。<br />
 拡張の必要がない場合は何もせず <a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a> を返します。<br />
 空き容量が不足している場合、システムが容量確保のためのUIやエラービューアを自動で表示します。<br />
 詳細は NintendoSDK ドキュメントの <a href="../../Package/contents/Pages/Page_107320205.html">セーブデータ</a> を参照してください。</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>対象のユーザーを指す Uid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveDataSize</td><td>拡張後のセーブデータのデータ保存領域のサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveDataJournalSize</td><td>拡張後のセーブデータのジャーナリング領域のサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000063">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1fs_1_1_result_target_locked.html" title="エラー Result (fs: 対象がロックされている) を表すクラスです。 ">ResultTargetLocked</a></b> セーブデータが使用中です。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_usable_space_not_enough.html" title="エラー Result (fs: 空き容量が不足) を表すクラスです。 ">ResultUsableSpaceNotEnough</a></b> 空き容量が不足しています。</p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li><a class="el" href="namespacenn_1_1account.html#ac5870470963c9923c63f76e03c8c024e" title="アカウントシステムの利用を開始します。 ">nn::account::Initialize()</a> でアカウントシステムのライブラリが初期化済みである。</li>
<li>static_cast&lt;bool&gt;(user) == true</li>
<li>user が指すユーザーアカウントが存在する。</li>
<li>対象のセーブデータが存在する。</li>
<li>対象セーブデータがマウントされていない。</li>
<li>対象セーブデータが拡張回数限度に達していない。</li>
<li>saveDataSize, saveDataJournalSize がそれぞれメタデータで指定した拡張上限値以下である。</li>
<li>saveDataSize, saveDataJournalSize がそれぞれ <a class="el" href="namespacenn_1_1fs.html#aaec0be52744559b8df1c4e5289cc9d65" title="セーブデータ拡張で指定できる単位サイズです。 ">nn::fs::SaveDataExtensionUnitSize</a> の倍数である。 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a92a313238d8b1826e81fe12bad80f82f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::GetSaveDataSize </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outSaveDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outSaveDataJournalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1account_1_1_uid.html">nn::account::Uid</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>セーブデータの現在のサイズを取得します。 </p>
<p><b>詳細</b> <br />
 user に紐づくユーザーアカウントセーブデータのデータ保存領域およびジャーナリング領域のサイズを取得します。</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outSaveDataSize</td><td>セーブデータのデータ保存領域のサイズ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outSaveDataJournalSize</td><td>セーブデータのジャーナリング領域のサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>対象のユーザーを指す Uid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000064">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>outSaveDataSize が有効なメモリを指している。</li>
<li>outSaveDataJournalSize が有効なメモリを指している。</li>
<li><a class="el" href="namespacenn_1_1account.html#ac5870470963c9923c63f76e03c8c024e" title="アカウントシステムの利用を開始します。 ">nn::account::Initialize()</a> でアカウントシステムのライブラリが初期化済みである。</li>
<li>static_cast&lt;bool&gt;(user) == true</li>
<li>user が指すユーザーアカウントが存在する。</li>
<li>対象のセーブデータが存在する。 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a329828b4375a88fa6567f6a74f207fac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::GetFileTimeStampForDebug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1fs_1_1_file_time_stamp.html">FileTimeStamp</a> *&#160;</td>
          <td class="paramname"><em>outTimeStamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>対象のパスのファイルのタイムスタンプを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outTimeStamp</td><td>ファイルのタイムスタンプ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>タイムスタンプを取得したいパス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000065">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1fs_1_1_result_path_not_found.html" title="エラー Result (fs: 指定されたパスに対象が見つからない) を表すクラスです。 ">ResultPathNotFound</a></b> 対象のエントリが存在しません。</p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>outTimeStamp が有効なメモリを指している。</li>
<li>path が <a class="el" href="namespacenn_1_1fs.html#entry_path">有効なパス </a> である。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 この API はデバッグ用途に限り使用可能です。<br />
 </p><div id="dynsection-NX" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-NX-trigger" src="closed.png"/>
  <b>（NXプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-NX-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-NX-content" class="dyncontent" style="display:none;"> NX Addon 3.1.0 以降で、ホストファイルシステムで使用できます。<br />
 NX Addon 4.1.0 以降で、SDカードファイルシステムで使用できます。<br />
 各ファイルシステムの詳細は NintendoSDK ドキュメントの FS ライブラリ <a href="../../Package/contents/Pages/Page_107320200.html">機能説明</a> を参照してください。 </div> 
</div>
</div>
<a class="anchor" id="afcb1fa310028d36752df80ff69beec4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::QueryMountAddOnContentCacheSize </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1aoc.html#a034a2abde78298e64250210a18f400ba">nn::aoc::AddOnContentIndex</a>&#160;</td>
          <td class="paramname"><em>targetIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MountAddOnContent のファイルシステムキャッシュに必要なサイズを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutValue</td><td>ファイルシステムキャッシュに必要なサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetIndex</td><td>対象追加コンテンツの追加コンテンツインデックス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000354">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>pOutValue が有効なメモリを指している。</li>
<li>対象の追加コンテンツがインストール済みである。 </li>
</ul>
</dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_aoc_season_pass_delivery_8cpp-example.html#a6">AocSeasonPassDelivery.cpp</a>, <a class="el" href="_aoc_season_pass_sales_start_8cpp-example.html#a6">AocSeasonPassSalesStart.cpp</a>, <a class="el" href="_aoc_simple_8cpp-example.html#a5">AocSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad92caf5815857651653369e760f85a66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::fs::MountAddOnContent </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1aoc.html#a034a2abde78298e64250210a18f400ba">nn::aoc::AddOnContentIndex</a>&#160;</td>
          <td class="paramname"><em>targetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pFileSystemCacheBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fileSystemCacheBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>追加コンテンツを扱う読み込み専用のファイルシステムをマウントします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>マウント名 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetIndex</td><td>対象追加コンテンツの追加コンテンツインデックス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFileSystemCacheBuffer</td><td>ファイルシステムキャッシュのバッファ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileSystemCacheBufferSize</td><td>バッファのサイズ（必要なバッファサイズは <a class="el" href="namespacenn_1_1fs.html#afcb1fa310028d36752df80ff69beec4c" title="MountAddOnContent のファイルシステムキャッシュに必要なサイズを取得します。 ">QueryMountAddOnContentCacheSize(size_t* pOutValue, nn::aoc::AddOnContentIndex  targetIndex)</a> で取得できます）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000355">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>name が <a class="el" href="namespacenn_1_1fs.html#mount_name">有効なマウント名 </a> である。</li>
<li>pFileSystemCacheBuffer != nullptr</li>
<li>fileSystemCacheBufferSize が <a class="el" href="namespacenn_1_1fs.html#afcb1fa310028d36752df80ff69beec4c" title="MountAddOnContent のファイルシステムキャッシュに必要なサイズを取得します。 ">QueryMountAddOnContentCacheSize(size_t* pOutValue, nn::aoc::AddOnContentIndex  targetIndex)</a> で取得できるサイズ以上</li>
<li>対象の追加コンテンツがインストール済みである。</li>
<li>マウント済みの追加コンテンツの数が 127 個以下である。 </li>
</ul>
</dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_aoc_season_pass_delivery_8cpp-example.html#a9">AocSeasonPassDelivery.cpp</a>, <a class="el" href="_aoc_season_pass_sales_start_8cpp-example.html#a9">AocSeasonPassSalesStart.cpp</a>, <a class="el" href="_aoc_simple_8cpp-example.html#a9">AocSimple.cpp</a>.</dd>
</dl>
</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
