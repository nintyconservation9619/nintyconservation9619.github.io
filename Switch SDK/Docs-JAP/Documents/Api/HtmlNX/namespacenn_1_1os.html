<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>NintendoSDK API Reference: nn::os 名前空間</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>総合概要</span></a></li>
      <li><a href="pages.html"><span>諸情報</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li class="current"><a href="namespaces.html"><span>名前空間</span></a></li>
      <li><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>名前空間一覧</span></a></li>
      <li><a href="namespacemembers.html"><span>名前空間メンバ</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1os.html">os</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">クラス</a> &#124;
<a href="#typedef-members">型定義</a> &#124;
<a href="#enum-members">列挙型</a> &#124;
<a href="#var-members">変数</a>  </div>
  <div class="headertitle">
<div class="title">nn::os 名前空間</div>  </div>
</div><!--header-->
<div class="contents">

<p>オペレーティングシステムライブラリの名前空間です。  
<a href="#details">[詳解]</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
クラス</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_barrier.html">Barrier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">バリアを扱うためのクラスです。  <a href="classnn_1_1os_1_1_barrier.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_barrier_type.html">BarrierType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">バリアオブジェクトを定義する構造体です。  <a href="structnn_1_1os_1_1_barrier_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_condition_variable.html">ConditionVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">条件変数を扱うためのクラスです。  <a href="classnn_1_1os_1_1_condition_variable.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">条件変数オブジェクトを定義する構造体です。  <a href="structnn_1_1os_1_1_condition_variable_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_event.html">Event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">イベントを扱うためのクラスです。  <a href="classnn_1_1os_1_1_event.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">イベントオブジェクトを定義する構造体です。  <a href="structnn_1_1os_1_1_event_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイバオブジェクトを定義する構造体です。  <a href="structnn_1_1os_1_1_fiber_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_light_event.html">LightEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">軽量イベントを扱うためのクラスです。  <a href="classnn_1_1os_1_1_light_event.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">軽量イベントオブジェクトを定義する構造体です。  <a href="structnn_1_1os_1_1_light_event_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_memory_info.html">MemoryInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ情報などを取得した結果を格納する構造体です。  <a href="structnn_1_1os_1_1_memory_info.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_message_queue.html">MessageQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッセージキューを扱うためのクラスです。  <a href="classnn_1_1os_1_1_message_queue.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッセージキューオブジェクトを定義する構造体です。  <a href="structnn_1_1os_1_1_message_queue_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">多重待ちオブジェクトホルダーを定義する構造体です。  <a href="structnn_1_1os_1_1_multi_wait_holder_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">多重待ちオブジェクトのヘッダを定義する構造体です。  <a href="structnn_1_1os_1_1_multi_wait_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_mutex.html">Mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ミューテックスを扱うためのクラスです。  <a href="classnn_1_1os_1_1_mutex.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ミューテックスオブジェクトを定義する構造体です。  <a href="structnn_1_1os_1_1_mutex_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_reader_writer_lock.html">ReaderWriterLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Readers-Writer ロックを扱うためのクラスです。  <a href="classnn_1_1os_1_1_reader_writer_lock.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Readers-Writer ロックオブジェクトを定義する構造体です。  <a href="structnn_1_1os_1_1_reader_writer_lock_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_access_violation.html">ResultAccessViolation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (os: 不正アクセスを検出) を表すクラスです。  <a href="classnn_1_1os_1_1_result_access_violation.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_bad_request.html">ResultBadRequest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (os: 不正なリクエストコード) を表すクラスです。  <a href="classnn_1_1os_1_1_result_bad_request.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_busy.html">ResultBusy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (os: リソースが使用中) を表すクラスです。  <a href="classnn_1_1os_1_1_result_busy.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_deadlock.html">ResultDeadlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (os: デッドロック) を表すクラスです。  <a href="classnn_1_1os_1_1_result_deadlock.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_internal_error.html">ResultInternalError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (os: 内部エラー) を表すクラスです。  <a href="classnn_1_1os_1_1_result_internal_error.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_invalid_address.html">ResultInvalidAddress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (os: アドレスが不正) を表すクラスです。  <a href="classnn_1_1os_1_1_result_invalid_address.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_invalid_parameter.html">ResultInvalidParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (os: 引数（パラメータ）が無効) を表すクラスです。  <a href="classnn_1_1os_1_1_result_invalid_parameter.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_no_permission.html">ResultNoPermission</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (os: 許可されていない操作) を表すクラスです。  <a href="classnn_1_1os_1_1_result_no_permission.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_not_implemented.html">ResultNotImplemented</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (os: 関数が未実装) を表すクラスです。  <a href="classnn_1_1os_1_1_result_not_implemented.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_not_supported.html">ResultNotSupported</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (os: 未実装) を表すクラスです。  <a href="classnn_1_1os_1_1_result_not_supported.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_out_of_memory.html">ResultOutOfMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (os: 十分な空きメモリ領域がない) を表すクラスです。  <a href="classnn_1_1os_1_1_result_out_of_memory.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_out_of_resource.html">ResultOutOfResource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (os: 十分な空きリソースがない) を表すクラスです。  <a href="classnn_1_1os_1_1_result_out_of_resource.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_out_of_virtual_address_space.html">ResultOutOfVirtualAddressSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (os: 十分な仮想アドレス空間がない) を表すクラスです。  <a href="classnn_1_1os_1_1_result_out_of_virtual_address_space.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_overflow.html">ResultOverflow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (os: 最大値を超えた) を表すクラスです。  <a href="classnn_1_1os_1_1_result_overflow.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_resource_limit.html">ResultResourceLimit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (os: 使用リソースが上限に達した) を表すクラスです。  <a href="classnn_1_1os_1_1_result_resource_limit.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_result_timedout.html">ResultTimedout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (os: 操作がタイムアウトした) を表すクラスです。  <a href="classnn_1_1os_1_1_result_timedout.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_semaphore.html">Semaphore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">セマフォを扱うためのクラスです。  <a href="classnn_1_1os_1_1_semaphore.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">セマフォオブジェクトを定義する構造体です。  <a href="structnn_1_1os_1_1_semaphore_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_system_event.html">SystemEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">システムイベントを扱うためのクラスです。  <a href="classnn_1_1os_1_1_system_event.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">システムイベントオブジェクトを定義する構造体です。  <a href="structnn_1_1os_1_1_system_event_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_thread_local_storage.html">ThreadLocalStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッドローカルストレージを扱うためのクラスです。  <a href="classnn_1_1os_1_1_thread_local_storage.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッドオブジェクトを定義する構造体です。  <a href="structnn_1_1os_1_1_thread_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">システムチックを扱う為のクラスです。  <a href="classnn_1_1os_1_1_tick.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1os_1_1_timer_event.html">TimerEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">タイマーイベントを扱うためのクラスです。  <a href="classnn_1_1os_1_1_timer_event.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">タイマーイベントオブジェクトを定義する構造体です。  <a href="structnn_1_1os_1_1_timer_event_type.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_tls_slot.html">TlsSlot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TLS のスロット番号を表す型です。  <a href="structnn_1_1os_1_1_tls_slot.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_user_exception_info.html">UserExceptionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">例外情報を格納する構造体です。  <a href="structnn_1_1os_1_1_user_exception_info.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_user_exception_info_detail.html">UserExceptionInfoDetail</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">例外情報を格納する構造体です。  <a href="structnn_1_1os_1_1_user_exception_info_detail.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_user_exception_info_detail_aarch32_status32.html">UserExceptionInfoDetailAarch32Status32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ARMv7A 動作環境での例外情報の詳細を格納する構造体です。  <a href="structnn_1_1os_1_1_user_exception_info_detail_aarch32_status32.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_user_exception_info_detail_aarch32_status64.html">UserExceptionInfoDetailAarch32Status64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ARMv8A, AArch32 動作環境での例外情報の詳細を格納する構造体です。  <a href="structnn_1_1os_1_1_user_exception_info_detail_aarch32_status64.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_user_exception_info_detail_aarch64.html">UserExceptionInfoDetailAarch64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ARMv8A, AArch64 動作環境での例外情報の詳細を格納する構造体です。  <a href="structnn_1_1os_1_1_user_exception_info_detail_aarch64.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_user_exception_info_detail_win32.html">UserExceptionInfoDetailWin32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Windows 環境において例外情報の詳細を格納する構造体です。  <a href="structnn_1_1os_1_1_user_exception_info_detail_win32.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1os_1_1_virtual_address_memory_resource_usage.html">VirtualAddressMemoryResourceUsage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">仮想アドレスメモリ管理用のリソース消費量を格納する構造体です。  <a href="structnn_1_1os_1_1_virtual_address_memory_resource_usage.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
型定義</h2></td></tr>
<tr class="memitem:a00a0fffd9172c3779939c06927973bed"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a00a0fffd9172c3779939c06927973bed">FiberFunction</a>) (void *argument)</td></tr>
<tr class="memdesc:a00a0fffd9172c3779939c06927973bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイバ関数のエントリを表す型です。  <a href="#a00a0fffd9172c3779939c06927973bed">[詳解]</a><br /></td></tr>
<tr class="separator:a00a0fffd9172c3779939c06927973bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b48561ef817ac28bde556d321a382e"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a84b48561ef817ac28bde556d321a382e">NativeHandle</a></td></tr>
<tr class="memdesc:a84b48561ef817ac28bde556d321a382e"><td class="mdescLeft">&#160;</td><td class="mdescRight">システムが管理しているハンドルを表す型です。  <a href="#a84b48561ef817ac28bde556d321a382e">[詳解]</a><br /></td></tr>
<tr class="separator:a84b48561ef817ac28bde556d321a382e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec974a5d224f7c62cfa9af4af3c954a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abec974a5d224f7c62cfa9af4af3c954a"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#abec974a5d224f7c62cfa9af4af3c954a">ThreadFunction</a>) (void *)</td></tr>
<tr class="memdesc:abec974a5d224f7c62cfa9af4af3c954a"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッド関数のエントリを表す型です。 <br /></td></tr>
<tr class="separator:abec974a5d224f7c62cfa9af4af3c954a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af369e7c06c6548eebe7abda706ec54f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af369e7c06c6548eebe7abda706ec54f3"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#af369e7c06c6548eebe7abda706ec54f3">TlsDestructor</a>) (uintptr_t value)</td></tr>
<tr class="memdesc:af369e7c06c6548eebe7abda706ec54f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">TLS のデストラクタ関数を表す型です。 <br /></td></tr>
<tr class="separator:af369e7c06c6548eebe7abda706ec54f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff433bbe881d0fcb8fbb47fe3e299173"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aff433bbe881d0fcb8fbb47fe3e299173">UserExceptionHandler</a>) (<a class="el" href="structnn_1_1os_1_1_user_exception_info.html">UserExceptionInfo</a> *info)</td></tr>
<tr class="memdesc:aff433bbe881d0fcb8fbb47fe3e299173"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザ例外ハンドラの関数を表す型です。  <a href="#aff433bbe881d0fcb8fbb47fe3e299173">[詳解]</a><br /></td></tr>
<tr class="separator:aff433bbe881d0fcb8fbb47fe3e299173"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
列挙型</h2></td></tr>
<tr class="memitem:ae1fe4fe10826c19cf2c66e534962180a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae1fe4fe10826c19cf2c66e534962180a">ConditionVariableStatus</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#ae1fe4fe10826c19cf2c66e534962180aa4cad80372ca8b9c68ee8d1a34e806d24">ConditionVariableStatus_Timeout</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#ae1fe4fe10826c19cf2c66e534962180aa2f5f309e61d650e34b30f0308c17818c">ConditionVariableStatus_NoTimeout</a> = 1
<br />
 }<tr class="memdesc:ae1fe4fe10826c19cf2c66e534962180a"><td class="mdescLeft">&#160;</td><td class="mdescRight">時限付き条件変数待ち機能の返値を表す列挙型です。  <a href="namespacenn_1_1os.html#ae1fe4fe10826c19cf2c66e534962180a">[詳解]</a><br /></td></tr>
<tr class="separator:ae1fe4fe10826c19cf2c66e534962180a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a11ab71d44973a4135958c420e5682452"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">EventClearMode</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a8b702480f5120eeeb01e7102227285da">EventClearMode_ManualClear</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc">EventClearMode_AutoClear</a> = 1
<br />
 }<tr class="memdesc:a11ab71d44973a4135958c420e5682452"><td class="mdescLeft">&#160;</td><td class="mdescRight">イベントのクリアモードを表す列挙型です。  <a href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">[詳解]</a><br /></td></tr>
<tr class="separator:a11ab71d44973a4135958c420e5682452"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a39b515dc6753642a34364d91b5813104"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104">FiberFlag</a> { <a class="el" href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104ac2bbce12f37e3e01eb6a244e2ada14c7">FiberFlag_NoStackGuard</a> = 0x1
 }<tr class="memdesc:a39b515dc6753642a34364d91b5813104"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイバに付随するフラグを表す列挙型です。  <a href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104">[詳解]</a><br /></td></tr>
<tr class="separator:a39b515dc6753642a34364d91b5813104"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a883ab0b53c72a07619d9e83de4836b9a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9a">MemoryPermission</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9aaf6942de46447bc0df8294a749a329d08">MemoryPermission_None</a> = 0x0, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9aad0057f9250371335c5b9292ff44e1750">MemoryPermission_ReadOnly</a> = 0x1, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9aa699f0e08f6eddbe0264cf6664a2a1a4b">MemoryPermission_WriteOnly</a> = 0x2, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9aa57ead1592d9473ac1c22f0b4f75ed2c0">MemoryPermission_ReadWrite</a> = 0x3
<br />
 }<tr class="memdesc:a883ab0b53c72a07619d9e83de4836b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリアクセス権を表す列挙型です。  <a href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9a">[詳解]</a><br /></td></tr>
<tr class="separator:a883ab0b53c72a07619d9e83de4836b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a3271c9fc6c46cffdb076b966f15a80bc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bc">MessageQueueWaitType</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bca0fa8f18b62354b68a7838af2bf4e6f01">MessageQueueWaitType_WaitForNotFull</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bca40a79a4dabe0233dd5c21d7c4a718eea">MessageQueueWaitType_WaitForNotEmpty</a> = 2
<br />
 }<tr class="memdesc:a3271c9fc6c46cffdb076b966f15a80bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">多重待ちオブジェクトのメッセージキュー待ちタイプの列挙型です。  <a href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bc">[詳解]</a><br /></td></tr>
<tr class="separator:a3271c9fc6c46cffdb076b966f15a80bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a02aa5878802b6b43d6f12dacb05a5460"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a02aa5878802b6b43d6f12dacb05a5460">UserExceptionType</a> { , <br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a02aa5878802b6b43d6f12dacb05a5460ad563258d2c5fdbb3034dfab01d83759c">UserExceptionType_InvalidInstructionAccess</a> = 0x0100, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a02aa5878802b6b43d6f12dacb05a5460ac0086e1b87acfa1b2009247bc8fda2cb">UserExceptionType_InvalidDataAccess</a> = 0x0101, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a02aa5878802b6b43d6f12dacb05a5460ad8cd36398e52f181e3f42c17344b374d">UserExceptionType_UnalignedInstructionAccess</a> = 0x0102, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a02aa5878802b6b43d6f12dacb05a5460a422b59612c02820b465514da0cd55418">UserExceptionType_UnalignedDataAccess</a> = 0x0103, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a02aa5878802b6b43d6f12dacb05a5460acda61d04ba9081139baade0f28796133">UserExceptionType_UndefinedInstruction</a> = 0x0104, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a02aa5878802b6b43d6f12dacb05a5460af92e12c9f4fb7359a207ca3a800fd050">UserExceptionType_ExceptionalInstruction</a> = 0x0105, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a02aa5878802b6b43d6f12dacb05a5460af78513bf294c682e7096df4862c16d2e">UserExceptionType_MemorySystemError</a> = 0x0106, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a02aa5878802b6b43d6f12dacb05a5460a6bcda4d1a1563579a851bef2515b5bee">UserExceptionType_FloatingPointException</a> = 0x0200, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1os.html#a02aa5878802b6b43d6f12dacb05a5460af85b93bd5f06784cc5ed23911c288d69">UserExceptionType_InvalidSystemCall</a> = 0x0301
<br />
 }<tr class="memdesc:a02aa5878802b6b43d6f12dacb05a5460"><td class="mdescLeft">&#160;</td><td class="mdescRight">例外種別を定義した列挙体です。  <a href="namespacenn_1_1os.html#a02aa5878802b6b43d6f12dacb05a5460">[詳解]</a><br /></td></tr>
<tr class="separator:a02aa5878802b6b43d6f12dacb05a5460"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
関数</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">コマンドライン引数関連 API</div></td></tr>
<tr class="memitem:acf2fa6b7b7074a51d0b2de1664cc7bb5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#acf2fa6b7b7074a51d0b2de1664cc7bb5">GetHostArgc</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acf2fa6b7b7074a51d0b2de1664cc7bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ホスト指定のコマンドライン引数の数 (argc) を取得します。  <a href="#acf2fa6b7b7074a51d0b2de1664cc7bb5">[詳解]</a><br /></td></tr>
<tr class="separator:acf2fa6b7b7074a51d0b2de1664cc7bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd77e6bf19be140867869cc759fa492c"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#abd77e6bf19be140867869cc759fa492c">GetHostArgv</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abd77e6bf19be140867869cc759fa492c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ホスト指定のコマンドライン引数の文字列を指すポインタの配列 (argv) を取得します。  <a href="#abd77e6bf19be140867869cc759fa492c">[詳解]</a><br /></td></tr>
<tr class="separator:abd77e6bf19be140867869cc759fa492c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">バリア関連 API</div></td></tr>
<tr class="memitem:a063c2e1620b936cdc599de617a458516"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a063c2e1620b936cdc599de617a458516">InitializeBarrier</a> (<a class="el" href="structnn_1_1os_1_1_barrier_type.html">BarrierType</a> *barrier, int numThreads) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a063c2e1620b936cdc599de617a458516"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="バリアオブジェクトを定義する構造体です。 ">BarrierType</a> オブジェクトを初期化します。  <a href="#a063c2e1620b936cdc599de617a458516">[詳解]</a><br /></td></tr>
<tr class="separator:a063c2e1620b936cdc599de617a458516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062ceb897c5cd9b7bd4d779bf5e17c0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a062ceb897c5cd9b7bd4d779bf5e17c0b">FinalizeBarrier</a> (<a class="el" href="structnn_1_1os_1_1_barrier_type.html">BarrierType</a> *barrier) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a062ceb897c5cd9b7bd4d779bf5e17c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="バリアオブジェクトを定義する構造体です。 ">BarrierType</a> オブジェクトを Finalize します。  <a href="#a062ceb897c5cd9b7bd4d779bf5e17c0b">[詳解]</a><br /></td></tr>
<tr class="separator:a062ceb897c5cd9b7bd4d779bf5e17c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fc159f1fb100df1371bbaf63e1ba14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a41fc159f1fb100df1371bbaf63e1ba14">AwaitBarrier</a> (<a class="el" href="structnn_1_1os_1_1_barrier_type.html">BarrierType</a> *barrier) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a41fc159f1fb100df1371bbaf63e1ba14"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="バリアオブジェクトを定義する構造体です。 ">BarrierType</a> オブジェクトの待ち合わせを行ないます。  <a href="#a41fc159f1fb100df1371bbaf63e1ba14">[詳解]</a><br /></td></tr>
<tr class="separator:a41fc159f1fb100df1371bbaf63e1ba14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">キャッシュ操作関連 API</div></td></tr>
<tr class="memitem:a0fc3b750c03200539a98c98f7acca022"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a0fc3b750c03200539a98c98f7acca022">FlushDataCache</a> (const void *addr, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0fc3b750c03200539a98c98f7acca022"><td class="mdescLeft">&#160;</td><td class="mdescRight">データキャッシュをメモリに書き出したのち破棄します。  <a href="#a0fc3b750c03200539a98c98f7acca022">[詳解]</a><br /></td></tr>
<tr class="separator:a0fc3b750c03200539a98c98f7acca022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">条件変数関連 API</div></td></tr>
<tr class="memitem:a1ea1d7b36ec1844ed9e05729e832f6c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a1ea1d7b36ec1844ed9e05729e832f6c3">InitializeConditionVariable</a> (<a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *conditionVariable) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1ea1d7b36ec1844ed9e05729e832f6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html" title="条件変数オブジェクトを定義する構造体です。 ">ConditionVariableType</a> オブジェクトを初期化します。  <a href="#a1ea1d7b36ec1844ed9e05729e832f6c3">[詳解]</a><br /></td></tr>
<tr class="separator:a1ea1d7b36ec1844ed9e05729e832f6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817379cd29b11b49b185d0dc6afdc5c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a817379cd29b11b49b185d0dc6afdc5c6">FinalizeConditionVariable</a> (<a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *conditionVariable) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a817379cd29b11b49b185d0dc6afdc5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html" title="条件変数オブジェクトを定義する構造体です。 ">ConditionVariableType</a> オブジェクトを Finalize します。  <a href="#a817379cd29b11b49b185d0dc6afdc5c6">[詳解]</a><br /></td></tr>
<tr class="separator:a817379cd29b11b49b185d0dc6afdc5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae609d8150763b000d77f75d27fd44ac2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae609d8150763b000d77f75d27fd44ac2">SignalConditionVariable</a> (<a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *conditionVariable) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae609d8150763b000d77f75d27fd44ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html" title="条件変数オブジェクトを定義する構造体です。 ">ConditionVariableType</a> にシグナルを通知します。  <a href="#ae609d8150763b000d77f75d27fd44ac2">[詳解]</a><br /></td></tr>
<tr class="separator:ae609d8150763b000d77f75d27fd44ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1588e76fa05096006c0dcba27f9c95bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a1588e76fa05096006c0dcba27f9c95bf">BroadcastConditionVariable</a> (<a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *conditionVariable) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1588e76fa05096006c0dcba27f9c95bf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html" title="条件変数オブジェクトを定義する構造体です。 ">ConditionVariableType</a> にブロードキャスト通知を行ないます。  <a href="#a1588e76fa05096006c0dcba27f9c95bf">[詳解]</a><br /></td></tr>
<tr class="separator:a1588e76fa05096006c0dcba27f9c95bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a1e2e570d09ebd7cdbaa9da2d7b187"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a69a1e2e570d09ebd7cdbaa9da2d7b187">WaitConditionVariable</a> (<a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *conditionVariable, <a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *mutex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a69a1e2e570d09ebd7cdbaa9da2d7b187"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> のアンロックと条件変数の待機をアトミックに行ないます。  <a href="#a69a1e2e570d09ebd7cdbaa9da2d7b187">[詳解]</a><br /></td></tr>
<tr class="separator:a69a1e2e570d09ebd7cdbaa9da2d7b187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2643c34ccfd738890fdd0c546b61c7a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1os.html#ae1fe4fe10826c19cf2c66e534962180a">ConditionVariableStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a2643c34ccfd738890fdd0c546b61c7a8">TimedWaitConditionVariable</a> (<a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *conditionVariable, <a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *mutex, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2643c34ccfd738890fdd0c546b61c7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> のアンロックと条件変数の待機をアトミックに行ないます。  <a href="#a2643c34ccfd738890fdd0c546b61c7a8">[詳解]</a><br /></td></tr>
<tr class="separator:a2643c34ccfd738890fdd0c546b61c7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">OS ライブラリのデバッグ関連 API</div></td></tr>
<tr class="memitem:a036a9dca8974a28f03c6e8f3688efb12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a036a9dca8974a28f03c6e8f3688efb12">GetCurrentStackInfo</a> (uintptr_t *outStack, size_t *outStackSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a036a9dca8974a28f03c6e8f3688efb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">現在のコンテキストで使用中のスタック情報を取得します  <a href="#a036a9dca8974a28f03c6e8f3688efb12">[詳解]</a><br /></td></tr>
<tr class="separator:a036a9dca8974a28f03c6e8f3688efb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c8cba8c82b32e87d1d8521e4bef3dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a07c8cba8c82b32e87d1d8521e4bef3dd">GetCurrentStackInfoForDebug</a> (uintptr_t *outStack, size_t *outStackSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a07c8cba8c82b32e87d1d8521e4bef3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">本 API は deprecated されました。 <a class="el" href="namespacenn_1_1os.html#a036a9dca8974a28f03c6e8f3688efb12" title="現在のコンテキストで使用中のスタック情報を取得します ">GetCurrentStackInfo()</a> をご使用下さい。  <a href="#a07c8cba8c82b32e87d1d8521e4bef3dd">[詳解]</a><br /></td></tr>
<tr class="separator:a07c8cba8c82b32e87d1d8521e4bef3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f2a489da0a124ebdc8130595c70b94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a79f2a489da0a124ebdc8130595c70b94">QueryMemoryInfo</a> (<a class="el" href="structnn_1_1os_1_1_memory_info.html">MemoryInfo</a> *info) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a79f2a489da0a124ebdc8130595c70b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">自プログラムが現在使用しているメモリ使用量などの情報を取得します  <a href="#a79f2a489da0a124ebdc8130595c70b94">[詳解]</a><br /></td></tr>
<tr class="separator:a79f2a489da0a124ebdc8130595c70b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fc088880bfcf22817f53558a5a8ab7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae5fc088880bfcf22817f53558a5a8ab7">QueryMemoryInfoForDebug</a> (<a class="el" href="structnn_1_1os_1_1_memory_info.html">MemoryInfo</a> *info) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae5fc088880bfcf22817f53558a5a8ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">本 API は deprecated されました。 <a class="el" href="namespacenn_1_1os.html#a79f2a489da0a124ebdc8130595c70b94" title="自プログラムが現在使用しているメモリ使用量などの情報を取得します ">QueryMemoryInfo()</a> をご使用下さい。  <a href="#ae5fc088880bfcf22817f53558a5a8ab7">[詳解]</a><br /></td></tr>
<tr class="separator:ae5fc088880bfcf22817f53558a5a8ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cfc2e44df793d57fdd057a94578bf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a54cfc2e44df793d57fdd057a94578bf8">GetIdleTickCount</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a54cfc2e44df793d57fdd057a94578bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">自コアにおけるアイドル区間中の累積チックカウント値を取得します  <a href="#a54cfc2e44df793d57fdd057a94578bf8">[詳解]</a><br /></td></tr>
<tr class="separator:a54cfc2e44df793d57fdd057a94578bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">クラッシュレポートに含めるユーザー定義のデータに関する API</div></td></tr>
<tr class="memitem:a25125eea675c69bc6912e1140d4df148"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a25125eea675c69bc6912e1140d4df148">SetDyingMessageRegion</a> (uintptr_t address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a25125eea675c69bc6912e1140d4df148"><td class="mdescLeft">&#160;</td><td class="mdescRight">クラッシュレポートに含めるユーザー定義のデータ（ダイイング・メッセージ）を格納するメモリ領域を指定します。  <a href="#a25125eea675c69bc6912e1140d4df148">[詳解]</a><br /></td></tr>
<tr class="separator:a25125eea675c69bc6912e1140d4df148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">イベント関連 API</div></td></tr>
<tr class="memitem:af07abef747ac6b51112b9e800ba9632c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#af07abef747ac6b51112b9e800ba9632c">InitializeEvent</a> (<a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *event, bool initiallySignaled, <a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">EventClearMode</a> clearMode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af07abef747ac6b51112b9e800ba9632c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> オブジェクトを初期化します。  <a href="#af07abef747ac6b51112b9e800ba9632c">[詳解]</a><br /></td></tr>
<tr class="separator:af07abef747ac6b51112b9e800ba9632c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae3d14bd5e37dd1feee56bbf1717e37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#adae3d14bd5e37dd1feee56bbf1717e37">FinalizeEvent</a> (<a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adae3d14bd5e37dd1feee56bbf1717e37"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> オブジェクトを Finalize します。  <a href="#adae3d14bd5e37dd1feee56bbf1717e37">[詳解]</a><br /></td></tr>
<tr class="separator:adae3d14bd5e37dd1feee56bbf1717e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b959a51c1d28b76894597695fd3d081"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a9b959a51c1d28b76894597695fd3d081">SignalEvent</a> (<a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9b959a51c1d28b76894597695fd3d081"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> をシグナル状態にします。  <a href="#a9b959a51c1d28b76894597695fd3d081">[詳解]</a><br /></td></tr>
<tr class="separator:a9b959a51c1d28b76894597695fd3d081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdcb2de0b5dbdd64a0ec3d7e65c72f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aabdcb2de0b5dbdd64a0ec3d7e65c72f4">WaitEvent</a> (<a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aabdcb2de0b5dbdd64a0ec3d7e65c72f4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> がシグナル状態になるまで待機します。  <a href="#aabdcb2de0b5dbdd64a0ec3d7e65c72f4">[詳解]</a><br /></td></tr>
<tr class="separator:aabdcb2de0b5dbdd64a0ec3d7e65c72f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679439764fa7d9544094a0246ab6eebb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a679439764fa7d9544094a0246ab6eebb">TryWaitEvent</a> (<a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a679439764fa7d9544094a0246ab6eebb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> のシグナル状態をポーリングします。  <a href="#a679439764fa7d9544094a0246ab6eebb">[詳解]</a><br /></td></tr>
<tr class="separator:a679439764fa7d9544094a0246ab6eebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fba39baba3e475cae08127a632cab07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a9fba39baba3e475cae08127a632cab07">TimedWaitEvent</a> (<a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *event, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9fba39baba3e475cae08127a632cab07"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> がシグナル状態になるまで待機します。  <a href="#a9fba39baba3e475cae08127a632cab07">[詳解]</a><br /></td></tr>
<tr class="separator:a9fba39baba3e475cae08127a632cab07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46abbb4e59711874cfec72fe97b58e36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a46abbb4e59711874cfec72fe97b58e36">ClearEvent</a> (<a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a46abbb4e59711874cfec72fe97b58e36"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> をクリア状態にします。  <a href="#a46abbb4e59711874cfec72fe97b58e36">[詳解]</a><br /></td></tr>
<tr class="separator:a46abbb4e59711874cfec72fe97b58e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">多重待ち関連 API</div></td></tr>
<tr class="memitem:a4f8d998425d067cb5fec2604ae7845dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a4f8d998425d067cb5fec2604ae7845dc">InitializeMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder, <a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4f8d998425d067cb5fec2604ae7845dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWaitHolder を初期化し、event と関連付けます。  <a href="#a4f8d998425d067cb5fec2604ae7845dc">[詳解]</a><br /></td></tr>
<tr class="separator:a4f8d998425d067cb5fec2604ae7845dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4083f1b95f58372c092726cfd9800054"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a4083f1b95f58372c092726cfd9800054">InitializeMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder, <a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *timerEvent) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4083f1b95f58372c092726cfd9800054"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWaitHolder を初期化し、タイマーイベントと関連付けます。  <a href="#a4083f1b95f58372c092726cfd9800054">[詳解]</a><br /></td></tr>
<tr class="separator:a4083f1b95f58372c092726cfd9800054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b03654db54c77da2e8a8c185257d250"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a4b03654db54c77da2e8a8c185257d250">InitializeMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder, <a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4b03654db54c77da2e8a8c185257d250"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWaitHolder を初期化し <a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="システムイベントオブジェクトを定義する構造体です。 ">SystemEventType</a> オブジェクトと関連付けます。  <a href="#a4b03654db54c77da2e8a8c185257d250">[詳解]</a><br /></td></tr>
<tr class="separator:a4b03654db54c77da2e8a8c185257d250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241484ed12a060d60eeb234db88484d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a241484ed12a060d60eeb234db88484d0">InitializeMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder, <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, <a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bc">MessageQueueWaitType</a> waitType) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a241484ed12a060d60eeb234db88484d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWaitHolder を初期化し、messageQueue と関連付けます。  <a href="#a241484ed12a060d60eeb234db88484d0">[詳解]</a><br /></td></tr>
<tr class="separator:a241484ed12a060d60eeb234db88484d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e6662e7fdf9f78bcae79ba94d64a93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a48e6662e7fdf9f78bcae79ba94d64a93">InitializeMultiWait</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *multiWait) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a48e6662e7fdf9f78bcae79ba94d64a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWait オブジェクトヘッダを初期化します。  <a href="#a48e6662e7fdf9f78bcae79ba94d64a93">[詳解]</a><br /></td></tr>
<tr class="separator:a48e6662e7fdf9f78bcae79ba94d64a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60873f9b623e014948a9ea53a611da4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a60873f9b623e014948a9ea53a611da4c">FinalizeMultiWait</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *multiWait) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a60873f9b623e014948a9ea53a611da4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWait オブジェクトヘッダをファイナライズします。  <a href="#a60873f9b623e014948a9ea53a611da4c">[詳解]</a><br /></td></tr>
<tr class="separator:a60873f9b623e014948a9ea53a611da4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b837eb53fa2c8a9610cec2b69666fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd">WaitAny</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *multiWait) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab9b837eb53fa2c8a9610cec2b69666fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWait リスト内のいずれかの multiWaitHolder を待機します。  <a href="#ab9b837eb53fa2c8a9610cec2b69666fd">[詳解]</a><br /></td></tr>
<tr class="separator:ab9b837eb53fa2c8a9610cec2b69666fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add056696d279031175e9053145c82677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#add056696d279031175e9053145c82677">TryWaitAny</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *multiWait) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:add056696d279031175e9053145c82677"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWait リスト内のいずれかの multiWaitHolder をポーリングします。  <a href="#add056696d279031175e9053145c82677">[詳解]</a><br /></td></tr>
<tr class="separator:add056696d279031175e9053145c82677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a76f1be743cfc8791d2a139c7409470"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a6a76f1be743cfc8791d2a139c7409470">TimedWaitAny</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *multiWait, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6a76f1be743cfc8791d2a139c7409470"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWait リスト内のいずれかの multiWaitHolder を待機します。  <a href="#a6a76f1be743cfc8791d2a139c7409470">[詳解]</a><br /></td></tr>
<tr class="separator:a6a76f1be743cfc8791d2a139c7409470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de358e6bfa261b74c399b5b59c0da1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a2de358e6bfa261b74c399b5b59c0da1d">FinalizeMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2de358e6bfa261b74c399b5b59c0da1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWaitHolder オブジェクトをファイナライズします。  <a href="#a2de358e6bfa261b74c399b5b59c0da1d">[詳解]</a><br /></td></tr>
<tr class="separator:a2de358e6bfa261b74c399b5b59c0da1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd9b25e14bee063959eb9e7f62a4aa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a7cd9b25e14bee063959eb9e7f62a4aa8">LinkMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *multiWait, <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7cd9b25e14bee063959eb9e7f62a4aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWait ヘッダに多重待ちオブジェクト multiWaitHolder をリンクします。  <a href="#a7cd9b25e14bee063959eb9e7f62a4aa8">[詳解]</a><br /></td></tr>
<tr class="separator:a7cd9b25e14bee063959eb9e7f62a4aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c9c7bbc51249b69dc2361957fd650b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a07c9c7bbc51249b69dc2361957fd650b">UnlinkMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a07c9c7bbc51249b69dc2361957fd650b"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWait ヘッダから、多重待ちオブジェクト multiWaitHolder をアンリンクします。  <a href="#a07c9c7bbc51249b69dc2361957fd650b">[詳解]</a><br /></td></tr>
<tr class="separator:a07c9c7bbc51249b69dc2361957fd650b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdfded3152755dfd1fadb8eeea4565e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a7bdfded3152755dfd1fadb8eeea4565e">UnlinkAllMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *multiWait) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7bdfded3152755dfd1fadb8eeea4565e"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWait ヘッダにリンクされている全ての多重待ちオブジェクトホルダーをアンリンクします。  <a href="#a7bdfded3152755dfd1fadb8eeea4565e">[詳解]</a><br /></td></tr>
<tr class="separator:a7bdfded3152755dfd1fadb8eeea4565e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fb5f6b288f3b208f0d4750d0ba079d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ab8fb5f6b288f3b208f0d4750d0ba079d">MoveAllMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *dstMultiWait, <a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *srcMultiWait) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab8fb5f6b288f3b208f0d4750d0ba079d"><td class="mdescLeft">&#160;</td><td class="mdescRight">srcMultiWait ヘッダにリンクされている全ての多重待ちオブジェクトホルダーをアンリンクし dstMultiWait にリンクします。  <a href="#ab8fb5f6b288f3b208f0d4750d0ba079d">[詳解]</a><br /></td></tr>
<tr class="separator:ab8fb5f6b288f3b208f0d4750d0ba079d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05af1a7e142f1ece42a53fe41085f53b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a05af1a7e142f1ece42a53fe41085f53b">SetMultiWaitHolderUserData</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder, uintptr_t userData) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a05af1a7e142f1ece42a53fe41085f53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWaitHolder にユーザデータの値を設定します  <a href="#a05af1a7e142f1ece42a53fe41085f53b">[詳解]</a><br /></td></tr>
<tr class="separator:a05af1a7e142f1ece42a53fe41085f53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8c73312415fc00c72808fcc00fea33"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a9e8c73312415fc00c72808fcc00fea33">GetMultiWaitHolderUserData</a> (const <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9e8c73312415fc00c72808fcc00fea33"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWaitHolder に設定されているユーザデータ値を取得します  <a href="#a9e8c73312415fc00c72808fcc00fea33">[詳解]</a><br /></td></tr>
<tr class="separator:a9e8c73312415fc00c72808fcc00fea33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0b40464c9936df7d8cb77dadffcbd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a0e0b40464c9936df7d8cb77dadffcbd9">InitializeMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder, <a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *semaphore) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0e0b40464c9936df7d8cb77dadffcbd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWaitHolder を初期化し、semaphore と関連付けます。  <a href="#a0e0b40464c9936df7d8cb77dadffcbd9">[詳解]</a><br /></td></tr>
<tr class="separator:a0e0b40464c9936df7d8cb77dadffcbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d36b7ef64f2c1e82f03d895fdd5609"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a72d36b7ef64f2c1e82f03d895fdd5609">InitializeMultiWaitHolder</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *multiWaitHolder, <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a72d36b7ef64f2c1e82f03d895fdd5609"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWaitHolder を初期化し、thread と関連付けます。  <a href="#a72d36b7ef64f2c1e82f03d895fdd5609">[詳解]</a><br /></td></tr>
<tr class="separator:a72d36b7ef64f2c1e82f03d895fdd5609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">OS ライブラリのデバッグ関連 API（製品機では使用不可）</div></td></tr>
<tr class="memitem:a20238ce26424ba34876552fb2d53165a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a20238ce26424ba34876552fb2d53165a">IsMemoryLocked</a> (void *address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a20238ce26424ba34876552fb2d53165a"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたメモリ領域がロックされているかどうかを検査します。  <a href="#a20238ce26424ba34876552fb2d53165a">[詳解]</a><br /></td></tr>
<tr class="separator:a20238ce26424ba34876552fb2d53165a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2789b550619d98db2c52198839d35c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ac2789b550619d98db2c52198839d35c0">IsMemoryLocked</a> (uintptr_t address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac2789b550619d98db2c52198839d35c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたメモリ領域がロックされているかどうかを検査します。  <a href="#ac2789b550619d98db2c52198839d35c0">[詳解]</a><br /></td></tr>
<tr class="separator:ac2789b550619d98db2c52198839d35c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">軽量イベント関連 API</div></td></tr>
<tr class="memitem:af5900620f2a25ffdd500d7fbcba5fe26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#af5900620f2a25ffdd500d7fbcba5fe26">InitializeLightEvent</a> (<a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *event, bool initiallySignaled, <a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">EventClearMode</a> clearMode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af5900620f2a25ffdd500d7fbcba5fe26"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> オブジェクトを初期化します。  <a href="#af5900620f2a25ffdd500d7fbcba5fe26">[詳解]</a><br /></td></tr>
<tr class="separator:af5900620f2a25ffdd500d7fbcba5fe26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b4a0191e818ad124b28b818349f072"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a88b4a0191e818ad124b28b818349f072">FinalizeLightEvent</a> (<a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a88b4a0191e818ad124b28b818349f072"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> オブジェクトをファイナライズします。  <a href="#a88b4a0191e818ad124b28b818349f072">[詳解]</a><br /></td></tr>
<tr class="separator:a88b4a0191e818ad124b28b818349f072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e40a45392d6eb98e2ca635bc0c3506"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a07e40a45392d6eb98e2ca635bc0c3506">SignalLightEvent</a> (<a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a07e40a45392d6eb98e2ca635bc0c3506"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> をシグナル状態にセットします。  <a href="#a07e40a45392d6eb98e2ca635bc0c3506">[詳解]</a><br /></td></tr>
<tr class="separator:a07e40a45392d6eb98e2ca635bc0c3506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148036d27d59d8b674c3f1b7579aa5c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a148036d27d59d8b674c3f1b7579aa5c9">WaitLightEvent</a> (<a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a148036d27d59d8b674c3f1b7579aa5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> がシグナル状態になるまで待機します。  <a href="#a148036d27d59d8b674c3f1b7579aa5c9">[詳解]</a><br /></td></tr>
<tr class="separator:a148036d27d59d8b674c3f1b7579aa5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d2d9367d6312b284cd9e205a69adab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae1d2d9367d6312b284cd9e205a69adab">TryWaitLightEvent</a> (<a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae1d2d9367d6312b284cd9e205a69adab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> のシグナル状態をポーリングします。  <a href="#ae1d2d9367d6312b284cd9e205a69adab">[詳解]</a><br /></td></tr>
<tr class="separator:ae1d2d9367d6312b284cd9e205a69adab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aeea3ec3d35c57cd757b4a3d2ff7273"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a6aeea3ec3d35c57cd757b4a3d2ff7273">TimedWaitLightEvent</a> (<a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *event, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6aeea3ec3d35c57cd757b4a3d2ff7273"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> がシグナル状態になるまで時限付きで待機します。  <a href="#a6aeea3ec3d35c57cd757b4a3d2ff7273">[詳解]</a><br /></td></tr>
<tr class="separator:a6aeea3ec3d35c57cd757b4a3d2ff7273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab236036e46ae861732a4c6418b63ec01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ab236036e46ae861732a4c6418b63ec01">ClearLightEvent</a> (<a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab236036e46ae861732a4c6418b63ec01"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> をクリア状態にします。  <a href="#ab236036e46ae861732a4c6418b63ec01">[詳解]</a><br /></td></tr>
<tr class="separator:ab236036e46ae861732a4c6418b63ec01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ファイバ関連 API</div></td></tr>
<tr class="memitem:a9f0b5787e55da6b3b0e089d6b3ee6816"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a9f0b5787e55da6b3b0e089d6b3ee6816">InitializeFiber</a> (<a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a> *fiber, <a class="el" href="namespacenn_1_1os.html#a00a0fffd9172c3779939c06927973bed">FiberFunction</a> function, void *argument, void *stack, size_t stackSize, int fiberFlag) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9f0b5787e55da6b3b0e089d6b3ee6816"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイバオブジェクトを初期化します。  <a href="#a9f0b5787e55da6b3b0e089d6b3ee6816">[詳解]</a><br /></td></tr>
<tr class="separator:a9f0b5787e55da6b3b0e089d6b3ee6816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54bbd489d9e733f72e8555d7ff940cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#af54bbd489d9e733f72e8555d7ff940cf">FinalizeFiber</a> (<a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a> *fiber) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af54bbd489d9e733f72e8555d7ff940cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイバオブジェクトを破棄します。  <a href="#af54bbd489d9e733f72e8555d7ff940cf">[詳解]</a><br /></td></tr>
<tr class="separator:af54bbd489d9e733f72e8555d7ff940cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba39dbca8b416903a5e2947927ed3e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a3ba39dbca8b416903a5e2947927ed3e0">SwitchToFiber</a> (<a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a> *fiber) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3ba39dbca8b416903a5e2947927ed3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイバの実行を開始もしくは再開します。  <a href="#a3ba39dbca8b416903a5e2947927ed3e0">[詳解]</a><br /></td></tr>
<tr class="separator:a3ba39dbca8b416903a5e2947927ed3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bacafa4afccd548bb410d0f2fb3762e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a5bacafa4afccd548bb410d0f2fb3762e">GetCurrentFiber</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5bacafa4afccd548bb410d0f2fb3762e"><td class="mdescLeft">&#160;</td><td class="mdescRight">カレントファイバの <a class="el" href="structnn_1_1os_1_1_fiber_type.html" title="ファイバオブジェクトを定義する構造体です。 ">FiberType</a> オブジェクトを取得します。  <a href="#a5bacafa4afccd548bb410d0f2fb3762e">[詳解]</a><br /></td></tr>
<tr class="separator:a5bacafa4afccd548bb410d0f2fb3762e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">タイマーイベント関連 API</div></td></tr>
<tr class="memitem:a9fdcd9b26aa9e78c2c17f6b9c02c0314"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a9fdcd9b26aa9e78c2c17f6b9c02c0314">InitializeTimerEvent</a> (<a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *event, <a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">EventClearMode</a> clearMode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9fdcd9b26aa9e78c2c17f6b9c02c0314"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトを初期化します。  <a href="#a9fdcd9b26aa9e78c2c17f6b9c02c0314">[詳解]</a><br /></td></tr>
<tr class="separator:a9fdcd9b26aa9e78c2c17f6b9c02c0314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1752ba511e60ce027c4af0f6d5e3ebe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a1752ba511e60ce027c4af0f6d5e3ebe9">FinalizeTimerEvent</a> (<a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1752ba511e60ce027c4af0f6d5e3ebe9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトを破棄します。  <a href="#a1752ba511e60ce027c4af0f6d5e3ebe9">[詳解]</a><br /></td></tr>
<tr class="separator:a1752ba511e60ce027c4af0f6d5e3ebe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3ec8d6c3a7f4410dc6f9c4dec0f88d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a9b3ec8d6c3a7f4410dc6f9c4dec0f88d">StartOneShotTimerEvent</a> (<a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *event, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> first) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9b3ec8d6c3a7f4410dc6f9c4dec0f88d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトのワンショットタイマー動作を開始します。  <a href="#a9b3ec8d6c3a7f4410dc6f9c4dec0f88d">[詳解]</a><br /></td></tr>
<tr class="separator:a9b3ec8d6c3a7f4410dc6f9c4dec0f88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac869e53e9d805c3a5781d6493fad6ccd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ac869e53e9d805c3a5781d6493fad6ccd">StartPeriodicTimerEvent</a> (<a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *event, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> first, <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> interval) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac869e53e9d805c3a5781d6493fad6ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトの周期タイマー動作を開始します。  <a href="#ac869e53e9d805c3a5781d6493fad6ccd">[詳解]</a><br /></td></tr>
<tr class="separator:ac869e53e9d805c3a5781d6493fad6ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa23680b72e19fd5cb974ef44325695"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a6aa23680b72e19fd5cb974ef44325695">StopTimerEvent</a> (<a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6aa23680b72e19fd5cb974ef44325695"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトのタイマー動作を停止します。  <a href="#a6aa23680b72e19fd5cb974ef44325695">[詳解]</a><br /></td></tr>
<tr class="separator:a6aa23680b72e19fd5cb974ef44325695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdecafeed401cb6b8accdb15178ad66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a3bdecafeed401cb6b8accdb15178ad66">WaitTimerEvent</a> (<a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3bdecafeed401cb6b8accdb15178ad66"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトがシグナル状態になるまで待機します。  <a href="#a3bdecafeed401cb6b8accdb15178ad66">[詳解]</a><br /></td></tr>
<tr class="separator:a3bdecafeed401cb6b8accdb15178ad66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa431fe82cc23064bbad8cacf102756fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aa431fe82cc23064bbad8cacf102756fd">TryWaitTimerEvent</a> (<a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa431fe82cc23064bbad8cacf102756fd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトがシグナル状態かをポーリングします。  <a href="#aa431fe82cc23064bbad8cacf102756fd">[詳解]</a><br /></td></tr>
<tr class="separator:aa431fe82cc23064bbad8cacf102756fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad526c59d6481d5fcf0e130d71c7f1252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ad526c59d6481d5fcf0e130d71c7f1252">SignalTimerEvent</a> (<a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad526c59d6481d5fcf0e130d71c7f1252"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトを即座にシグナル状態にします。  <a href="#ad526c59d6481d5fcf0e130d71c7f1252">[詳解]</a><br /></td></tr>
<tr class="separator:ad526c59d6481d5fcf0e130d71c7f1252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2612c1c11f55172e23bf13d0b8a4e5b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a2612c1c11f55172e23bf13d0b8a4e5b2">ClearTimerEvent</a> (<a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2612c1c11f55172e23bf13d0b8a4e5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトを非シグナル状態にクリアします。  <a href="#a2612c1c11f55172e23bf13d0b8a4e5b2">[詳解]</a><br /></td></tr>
<tr class="separator:a2612c1c11f55172e23bf13d0b8a4e5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">システムイベント関連 API</div></td></tr>
<tr class="memitem:a3d924bc362ec80648323428be5182338"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a3d924bc362ec80648323428be5182338">DestroySystemEvent</a> (<a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3d924bc362ec80648323428be5182338"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="システムイベントオブジェクトを定義する構造体です。 ">SystemEventType</a> オブジェクトを破棄します。  <a href="#a3d924bc362ec80648323428be5182338">[詳解]</a><br /></td></tr>
<tr class="separator:a3d924bc362ec80648323428be5182338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa689721442ec303678047dd75c957bea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aa689721442ec303678047dd75c957bea">WaitSystemEvent</a> (<a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa689721442ec303678047dd75c957bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">システムイベントがシグナル状態になるまで待機します。  <a href="#aa689721442ec303678047dd75c957bea">[詳解]</a><br /></td></tr>
<tr class="separator:aa689721442ec303678047dd75c957bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0367a830f313d114698a17311e7274c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a0367a830f313d114698a17311e7274c5">TryWaitSystemEvent</a> (<a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0367a830f313d114698a17311e7274c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">システムイベントがシグナル状態かをポーリングします。  <a href="#a0367a830f313d114698a17311e7274c5">[詳解]</a><br /></td></tr>
<tr class="separator:a0367a830f313d114698a17311e7274c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25710360462b312201c3685e238f46e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#af25710360462b312201c3685e238f46e">TimedWaitSystemEvent</a> (<a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *event, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af25710360462b312201c3685e238f46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">システムイベントがシグナル状態になるまで待機します。  <a href="#af25710360462b312201c3685e238f46e">[詳解]</a><br /></td></tr>
<tr class="separator:af25710360462b312201c3685e238f46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70789090416cc882f4aa2c786092e49a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a70789090416cc882f4aa2c786092e49a">ClearSystemEvent</a> (<a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *event) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a70789090416cc882f4aa2c786092e49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">システムイベントを非シグナル状態にクリアします。  <a href="#a70789090416cc882f4aa2c786092e49a">[詳解]</a><br /></td></tr>
<tr class="separator:a70789090416cc882f4aa2c786092e49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">メッセージキュー関連 API</div></td></tr>
<tr class="memitem:ab7baa013ea5d9d4f9e84eb5d1afcec49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ab7baa013ea5d9d4f9e84eb5d1afcec49">InitializeMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, uintptr_t *buffer, size_t count) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab7baa013ea5d9d4f9e84eb5d1afcec49"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッセージキューオブジェクトを初期化します。  <a href="#ab7baa013ea5d9d4f9e84eb5d1afcec49">[詳解]</a><br /></td></tr>
<tr class="separator:ab7baa013ea5d9d4f9e84eb5d1afcec49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c98095075b7ef0570c1a449545e392"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#af9c98095075b7ef0570c1a449545e392">FinalizeMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af9c98095075b7ef0570c1a449545e392"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッセージキューオブジェクトをファイナライズします。  <a href="#af9c98095075b7ef0570c1a449545e392">[詳解]</a><br /></td></tr>
<tr class="separator:af9c98095075b7ef0570c1a449545e392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec9c0c3cacf43c7aa82f323da656af5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#afec9c0c3cacf43c7aa82f323da656af5">SendMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, uintptr_t data) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afec9c0c3cacf43c7aa82f323da656af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッセージキューの最後尾にデータを１つ送信します。  <a href="#afec9c0c3cacf43c7aa82f323da656af5">[詳解]</a><br /></td></tr>
<tr class="separator:afec9c0c3cacf43c7aa82f323da656af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cd82954aa87f10f881a7e34fad596b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a78cd82954aa87f10f881a7e34fad596b">TrySendMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, uintptr_t data) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a78cd82954aa87f10f881a7e34fad596b"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッセージキューの最後尾にデータを１つ送信します。  <a href="#a78cd82954aa87f10f881a7e34fad596b">[詳解]</a><br /></td></tr>
<tr class="separator:a78cd82954aa87f10f881a7e34fad596b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e14ae7d5a67147af209a1029991095"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ad5e14ae7d5a67147af209a1029991095">TimedSendMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, uintptr_t data, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad5e14ae7d5a67147af209a1029991095"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッセージキューの最後尾にデータを１つ送信します。  <a href="#ad5e14ae7d5a67147af209a1029991095">[詳解]</a><br /></td></tr>
<tr class="separator:ad5e14ae7d5a67147af209a1029991095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a47bc9d914dbdf48011deeb859cb877"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a7a47bc9d914dbdf48011deeb859cb877">JamMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, uintptr_t data) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7a47bc9d914dbdf48011deeb859cb877"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッセージキューの先頭にデータを１つ送信します。  <a href="#a7a47bc9d914dbdf48011deeb859cb877">[詳解]</a><br /></td></tr>
<tr class="separator:a7a47bc9d914dbdf48011deeb859cb877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fd916fb5a94b34c37d2b8faa43ce3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aa6fd916fb5a94b34c37d2b8faa43ce3c">TryJamMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, uintptr_t data) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa6fd916fb5a94b34c37d2b8faa43ce3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッセージキューの先頭にデータを１つ送信します。  <a href="#aa6fd916fb5a94b34c37d2b8faa43ce3c">[詳解]</a><br /></td></tr>
<tr class="separator:aa6fd916fb5a94b34c37d2b8faa43ce3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cfd66c4587832586ee7a50e5fd90b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ad4cfd66c4587832586ee7a50e5fd90b0">TimedJamMessageQueue</a> (<a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, uintptr_t data, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad4cfd66c4587832586ee7a50e5fd90b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッセージキューの先頭にデータを１つ送信します。  <a href="#ad4cfd66c4587832586ee7a50e5fd90b0">[詳解]</a><br /></td></tr>
<tr class="separator:ad4cfd66c4587832586ee7a50e5fd90b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7ad0de1da8fdeeeb01e7de7494dc87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ace7ad0de1da8fdeeeb01e7de7494dc87">ReceiveMessageQueue</a> (uintptr_t *outData, <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ace7ad0de1da8fdeeeb01e7de7494dc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッセージキューの先頭からデータを１つ受信します。  <a href="#ace7ad0de1da8fdeeeb01e7de7494dc87">[詳解]</a><br /></td></tr>
<tr class="separator:ace7ad0de1da8fdeeeb01e7de7494dc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921571e9781d3e6fbf60ca8ee4a1825d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a921571e9781d3e6fbf60ca8ee4a1825d">TryReceiveMessageQueue</a> (uintptr_t *outData, <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a921571e9781d3e6fbf60ca8ee4a1825d"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッセージキューの先頭からデータを１つ受信します。  <a href="#a921571e9781d3e6fbf60ca8ee4a1825d">[詳解]</a><br /></td></tr>
<tr class="separator:a921571e9781d3e6fbf60ca8ee4a1825d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0838f36e8391d50f81549950611aeb4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae0838f36e8391d50f81549950611aeb4">TimedReceiveMessageQueue</a> (uintptr_t *outData, <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae0838f36e8391d50f81549950611aeb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッセージキューの先頭からデータを１つ受信します。  <a href="#ae0838f36e8391d50f81549950611aeb4">[詳解]</a><br /></td></tr>
<tr class="separator:ae0838f36e8391d50f81549950611aeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fab6d997fb47451e6c9cd47ef754e99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a7fab6d997fb47451e6c9cd47ef754e99">PeekMessageQueue</a> (uintptr_t *outData, const <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7fab6d997fb47451e6c9cd47ef754e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッセージキューの先頭データを参照します。  <a href="#a7fab6d997fb47451e6c9cd47ef754e99">[詳解]</a><br /></td></tr>
<tr class="separator:a7fab6d997fb47451e6c9cd47ef754e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f08aef79a422888383a8ab1d5786fe3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a6f08aef79a422888383a8ab1d5786fe3">TryPeekMessageQueue</a> (uintptr_t *outData, const <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6f08aef79a422888383a8ab1d5786fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッセージキューの先頭データを参照します。  <a href="#a6f08aef79a422888383a8ab1d5786fe3">[詳解]</a><br /></td></tr>
<tr class="separator:a6f08aef79a422888383a8ab1d5786fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc5fb4ad2ef7a5dfff029e0128efa55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a0dc5fb4ad2ef7a5dfff029e0128efa55">TimedPeekMessageQueue</a> (uintptr_t *outData, const <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0dc5fb4ad2ef7a5dfff029e0128efa55"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッセージキューの先頭データを参照します。  <a href="#a0dc5fb4ad2ef7a5dfff029e0128efa55">[詳解]</a><br /></td></tr>
<tr class="separator:a0dc5fb4ad2ef7a5dfff029e0128efa55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">多重待ち関連ユーティリティ API</div></td></tr>
<tr class="memitem:a547f598078ce4b3fd6d25f8cf2339631"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a547f598078ce4b3fd6d25f8cf2339631"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a547f598078ce4b3fd6d25f8cf2339631">WaitAny</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *pMultiWait, Args &amp;&amp;...args) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a547f598078ce4b3fd6d25f8cf2339631"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWait リスト内のいずれかの multiWaitHolder または指定された複数の待機可能オブジェクトを待機します。  <a href="#a547f598078ce4b3fd6d25f8cf2339631">[詳解]</a><br /></td></tr>
<tr class="separator:a547f598078ce4b3fd6d25f8cf2339631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e2d082ce0e2cd4e8eac49ab5a8347d"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a13e2d082ce0e2cd4e8eac49ab5a8347d"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a13e2d082ce0e2cd4e8eac49ab5a8347d">WaitAny</a> (Args &amp;&amp;...args) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a13e2d082ce0e2cd4e8eac49ab5a8347d"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定された複数の待機可能オブジェクトを待機します。  <a href="#a13e2d082ce0e2cd4e8eac49ab5a8347d">[詳解]</a><br /></td></tr>
<tr class="separator:a13e2d082ce0e2cd4e8eac49ab5a8347d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5be969099705ab608e826ac52ed6d0"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a5d5be969099705ab608e826ac52ed6d0"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a5d5be969099705ab608e826ac52ed6d0">TryWaitAny</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *pMultiWait, Args &amp;&amp;...args) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5d5be969099705ab608e826ac52ed6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWait リスト内のいずれかの multiWaitHolder または指定された複数の待機可能オブジェクトをポーリングします。  <a href="#a5d5be969099705ab608e826ac52ed6d0">[詳解]</a><br /></td></tr>
<tr class="separator:a5d5be969099705ab608e826ac52ed6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d6121699d50103ea2cb44658122a08"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a76d6121699d50103ea2cb44658122a08"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a76d6121699d50103ea2cb44658122a08">TryWaitAny</a> (Args &amp;&amp;...args) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a76d6121699d50103ea2cb44658122a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定された複数の待機可能オブジェクトをポーリングします。  <a href="#a76d6121699d50103ea2cb44658122a08">[詳解]</a><br /></td></tr>
<tr class="separator:a76d6121699d50103ea2cb44658122a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f8a8f45f9e0a8ef118c9fcf81d1d15"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab3f8a8f45f9e0a8ef118c9fcf81d1d15"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ab3f8a8f45f9e0a8ef118c9fcf81d1d15">TimedWaitAny</a> (<a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *pMultiWait, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout, Args &amp;&amp;...args) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab3f8a8f45f9e0a8ef118c9fcf81d1d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiWait リスト内のいずれかの multiWaitHolder または指定された複数の待機可能オブジェクトをタイムアウト付きで待機します。  <a href="#ab3f8a8f45f9e0a8ef118c9fcf81d1d15">[詳解]</a><br /></td></tr>
<tr class="separator:ab3f8a8f45f9e0a8ef118c9fcf81d1d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7680123d43331cc6b512cfc4463e072b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7680123d43331cc6b512cfc4463e072b"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a7680123d43331cc6b512cfc4463e072b">TimedWaitAny</a> (<a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout, Args &amp;&amp;...args) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7680123d43331cc6b512cfc4463e072b"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定された複数の待機可能オブジェクトをタイムアウト付きで待機します。  <a href="#a7680123d43331cc6b512cfc4463e072b">[詳解]</a><br /></td></tr>
<tr class="separator:a7680123d43331cc6b512cfc4463e072b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a434b3b646d4fafdc951f63fa3a4689"><td class="memItemLeft" align="right" valign="top">detail::MessageQueueWaitMultiWaitHelper&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a0a434b3b646d4fafdc951f63fa3a4689">operator&amp;</a> (<a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *messageQueue, <a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bc">MessageQueueWaitType</a> waitType) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0a434b3b646d4fafdc951f63fa3a4689"><td class="mdescLeft">&#160;</td><td class="mdescRight">多重待ちユーティリティでメッセージキューを指定する際のユーティリティです。  <a href="#a0a434b3b646d4fafdc951f63fa3a4689">[詳解]</a><br /></td></tr>
<tr class="separator:a0a434b3b646d4fafdc951f63fa3a4689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ミューテックス関連 API</div></td></tr>
<tr class="memitem:a8d0a550df15490a884932a062dc26533"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8d0a550df15490a884932a062dc26533">InitializeMutex</a> (<a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *mutex, bool recursive, int lockLevel) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8d0a550df15490a884932a062dc26533"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> オブジェクトを初期化します。  <a href="#a8d0a550df15490a884932a062dc26533">[詳解]</a><br /></td></tr>
<tr class="separator:a8d0a550df15490a884932a062dc26533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce43d38754bf3049ab8d60b9d9e0046"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8ce43d38754bf3049ab8d60b9d9e0046">FinalizeMutex</a> (<a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *mutex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8ce43d38754bf3049ab8d60b9d9e0046"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> オブジェクトを Finalize します。  <a href="#a8ce43d38754bf3049ab8d60b9d9e0046">[詳解]</a><br /></td></tr>
<tr class="separator:a8ce43d38754bf3049ab8d60b9d9e0046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4678856d87c3faea21f47ced342bb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8d4678856d87c3faea21f47ced342bb6">LockMutex</a> (<a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *mutex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8d4678856d87c3faea21f47ced342bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> をロックします。  <a href="#a8d4678856d87c3faea21f47ced342bb6">[詳解]</a><br /></td></tr>
<tr class="separator:a8d4678856d87c3faea21f47ced342bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32963cc501eefcb10a0ebb993080b9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#af32963cc501eefcb10a0ebb993080b9f">TryLockMutex</a> (<a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *mutex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af32963cc501eefcb10a0ebb993080b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> がロック操作を試みます。  <a href="#af32963cc501eefcb10a0ebb993080b9f">[詳解]</a><br /></td></tr>
<tr class="separator:af32963cc501eefcb10a0ebb993080b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa661a7036a18c378a694ad67941cd75e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aa661a7036a18c378a694ad67941cd75e">UnlockMutex</a> (<a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *mutex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa661a7036a18c378a694ad67941cd75e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> をアンロックします。  <a href="#aa661a7036a18c378a694ad67941cd75e">[詳解]</a><br /></td></tr>
<tr class="separator:aa661a7036a18c378a694ad67941cd75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2107dd611741af2a44adf2dad29c74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a3a2107dd611741af2a44adf2dad29c74">IsMutexLockedByCurrentThread</a> (const <a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *mutex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3a2107dd611741af2a44adf2dad29c74"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> が自スレッドによってロックされているかを返します。  <a href="#a3a2107dd611741af2a44adf2dad29c74">[詳解]</a><br /></td></tr>
<tr class="separator:a3a2107dd611741af2a44adf2dad29c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">乱数生成</div></td></tr>
<tr class="memitem:a1771e01a3ebd2fb3dc464756f7208276"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a1771e01a3ebd2fb3dc464756f7208276">GenerateRandomBytes</a> (void *pOutBuffer, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1771e01a3ebd2fb3dc464756f7208276"><td class="mdescLeft">&#160;</td><td class="mdescRight">ランダムなバイト列を生成します  <a href="#a1771e01a3ebd2fb3dc464756f7208276">[詳解]</a><br /></td></tr>
<tr class="separator:a1771e01a3ebd2fb3dc464756f7208276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Readers-Writer ロック関連 API</div></td></tr>
<tr class="memitem:a659d0526afb3df351ed0a95ddc0776fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a659d0526afb3df351ed0a95ddc0776fa">InitializeReaderWriterLock</a> (<a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a659d0526afb3df351ed0a95ddc0776fa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="Readers-Writer ロックオブジェクトを定義する構造体です。 ">ReaderWriterLockType</a> オブジェクトを初期化します。  <a href="#a659d0526afb3df351ed0a95ddc0776fa">[詳解]</a><br /></td></tr>
<tr class="separator:a659d0526afb3df351ed0a95ddc0776fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b179b4351145d32ec583bc5a52452bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a6b179b4351145d32ec583bc5a52452bb">FinalizeReaderWriterLock</a> (<a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6b179b4351145d32ec583bc5a52452bb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="Readers-Writer ロックオブジェクトを定義する構造体です。 ">ReaderWriterLockType</a> オブジェクトを破棄します。  <a href="#a6b179b4351145d32ec583bc5a52452bb">[詳解]</a><br /></td></tr>
<tr class="separator:a6b179b4351145d32ec583bc5a52452bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa888b2694902212ebc056ccaa4354b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a6fa888b2694902212ebc056ccaa4354b">AcquireReadLock</a> (<a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6fa888b2694902212ebc056ccaa4354b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Readers ロックを取得します。  <a href="#a6fa888b2694902212ebc056ccaa4354b">[詳解]</a><br /></td></tr>
<tr class="separator:a6fa888b2694902212ebc056ccaa4354b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ce54963ebf2636dd1c78a0d16125a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ac0ce54963ebf2636dd1c78a0d16125a8">TryAcquireReadLock</a> (<a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac0ce54963ebf2636dd1c78a0d16125a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Readers ロックの取得を試みます。  <a href="#ac0ce54963ebf2636dd1c78a0d16125a8">[詳解]</a><br /></td></tr>
<tr class="separator:ac0ce54963ebf2636dd1c78a0d16125a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8f51bbfa3341c9678758b191896a05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a4d8f51bbfa3341c9678758b191896a05">ReleaseReadLock</a> (<a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4d8f51bbfa3341c9678758b191896a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Readers ロックを 1 つだけ解放します。  <a href="#a4d8f51bbfa3341c9678758b191896a05">[詳解]</a><br /></td></tr>
<tr class="separator:a4d8f51bbfa3341c9678758b191896a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d3e3f946b214bcbf85e4aebb61699f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a97d3e3f946b214bcbf85e4aebb61699f">AcquireWriteLock</a> (<a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a97d3e3f946b214bcbf85e4aebb61699f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writer ロックを取得します。  <a href="#a97d3e3f946b214bcbf85e4aebb61699f">[詳解]</a><br /></td></tr>
<tr class="separator:a97d3e3f946b214bcbf85e4aebb61699f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad042341aecc3ba00473ab85466fa76a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ad042341aecc3ba00473ab85466fa76a8">TryAcquireWriteLock</a> (<a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad042341aecc3ba00473ab85466fa76a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writer ロックの取得を試みます。  <a href="#ad042341aecc3ba00473ab85466fa76a8">[詳解]</a><br /></td></tr>
<tr class="separator:ad042341aecc3ba00473ab85466fa76a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30220320ff7ba5af52183fd5fbe1312"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae30220320ff7ba5af52183fd5fbe1312">ReleaseWriteLock</a> (<a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae30220320ff7ba5af52183fd5fbe1312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writer ロックを 1 つだけ解放します。  <a href="#ae30220320ff7ba5af52183fd5fbe1312">[詳解]</a><br /></td></tr>
<tr class="separator:ae30220320ff7ba5af52183fd5fbe1312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434e0c862bf65234e1eee8756edbabf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a434e0c862bf65234e1eee8756edbabf4">IsReadLockHeld</a> (const <a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a434e0c862bf65234e1eee8756edbabf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">いずれかのスレッドで Readers ロックが取得済みか否かを返します。  <a href="#a434e0c862bf65234e1eee8756edbabf4">[詳解]</a><br /></td></tr>
<tr class="separator:a434e0c862bf65234e1eee8756edbabf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6658b045d8ca185b5108ddb802f2440e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a6658b045d8ca185b5108ddb802f2440e">IsWriteLockHeldByCurrentThread</a> (const <a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6658b045d8ca185b5108ddb802f2440e"><td class="mdescLeft">&#160;</td><td class="mdescRight">自スレッドで Writer ロックを取得済みか否かを返します。  <a href="#a6658b045d8ca185b5108ddb802f2440e">[詳解]</a><br /></td></tr>
<tr class="separator:a6658b045d8ca185b5108ddb802f2440e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3bf890340f587ab633cd1804a93e0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ace3bf890340f587ab633cd1804a93e0b">IsReaderWriterLockOwnerThread</a> (const <a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *rwlock) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ace3bf890340f587ab633cd1804a93e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">自スレッドがロックオーナーか否かを返します。  <a href="#ace3bf890340f587ab633cd1804a93e0b">[詳解]</a><br /></td></tr>
<tr class="separator:ace3bf890340f587ab633cd1804a93e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">セマフォ関連 API</div></td></tr>
<tr class="memitem:af76bc96a9333f18ed5d7bead209eb4f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#af76bc96a9333f18ed5d7bead209eb4f3">InitializeSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *semaphore, int initialCount, int maxCount) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af76bc96a9333f18ed5d7bead209eb4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> オブジェクトを初期化します。  <a href="#af76bc96a9333f18ed5d7bead209eb4f3">[詳解]</a><br /></td></tr>
<tr class="separator:af76bc96a9333f18ed5d7bead209eb4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201a00464d5606e40bef1798cba2ace8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a201a00464d5606e40bef1798cba2ace8">FinalizeSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *semaphore) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a201a00464d5606e40bef1798cba2ace8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> オブジェクトをファイナライズします。  <a href="#a201a00464d5606e40bef1798cba2ace8">[詳解]</a><br /></td></tr>
<tr class="separator:a201a00464d5606e40bef1798cba2ace8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e1d42bdb0279e887dc1caef45fcff1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ac9e1d42bdb0279e887dc1caef45fcff1">AcquireSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *semaphore) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac9e1d42bdb0279e887dc1caef45fcff1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> を獲得します（Ｐ操作）  <a href="#ac9e1d42bdb0279e887dc1caef45fcff1">[詳解]</a><br /></td></tr>
<tr class="separator:ac9e1d42bdb0279e887dc1caef45fcff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fa41594b3b3072d78735f366bdb7ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#af5fa41594b3b3072d78735f366bdb7ce">TryAcquireSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *semaphore) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af5fa41594b3b3072d78735f366bdb7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> の獲得を試みます（Ｐ操作）  <a href="#af5fa41594b3b3072d78735f366bdb7ce">[詳解]</a><br /></td></tr>
<tr class="separator:af5fa41594b3b3072d78735f366bdb7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c8209e58cabbf5ab5173867dcad732"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a54c8209e58cabbf5ab5173867dcad732">TimedAcquireSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *semaphore, <a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> timeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a54c8209e58cabbf5ab5173867dcad732"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> を時限付きで獲得を試みます（Ｐ操作）  <a href="#a54c8209e58cabbf5ab5173867dcad732">[詳解]</a><br /></td></tr>
<tr class="separator:a54c8209e58cabbf5ab5173867dcad732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2cbceb4266858d27387ff2cb29a5ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#acf2cbceb4266858d27387ff2cb29a5ae">ReleaseSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *semaphore) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acf2cbceb4266858d27387ff2cb29a5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> を１カウントだけ返却します（Ｖ操作）  <a href="#acf2cbceb4266858d27387ff2cb29a5ae">[詳解]</a><br /></td></tr>
<tr class="separator:acf2cbceb4266858d27387ff2cb29a5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40039d059051bc9970e072417ac9576d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a40039d059051bc9970e072417ac9576d">ReleaseSemaphore</a> (<a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *semaphore, int count) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a40039d059051bc9970e072417ac9576d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> を複数カウント返却します（Ｖ操作）  <a href="#a40039d059051bc9970e072417ac9576d">[詳解]</a><br /></td></tr>
<tr class="separator:a40039d059051bc9970e072417ac9576d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a315a7f4822cee3e62e9912737edfa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aa6a315a7f4822cee3e62e9912737edfa">GetCurrentSemaphoreCount</a> (const <a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *semaphore) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa6a315a7f4822cee3e62e9912737edfa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> の現在のカウンタ値を返します  <a href="#aa6a315a7f4822cee3e62e9912737edfa">[詳解]</a><br /></td></tr>
<tr class="separator:aa6a315a7f4822cee3e62e9912737edfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">スレッド関連 API</div></td></tr>
<tr class="memitem:a75f43e1d3c194c0d2173ef5d95785933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a75f43e1d3c194c0d2173ef5d95785933">CreateThread</a> (<a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread, <a class="el" href="namespacenn_1_1os.html#abec974a5d224f7c62cfa9af4af3c954a">ThreadFunction</a> function, void *argument, void *stack, size_t stackSize, int priority, int idealCoreNumber) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a75f43e1d3c194c0d2173ef5d95785933"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッドを生成します。  <a href="#a75f43e1d3c194c0d2173ef5d95785933">[詳解]</a><br /></td></tr>
<tr class="separator:a75f43e1d3c194c0d2173ef5d95785933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7db66d31e254873b613d4eadd0d716"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a1e7db66d31e254873b613d4eadd0d716">CreateThread</a> (<a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread, <a class="el" href="namespacenn_1_1os.html#abec974a5d224f7c62cfa9af4af3c954a">ThreadFunction</a> function, void *argument, void *stack, size_t stackSize, int priority) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1e7db66d31e254873b613d4eadd0d716"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッドを生成します。  <a href="#a1e7db66d31e254873b613d4eadd0d716">[詳解]</a><br /></td></tr>
<tr class="separator:a1e7db66d31e254873b613d4eadd0d716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbfcfb82583a9e34431e8c11d2411dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a9dbfcfb82583a9e34431e8c11d2411dd">DestroyThread</a> (<a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9dbfcfb82583a9e34431e8c11d2411dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッドを削除します。  <a href="#a9dbfcfb82583a9e34431e8c11d2411dd">[詳解]</a><br /></td></tr>
<tr class="separator:a9dbfcfb82583a9e34431e8c11d2411dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18eec7c4c4c298f7abaa9ef41d6de76b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a18eec7c4c4c298f7abaa9ef41d6de76b">StartThread</a> (<a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a18eec7c4c4c298f7abaa9ef41d6de76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッドの実行を開始します。  <a href="#a18eec7c4c4c298f7abaa9ef41d6de76b">[詳解]</a><br /></td></tr>
<tr class="separator:a18eec7c4c4c298f7abaa9ef41d6de76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad106866a5b13bc3d430104333966b479"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ad106866a5b13bc3d430104333966b479">GetCurrentThread</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad106866a5b13bc3d430104333966b479"><td class="mdescLeft">&#160;</td><td class="mdescRight">自スレッドの <a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトを取得します。  <a href="#ad106866a5b13bc3d430104333966b479">[詳解]</a><br /></td></tr>
<tr class="separator:ad106866a5b13bc3d430104333966b479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8070c91be85c5ccb36b56e9ff3a75b26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8070c91be85c5ccb36b56e9ff3a75b26">WaitThread</a> (<a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8070c91be85c5ccb36b56e9ff3a75b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">対象スレッドが終了するのを待ちます。  <a href="#a8070c91be85c5ccb36b56e9ff3a75b26">[詳解]</a><br /></td></tr>
<tr class="separator:a8070c91be85c5ccb36b56e9ff3a75b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd5e5e72c058eb7d1b5f0ebfbb2cf6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8bd5e5e72c058eb7d1b5f0ebfbb2cf6f">YieldThread</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8bd5e5e72c058eb7d1b5f0ebfbb2cf6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">同一優先度の他のスレッドに実行機会を譲ります。  <a href="#a8bd5e5e72c058eb7d1b5f0ebfbb2cf6f">[詳解]</a><br /></td></tr>
<tr class="separator:a8bd5e5e72c058eb7d1b5f0ebfbb2cf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b335e87af44c60a0d6dca75f11c9d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a96b335e87af44c60a0d6dca75f11c9d2">SleepThread</a> (<a class="el" href="classnn_1_1_time_span.html">TimeSpan</a> time) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a96b335e87af44c60a0d6dca75f11c9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">自スレッドを指定された時間だけ休止します。  <a href="#a96b335e87af44c60a0d6dca75f11c9d2">[詳解]</a><br /></td></tr>
<tr class="separator:a96b335e87af44c60a0d6dca75f11c9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7eb0e6eae11777e92308cdee62e6cb2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ac7eb0e6eae11777e92308cdee62e6cb2">ChangeThreadPriority</a> (<a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread, int priority) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac7eb0e6eae11777e92308cdee62e6cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">対象スレッドの優先度を変更します。  <a href="#ac7eb0e6eae11777e92308cdee62e6cb2">[詳解]</a><br /></td></tr>
<tr class="separator:ac7eb0e6eae11777e92308cdee62e6cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912a6d5e17c206344f177bc192cb1e50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a912a6d5e17c206344f177bc192cb1e50">GetThreadPriority</a> (const <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a912a6d5e17c206344f177bc192cb1e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">対象スレッドの本来の優先度を取得します。  <a href="#a912a6d5e17c206344f177bc192cb1e50">[詳解]</a><br /></td></tr>
<tr class="separator:a912a6d5e17c206344f177bc192cb1e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6b2e5e1968e008dde27d6c4762b33d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a9b6b2e5e1968e008dde27d6c4762b33d">GetThreadCurrentPriority</a> (const <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9b6b2e5e1968e008dde27d6c4762b33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">対象スレッドの現在の優先度を取得します。  <a href="#a9b6b2e5e1968e008dde27d6c4762b33d">[詳解]</a><br /></td></tr>
<tr class="separator:a9b6b2e5e1968e008dde27d6c4762b33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cbcb85bd308694ec37eff49be93cf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a05cbcb85bd308694ec37eff49be93cf1">SetThreadName</a> (<a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread, const char *threadName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a05cbcb85bd308694ec37eff49be93cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">対象スレッドのスレッド名を設定します。  <a href="#a05cbcb85bd308694ec37eff49be93cf1">[詳解]</a><br /></td></tr>
<tr class="separator:a05cbcb85bd308694ec37eff49be93cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f2d7d33024e710d09a2b6d01b15522"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a90f2d7d33024e710d09a2b6d01b15522">SetThreadNamePointer</a> (<a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread, const char *threadName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a90f2d7d33024e710d09a2b6d01b15522"><td class="mdescLeft">&#160;</td><td class="mdescRight">対象スレッドのスレッド名が格納されているアドレスを設定します。  <a href="#a90f2d7d33024e710d09a2b6d01b15522">[詳解]</a><br /></td></tr>
<tr class="separator:a90f2d7d33024e710d09a2b6d01b15522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2941b0122ed1f1af2d7007af285d83b5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a2941b0122ed1f1af2d7007af285d83b5">GetThreadNamePointer</a> (const <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2941b0122ed1f1af2d7007af285d83b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">対象スレッドのスレッド名が格納されているアドレスを取得します。  <a href="#a2941b0122ed1f1af2d7007af285d83b5">[詳解]</a><br /></td></tr>
<tr class="separator:a2941b0122ed1f1af2d7007af285d83b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500af81132a0e2b26db7289bbd19942e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a500af81132a0e2b26db7289bbd19942e">GetCurrentProcessorNumber</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a500af81132a0e2b26db7289bbd19942e"><td class="mdescLeft">&#160;</td><td class="mdescRight">現在自スレッドが動作しているコア番号を取得します。  <a href="#a500af81132a0e2b26db7289bbd19942e">[詳解]</a><br /></td></tr>
<tr class="separator:a500af81132a0e2b26db7289bbd19942e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b94c321b41c4fb4d0a4e87473297c48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a4b94c321b41c4fb4d0a4e87473297c48">GetCurrentCoreNumber</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4b94c321b41c4fb4d0a4e87473297c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">現在自スレッドが動作しているコア番号を取得します。  <a href="#a4b94c321b41c4fb4d0a4e87473297c48">[詳解]</a><br /></td></tr>
<tr class="separator:a4b94c321b41c4fb4d0a4e87473297c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50b86561c15ee3e8195c83fddc8e732"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ac50b86561c15ee3e8195c83fddc8e732">SetThreadCoreMask</a> (<a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread, int idealCore, Bit64 affinityMask) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac50b86561c15ee3e8195c83fddc8e732"><td class="mdescLeft">&#160;</td><td class="mdescRight">対象のスレッドのコア割り当てを設定します。  <a href="#ac50b86561c15ee3e8195c83fddc8e732">[詳解]</a><br /></td></tr>
<tr class="separator:ac50b86561c15ee3e8195c83fddc8e732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39edb8f3e676c4bab13047a5ad1894f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a39edb8f3e676c4bab13047a5ad1894f8">GetThreadCoreMask</a> (int *pOutIdealCore, Bit64 *pOutAffinityMask, const <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a39edb8f3e676c4bab13047a5ad1894f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">対象のスレッドのコア割り当てを取得します。  <a href="#a39edb8f3e676c4bab13047a5ad1894f8">[詳解]</a><br /></td></tr>
<tr class="separator:a39edb8f3e676c4bab13047a5ad1894f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91345e6e4543ab561f49480b89ae9a65"><td class="memItemLeft" align="right" valign="top">nn::Bit64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a91345e6e4543ab561f49480b89ae9a65">GetThreadAvailableCoreMask</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a91345e6e4543ab561f49480b89ae9a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">割り当て可能なコアを取得します。  <a href="#a91345e6e4543ab561f49480b89ae9a65">[詳解]</a><br /></td></tr>
<tr class="separator:a91345e6e4543ab561f49480b89ae9a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcae078c4e6e1d1746ff8bd0eb7f7d85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcae078c4e6e1d1746ff8bd0eb7f7d85"></a>
ThreadId&#160;</td><td class="memItemRight" valign="bottom"><b>GetThreadId</b> (const <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *thread) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="separator:adcae078c4e6e1d1746ff8bd0eb7f7d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">スレッド固有領域関連 API</div></td></tr>
<tr class="memitem:a2a67ebeb78e5d624b45ec27d66bdf0b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a2a67ebeb78e5d624b45ec27d66bdf0b2">AllocateTlsSlot</a> (<a class="el" href="structnn_1_1os_1_1_tls_slot.html">TlsSlot</a> *outTlsSlot, <a class="el" href="namespacenn_1_1os.html#af369e7c06c6548eebe7abda706ec54f3">TlsDestructor</a> function) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2a67ebeb78e5d624b45ec27d66bdf0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">空き TLS スロットを確保します。  <a href="#a2a67ebeb78e5d624b45ec27d66bdf0b2">[詳解]</a><br /></td></tr>
<tr class="separator:a2a67ebeb78e5d624b45ec27d66bdf0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afded66e76230ba96acc86ba3d48d76c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#afded66e76230ba96acc86ba3d48d76c4">FreeTlsSlot</a> (<a class="el" href="structnn_1_1os_1_1_tls_slot.html">TlsSlot</a> tlsSlot) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afded66e76230ba96acc86ba3d48d76c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">TLS スロットを返却します。  <a href="#afded66e76230ba96acc86ba3d48d76c4">[詳解]</a><br /></td></tr>
<tr class="separator:afded66e76230ba96acc86ba3d48d76c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452445507fba4dc49cb9cfb77b4c88c1"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a452445507fba4dc49cb9cfb77b4c88c1">GetTlsValue</a> (<a class="el" href="structnn_1_1os_1_1_tls_slot.html">TlsSlot</a> tlsSlot) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a452445507fba4dc49cb9cfb77b4c88c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定された TLS スロットから値を取得します。  <a href="#a452445507fba4dc49cb9cfb77b4c88c1">[詳解]</a><br /></td></tr>
<tr class="separator:a452445507fba4dc49cb9cfb77b4c88c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f54d6581f3380bc9b6b7d92c9855acd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8f54d6581f3380bc9b6b7d92c9855acd">SetTlsValue</a> (<a class="el" href="structnn_1_1os_1_1_tls_slot.html">TlsSlot</a> tlsSlot, uintptr_t value) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8f54d6581f3380bc9b6b7d92c9855acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定された TLS スロットに値を設定します。  <a href="#a8f54d6581f3380bc9b6b7d92c9855acd">[詳解]</a><br /></td></tr>
<tr class="separator:a8f54d6581f3380bc9b6b7d92c9855acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0db5a1ab770f99f96e327aeb5c653ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aa0db5a1ab770f99f96e327aeb5c653ce">GetUsedTlsSlotCount</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa0db5a1ab770f99f96e327aeb5c653ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">確保済みの TLS スロット数を取得します。  <a href="#aa0db5a1ab770f99f96e327aeb5c653ce">[詳解]</a><br /></td></tr>
<tr class="separator:aa0db5a1ab770f99f96e327aeb5c653ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">時間管理関連 API</div></td></tr>
<tr class="memitem:a79e29821bfb2b0c3a5c222488e90cc89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a79e29821bfb2b0c3a5c222488e90cc89">GetSystemTick</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a79e29821bfb2b0c3a5c222488e90cc89"><td class="mdescLeft">&#160;</td><td class="mdescRight">システムチック値を取得します。  <a href="#a79e29821bfb2b0c3a5c222488e90cc89">[詳解]</a><br /></td></tr>
<tr class="separator:a79e29821bfb2b0c3a5c222488e90cc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64f2523f9e13afef5de6197898afa27"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aa64f2523f9e13afef5de6197898afa27">GetSystemTickFrequency</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa64f2523f9e13afef5de6197898afa27"><td class="mdescLeft">&#160;</td><td class="mdescRight">システムチック値の周波数を取得します。  <a href="#aa64f2523f9e13afef5de6197898afa27">[詳解]</a><br /></td></tr>
<tr class="separator:aa64f2523f9e13afef5de6197898afa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53032bee4cfe0f01916e8149c393adad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a53032bee4cfe0f01916e8149c393adad">ConvertToTimeSpan</a> (<a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a> tick) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a53032bee4cfe0f01916e8149c393adad"><td class="mdescLeft">&#160;</td><td class="mdescRight">システムチックを <a class="el" href="classnn_1_1_time_span.html" title="時間の長さを表すクラスです。 ">nn::TimeSpan</a> 型の時間表現に変換して返します。  <a href="#a53032bee4cfe0f01916e8149c393adad">[詳解]</a><br /></td></tr>
<tr class="separator:a53032bee4cfe0f01916e8149c393adad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9b3542885a746dca530490408f78c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8c9b3542885a746dca530490408f78c1">ConvertToTick</a> (<a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> timeSpan) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8c9b3542885a746dca530490408f78c1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_time_span.html" title="時間の長さを表すクラスです。 ">nn::TimeSpan</a> 型の時間表現をシステムチックに変換して返します。  <a href="#a8c9b3542885a746dca530490408f78c1">[詳解]</a><br /></td></tr>
<tr class="separator:a8c9b3542885a746dca530490408f78c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">コンパイラのスレッドローカル用メモリアロケータの初期化</div></td></tr>
<tr class="memitem:a347a69381452967e4a51b3c18aae7807"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a347a69381452967e4a51b3c18aae7807">SetMemoryAllocatorForThreadLocal</a> (<a class="el" href="namespacenn.html#ae292809a1837a548ce8e91c92dd5fac8">nn::AlignedAllocateFunction</a> allocator, <a class="el" href="namespacenn.html#ac4bc1dec66991644b7abd9f9cd9d0ca6">nn::DeallocateFunction</a> deallocator) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a347a69381452967e4a51b3c18aae7807"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンパイラのスレッドローカル実装で使用されるメモリアロケータ／デアロケータを登録します。  <a href="#a347a69381452967e4a51b3c18aae7807">[詳解]</a><br /></td></tr>
<tr class="separator:a347a69381452967e4a51b3c18aae7807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">メモリ管理関連 API</div></td></tr>
<tr class="memitem:a2be8bac50d8d37a91f866d9e0c55886e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a2be8bac50d8d37a91f866d9e0c55886e">SetMemoryHeapSize</a> (size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2be8bac50d8d37a91f866d9e0c55886e"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリヒープ領域のサイズを変更します。  <a href="#a2be8bac50d8d37a91f866d9e0c55886e">[詳解]</a><br /></td></tr>
<tr class="separator:a2be8bac50d8d37a91f866d9e0c55886e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875bf6b3129f06654e641513c63017dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a875bf6b3129f06654e641513c63017dd">AllocateMemoryBlock</a> (uintptr_t *address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a875bf6b3129f06654e641513c63017dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリヒープからメモリブロックを獲得します。  <a href="#a875bf6b3129f06654e641513c63017dd">[詳解]</a><br /></td></tr>
<tr class="separator:a875bf6b3129f06654e641513c63017dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fa47e171856fb202b60e6b2a1de719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a20fa47e171856fb202b60e6b2a1de719">FreeMemoryBlock</a> (uintptr_t address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a20fa47e171856fb202b60e6b2a1de719"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリヒープ領域へメモリブロックを返却します。  <a href="#a20fa47e171856fb202b60e6b2a1de719">[詳解]</a><br /></td></tr>
<tr class="separator:a20fa47e171856fb202b60e6b2a1de719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">メモリアクセス権関連 API</div></td></tr>
<tr class="memitem:ae3d0ddd1807c032d7ab0e0fda9739bef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae3d0ddd1807c032d7ab0e0fda9739bef">SetMemoryPermission</a> (uintptr_t address, size_t size, <a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9a">MemoryPermission</a> permission) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae3d0ddd1807c032d7ab0e0fda9739bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたメモリ領域のメモリアクセス権を変更します。  <a href="#ae3d0ddd1807c032d7ab0e0fda9739bef">[詳解]</a><br /></td></tr>
<tr class="separator:ae3d0ddd1807c032d7ab0e0fda9739bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">仮想アドレスメモリ管理関連 API</div></td></tr>
<tr class="memitem:a11dca1988a4d23dc773f216847a56ecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a11dca1988a4d23dc773f216847a56ecd">AllocateAddressRegion</a> (uintptr_t *pOutAddress, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a11dca1988a4d23dc773f216847a56ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">仮想アドレス空間からアドレス領域を確保します  <a href="#a11dca1988a4d23dc773f216847a56ecd">[詳解]</a><br /></td></tr>
<tr class="separator:a11dca1988a4d23dc773f216847a56ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822e071b5061ef30ce2202d67fad8dd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a822e071b5061ef30ce2202d67fad8dd0">FreeAddressRegion</a> (uintptr_t address) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a822e071b5061ef30ce2202d67fad8dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">アドレス領域を解放します。  <a href="#a822e071b5061ef30ce2202d67fad8dd0">[詳解]</a><br /></td></tr>
<tr class="separator:a822e071b5061ef30ce2202d67fad8dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2aecae3365f9881e63f3c9a77be239"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#afc2aecae3365f9881e63f3c9a77be239">AllocateMemoryPages</a> (uintptr_t address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afc2aecae3365f9881e63f3c9a77be239"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定の領域に物理メモリを割り当てます  <a href="#afc2aecae3365f9881e63f3c9a77be239">[詳解]</a><br /></td></tr>
<tr class="separator:afc2aecae3365f9881e63f3c9a77be239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadde176efe5d5ec8352539a4c41cc468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aadde176efe5d5ec8352539a4c41cc468">FreeMemoryPages</a> (uintptr_t address, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aadde176efe5d5ec8352539a4c41cc468"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定の領域へのメモリの割り当てを解除します。  <a href="#aadde176efe5d5ec8352539a4c41cc468">[詳解]</a><br /></td></tr>
<tr class="separator:aadde176efe5d5ec8352539a4c41cc468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b13b1f8e6e4fa352192eb9d121ff49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1os_1_1_virtual_address_memory_resource_usage.html">VirtualAddressMemoryResourceUsage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a49b13b1f8e6e4fa352192eb9d121ff49">GetVirtualAddressMemoryResourceUsage</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a49b13b1f8e6e4fa352192eb9d121ff49"><td class="mdescLeft">&#160;</td><td class="mdescRight">仮想アドレスメモリ管理用のリソース消費量を取得します。  <a href="#a49b13b1f8e6e4fa352192eb9d121ff49">[詳解]</a><br /></td></tr>
<tr class="separator:a49b13b1f8e6e4fa352192eb9d121ff49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e6556970df605db16e5548b9fd188c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c">IsVirtualAddressMemoryEnabled</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab9e6556970df605db16e5548b9fd188c"><td class="mdescLeft">&#160;</td><td class="mdescRight">仮想アドレスメモリ管理が使用可能になっているかを判定します。  <a href="#ab9e6556970df605db16e5548b9fd188c">[詳解]</a><br /></td></tr>
<tr class="separator:ab9e6556970df605db16e5548b9fd188c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">メモリフェンス関連 API</div></td></tr>
<tr class="memitem:a0b9900ac6f5ffc3cceeaf9e4d4628fd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a0b9900ac6f5ffc3cceeaf9e4d4628fd6">FenceMemoryStoreStore</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0b9900ac6f5ffc3cceeaf9e4d4628fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store-Store メモリフェンスを挿入します。  <a href="#a0b9900ac6f5ffc3cceeaf9e4d4628fd6">[詳解]</a><br /></td></tr>
<tr class="separator:a0b9900ac6f5ffc3cceeaf9e4d4628fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bc7c5ef7a7884fa2cdb771d1050045"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a89bc7c5ef7a7884fa2cdb771d1050045">FenceMemoryStoreLoad</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a89bc7c5ef7a7884fa2cdb771d1050045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store-Load メモリフェンスを挿入します。  <a href="#a89bc7c5ef7a7884fa2cdb771d1050045">[詳解]</a><br /></td></tr>
<tr class="separator:a89bc7c5ef7a7884fa2cdb771d1050045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecf770755dd217ffff4479db6102863"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8ecf770755dd217ffff4479db6102863">FenceMemoryStoreAny</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8ecf770755dd217ffff4479db6102863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store-Any メモリフェンスを挿入します。  <a href="#a8ecf770755dd217ffff4479db6102863">[詳解]</a><br /></td></tr>
<tr class="separator:a8ecf770755dd217ffff4479db6102863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d20e99e9c3b0e699b51a13acd3ead6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a36d20e99e9c3b0e699b51a13acd3ead6">FenceMemoryLoadStore</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a36d20e99e9c3b0e699b51a13acd3ead6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load-Store メモリフェンスを挿入します。  <a href="#a36d20e99e9c3b0e699b51a13acd3ead6">[詳解]</a><br /></td></tr>
<tr class="separator:a36d20e99e9c3b0e699b51a13acd3ead6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24612da5b069435fc5f1d8f8720adadf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a24612da5b069435fc5f1d8f8720adadf">FenceMemoryLoadLoad</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a24612da5b069435fc5f1d8f8720adadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load-Load メモリフェンスを挿入します。  <a href="#a24612da5b069435fc5f1d8f8720adadf">[詳解]</a><br /></td></tr>
<tr class="separator:a24612da5b069435fc5f1d8f8720adadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367aa8b77b2ae4d88e358810ef54b973"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a367aa8b77b2ae4d88e358810ef54b973">FenceMemoryLoadAny</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a367aa8b77b2ae4d88e358810ef54b973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load-Any メモリフェンスを挿入します。  <a href="#a367aa8b77b2ae4d88e358810ef54b973">[詳解]</a><br /></td></tr>
<tr class="separator:a367aa8b77b2ae4d88e358810ef54b973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebc9c7ff99fc0e1b04a693daeebda8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#acebc9c7ff99fc0e1b04a693daeebda8f">FenceMemoryAnyStore</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acebc9c7ff99fc0e1b04a693daeebda8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any-Store メモリフェンスを挿入します。  <a href="#acebc9c7ff99fc0e1b04a693daeebda8f">[詳解]</a><br /></td></tr>
<tr class="separator:acebc9c7ff99fc0e1b04a693daeebda8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfb421bf54c835b5b731db28d171cf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a7bfb421bf54c835b5b731db28d171cf9">FenceMemoryAnyLoad</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7bfb421bf54c835b5b731db28d171cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any-Load メモリフェンスを挿入します。  <a href="#a7bfb421bf54c835b5b731db28d171cf9">[詳解]</a><br /></td></tr>
<tr class="separator:a7bfb421bf54c835b5b731db28d171cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf5cd70de75b033bb8ae4eac87f8fe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#addf5cd70de75b033bb8ae4eac87f8fe2">FenceMemoryAnyAny</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:addf5cd70de75b033bb8ae4eac87f8fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any-Any メモリフェンスを挿入します。  <a href="#addf5cd70de75b033bb8ae4eac87f8fe2">[詳解]</a><br /></td></tr>
<tr class="separator:addf5cd70de75b033bb8ae4eac87f8fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ユーザ例外ハンドラ関連 API</div></td></tr>
<tr class="memitem:a80a1e659aaba155ff9552f48604aec54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a80a1e659aaba155ff9552f48604aec54">SetUserExceptionHandler</a> (<a class="el" href="namespacenn_1_1os.html#aff433bbe881d0fcb8fbb47fe3e299173">UserExceptionHandler</a> pHandler, void *stack, size_t stackSize, <a class="el" href="structnn_1_1os_1_1_user_exception_info.html">UserExceptionInfo</a> *pExceptionInfo) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a80a1e659aaba155ff9552f48604aec54"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザ例外ハンドラを設定します。  <a href="#a80a1e659aaba155ff9552f48604aec54">[詳解]</a><br /></td></tr>
<tr class="separator:a80a1e659aaba155ff9552f48604aec54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dba2921df0ef2adf203a4b9829a6d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a52dba2921df0ef2adf203a4b9829a6d6">EnableUserExceptionHandlerOnDebugging</a> (bool isEnabled) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a52dba2921df0ef2adf203a4b9829a6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">デバッガ接続時にもユーザ例外ハンドラを起動するか否かを設定します。  <a href="#a52dba2921df0ef2adf203a4b9829a6d6">[詳解]</a><br /></td></tr>
<tr class="separator:a52dba2921df0ef2adf203a4b9829a6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">デフォルトユーザー例外ハンドラ</div></td></tr>
<tr class="memitem:aa9f112844be928c69600e987eb45980f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aa9f112844be928c69600e987eb45980f">DefaultUserExceptionHandler</a> (<a class="el" href="structnn_1_1os_1_1_user_exception_info.html">nn::os::UserExceptionInfo</a> *info) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa9f112844be928c69600e987eb45980f"><td class="mdescLeft">&#160;</td><td class="mdescRight">デフォルトユーザー例外ハンドラです。  <a href="#aa9f112844be928c69600e987eb45980f">[詳解]</a><br /></td></tr>
<tr class="separator:aa9f112844be928c69600e987eb45980f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ハンドル関連共通 API</div></td></tr>
<tr class="memitem:a84abb8d61f9ab227f76ae7b54dcce5d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a84abb8d61f9ab227f76ae7b54dcce5d4">CloseNativeHandle</a> (<a class="el" href="namespacenn_1_1os.html#a84b48561ef817ac28bde556d321a382e">NativeHandle</a> handle) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a84abb8d61f9ab227f76ae7b54dcce5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたハンドルをクローズします。  <a href="#a84abb8d61f9ab227f76ae7b54dcce5d4">[詳解]</a><br /></td></tr>
<tr class="separator:a84abb8d61f9ab227f76ae7b54dcce5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
変数</h2></td></tr>
<tr class="memitem:a82acf7f7f39eb127ebffdef2c748c5e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82acf7f7f39eb127ebffdef2c748c5e6"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a82acf7f7f39eb127ebffdef2c748c5e6">AddressRegionAlignment</a> = 64 * 1024</td></tr>
<tr class="memdesc:a82acf7f7f39eb127ebffdef2c748c5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">アドレス領域の先頭アドレスが満たすアライメント制約を表す定数です。 <br /></td></tr>
<tr class="separator:a82acf7f7f39eb127ebffdef2c748c5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5985811d04e64c0823ed758fd420591d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5985811d04e64c0823ed758fd420591d"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a5985811d04e64c0823ed758fd420591d">DefaultThreadPriority</a> = (ThreadPriorityRangeSize / 2)</td></tr>
<tr class="memdesc:a5985811d04e64c0823ed758fd420591d"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッド優先度のデフォルト値を表す定数です。16 です。 <br /></td></tr>
<tr class="separator:a5985811d04e64c0823ed758fd420591d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8818e7de49601e4f83bd6d3ee822449"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ab8818e7de49601e4f83bd6d3ee822449">FiberStackAlignment</a> = 16</td></tr>
<tr class="memdesc:ab8818e7de49601e4f83bd6d3ee822449"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイバスタック領域のアライメント制約を表す定数です。  <a href="#ab8818e7de49601e4f83bd6d3ee822449">[詳解]</a><br /></td></tr>
<tr class="separator:ab8818e7de49601e4f83bd6d3ee822449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b2d95cc4315e16021578c2ba43208d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09b2d95cc4315e16021578c2ba43208d"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a09b2d95cc4315e16021578c2ba43208d">GuardedStackAlignment</a> = 4096</td></tr>
<tr class="memdesc:a09b2d95cc4315e16021578c2ba43208d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ガード付きスタック領域のアライメント制約を表す定数です。 <br /></td></tr>
<tr class="separator:a09b2d95cc4315e16021578c2ba43208d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88f7888a125e3cf4d07f28cf9acb95a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae88f7888a125e3cf4d07f28cf9acb95a"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae88f7888a125e3cf4d07f28cf9acb95a">HandlerStackAlignment</a> = 16</td></tr>
<tr class="memdesc:ae88f7888a125e3cf4d07f28cf9acb95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザ例外ハンドラのスタックアライメント制約を表す定数です。 <br /></td></tr>
<tr class="separator:ae88f7888a125e3cf4d07f28cf9acb95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ca06939bae41f0ab89eda5be97d4fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0ca06939bae41f0ab89eda5be97d4fa"></a>
void *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ac0ca06939bae41f0ab89eda5be97d4fa">HandlerStackUsesThreadStack</a> = reinterpret_cast&lt;void*&gt;(HandlerStackUsesThreadStackValue)</td></tr>
<tr class="memdesc:ac0ca06939bae41f0ab89eda5be97d4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザ例外ハンドラのスタックとしてスレッドスタックを指定する定数です。 <br /></td></tr>
<tr class="separator:ac0ca06939bae41f0ab89eda5be97d4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ed3b4dddf9ebfb69bc33167369b816"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44ed3b4dddf9ebfb69bc33167369b816"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a44ed3b4dddf9ebfb69bc33167369b816">HighestThreadPriority</a> = 0</td></tr>
<tr class="memdesc:a44ed3b4dddf9ebfb69bc33167369b816"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッドの最高優先度を表す定数です。0 です。 <br /></td></tr>
<tr class="separator:a44ed3b4dddf9ebfb69bc33167369b816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333a7029b85a51321a4c79176e91eab3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a333a7029b85a51321a4c79176e91eab3"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a333a7029b85a51321a4c79176e91eab3">IdealCoreDontCare</a> = -1</td></tr>
<tr class="memdesc:a333a7029b85a51321a4c79176e91eab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">優先コア番号なしに設定します <br /></td></tr>
<tr class="separator:a333a7029b85a51321a4c79176e91eab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418170f89de31518fdc59c699d78a1b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a418170f89de31518fdc59c699d78a1b1"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a418170f89de31518fdc59c699d78a1b1">IdealCoreNoUpdate</a> = -3</td></tr>
<tr class="memdesc:a418170f89de31518fdc59c699d78a1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">優先コア番号の更新を行いません <br /></td></tr>
<tr class="separator:a418170f89de31518fdc59c699d78a1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3959f30f2583f83a37ec382f091fd9fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3959f30f2583f83a37ec382f091fd9fa"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a3959f30f2583f83a37ec382f091fd9fa">IdealCoreUseDefaultValue</a> = -2</td></tr>
<tr class="memdesc:a3959f30f2583f83a37ec382f091fd9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">自プログラムに設定された優先コアでのみ動作します。 <br /></td></tr>
<tr class="separator:a3959f30f2583f83a37ec382f091fd9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8beb482b6d0aef56dc4877498abc9756"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8beb482b6d0aef56dc4877498abc9756"></a>
const <a class="el" href="namespacenn_1_1os.html#a84b48561ef817ac28bde556d321a382e">NativeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8beb482b6d0aef56dc4877498abc9756">InvalidNativeHandle</a> = 0</td></tr>
<tr class="memdesc:a8beb482b6d0aef56dc4877498abc9756"><td class="mdescLeft">&#160;</td><td class="mdescRight">無効なハンドルであることを表す定数です。 <br /></td></tr>
<tr class="separator:a8beb482b6d0aef56dc4877498abc9756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88510f5f630a16612aa8d479c10b56de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88510f5f630a16612aa8d479c10b56de"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a88510f5f630a16612aa8d479c10b56de">LowestThreadPriority</a> = (ThreadPriorityRangeSize - 1)</td></tr>
<tr class="memdesc:a88510f5f630a16612aa8d479c10b56de"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッドの最低優先度を表す定数です。31 です。 <br /></td></tr>
<tr class="separator:a88510f5f630a16612aa8d479c10b56de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade84ad9f438e76820510ca0623c5a823"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade84ad9f438e76820510ca0623c5a823"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ade84ad9f438e76820510ca0623c5a823">MemoryBlockUnitSize</a> = 2 * 1024 * 1024</td></tr>
<tr class="memdesc:ade84ad9f438e76820510ca0623c5a823"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリブロックの最小単位を格納した定数です。 <br /></td></tr>
<tr class="separator:ade84ad9f438e76820510ca0623c5a823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed47f05ce9175eb46876c1ddd0512c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeed47f05ce9175eb46876c1ddd0512c7"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aeed47f05ce9175eb46876c1ddd0512c7">MemoryHeapUnitSize</a> = 2 * 1024 * 1024</td></tr>
<tr class="memdesc:aeed47f05ce9175eb46876c1ddd0512c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリヒープ領域の最小単位を格納した定数です。 <br /></td></tr>
<tr class="separator:aeed47f05ce9175eb46876c1ddd0512c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac880b46610757e748d5bd79211af4236"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac880b46610757e748d5bd79211af4236"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236">MemoryPageSize</a> = 4 * 1024</td></tr>
<tr class="memdesc:ac880b46610757e748d5bd79211af4236"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ操作の最小単位を格納した定数です。 <br /></td></tr>
<tr class="separator:ac880b46610757e748d5bd79211af4236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6aa9ce2dde219059e2a4b798ab7745"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f6aa9ce2dde219059e2a4b798ab7745"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a0f6aa9ce2dde219059e2a4b798ab7745">MutexLockLevelInitial</a> = 0</td></tr>
<tr class="memdesc:a0f6aa9ce2dde219059e2a4b798ab7745"><td class="mdescLeft">&#160;</td><td class="mdescRight">カレントスレッドのミューテックスロックレベルの初期値を表す定数です。 <br /></td></tr>
<tr class="separator:a0f6aa9ce2dde219059e2a4b798ab7745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b0e2596b8091c49374130b049168f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20b0e2596b8091c49374130b049168f6"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a20b0e2596b8091c49374130b049168f6">MutexLockLevelMax</a> = 31</td></tr>
<tr class="memdesc:a20b0e2596b8091c49374130b049168f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ミューテックスのロックレベルの最大値を表す定数です。 <br /></td></tr>
<tr class="separator:a20b0e2596b8091c49374130b049168f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb8cce9509759efcb7b1080b20ca960"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafb8cce9509759efcb7b1080b20ca960"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#aafb8cce9509759efcb7b1080b20ca960">MutexLockLevelMin</a> = 1</td></tr>
<tr class="memdesc:aafb8cce9509759efcb7b1080b20ca960"><td class="mdescLeft">&#160;</td><td class="mdescRight">ミューテックスのロックレベルの最小値を表す定数です。 <br /></td></tr>
<tr class="separator:aafb8cce9509759efcb7b1080b20ca960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e36be94a982f77ee0ff4ecd1f2c1af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7e36be94a982f77ee0ff4ecd1f2c1af"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae7e36be94a982f77ee0ff4ecd1f2c1af">MutexRecursiveLockCountMax</a> = 65535</td></tr>
<tr class="memdesc:ae7e36be94a982f77ee0ff4ecd1f2c1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">ミューテックスの再帰ロック回数の最大値を表す定数です。 <br /></td></tr>
<tr class="separator:ae7e36be94a982f77ee0ff4ecd1f2c1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb4af12ad2e9b3e32f1e72d3a313f32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cb4af12ad2e9b3e32f1e72d3a313f32"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a3cb4af12ad2e9b3e32f1e72d3a313f32">ReaderWriterLockCountMax</a> = 65535</td></tr>
<tr class="memdesc:a3cb4af12ad2e9b3e32f1e72d3a313f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Readers-Writer ロックのロックカウントの最大値を表す定数です。 <br /></td></tr>
<tr class="separator:a3cb4af12ad2e9b3e32f1e72d3a313f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa3807e422796d3f349b4d2dbb1d656"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7aa3807e422796d3f349b4d2dbb1d656"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a7aa3807e422796d3f349b4d2dbb1d656">SdkTlsSlotCountMax</a> = 16</td></tr>
<tr class="memdesc:a7aa3807e422796d3f349b4d2dbb1d656"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDK 内部用の TLS スロットの総数を示す定数です。 <br /></td></tr>
<tr class="separator:a7aa3807e422796d3f349b4d2dbb1d656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895eb281cfb4500d6ac462cec6631613"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a895eb281cfb4500d6ac462cec6631613">StackRegionAlignment</a> = <a class="el" href="namespacenn_1_1os.html#a8b116319f3d483f3805c193661f22150">ThreadStackAlignment</a></td></tr>
<tr class="memdesc:a895eb281cfb4500d6ac462cec6631613"><td class="mdescLeft">&#160;</td><td class="mdescRight">スタック領域のアライメント制約を表す定数です。  <a href="#a895eb281cfb4500d6ac462cec6631613">[詳解]</a><br /></td></tr>
<tr class="separator:a895eb281cfb4500d6ac462cec6631613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793a3781900c43f3d8afda6e02ec1b58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a793a3781900c43f3d8afda6e02ec1b58"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a793a3781900c43f3d8afda6e02ec1b58">ThreadNameLengthMax</a> = 32</td></tr>
<tr class="memdesc:a793a3781900c43f3d8afda6e02ec1b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッド名の最大文字数を表す定数です。<br />
 文字列終端の '\0' 文字を含んだ文字数です。 <br /></td></tr>
<tr class="separator:a793a3781900c43f3d8afda6e02ec1b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b116319f3d483f3805c193661f22150"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a8b116319f3d483f3805c193661f22150">ThreadStackAlignment</a> = 4096</td></tr>
<tr class="memdesc:a8b116319f3d483f3805c193661f22150"><td class="mdescLeft">&#160;</td><td class="mdescRight">スレッドのスタック領域のアライメント制約を表す定数です。  <a href="#a8b116319f3d483f3805c193661f22150">[詳解]</a><br /></td></tr>
<tr class="separator:a8b116319f3d483f3805c193661f22150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fab4470b957077f8605c71502c9f2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59fab4470b957077f8605c71502c9f2f"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a59fab4470b957077f8605c71502c9f2f">TlsSlotCountMax</a> = 16</td></tr>
<tr class="memdesc:a59fab4470b957077f8605c71502c9f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">TLS スロットの総数を示す定数です。 <br /></td></tr>
<tr class="separator:a59fab4470b957077f8605c71502c9f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b6dc109705a61e232eb0087fbb8720"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74b6dc109705a61e232eb0087fbb8720"></a>
<a class="el" href="structnn_1_1os_1_1_user_exception_info.html">UserExceptionInfo</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#a74b6dc109705a61e232eb0087fbb8720">UserExceptionInfoUsesHandlerStack</a> = reinterpret_cast&lt;<a class="el" href="structnn_1_1os_1_1_user_exception_info.html">UserExceptionInfo</a>*&gt;(reinterpret_cast&lt;char*&gt;(0) + UserExceptionInfoUsesHandlerStackValue)</td></tr>
<tr class="memdesc:a74b6dc109705a61e232eb0087fbb8720"><td class="mdescLeft">&#160;</td><td class="mdescRight">例外情報格納領域として例外ハンドラのスタックを指定する定数です。 <br /></td></tr>
<tr class="separator:a74b6dc109705a61e232eb0087fbb8720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95b1a34cff3839ca8d8af43ff4512cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae95b1a34cff3839ca8d8af43ff4512cd"></a>
<a class="el" href="structnn_1_1os_1_1_user_exception_info.html">UserExceptionInfo</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1os.html#ae95b1a34cff3839ca8d8af43ff4512cd">UserExceptionInfoUsesThreadStack</a> = reinterpret_cast&lt;<a class="el" href="structnn_1_1os_1_1_user_exception_info.html">UserExceptionInfo</a>*&gt;(reinterpret_cast&lt;char*&gt;(0) + UserExceptionInfoUsesThreadStackValue)</td></tr>
<tr class="memdesc:ae95b1a34cff3839ca8d8af43ff4512cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">例外情報格納領域としてスレッドスタックを指定する定数です。 <br /></td></tr>
<tr class="separator:ae95b1a34cff3839ca8d8af43ff4512cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p>オペレーティングシステムライブラリの名前空間です。 </p>
</div><h2 class="groupheader">型定義詳解</h2>
<a class="anchor" id="a00a0fffd9172c3779939c06927973bed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a>*(* nn::os::FiberFunction) (void *argument)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイバ関数のエントリを表す型です。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argument</td><td>ファイバ関数が受け取る引数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>遷移先のファイバを示す <a class="el" href="structnn_1_1os_1_1_fiber_type.html" title="ファイバオブジェクトを定義する構造体です。 ">FiberType</a> オブジェクトへのポインタ</dd></dl>
<p><b>詳細</b> <br />
 ファイバ関数のエントリを表す型です。</p>
<p>ファイバ関数からリターンで終了する際には、遷移先のファイバを示す <a class="el" href="structnn_1_1os_1_1_fiber_type.html" title="ファイバオブジェクトを定義する構造体です。 ">FiberType</a> ポインタを返値として渡して下さい。<br />
 返値に NULL を渡した場合は、元々のスレッドが <a class="el" href="namespacenn_1_1os.html#a3ba39dbca8b416903a5e2947927ed3e0" title="ファイバの実行を開始もしくは再開します。 ">SwitchToFiber()</a> を呼び出した ポイントに戻ります。詳細は <a class="el" href="namespacenn_1_1os.html#a9f0b5787e55da6b3b0e089d6b3ee6816" title="ファイバオブジェクトを初期化します。 ">InitializeFiber()</a> も合わせて確認して下さい。 </p>

</div>
</div>
<a class="anchor" id="aff433bbe881d0fcb8fbb47fe3e299173"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* nn::os::UserExceptionHandler) (<a class="el" href="structnn_1_1os_1_1_user_exception_info.html">UserExceptionInfo</a> *info)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユーザ例外ハンドラの関数を表す型です。 </p>
<p><b>詳細</b> <br />
 例外ハンドラの関数を表す型です。 info には発生した例外の情報が渡されます。</p>
<p>例外ハンドラから return した場合はシステムは panic で停止します。<br />
 例外ハンドラの詳細は <a class="el" href="namespacenn_1_1os.html#a80a1e659aaba155ff9552f48604aec54" title="ユーザ例外ハンドラを設定します。 ">SetUserExceptionHandler()</a> を参照してください </p>

</div>
</div>
<a class="anchor" id="a84b48561ef817ac28bde556d321a382e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="namespacenn_1_1os.html#a84b48561ef817ac28bde556d321a382e">nn::os::NativeHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>システムが管理しているハンドルを表す型です。 </p>
<p><b>詳細</b> <br />
 システムが管理しているハンドルを扱う場合に使用する型です。<br />
 通常は一部の SDK 開発者のみが使用します。</p>
<div id="dynsection-Windows" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-Windows-trigger" src="closed.png"/>
  <b>（Windowsプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-Windows-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-Windows-content" class="dyncontent" style="display:none;"> Windows 環境では uint32_t ではなく void* に typedef されています。 </div><p> 値を直接変更することは禁止です。 <br />
次の関数を介して利用してください。</p>
<ul>
<li><a class="el" href="namespacenn_1_1os.html#a84abb8d61f9ab227f76ae7b54dcce5d4">CloseNativeHandle()</a></li>
</ul>
<p>上記の関数を利用するには <a class="el" href="os___native_handle_types_8h.html" title="ハンドル関連の型や定数の宣言 ">nn/os/os_NativeHandleTypes.h</a> をインクルードする必要があります。 </p>

</div>
</div>
<h2 class="groupheader">列挙型詳解</h2>
<a class="anchor" id="ae1fe4fe10826c19cf2c66e534962180a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1os.html#ae1fe4fe10826c19cf2c66e534962180a">nn::os::ConditionVariableStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>時限付き条件変数待ち機能の返値を表す列挙型です。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="ae1fe4fe10826c19cf2c66e534962180aa4cad80372ca8b9c68ee8d1a34e806d24"></a>ConditionVariableStatus_Timeout&#160;</td><td class="fielddoc">
<p>タイムアウトしました </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae1fe4fe10826c19cf2c66e534962180aa2f5f309e61d650e34b30f0308c17818c"></a>ConditionVariableStatus_NoTimeout&#160;</td><td class="fielddoc">
<p>タイムアウト以外で起床しました </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a883ab0b53c72a07619d9e83de4836b9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9a">nn::os::MemoryPermission</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリアクセス権を表す列挙型です。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a883ab0b53c72a07619d9e83de4836b9aaf6942de46447bc0df8294a749a329d08"></a>MemoryPermission_None&#160;</td><td class="fielddoc">
<p>メモリはアクセス禁止です。 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a883ab0b53c72a07619d9e83de4836b9aad0057f9250371335c5b9292ff44e1750"></a>MemoryPermission_ReadOnly&#160;</td><td class="fielddoc">
<p>メモリは読み込み専用です。 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a883ab0b53c72a07619d9e83de4836b9aa699f0e08f6eddbe0264cf6664a2a1a4b"></a>MemoryPermission_WriteOnly&#160;</td><td class="fielddoc">
<p>メモリは書き込み専用です。 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a883ab0b53c72a07619d9e83de4836b9aa57ead1592d9473ac1c22f0b4f75ed2c0"></a>MemoryPermission_ReadWrite&#160;</td><td class="fielddoc">
<p>メモリは読み書き可能です。 </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a11ab71d44973a4135958c420e5682452"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">nn::os::EventClearMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>イベントのクリアモードを表す列挙型です。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a11ab71d44973a4135958c420e5682452a8b702480f5120eeeb01e7102227285da"></a>EventClearMode_ManualClear&#160;</td><td class="fielddoc">
<p>イベントの手動クリア </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc"></a>EventClearMode_AutoClear&#160;</td><td class="fielddoc">
<p>イベントの自動クリア </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a39b515dc6753642a34364d91b5813104"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104">nn::os::FiberFlag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイバに付随するフラグを表す列挙型です。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a39b515dc6753642a34364d91b5813104ac2bbce12f37e3e01eb6a244e2ada14c7"></a>FiberFlag_NoStackGuard&#160;</td><td class="fielddoc">
<p>スタックガードを設置しません </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a3271c9fc6c46cffdb076b966f15a80bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bc">nn::os::MessageQueueWaitType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>多重待ちオブジェクトのメッセージキュー待ちタイプの列挙型です。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a3271c9fc6c46cffdb076b966f15a80bca0fa8f18b62354b68a7838af2bf4e6f01"></a>MessageQueueWaitType_WaitForNotFull&#160;</td><td class="fielddoc">
<p>メッセージキューに空きが出来るまで待つ </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3271c9fc6c46cffdb076b966f15a80bca40a79a4dabe0233dd5c21d7c4a718eea"></a>MessageQueueWaitType_WaitForNotEmpty&#160;</td><td class="fielddoc">
<p>メッセージキューが空でなくなるまで待つ </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a02aa5878802b6b43d6f12dacb05a5460"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1os.html#a02aa5878802b6b43d6f12dacb05a5460">nn::os::UserExceptionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>例外種別を定義した列挙体です。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a02aa5878802b6b43d6f12dacb05a5460ad563258d2c5fdbb3034dfab01d83759c"></a>UserExceptionType_InvalidInstructionAccess&#160;</td><td class="fielddoc">
<p>不正なメモリ領域への命令アクセスを表します </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a02aa5878802b6b43d6f12dacb05a5460ac0086e1b87acfa1b2009247bc8fda2cb"></a>UserExceptionType_InvalidDataAccess&#160;</td><td class="fielddoc">
<p>不正なメモリ領域へのデータアクセスを表します </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a02aa5878802b6b43d6f12dacb05a5460ad8cd36398e52f181e3f42c17344b374d"></a>UserExceptionType_UnalignedInstructionAccess&#160;</td><td class="fielddoc">
<p>不正なアライメントへの命令アクセスを表します </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a02aa5878802b6b43d6f12dacb05a5460a422b59612c02820b465514da0cd55418"></a>UserExceptionType_UnalignedDataAccess&#160;</td><td class="fielddoc">
<p>不正なアライメントへのデータアクセスを表します </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a02aa5878802b6b43d6f12dacb05a5460acda61d04ba9081139baade0f28796133"></a>UserExceptionType_UndefinedInstruction&#160;</td><td class="fielddoc">
<p>未定義命令の実行を表します </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a02aa5878802b6b43d6f12dacb05a5460af92e12c9f4fb7359a207ca3a800fd050"></a>UserExceptionType_ExceptionalInstruction&#160;</td><td class="fielddoc">
<p>例外命令の実行を表します </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a02aa5878802b6b43d6f12dacb05a5460af78513bf294c682e7096df4862c16d2e"></a>UserExceptionType_MemorySystemError&#160;</td><td class="fielddoc">
<p>メモリシステムでのエラーを表します </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a02aa5878802b6b43d6f12dacb05a5460a6bcda4d1a1563579a851bef2515b5bee"></a>UserExceptionType_FloatingPointException&#160;</td><td class="fielddoc">
<p>浮動小数点数演算例外を表します </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a02aa5878802b6b43d6f12dacb05a5460af85b93bd5f06784cc5ed23911c288d69"></a>UserExceptionType_InvalidSystemCall&#160;</td><td class="fielddoc">
<p>無効なシステムコール呼び出しを表します </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a class="anchor" id="acf2fa6b7b7074a51d0b2de1664cc7bb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::GetHostArgc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ホスト指定のコマンドライン引数の数 (argc) を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>ホスト指定のコマンドライン引数の数（常に 1 以上）</dd></dl>
<p><b>詳細</b> <br />
 ホスト指定のコマンドライン引数の数 (argc) を取得します。 引数情報がない場合、返り値は 1 となり、 <a class="el" href="namespacenn_1_1os.html#abd77e6bf19be140867869cc759fa492c" title="ホスト指定のコマンドライン引数の文字列を指すポインタの配列 (argv) を取得します。 ">nn::os::GetHostArgv()</a>[0][0] == '\0' となります。</p>
<p>本 API は、TargetManager や VSI、RunOnTarget などからプログラムを起動する際に指定したコマンドライン引数を取得するためのものです。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_echoback_8cpp-example.html#a78">AudioEchoback.cpp</a>, <a class="el" href="_audio_out_8cpp-example.html#a39">AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_8cpp-example.html#a39">AudioOutWithResampler.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a151">FontDemo/Main.cpp</a>, <a class="el" href="_ldn_simple_2_main_8cpp-example.html#a9">LdnSimple/Main.cpp</a>, <a class="el" href="_libcurl_basic_8cpp-example.html#a9">LibcurlBasic.cpp</a>, <a class="el" href="_libcurl_speed_test_8cpp-example.html#a37">LibcurlSpeedTest.cpp</a>, <a class="el" href="_libcurl_ssl_context_import_8cpp-example.html#a9">LibcurlSslContextImport.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a12">MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a4">MoviePlayerSimple.cpp</a>, <a class="el" href="_simple_8cpp-example.html#a17">Simple.cpp</a>, <a class="el" href="_socket_basic_8cpp-example.html#a34">SocketBasic.cpp</a>, <a class="el" href="_socket_resolver_8cpp-example.html#a32">SocketResolver.cpp</a>, <a class="el" href="_ssl_simple_8cpp-example.html#a53">SslSimple.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a129">Ui2dDemo/Main.cpp</a> (計15項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="abd77e6bf19be140867869cc759fa492c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** nn::os::GetHostArgv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ホスト指定のコマンドライン引数の文字列を指すポインタの配列 (argv) を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>ホスト指定のコマンドライン引数の文字列を指すポインタの配列へのポインタ</dd></dl>
<p><b>詳細</b> <br />
 ホスト指定のコマンドライン引数の文字列を指すポインタの配列 (argv) を取得します。 引数情報がない場合、返り値は { "", NULL } という配列へのポインタを返します。</p>
<p>本 API は、TargetManager や VSI、RunOnTarget などからプログラムを起動する際に指定したコマンドライン引数を取得するためのものです。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_echoback_8cpp-example.html#a79">AudioEchoback.cpp</a>, <a class="el" href="_audio_out_8cpp-example.html#a38">AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_8cpp-example.html#a38">AudioOutWithResampler.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a152">FontDemo/Main.cpp</a>, <a class="el" href="_fontll_save_to_jpeg_8cpp-example.html#a39">FontllSaveToJpeg.cpp</a>, <a class="el" href="_ldn_simple_2_main_8cpp-example.html#a10">LdnSimple/Main.cpp</a>, <a class="el" href="_libcurl_basic_8cpp-example.html#a19">LibcurlBasic.cpp</a>, <a class="el" href="_libcurl_speed_test_8cpp-example.html#a38">LibcurlSpeedTest.cpp</a>, <a class="el" href="_libcurl_ssl_context_import_8cpp-example.html#a19">LibcurlSslContextImport.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a13">MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a5">MoviePlayerSimple.cpp</a>, <a class="el" href="_simple_8cpp-example.html#a18">Simple.cpp</a>, <a class="el" href="_socket_basic_8cpp-example.html#a35">SocketBasic.cpp</a>, <a class="el" href="_socket_resolver_8cpp-example.html#a33">SocketResolver.cpp</a>, <a class="el" href="_ssl_simple_8cpp-example.html#a54">SslSimple.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a130">Ui2dDemo/Main.cpp</a> (計16項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="a063c2e1620b936cdc599de617a458516"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeBarrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_barrier_type.html">BarrierType</a> *&#160;</td>
          <td class="paramname"><em>barrier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="バリアオブジェクトを定義する構造体です。 ">BarrierType</a> オブジェクトを初期化します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">barrier</td><td><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="バリアオブジェクトを定義する構造体です。 ">BarrierType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numThreads</td><td>待ち合わせたいスレッド数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>numThreads &gt; 0</li>
<li>barrier が未初期化状態もしくは初期化されていない状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>barrier が非シグナル状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 <a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="バリアオブジェクトを定義する構造体です。 ">BarrierType</a> オブジェクトを初期化します。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 barrier に対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_barrier_8cpp-example.html#a11">OsBarrier.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a062ceb897c5cd9b7bd4d779bf5e17c0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeBarrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_barrier_type.html">BarrierType</a> *&#160;</td>
          <td class="paramname"><em>barrier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="バリアオブジェクトを定義する構造体です。 ">BarrierType</a> オブジェクトを Finalize します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">barrier</td><td><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="バリアオブジェクトを定義する構造体です。 ">BarrierType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>barrier が非シグナル状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>barrier が未初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 <a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="バリアオブジェクトを定義する構造体です。 ">BarrierType</a> オブジェクトをファイナライズします。 barrier に対して待機中のスレッドがある場合にはアサートに失敗します。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 barrier に対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_barrier_8cpp-example.html#a19">OsBarrier.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a41fc159f1fb100df1371bbaf63e1ba14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::AwaitBarrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_barrier_type.html">BarrierType</a> *&#160;</td>
          <td class="paramname"><em>barrier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="バリアオブジェクトを定義する構造体です。 ">BarrierType</a> オブジェクトの待ち合わせを行ないます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">barrier</td><td><a class="el" href="structnn_1_1os_1_1_barrier_type.html" title="バリアオブジェクトを定義する構造体です。 ">BarrierType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>barrier が非シグナル状態である</li>
<li>待ち合わせスレッド数が、0 ～ (numThreads - 1) のいずれかである</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>barrier は非シグナル状態である</li>
<li>待ち合わせスレッド数が 0 である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 対象バリアに対して、自スレッドを待ち合わせ同期待ちに移行させます。 ポーリングやタイムアウト付きの同期待ち機能はありません。</p>
<p>対象バリアに対して、 <a class="el" href="namespacenn_1_1os.html#a063c2e1620b936cdc599de617a458516" title="BarrierType オブジェクトを初期化します。 ">InitializeBarrier()</a> 時に指定した numThreads の 数だけ本 API が発行された時点で、同期待ちしていた全てのスレッドの 待ちが解除されます。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_barrier_8cpp-example.html#a7">OsBarrier.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a0fc3b750c03200539a98c98f7acca022"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FlushDataCache </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>データキャッシュをメモリに書き出したのち破棄します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>開始アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>サイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>指定されたメモリ領域がキャッシュ対象である</li>
<li>指定されたメモリ領域が読み込みまたは書き込み可能である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 指定されたメモリ領域のデータキャッシュをメモリに書き出したのち破棄します。 </p>

</div>
</div>
<a class="anchor" id="a1ea1d7b36ec1844ed9e05729e832f6c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeConditionVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *&#160;</td>
          <td class="paramname"><em>conditionVariable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html" title="条件変数オブジェクトを定義する構造体です。 ">ConditionVariableType</a> オブジェクトを初期化します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conditionVariable</td><td>条件変数オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>conditionVariable が未初期化状態もしくは初期化されていない状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>conditionVariable が非シグナル状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 条件変数オブジェクトを初期化します。</p>
<p>条件変数オブジェクトの初期化を行なう方法として、静的に初期化を行なう <a class="el" href="os___condition_variable_api_8h.html#aa662896cf5af9d678aadcc17399c55e1">NN_OS_CONDITION_VARIABLE_INITIALIZER()</a> マクロもあります。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 conditionVariable に対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_condition_variable_8cpp-example.html#a13">OsConditionVariable.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a817379cd29b11b49b185d0dc6afdc5c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeConditionVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *&#160;</td>
          <td class="paramname"><em>conditionVariable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html" title="条件変数オブジェクトを定義する構造体です。 ">ConditionVariableType</a> オブジェクトを Finalize します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conditionVariable</td><td>条件変数オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>conditionVariable が初期化状態である</li>
<li>conditionVariable を待機しているスレッドがいない</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>conditionVariable が未初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 条件変数オブジェクトをファイナライズします。<br />
 conditionVariable に対して待機中のスレッドがある場合には、 アサートに失敗します。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 conditionVariable に対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_condition_variable_8cpp-example.html#a22">OsConditionVariable.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ae609d8150763b000d77f75d27fd44ac2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SignalConditionVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *&#160;</td>
          <td class="paramname"><em>conditionVariable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html" title="条件変数オブジェクトを定義する構造体です。 ">ConditionVariableType</a> にシグナルを通知します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conditionVariable</td><td>条件変数オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>conditionVariable が非シグナル状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>conditionVariable が非シグナル状態である</li>
<li>conditionVariable を待機しているスレッドが１つだけ起床する</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 指定された条件変数オブジェクトにシグナル通知を行ない、 対象の条件変数を待機するスレッドを１つだけ起床します。</p>
<p>スレッド起床後は、対象の条件変数は自動的に 非シグナル状態 に戻ります。<br />
 待ちスレッドがない場合、本 API は何も行ないません（非シグナル状態のまま となります）。</p>
<p>本 API は、シグナルを待機しているスレッドがロックしていたものと 同じミューテックスをロックした状態で呼び出す方が安全です。<br />
 そうしないと、関連する条件が評価されてから <a class="el" href="namespacenn_1_1os.html#a69a1e2e570d09ebd7cdbaa9da2d7b187" title="MutexType のアンロックと条件変数の待機をアトミックに行ないます。 ">WaitConditionVariable()</a> で 待機状態に入るまでの間に、条件変数にシグナルが送られてしまう可能性があり、 その場合 <a class="el" href="namespacenn_1_1os.html#a69a1e2e570d09ebd7cdbaa9da2d7b187" title="MutexType のアンロックと条件変数の待機をアトミックに行ないます。 ">WaitConditionVariable()</a> は永久待ちに入ってしまいます。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_condition_variable_8cpp-example.html#a5">OsConditionVariable.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1588e76fa05096006c0dcba27f9c95bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::BroadcastConditionVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *&#160;</td>
          <td class="paramname"><em>conditionVariable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html" title="条件変数オブジェクトを定義する構造体です。 ">ConditionVariableType</a> にブロードキャスト通知を行ないます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conditionVariable</td><td>条件変数オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>conditionVariable が非シグナル状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>conditionVariable が非シグナル状態である</li>
<li>conditionVariable を待機しているスレッドが全て起床する</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 指定された条件変数オブジェクトにブロードキャスト通知を行ない、 対象の条件変数を待機する全てのスレッドを起床します。</p>
<p>スレッド起床後は、対象の条件変数は自動的に 非シグナル状態 に戻ります。<br />
 待ちスレッドがない場合、本 API は何も行ないません（非シグナル状態のまま となります）。</p>
<p>本 API は、シグナルを待機しているスレッドがロックしていたものと 同じミューテックスをロックした状態で呼び出す方が安全です。<br />
 そうしないと、関連する条件が評価されてから <a class="el" href="namespacenn_1_1os.html#a69a1e2e570d09ebd7cdbaa9da2d7b187" title="MutexType のアンロックと条件変数の待機をアトミックに行ないます。 ">WaitConditionVariable()</a> で 待機状態に入るまでの間に、条件変数にシグナルが送られてしまう可能性があり、 その場合 <a class="el" href="namespacenn_1_1os.html#a69a1e2e570d09ebd7cdbaa9da2d7b187" title="MutexType のアンロックと条件変数の待機をアトミックに行ないます。 ">WaitConditionVariable()</a> は永久待ちに入ってしまいます。 </p>

</div>
</div>
<a class="anchor" id="a69a1e2e570d09ebd7cdbaa9da2d7b187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::WaitConditionVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *&#160;</td>
          <td class="paramname"><em>conditionVariable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> のアンロックと条件変数の待機をアトミックに行ないます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conditionVariable</td><td>条件変数オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>対象となる <a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>conditionVariable が初期化状態である</li>
<li>mutex が一度だけロックされた状態である</li>
<li>mutex のロック所有者が、自スレッドである</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>事前条件と同じ</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 mutex が指すミューテックスのアンロックと、 conditionVariable の 条件変数への待機をアトミックに行ないます。<br />
 対象ミューテックスは、本 API が呼び出される時点で、 自スレッドによって一度だけロックされた状態でなければなりません。</p>
<p>対象ミューテックスがアンロック状態であったり、他スレッドによって ロックされている場合には、本 API はアサートに失敗します。 また、recursive = true なミューテックスにおいて、2 回以上ロックされた 状態の場合には本 API はアボートします。</p>
<p>条件変数待機中に、 <a class="el" href="namespacenn_1_1os.html#ae609d8150763b000d77f75d27fd44ac2" title="ConditionVariableType にシグナルを通知します。 ">SignalConditionVariable()</a> または <a class="el" href="namespacenn_1_1os.html#a1588e76fa05096006c0dcba27f9c95bf" title="ConditionVariableType にブロードキャスト通知を行ないます。 ">BroadcastConditionVariable()</a> 通知を受けて条件変数待機が解除された場合、 再び対象ミューテックスをロックしてから caller に制御を戻します。</p>
<p>【注意事項】</p>
<p>条件変数待機機能は、spurious wakeup 問題を引き起こす可能性があります。 使用される場合には、spurious wakeup 対策が必要です。 spurious wakeup 問題については、 <a href="../../Package/contents/Pages/Page_83955531.html">条件変数機能説明の「条件変数使用上の注意事項」</a> を参照して下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_condition_variable_8cpp-example.html#a4">OsConditionVariable.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a2643c34ccfd738890fdd0c546b61c7a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1os.html#ae1fe4fe10826c19cf2c66e534962180a">nn::os::ConditionVariableStatus</a> nn::os::TimedWaitConditionVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_condition_variable_type.html">ConditionVariableType</a> *&#160;</td>
          <td class="paramname"><em>conditionVariable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> のアンロックと条件変数の待機をアトミックに行ないます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conditionVariable</td><td>条件変数オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>対象となる <a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>最大待ち時間</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>条件変数待ちが解除された要因を返します</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>conditionVariable オブジェクトが初期化状態である</li>
<li>mutex が一度だけロックされた状態である</li>
<li>mutex のロック所有者が、自スレッドである</li>
<li>timeout &gt;= 0</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>事前条件と同じ</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 mutex が指すミューテックスのアンロックと、conditionVariable の 条件変数への待機をアトミックに行ないます。<br />
 対象ミューテックスは、本 API が呼び出される時点で、 自スレッドによって一度だけロックされた状態でなければなりません。</p>
<p>対象ミューテックスがアンロック状態であったり、他スレッドによって ロックされている場合には、本 API はアサートに失敗します。 また、recursive = true なミューテックスにおいて、2 回以上ロックされた 状態の場合には本 API はアボートします。</p>
<p>条件変数待機中に、 <a class="el" href="namespacenn_1_1os.html#ae609d8150763b000d77f75d27fd44ac2" title="ConditionVariableType にシグナルを通知します。 ">SignalConditionVariable()</a> または <a class="el" href="namespacenn_1_1os.html#a1588e76fa05096006c0dcba27f9c95bf" title="ConditionVariableType にブロードキャスト通知を行ないます。 ">BroadcastConditionVariable()</a> 通知を受けて、条件変数待機が解除された場合 には、再び対象ミューテックスをロックしてから caller に制御を戻します。</p>
<p>条件変数待ちに入った後、timeout 時間経過するとタイムアウトが成立し、 自動的に待ちが解除されます。この場合でも、再度 mutex をロックして caller に制御を戻します。</p>
<p>タイムアウトの動作に関しては <a class="el" href="_page_notification_os_timeout.html">OS-API のタイムアウトについて</a> の 注意事項も参照して下さい。</p>
<p>本 API から戻った原因がタイムアウトなのか否かは返値で判別できます。 返値が <a class="el" href="namespacenn_1_1os.html#ae1fe4fe10826c19cf2c66e534962180aa4cad80372ca8b9c68ee8d1a34e806d24" title="タイムアウトしました ">nn::os::ConditionVariableStatus_Timeout</a> だった場合は、 タイムアウトが成立したことを示します。</p>
<p>一方で、返値が <a class="el" href="namespacenn_1_1os.html#ae1fe4fe10826c19cf2c66e534962180aa2f5f309e61d650e34b30f0308c17818c" title="タイムアウト以外で起床しました ">nn::os::ConditionVariableStatus_NoTimeout</a> の場合は、 他スレッドから <a class="el" href="namespacenn_1_1os.html#ae609d8150763b000d77f75d27fd44ac2" title="ConditionVariableType にシグナルを通知します。 ">SignalConditionVariable()</a> や <a class="el" href="namespacenn_1_1os.html#a1588e76fa05096006c0dcba27f9c95bf" title="ConditionVariableType にブロードキャスト通知を行ないます。 ">BroadcastConditionVariable()</a> の 通知を受けたか、spurious wakeup によって起床したかのいずれかであるため、 呼び出し元で再度待機条件をチェックするようにして下さい。</p>
<p>いずれの場合も、caller に戻る際に他スレッドが既に対象ミューテックスを ロックしている場合は、timeout 値に関係なく対象ミューテックスを 永久待ちでロックを試みます。<br />
 （つまり、指定された timeout は条件変数に対するタイムアウト値であり、 ミューテックスに対するものではありません。）</p>
<p>【注意事項】</p>
<p>条件変数待機機能は、spurious wakeup 問題を引き起こす可能性があります。 使用される場合には、spurious wakeup 対策が必要です。 spurious wakeup 問題については、 <a href="../../Package/contents/Pages/Page_83955531.html">条件変数機能説明の「条件変数使用上の注意事項」</a> を参照して下さい。 </p>

</div>
</div>
<a class="anchor" id="a036a9dca8974a28f03c6e8f3688efb12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::GetCurrentStackInfo </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outStack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outStackSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>現在のコンテキストで使用中のスタック情報を取得します </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outStack</td><td>現在使用中のスタックの先頭アドレスの格納先 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outStackSize</td><td>現在使用中のスタックのサイズの格納先</td></tr>
  </table>
  </dd>
</dl>
<p><b>詳細</b> <br />
 現在のコンテキストにおいて使用中のスタック領域の先頭アドレスとサイズを outStack および outStackSize に格納します。outStack または outStackSize に NULL を指定した場合、それらの情報は返されません。</p>
<p>「現在のコンテキスト」には以下のものが含まれます。</p>
<ul>
<li>スレッド</li>
<li>ファイバ</li>
<li>ユーザ例外ハンドラ</li>
</ul>
<p>現在のスタックポインタが、上記いずれのスタック領域内にもない場合、 すでにスタックオーバーフローが発生しているものと判断し、 内部でアボートします。 </p>

</div>
</div>
<a class="anchor" id="a07c8cba8c82b32e87d1d8521e4bef3dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::GetCurrentStackInfoForDebug </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outStack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outStackSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>本 API は deprecated されました。 <a class="el" href="namespacenn_1_1os.html#a036a9dca8974a28f03c6e8f3688efb12" title="現在のコンテキストで使用中のスタック情報を取得します ">GetCurrentStackInfo()</a> をご使用下さい。 </p>
<p>このAPIの利用は非推奨です。代替APIや利用条件の有無については詳細を確認してください。</p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">非推奨:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a79f2a489da0a124ebdc8130595c70b94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::QueryMemoryInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_memory_info.html">MemoryInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>自プログラムが現在使用しているメモリ使用量などの情報を取得します </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>情報を格納する構造体の先頭アドレス</td></tr>
  </table>
  </dd>
</dl>
<p><b>詳細</b> <br />
 自プログラムが現在使用しているメモリ使用量などの情報を <a class="el" href="structnn_1_1os_1_1_memory_info.html" title="メモリ情報などを取得した結果を格納する構造体です。 ">nn::os::MemoryInfo</a> 構造体に取得します。構造体の各メンバ変数は直接参照可能です。 各メンバに格納される値の詳細はそちらのリファレンスを参照して下さい。</p>
<p>本 API が情報を取得している間に、メモリ使用状況が変化することがあるため、 <a class="el" href="structnn_1_1os_1_1_memory_info.html" title="メモリ情報などを取得した結果を格納する構造体です。 ">nn::os::MemoryInfo</a> に格納される値は目安として参照して下さい。 極力、他のスレッドが動作していない状況下で使用されることを推奨します。</p>
<p>スレッドスタックなど、1 つの実メモリ領域を 複数の場所にマップするようなものは 1 つ分のサイズとしてカウントします。</p>
<p>本 API はスレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="ae5fc088880bfcf22817f53558a5a8ab7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::QueryMemoryInfoForDebug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_memory_info.html">MemoryInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>本 API は deprecated されました。 <a class="el" href="namespacenn_1_1os.html#a79f2a489da0a124ebdc8130595c70b94" title="自プログラムが現在使用しているメモリ使用量などの情報を取得します ">QueryMemoryInfo()</a> をご使用下さい。 </p>
<p>このAPIの利用は非推奨です。代替APIや利用条件の有無については詳細を確認してください。</p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">非推奨:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a54cfc2e44df793d57fdd057a94578bf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a> nn::os::GetIdleTickCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>自コアにおけるアイドル区間中の累積チックカウント値を取得します </p>
<dl class="section return"><dt>戻り値</dt><dd>自コアにおけるアイドル区間中の累積チックカウント値です。</dd></dl>
<p><b>詳細</b> <br />
 自スレッドが現在動作しているコア上で、過去のアイドル区間中の 累積 <a class="el" href="classnn_1_1os_1_1_tick.html" title="システムチックを扱う為のクラスです。 ">Tick</a> カウント値を取得します。アイドル区間とは、当該コア上で 動作すべきスレッドがなかった遊休区間を指します。</p>
<p>特定の二点間で本 API を発行し、それぞれの <a class="el" href="classnn_1_1os_1_1_tick.html" title="システムチックを扱う為のクラスです。 ">Tick</a> 値の差分を取ることで、 当該区間におけるプロセッサの使用率を算出する目的に使用できます。</p>
<p>本 API で取得できるのは、自スレッドが動作しているコアに関する情報のみです。 プログラムが使用可能なコア全てにおいて、アイドル区間中の 累積 <a class="el" href="classnn_1_1os_1_1_tick.html" title="システムチックを扱う為のクラスです。 ">Tick</a> カウント値を取得したい場合には、各コアで本 API を発行して下さい。</p>
<div id="dynsection-Windows" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-Windows-trigger" src="closed.png"/>
  <b>（Windowsプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-Windows-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-Windows-content" class="dyncontent" style="display:none;"><ul>
<li>Windows 環境では本 API はサポートされていません。 常に Tick(0) 相当のオブジェクトが返されます。</li>
</ul>
</div><div id="dynsection-Windows-content" class="dyncontent" style="display:none;"> </div> 
</div>
</div>
<a class="anchor" id="a25125eea675c69bc6912e1140d4df148"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SetDyingMessageRegion </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>クラッシュレポートに含めるユーザー定義のデータ（ダイイング・メッセージ）を格納するメモリ領域を指定します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>ダイイング・メッセージ領域の先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>ダイイング・メッセージ領域のサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>address が <a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="メモリ操作の最小単位を格納した定数です。 ">nn::os::MemoryPageSize</a> の整数倍である</li>
<li>size &lt;= 4096</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 本 API で指定したメモリ領域の内容がクラッシュレポートに格納されサーバーに送信されます。</p>
<p>指定できるメモリ領域のサイズは 4KB 以下です。</p>
<p>メモリ領域の内容を書き換える度に本 API を呼び出す必要はありません。 アプリケーション起動時に一度だけ呼び出せば十分です。</p>
<p>本 API で指定するメモリ領域に個人情報が含まれないようにしてください。 </p>

</div>
</div>
<a class="anchor" id="af07abef747ac6b51112b9e800ba9632c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initiallySignaled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">EventClearMode</a>&#160;</td>
          <td class="paramname"><em>clearMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> オブジェクトを初期化します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initiallySignaled</td><td>イベントの初期状態 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clearMode</td><td>イベントの自動クリアモード</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が未初期化状態もしくは初期化されていない状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>initiallySignaled == true の場合、event はシグナル状態である。</li>
<li>initiallySignaled == false の場合、event は非シグナル状態である。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 イベントオブジェクトを初期化します。</p>
<p>初期化されたイベントオブジェクトは、シグナル状態 と 非シグナル状態 の いずれか２つの状態を持ちます。初期化直後の状態は initiallySignaled によって決定されます。</p>
<p>シグナル化したイベントオブジェクトのクリア方法として、 clearMode に以下の２つのいずれかを指定します。</p>
<ul>
<li><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="イベントの自動クリア ">nn::os::EventClearMode_AutoClear</a> ・・・ 自動クリア</li>
<li><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a8b702480f5120eeeb01e7102227285da" title="イベントの手動クリア ">nn::os::EventClearMode_ManualClear</a> ・・・ 手動クリア</li>
</ul>
<p><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="イベントの自動クリア ">nn::os::EventClearMode_AutoClear</a> の場合、自動クリアとなります。<br />
 この場合、 <a class="el" href="namespacenn_1_1os.html#a9b959a51c1d28b76894597695fd3d081" title="EventType をシグナル状態にします。 ">SignalEvent()</a> 発行時に <a class="el" href="namespacenn_1_1os.html#aabdcb2de0b5dbdd64a0ec3d7e65c72f4" title="EventType がシグナル状態になるまで待機します。 ">WaitEvent()</a> で待機しているスレッドを 1 つだけ待ち解除し、イベントを非シグナル状態にクリアします。</p>
<p><a class="el" href="namespacenn_1_1os.html#a9b959a51c1d28b76894597695fd3d081" title="EventType をシグナル状態にします。 ">SignalEvent()</a> 発行時に <a class="el" href="namespacenn_1_1os.html#aabdcb2de0b5dbdd64a0ec3d7e65c72f4" title="EventType がシグナル状態になるまで待機します。 ">WaitEvent()</a> で待機しているスレッドがない場合には、 イベントは一旦 シグナル状態 を維持します。<br />
 その後、最初に <a class="el" href="namespacenn_1_1os.html#aabdcb2de0b5dbdd64a0ec3d7e65c72f4" title="EventType がシグナル状態になるまで待機します。 ">WaitEvent()</a> を発行したスレッドは即座に待ちが解除され、 イベント状態は自動的にクリアされます。</p>
<p><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a8b702480f5120eeeb01e7102227285da" title="イベントの手動クリア ">nn::os::EventClearMode_ManualClear</a> の場合、手動クリアとなります。<br />
 この場合、 <a class="el" href="namespacenn_1_1os.html#a9b959a51c1d28b76894597695fd3d081" title="EventType をシグナル状態にします。 ">SignalEvent()</a> 発行時に、 <a class="el" href="namespacenn_1_1os.html#aabdcb2de0b5dbdd64a0ec3d7e65c72f4" title="EventType がシグナル状態になるまで待機します。 ">WaitEvent()</a> で待機している全ての スレッドを待ち解除しますが、イベント状態はシグナル状態のまま変化せず、 <a class="el" href="namespacenn_1_1os.html#a46abbb4e59711874cfec72fe97b58e36" title="EventType をクリア状態にします。 ">ClearEvent()</a> 発行時にのみ、イベント状態をクリアすることが出来ます。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 event に対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_demo1_2_demo1_8cpp-example.html#a15">Demo1/Demo1.cpp</a>, <a class="el" href="_ldn_access_point_8cpp-example.html#a106">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a106">LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a57">MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a17">MoviePlayerSimple.cpp</a>, <a class="el" href="_os_event_8cpp-example.html#a11">OsEvent.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a30">OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_8cpp-example.html#a20">OsMultiWaitUtility.cpp</a>, <a class="el" href="_parallel_8cpp-example.html#a116">Parallel.cpp</a>, <a class="el" href="_perf_simple_8cpp-example.html#a70">PerfSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="adae3d14bd5e37dd1feee56bbf1717e37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> オブジェクトを Finalize します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が初期化状態である</li>
<li>event を待機しているスレッドがいない</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>event が未初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 イベントオブジェクトをファイナライズします。 既にファイナライズ済みであった場合には何もせずにリターンします。<br />
 対象イベントを待っているスレッドがある場合には、アサートに失敗します。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 event に対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_access_point_8cpp-example.html#a111">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a110">LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a64">MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a24">MoviePlayerSimple.cpp</a>, <a class="el" href="_os_event_8cpp-example.html#a20">OsEvent.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a41">OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_8cpp-example.html#a31">OsMultiWaitUtility.cpp</a>, <a class="el" href="_parallel_8cpp-example.html#a127">Parallel.cpp</a>, <a class="el" href="_perf_simple_8cpp-example.html#a72">PerfSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a9b959a51c1d28b76894597695fd3d081"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SignalEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> をシグナル状態にします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 イベントの状態を シグナル状態 にセットします。</p>
<p>イベントをシグナル状態にセットした後の振舞いは、 対象イベントの <a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452" title="イベントのクリアモードを表す列挙型です。 ">nn::os::EventClearMode</a> によって異なります。 詳細は <a class="el" href="namespacenn_1_1os.html#af07abef747ac6b51112b9e800ba9632c" title="EventType オブジェクトを初期化します。 ">InitializeEvent()</a> を参照して下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_access_point_8cpp-example.html#a24">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a24">LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a113">MovieDecoderPlayer.cpp</a>, <a class="el" href="_os_event_8cpp-example.html#a7">OsEvent.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a25">OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_8cpp-example.html#a15">OsMultiWaitUtility.cpp</a>, <a class="el" href="_parallel_8cpp-example.html#a11">Parallel.cpp</a>, <a class="el" href="_perf_simple_8cpp-example.html#a117">PerfSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aabdcb2de0b5dbdd64a0ec3d7e65c72f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::WaitEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> がシグナル状態になるまで待機します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 イベント状態が シグナル状態 になるまで待機します。<br />
 イベント状態が既に シグナル状態 の場合は、本 API は即座に成功します。<br />
 event が <a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="イベントの自動クリア ">nn::os::EventClearMode_AutoClear</a> の場合は、シグナル状態を検知すると 同時にイベントは非シグナル状態にクリアされます。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_access_point_8cpp-example.html#a93">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a93">LdnStation.cpp</a>, <a class="el" href="_os_event_8cpp-example.html#a4">OsEvent.cpp</a>, <a class="el" href="_parallel_8cpp-example.html#a12">Parallel.cpp</a>, <a class="el" href="_perf_simple_8cpp-example.html#a112">PerfSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a679439764fa7d9544094a0246ab6eebb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryWaitEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> のシグナル状態をポーリングします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>イベント待機の成否を示します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 イベント状態が シグナル状態 かどうかを確認します。<br />
 イベント状態が シグナル状態 の場合は、true を返します。<br />
 event が <a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="イベントの自動クリア ">nn::os::EventClearMode_AutoClear</a> の場合は、シグナル状態を検知すると 同時にイベントは非シグナル状態にクリアされます。</p>
<p>イベント状態が 非シグナル状態 の場合には、即座に false を返します。 本 API が待ちに入ることはありません。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_access_point_8cpp-example.html#a52">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a44">LdnStation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a9fba39baba3e475cae08127a632cab07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedWaitEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> がシグナル状態になるまで待機します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>最大待ち時間</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>イベント待機の成否を示します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が初期化状態である</li>
<li>timeout &gt;= 0</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 <a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> オブジェクトをシグナル状態になるまで時限付きで待機します。<br />
 イベント状態が既に シグナル状態 の場合は、スレッドは待機せずに 即座に true を返します。</p>
<p>event が <a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="イベントの自動クリア ">nn::os::EventClearMode_AutoClear</a> の場合は、シグナル状態を検知すると 同時にイベントは非シグナル状態にクリアされます。</p>
<p>自スレッドが待ちに入ってから timeout 時間経過すると、 タイムアウトが成立し、自動的に待ちが解除されます。<br />
 この場合、返値として false が返されます。</p>
<p>タイムアウトの動作に関しては <a class="el" href="_page_notification_os_timeout.html">OS-API のタイムアウトについて</a> の 注意事項も参照して下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_access_point_8cpp-example.html#a49">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a41">LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a121">MovieDecoderPlayer.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a46abbb4e59711874cfec72fe97b58e36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ClearEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> をクリア状態にします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_event_type.html" title="イベントオブジェクトを定義する構造体です。 ">EventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>event が非シグナル状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 イベント状態を 非シグナル状態 にクリアします。<br />
 対象イベントの clearMode によって、本 API の振舞いが 変わることはありません。</p>
<p>本 API はスレッドセーフですが、 本 API の発行と他スレッド上での <a class="el" href="namespacenn_1_1os.html#a9b959a51c1d28b76894597695fd3d081" title="EventType をシグナル状態にします。 ">SignalEvent()</a> や <a class="el" href="namespacenn_1_1os.html#aabdcb2de0b5dbdd64a0ec3d7e65c72f4" title="EventType がシグナル状態になるまで待機します。 ">WaitEvent()</a> が ほぼ同時に行なわれた場合、その順序関係は保証されないため注意が必要です。 そのため、本 API の使用は、対象 event が操作されていないことを ソフトウェア設計的に保障した上でご利用下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_movie_decoder_player_8cpp-example.html#a118">MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a32">MoviePlayerSimple.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a6">OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_8cpp-example.html#a6">OsMultiWaitUtility.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a4f8d998425d067cb5fec2604ae7845dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_event_type.html">EventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWaitHolder を初期化し、event と関連付けます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>多重待ちオブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>紐付ける先のイベントへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWaitHolder が未初期化状態である</li>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>multiWaitHolder が初期化状態である（event に関連付けられる）</li>
<li><a class="el" href="namespacenn_1_1os.html#a9e8c73312415fc00c72808fcc00fea33">nn::os::GetMultiWaitHolderUserData(multiWaitHolder)</a> == 0</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 multiWaitHolder を初期化し、event オブジェクトと関連付けます。</p>
<p>関連付けされた multiWaitHolder は、対象イベントがセットされた時に シグナル状態となります。また、対象イベントの状態が既にセットされて いた場合には、即座にシグナル状態となります。</p>
<p>本 API によって初期化された multiWaitHolder オブジェクトを使って多重待ちを 行ない、実際に対象イベントがシグナル化されることで多重待ちが解除された 場合でも、通常の <a class="el" href="namespacenn_1_1os.html#aabdcb2de0b5dbdd64a0ec3d7e65c72f4" title="EventType がシグナル状態になるまで待機します。 ">WaitEvent()</a> とは異なり、イベントが自動的に非シグナル状態に クリアされることはありません。<br />
 詳細は <a class="el" href="_page_notification_os_multi_wait.html#PageNotificationOsMultiWait_AboutWakeup">多重待ちの待ち解除について</a> を参照して下さい。</p>
<p>本 API の動作中に対象 multiWaitHolder に対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_echoback_8cpp-example.html#a63">AudioEchoback.cpp</a>, <a class="el" href="_ldn_access_point_8cpp-example.html#a18">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a18">LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a59">MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a34">MoviePlayerSimple.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a12">OsMultiWait.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a20238ce26424ba34876552fb2d53165a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::IsMemoryLocked </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定されたメモリ領域がロックされているかどうかを検査します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>検査対象のメモリ領域の先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>検査対象のメモリ領域のサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>size &gt; 0</li>
</ul>
</dd></dl>
<dl class="section return"><dt>戻り値</dt><dd>指定されたメモリ領域がロックされていれば true を、そうでなければ false を返します。</dd></dl>
<p><b>詳細</b> <br />
 特定のメモリ領域が他の用途で既に使用中の場合、間違った重複利用を 避けるために、当該メモリ領域はシステムによってロックされます。</p>
<p>本 API は指定されたメモリ領域が、上記のような ロックされた状態にあるか否かを検査し、その結果を bool 値で返します。</p>
<p>なお、本 API は製品機では使用できません。</p>
<div id="dynsection-Windows" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-Windows-trigger" src="closed.png"/>
  <b>（Windowsプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-Windows-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-Windows-content" class="dyncontent" style="display:none;"><ul>
<li>Windows 環境では本 API はサポートされていません。 本 API を発行すると内部でアボートします。</li>
</ul>
</div><div id="dynsection-Windows-content" class="dyncontent" style="display:none;"> </div> 
</div>
</div>
<a class="anchor" id="ac2789b550619d98db2c52198839d35c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::IsMemoryLocked </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定されたメモリ領域がロックされているかどうかを検査します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>検査対象のメモリ領域の先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>検査対象のメモリ領域のサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>size &gt; 0</li>
</ul>
</dd></dl>
<dl class="section return"><dt>戻り値</dt><dd>指定されたメモリ領域がロックされていれば true を、そうでなければ false を返します。</dd></dl>
<p><b>詳細</b> <br />
 <a class="el" href="namespacenn_1_1os.html#a20238ce26424ba34876552fb2d53165a">nn::os::IsMemoryLocked(void*, size_t)</a> と同機能です。</p>
<div id="dynsection-Windows" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-Windows-trigger" src="closed.png"/>
  <b>（Windowsプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-Windows-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-Windows-content" class="dyncontent" style="display:none;"><ul>
<li>Windows 環境では本 API はサポートされていません。 本 API を発行すると内部でアボートします。</li>
</ul>
</div><div id="dynsection-Windows-content" class="dyncontent" style="display:none;"> </div> 
</div>
</div>
<a class="anchor" id="af5900620f2a25ffdd500d7fbcba5fe26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeLightEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initiallySignaled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">EventClearMode</a>&#160;</td>
          <td class="paramname"><em>clearMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> オブジェクトを初期化します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initiallySignaled</td><td>軽量イベントの初期状態 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clearMode</td><td>軽量イベントの自動クリアモード</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が未初期化状態もしくは初期化されていない状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>initiallySignaled == true の場合、event はシグナル状態である。</li>
<li>initiallySignaled == false の場合、event は非シグナル状態である。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 軽量イベントオブジェクトを初期化します。</p>
<p>初期化された軽量イベントオブジェクトは、シグナル状態 と 非シグナル状態 の いずれか２つの状態を持ちます。初期状態は initiallySignaled で指定します。</p>
<p>軽量イベントオブジェクトのクリア方法として clearMode に以下のいずれかを 指定して下さい。</p>
<ul>
<li><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="イベントの自動クリア ">nn::os::EventClearMode_AutoClear</a> ・・・ 自動クリア</li>
<li><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a8b702480f5120eeeb01e7102227285da" title="イベントの手動クリア ">nn::os::EventClearMode_ManualClear</a> ・・・ 手動クリア</li>
</ul>
<p>自動クリアでは、シグナル状態にセットされることによっていずれかのスレッドが 起床した場合、自動的に非シグナル状態にクリアされます。 このため、複数のスレッドが待機していても一回のシグナル状態へのセットでは 一つのスレッドだけが起床します。</p>
<p>手動クリアではシグナル状態が自動的にクリアされることはありません。 そのため、複数のスレッドが待機しているなら一回のフラグのセットで 全てのスレッドが起床します。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 event に対する操作は行なわないで下さい。 </p>

</div>
</div>
<a class="anchor" id="a88b4a0191e818ad124b28b818349f072"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeLightEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> オブジェクトをファイナライズします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>event が未初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 軽量イベントオブジェクトをファイナライズします。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 event に対する操作は行なわないで下さい。 </p>

</div>
</div>
<a class="anchor" id="a07e40a45392d6eb98e2ca635bc0c3506"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SignalLightEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> をシグナル状態にセットします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 軽量イベントオブジェクトをシグナル状態にセットします。 対象イベントを待機しているスレッドがいる場合、そのスレッドを起床させます。 待機スレッドが存在しなかった場合、シグナル状態はセットされたままとなります。</p>
<p>自動クリアの場合は、複数のスレッドが待機していても 起床するスレッドは一つだけです。また、待機スレッドを起床させると同時に 非シグナル状態にクリアします。</p>
<p>手動クリアの場合、待機している全スレッドを起床させます。 こちらの場合は、シグナル状態はセットされたままとなります。 </p>

</div>
</div>
<a class="anchor" id="a148036d27d59d8b674c3f1b7579aa5c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::WaitLightEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> がシグナル状態になるまで待機します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 軽量イベントオブジェクトがシグナル状態にセットされるまで待機します。 軽量イベントが既にシグナル状態の場合は本 API は即座にリターンします。</p>
<p>自動クリアの場合は、シグナル状態を検知すると同時に 軽量イベントを非シグナル状態にクリアします。 手動クリアの場合はシグナル状態は自動的にはクリアされません。 </p>

</div>
</div>
<a class="anchor" id="ae1d2d9367d6312b284cd9e205a69adab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryWaitLightEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> のシグナル状態をポーリングします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>軽量イベントポーリングの成否を示します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 軽量イベントオブジェクトがシグナル状態かどうかをポーリングします。 軽量イベントがシグナル状態の場合には true を、 そうでなければ false を返します。 本 API が待ちに入ることはありません。</p>
<p>自動クリアの場合は、シグナル状態を検知すると同時に 軽量イベントを非シグナル状態にクリアします。 手動クリアの場合はシグナル状態は自動的にはクリアされません。 </p>

</div>
</div>
<a class="anchor" id="a6aeea3ec3d35c57cd757b4a3d2ff7273"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedWaitLightEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> がシグナル状態になるまで時限付きで待機します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>最大待ち時間</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>イベント待機の成否を示します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が初期化状態である</li>
<li>timeout &gt;= 0</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 軽量イベントオブジェクトがシグナル状態にセットされるまで時限付きで 待機します。シグナル状態を検知した場合は true を返し、シグナル状態を 検知できずに timeout 時間が経過した場合は false を返します。</p>
<p>シグナル状態を検知した場合、軽量イベントの自動クリアモードが 自動クリアの場合は、軽量イベントを非シグナル状態にクリアします。 手動クリアの場合はシグナル状態は自動的にはクリアされません。</p>
<p>タイムアウトの動作に関しては <a class="el" href="_page_notification_os_timeout.html">OS-API のタイムアウトについて</a> の 注意事項も参照して下さい。 </p>

</div>
</div>
<a class="anchor" id="ab236036e46ae861732a4c6418b63ec01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ClearLightEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_light_event_type.html">LightEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> をクリア状態にします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_light_event_type.html" title="軽量イベントオブジェクトを定義する構造体です。 ">LightEventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 軽量イベントオブジェクトを非シグナル状態にクリアします。 </p>

</div>
</div>
<a class="anchor" id="a9f0b5787e55da6b3b0e089d6b3ee6816"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeFiber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a> *&#160;</td>
          <td class="paramname"><em>fiber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#a00a0fffd9172c3779939c06927973bed">FiberFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fiberFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイバオブジェクトを初期化します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fiber</td><td><a class="el" href="structnn_1_1os_1_1_fiber_type.html" title="ファイバオブジェクトを定義する構造体です。 ">FiberType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>ファイバの関数エントリ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argument</td><td>ファイバに渡される引数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>ファイバのスタック領域の先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stackSize</td><td>ファイバのスタックサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fiberFlag</td><td>ファイバに付随するフラグ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>fiber が NotInitialized 状態もしくは初期化されていない状態である</li>
<li>fiberFlag に <a class="el" href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104ac2bbce12f37e3e01eb6a244e2ada14c7" title="スタックガードを設置しません ">nn::os::FiberFlag_NoStackGuard</a> が含まれる場合<ul>
<li>stack が <a class="el" href="namespacenn_1_1os.html#ab8818e7de49601e4f83bd6d3ee822449" title="ファイバスタック領域のアライメント制約を表す定数です。 ">nn::os::FiberStackAlignment</a> でアライメントされている</li>
<li>stackSize % <a class="el" href="namespacenn_1_1os.html#ab8818e7de49601e4f83bd6d3ee822449" title="ファイバスタック領域のアライメント制約を表す定数です。 ">nn::os::FiberStackAlignment</a> == 0</li>
<li>stackSize &gt; 0</li>
</ul>
</li>
<li>fiberFlag に <a class="el" href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104ac2bbce12f37e3e01eb6a244e2ada14c7" title="スタックガードを設置しません ">nn::os::FiberFlag_NoStackGuard</a> が含まれない場合<ul>
<li>stack が <a class="el" href="namespacenn_1_1os.html#a09b2d95cc4315e16021578c2ba43208d" title="ガード付きスタック領域のアライメント制約を表す定数です。 ">nn::os::GuardedStackAlignment</a> でアライメントされている</li>
<li>stackSize % <a class="el" href="namespacenn_1_1os.html#a09b2d95cc4315e16021578c2ba43208d" title="ガード付きスタック領域のアライメント制約を表す定数です。 ">nn::os::GuardedStackAlignment</a> == 0</li>
<li>stackSize &gt; 0</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>fiber が Ready 状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 fiber で指定されるファイバオブジェクトを初期化します。</p>
<p>ファイバは、利用者が手動でスケジューリングを行なう必要がある実行単位です。 ファイバは既存のスレッドコンテキスト上で動作し、 <a class="el" href="namespacenn_1_1os.html#a3ba39dbca8b416903a5e2947927ed3e0" title="ファイバの実行を開始もしくは再開します。 ">SwitchToFiber()</a> を明示的に呼び出すことで切り替えることができます。 ファイバが他のファイバによって自動的にプリエンプトされることはありません。</p>
<p>function はファイバ関数のエントリで、argument はファイバ関数に渡す引数、 stack と stackSize でファイバが使用するスタック領域を指定します。</p>
<p>fiberFlag には <a class="el" href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104" title="ファイバに付随するフラグを表す列挙型です。 ">nn::os::FiberFlag</a> で定義されている列挙子のパラメータを 論理和したものを指定します。</p>
<p>fiberFlag に <a class="el" href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104ac2bbce12f37e3e01eb6a244e2ada14c7" title="スタックガードを設置しません ">nn::os::FiberFlag_NoStackGuard</a> が含まれない場合は スタックガードを用意します。つまり、stack で指定された領域を他の空間に ミラーリングし、その前後にアクセス不可なガードページを設定した上で、 そこをファイバのスタック領域として使用します。</p>
<p>fiberFlag に <a class="el" href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104ac2bbce12f37e3e01eb6a244e2ada14c7" title="スタックガードを設置しません ">nn::os::FiberFlag_NoStackGuard</a> が含まれる場合はスタックガードを 用意しません。つまり、stack で指定された領域をそのままスタック領域として 使用します。スタック領域の前後にガードページは設定されないため、 スタックオーバーフロー等に注意して下さい。</p>
<p>カレントスレッドから初めてファイバへ遷移するには <a class="el" href="namespacenn_1_1os.html#a3ba39dbca8b416903a5e2947927ed3e0" title="ファイバの実行を開始もしくは再開します。 ">SwitchToFiber()</a> を 呼び出します。他のファイバから元々のスレッドへ戻るには、 SwitchToFiber( NULL ) のようにファイバオブジェクトに NULL を指定します。</p>
<p>全てのファイバは、その動作優先度や <a class="el" href="classnn_1_1os_1_1_thread_local_storage.html" title="スレッドローカルストレージを扱うためのクラスです。 ">nn::os::ThreadLocalStorage</a> などの スレッドに関連付けられるものについては、カレントスレッドのコンテキストと 共有しています。ただし、スタック領域だけはそれぞれのファイバで 専用のものを持ちます。</p>
<p>ファイバは他のスレッドで生成されたものであっても <a class="el" href="namespacenn_1_1os.html#a3ba39dbca8b416903a5e2947927ed3e0" title="ファイバの実行を開始もしくは再開します。 ">SwitchToFiber()</a> で 指定することができます。ただし、他のスレッドで実行中のファイバを 指定することは出来ません。</p>
<p>ファイバからリターンする際には、切り替え先のファイバを返値に指定する 必要があります。元々のスレッドに戻る場合には返値に NULL を渡して下さい。 また、一度リターンしたファイバに対して <a class="el" href="namespacenn_1_1os.html#a3ba39dbca8b416903a5e2947927ed3e0" title="ファイバの実行を開始もしくは再開します。 ">SwitchToFiber()</a> は出来ません。</p>
<div id="dynsection-Windows" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-Windows-trigger" src="closed.png"/>
  <b>（Windowsプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-Windows-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-Windows-content" class="dyncontent" style="display:none;"><ul>
<li>ファイバが使用するスタック領域は、指定された stack の場所ではなく、 Windows が独自に確保した領域が使用されます。</li>
<li>fiberFlag の <a class="el" href="namespacenn_1_1os.html#a39b515dc6753642a34364d91b5813104ac2bbce12f37e3e01eb6a244e2ada14c7" title="スタックガードを設置しません ">nn::os::FiberFlag_NoStackGuard</a> 指定は無視されます。</li>
</ul>
</div><div id="dynsection-Windows-content" class="dyncontent" style="display:none;"></div> <dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_fiber_8cpp-example.html#a10">OsFiber.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af54bbd489d9e733f72e8555d7ff940cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeFiber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a> *&#160;</td>
          <td class="paramname"><em>fiber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイバオブジェクトを破棄します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fiber</td><td><a class="el" href="structnn_1_1os_1_1_fiber_type.html" title="ファイバオブジェクトを定義する構造体です。 ">FiberType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>fiber が Ready, Completed のいずれかの状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>fiber が NotInitialized 状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 ファイバオブジェクトを破棄します。<br />
 対象ファイバが Running 状態の場合には内部のアサートに失敗します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_fiber_8cpp-example.html#a12">OsFiber.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a3ba39dbca8b416903a5e2947927ed3e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SwitchToFiber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a> *&#160;</td>
          <td class="paramname"><em>fiber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイバの実行を開始もしくは再開します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fiber</td><td><a class="el" href="structnn_1_1os_1_1_fiber_type.html" title="ファイバオブジェクトを定義する構造体です。 ">FiberType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>fiber が Ready 状態である</li>
<li>fiber != <a class="el" href="namespacenn_1_1os.html#a5bacafa4afccd548bb410d0f2fb3762e" title="カレントファイバの FiberType オブジェクトを取得します。 ">GetCurrentFiber()</a></li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>呼び出し前のカレントファイバが Ready 状態である</li>
<li>fiber が Running 状態である</li>
<li>fiber == <a class="el" href="namespacenn_1_1os.html#a5bacafa4afccd548bb410d0f2fb3762e" title="カレントファイバの FiberType オブジェクトを取得します。 ">GetCurrentFiber()</a></li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 現在動作中のスレッドもしくはファイバを停止し、 指定された fiber が指すファイバの実行を開始もしくは再開します。</p>
<p>fiber に NULL を指定すると、元々のスレッドから <a class="el" href="namespacenn_1_1os.html#a3ba39dbca8b416903a5e2947927ed3e0" title="ファイバの実行を開始もしくは再開します。 ">SwitchToFiber()</a> を 呼び出した場所へ復帰します。<br />
 また、カレントファイバを fiber に指定することはできません。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_fiber_8cpp-example.html#a8">OsFiber.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a5bacafa4afccd548bb410d0f2fb3762e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1os_1_1_fiber_type.html">FiberType</a>* nn::os::GetCurrentFiber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>カレントファイバの <a class="el" href="structnn_1_1os_1_1_fiber_type.html" title="ファイバオブジェクトを定義する構造体です。 ">FiberType</a> オブジェクトを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="structnn_1_1os_1_1_fiber_type.html" title="ファイバオブジェクトを定義する構造体です。 ">FiberType</a> オブジェクトへのポインタです。</dd></dl>
<p><b>詳細</b> <br />
 現在実行中のファイバの <a class="el" href="structnn_1_1os_1_1_fiber_type.html" title="ファイバオブジェクトを定義する構造体です。 ">FiberType</a> オブジェクトへのポインタを返します。<br />
 現在実行中のファイバがない場合（単にスレッドを実行中の場合）には、 NULL を返します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_fiber_8cpp-example.html#a7">OsFiber.cpp</a>, <a class="el" href="_os_user_exception_handler_sample_8cpp-example.html#a18">OsUserExceptionHandlerSample.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a9fdcd9b26aa9e78c2c17f6b9c02c0314"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeTimerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452">EventClearMode</a>&#160;</td>
          <td class="paramname"><em>clearMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトを初期化します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clearMode</td><td>タイマーイベントの自動クリアモード</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が未初期化状態もしくは初期化されていない状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 タイマーイベントオブジェクトを初期化します。</p>
<p>タイマーイベントオブジェクトは、通常のイベント機能に加え、 指定した時間だけ遅延してシグナル化させることの出来る機能を備えています。 ただし、時限付きの待機機能はありません。</p>
<p>初期化されたタイマーイベントオブジェクトは、 シグナル状態 と 非シグナル状態 のいずれか 2 つの状態を持ちます。 初期化直後の状態は 非シグナル状態 です。</p>
<p>シグナル化したタイマーイベントオブジェクトのクリア方法として、 clearMode に以下の 2 つのいずれかを指定します。</p>
<ul>
<li><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="イベントの自動クリア ">nn::os::EventClearMode_AutoClear</a></li>
<li><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a8b702480f5120eeeb01e7102227285da" title="イベントの手動クリア ">nn::os::EventClearMode_ManualClear</a></li>
</ul>
<p><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="イベントの自動クリア ">nn::os::EventClearMode_AutoClear</a> の場合、自動クリアとなります。<br />
 この場合、 <a class="el" href="namespacenn_1_1os.html#ad526c59d6481d5fcf0e130d71c7f1252" title="TimerEventType オブジェクトを即座にシグナル状態にします。 ">SignalTimerEvent()</a> を発行すると <a class="el" href="namespacenn_1_1os.html#a3bdecafeed401cb6b8accdb15178ad66" title="TimerEventType オブジェクトがシグナル状態になるまで待機します。 ">WaitTimerEvent()</a> で待機している スレッドを 1 つだけ待ち解除し、タイマーイベントを非シグナル状態にクリア します。<br />
 <a class="el" href="namespacenn_1_1os.html#ad526c59d6481d5fcf0e130d71c7f1252" title="TimerEventType オブジェクトを即座にシグナル状態にします。 ">SignalTimerEvent()</a> 発行時に <a class="el" href="namespacenn_1_1os.html#a3bdecafeed401cb6b8accdb15178ad66" title="TimerEventType オブジェクトがシグナル状態になるまで待機します。 ">WaitTimerEvent()</a> で待機しているスレッドがない 場合には、タイマーイベントは一旦 シグナル状態 にセットされます。 その後、最初に <a class="el" href="namespacenn_1_1os.html#a3bdecafeed401cb6b8accdb15178ad66" title="TimerEventType オブジェクトがシグナル状態になるまで待機します。 ">WaitTimerEvent()</a> を発行したスレッドは即座に待ちが解除され、 タイマーイベントは自動的に非シグナル状態にクリアされます。</p>
<p><a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a8b702480f5120eeeb01e7102227285da" title="イベントの手動クリア ">nn::os::EventClearMode_ManualClear</a> の場合、手動クリアとなります。<br />
 この場合、 <a class="el" href="namespacenn_1_1os.html#ad526c59d6481d5fcf0e130d71c7f1252" title="TimerEventType オブジェクトを即座にシグナル状態にします。 ">SignalTimerEvent()</a> を発行すると <a class="el" href="namespacenn_1_1os.html#a3bdecafeed401cb6b8accdb15178ad66" title="TimerEventType オブジェクトがシグナル状態になるまで待機します。 ">WaitTimerEvent()</a> で待機している 全てのスレッドを待ち解除しますが、タイマーイベントはシグナル状態を維持 します。タイマーイベントを非シグナル状態にクリアするには、 <a class="el" href="namespacenn_1_1os.html#a2612c1c11f55172e23bf13d0b8a4e5b2" title="TimerEventType オブジェクトを非シグナル状態にクリアします。 ">ClearTimerEvent()</a> を発行します。</p>
<p>上記のクリア動作は、 <a class="el" href="namespacenn_1_1os.html#a9b3ec8d6c3a7f4410dc6f9c4dec0f88d" title="TimerEventType オブジェクトのワンショットタイマー動作を開始します。 ">StartOneShotTimerEvent()</a> や <a class="el" href="namespacenn_1_1os.html#ac869e53e9d805c3a5781d6493fad6ccd" title="TimerEventType オブジェクトの周期タイマー動作を開始します。 ">StartPeriodicTimerEvent()</a> によってシグナル化された場合でも同様です。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象タイマーイベントに対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_hid_vibration_player_8cpp-example.html#a49">HidVibrationPlayer.cpp</a>, <a class="el" href="_os_timer_event_8cpp-example.html#a13">OsTimerEvent.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1752ba511e60ce027c4af0f6d5e3ebe9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeTimerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトを破棄します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が初期化状態である</li>
<li>event を待機しているスレッドがいない</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>event が未初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 タイマーイベントオブジェクトを破棄します。<br />
 対象タイマーイベントを待っているスレッドがある場合には、 アサートに失敗します。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象タイマーイベントに対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_hid_vibration_player_8cpp-example.html#a59">HidVibrationPlayer.cpp</a>, <a class="el" href="_os_timer_event_8cpp-example.html#a26">OsTimerEvent.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a9b3ec8d6c3a7f4410dc6f9c4dec0f88d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::StartOneShotTimerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトのワンショットタイマー動作を開始します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>最初のタイマー通知までの時間</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が初期化状態である</li>
<li>first &gt;= 0</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 タイマーイベントのワンショットタイマー動作を開始します。<br />
 first には、タイマーイベントがシグナル化されるまでの時間を指定します。</p>
<p>既にタイマー動作が開始されていた場合、そのタイマーは一旦停止させられ、 新しいワンショットタイマーとして動作を開始します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_timer_event_8cpp-example.html#a23">OsTimerEvent.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac869e53e9d805c3a5781d6493fad6ccd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::StartPeriodicTimerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトの周期タイマー動作を開始します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>最初のタイマー通知までの時間 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interval</td><td>2 度目以降のタイマー通知の間隔</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が初期化状態である</li>
<li>first &gt;= 0</li>
<li>interval &gt; 0</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 タイマーイベントの周期タイマー動作を開始します。<br />
 first には、タイマーイベントがシグナル化されるまでの時間を指定し、 interval には 2 度目以降のタイマー通知の間隔を指定します。</p>
<p>既にタイマー動作が開始されていた場合、そのタイマーは一旦停止させられ、 新しい周期タイマーとして動作を開始します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_hid_vibration_player_8cpp-example.html#a56">HidVibrationPlayer.cpp</a>, <a class="el" href="_os_timer_event_8cpp-example.html#a22">OsTimerEvent.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6aa23680b72e19fd5cb974ef44325695"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::StopTimerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトのタイマー動作を停止します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 タイマーイベントのタイマー動作を停止します。<br />
 本 API によってタイマーイベントのシグナル状態が変化することはありません。 また、待機スレッドがあっても、そのスレッドが本 API によって起床される こともありません。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_hid_vibration_player_8cpp-example.html#a23">HidVibrationPlayer.cpp</a>, <a class="el" href="_os_timer_event_8cpp-example.html#a9">OsTimerEvent.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a3bdecafeed401cb6b8accdb15178ad66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::WaitTimerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトがシグナル状態になるまで待機します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 タイマーイベントが シグナル状態 になるまで待機します。<br />
 タイマーイベントが既に シグナル状態 の場合は、本 API は即座に返ります。<br />
 タイマーイベントが <a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="イベントの自動クリア ">nn::os::EventClearMode_AutoClear</a> の場合は、シグナル状態を 検知すると同時にタイマーイベントは非シグナル状態にクリアされます。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_hid_vibration_player_8cpp-example.html#a21">HidVibrationPlayer.cpp</a>, <a class="el" href="_os_timer_event_8cpp-example.html#a7">OsTimerEvent.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa431fe82cc23064bbad8cacf102756fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryWaitTimerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトがシグナル状態かをポーリングします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>タイマーイベント待機の成否を示します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 タイマーイベントが シグナル状態 かどうかを確認します。<br />
 タイマーイベントが既に シグナル状態 の場合は即座に true を返します。 更にタイマーイベントが <a class="el" href="namespacenn_1_1os.html#a11ab71d44973a4135958c420e5682452a31f6133098296b3ddb7e14da3dc695cc" title="イベントの自動クリア ">nn::os::EventClearMode_AutoClear</a> の場合は、シグナル状態を 検知すると同時にタイマーイベントは非シグナル状態にクリアされます。</p>
<p>タイマーイベントが 非シグナル状態 の場合には即座に false を返します。 </p>

</div>
</div>
<a class="anchor" id="ad526c59d6481d5fcf0e130d71c7f1252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SignalTimerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトを即座にシグナル状態にします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 タイマーイベントを即座に シグナル状態 にセットします。<br />
 本 API によってタイマーイベントがシグナル状態にセットされても、 タイマー動作には影響を与えません。 </p>

</div>
</div>
<a class="anchor" id="a2612c1c11f55172e23bf13d0b8a4e5b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ClearTimerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトを非シグナル状態にクリアします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>event が非シグナル状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 タイマーイベントを 非シグナル状態 にクリアします。 本 API によってタイマーイベントが非シグナル状態にクリアされても、 タイマー動作には影響を与えません。 </p>

</div>
</div>
<a class="anchor" id="a4083f1b95f58372c092726cfd9800054"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_timer_event_type.html">TimerEventType</a> *&#160;</td>
          <td class="paramname"><em>timerEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWaitHolder を初期化し、タイマーイベントと関連付けます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>多重待ちオブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timerEvent</td><td>関連付ける <a class="el" href="structnn_1_1os_1_1_timer_event_type.html" title="タイマーイベントオブジェクトを定義する構造体です。 ">TimerEventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWaitHolder が未初期化状態である</li>
<li>timerEvent が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>multiWaitHolder が初期化状態である（timerEvent に関連付けられる）</li>
<li><a class="el" href="namespacenn_1_1os.html#a9e8c73312415fc00c72808fcc00fea33">nn::os::GetMultiWaitHolderUserData(multiWaitHolder)</a> == 0</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 multiWaitHolder を初期化し、timerEvent オブジェクトと関連付けます。</p>
<p>関連付けされた multiWaitHolder は、対象タイマーイベントがシグナル状態に セットされた時に シグナル状態 となります。また、対象タイマーイベントが 既にセットされていた場合には、即座にシグナル状態となります。</p>
<p>本 API によって初期化された multiWaitHolder オブジェクトを使って多重待ちを 行ない、実際に対象のタイマーイベントがシグナル化されることで多重待ちが解除 された場合でも、通常の <a class="el" href="namespacenn_1_1os.html#a3bdecafeed401cb6b8accdb15178ad66" title="TimerEventType オブジェクトがシグナル状態になるまで待機します。 ">WaitTimerEvent()</a> とは異なり、タイマーイベントが 自動的に非シグナル状態にクリアされることはありません。<br />
 詳細は <a class="el" href="_page_notification_os_multi_wait.html#PageNotificationOsMultiWait_AboutWakeup">多重待ちの待ち解除について</a> を参照して下さい。</p>
<p>本 API の動作中に対象 multiWaitHolder に対する操作は行なわないで下さい。 </p>

</div>
</div>
<a class="anchor" id="a3d924bc362ec80648323428be5182338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::DestroySystemEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="システムイベントオブジェクトを定義する構造体です。 ">SystemEventType</a> オブジェクトを破棄します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="システムイベントオブジェクトを定義する構造体です。 ">SystemEventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event オブジェクトが初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>event オブジェクトが未初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 <a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="システムイベントオブジェクトを定義する構造体です。 ">SystemEventType</a> オブジェクトを破棄します。</p>
<p>本 API の動作中に対象 event オブジェクトに対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_cpu_renderer_8cpp-example.html#a158">AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_8cpp-example.html#a132">AudioDevice.cpp</a>, <a class="el" href="_audio_echoback_8cpp-example.html#a58">AudioEchoback.cpp</a>, <a class="el" href="_audio_effect_8cpp-example.html#a173">AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_8cpp-example.html#a151">AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_8cpp-example.html#a124">AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_8cpp-example.html#a59">AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_out_8cpp-example.html#a90">AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_8cpp-example.html#a93">AudioOutWithResampler.cpp</a>, <a class="el" href="_audio_performance_metrics_8cpp-example.html#a163">AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_8cpp-example.html#a143">AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_8cpp-example.html#a119">AudioSink.cpp</a>, <a class="el" href="_audio_splitter_8cpp-example.html#a161">AudioSplitter.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_8cpp-example.html#a82">CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_8cpp-example.html#a81">CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_8cpp-example.html#a81">CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_8cpp-example.html#a90">CodecOpusMultiStreamDecoder.cpp</a> (計17項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa689721442ec303678047dd75c957bea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::WaitSystemEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>システムイベントがシグナル状態になるまで待機します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="システムイベントオブジェクトを定義する構造体です。 ">SystemEventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event オブジェクトが初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 システムイベントがシグナル状態になるまで待機します。<br />
 システムイベントが既にシグナル状態の場合は即座に返ります。 </p>

</div>
</div>
<a class="anchor" id="a0367a830f313d114698a17311e7274c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryWaitSystemEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>システムイベントがシグナル状態かをポーリングします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="システムイベントオブジェクトを定義する構造体です。 ">SystemEventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>システムイベントオブジェクト待機の成否を示します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event オブジェクトが初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 システムイベントがシグナル状態か否かをポーリングします。<br />
 システムイベントが既にシグナル状態の場合は即座に true を返します。<br />
 システムイベントが非シグナル状態の場合は待機せずに false を返します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_access_point_8cpp-example.html#a21">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a21">LdnStation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af25710360462b312201c3685e238f46e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedWaitSystemEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>システムイベントがシグナル状態になるまで待機します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="システムイベントオブジェクトを定義する構造体です。 ">SystemEventType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>最大待ち時間</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>システムイベントオブジェクト待機の成否を示します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event オブジェクトが初期化状態である</li>
<li>timeout &gt;= 0</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 システムイベントがシグナル状態になるまで待機します。<br />
 システムイベントがシグナル状態になると true を返します。<br />
 自スレッドが待ちに入ってから timeout 時間経過するとタイムアウトが成立し、 自動的に待ちが解除されます。この場合、返値として false が返されます。</p>
<p>タイムアウトの動作に関しては <a class="el" href="_page_notification_os_timeout.html">OS-API のタイムアウトについて</a> の 注意事項も参照して下さい。 </p>

</div>
</div>
<a class="anchor" id="a70789090416cc882f4aa2c786092e49a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ClearSystemEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>システムイベントを非シグナル状態にクリアします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="システムイベントオブジェクトを定義する構造体です。 ">SystemEventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>event オブジェクトが初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 システムイベントを 非シグナル状態 にクリアします。 </p>

</div>
</div>
<a class="anchor" id="a4b03654db54c77da2e8a8c185257d250"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_system_event_type.html">SystemEventType</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWaitHolder を初期化し <a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="システムイベントオブジェクトを定義する構造体です。 ">SystemEventType</a> オブジェクトと関連付けます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>多重待ちオブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>関連付ける先の <a class="el" href="structnn_1_1os_1_1_system_event_type.html" title="システムイベントオブジェクトを定義する構造体です。 ">SystemEventType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWaitHolder が未初期化状態である</li>
<li>event が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>multiWaitHolder が初期化状態である（event に関連付けられる）</li>
<li><a class="el" href="namespacenn_1_1os.html#a9e8c73312415fc00c72808fcc00fea33">nn::os::GetMultiWaitHolderUserData(multiWaitHolder)</a> == 0</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 multiWaitHolder を初期化し event オブジェクトと関連付けます。</p>
<p>関連付けられた multiWaitHolder は、対象のシステムイベントの状態に 合わせてシグナル状態か否かが変化します。</p>
<p>本 API によって初期化された multiWaitHolder オブジェクトを使って多重待ちを 行ない、実際に対象のシステムイベントがシグナル化されることで多重待ちが解除 された場合でも、通常の <a class="el" href="namespacenn_1_1os.html#aa689721442ec303678047dd75c957bea" title="システムイベントがシグナル状態になるまで待機します。 ">WaitSystemEvent()</a> とは異なり、システムイベントが 自動的に非シグナル状態にクリアされることはありません。<br />
 詳細は <a class="el" href="_page_notification_os_multi_wait.html#PageNotificationOsMultiWait_AboutWakeup">多重待ちの待ち解除について</a> を参照して下さい。</p>
<p>本 API の動作中に対象 multiWaitHolder に対する操作は行なわないで下さい。 </p>

</div>
</div>
<a class="anchor" id="ab7baa013ea5d9d4f9e84eb5d1afcec49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッセージキューオブジェクトを初期化します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="メッセージキューオブジェクトを定義する構造体です。 ">MessageQueueType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>メッセージキューのバッファ先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>メッセージキューに格納できるデータの最大個数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>messageQueue が未初期化状態もしくは初期化されていない状態である</li>
<li>buffer の先に count * sizeof(uintptr_t) バイト分のメモリ領域がある</li>
<li>count &gt;= 1</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>messageQueue が初期化状態（Empty 状態）である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 <a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="メッセージキューオブジェクトを定義する構造体です。 ">MessageQueueType</a> オブジェクトを初期化します。<br />
 すなわち、蓄積メッセージデータなし、送信待ちスレッドなし、 受信待ちスレッドなしに初期化します。<br />
 メッセージキューのバッファ領域には、uintptr_t 型の配列を渡して下さい。 ここには count * sizeof(uintptr_t) だけの領域が確保されていなければ なりません。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 messageQueue に対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_movie_decoder_player_8cpp-example.html#a62">MovieDecoderPlayer.cpp</a>, <a class="el" href="_os_message_queue_8cpp-example.html#a9">OsMessageQueue.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a32">OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_8cpp-example.html#a22">OsMultiWaitUtility.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af9c98095075b7ef0570c1a449545e392"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッセージキューオブジェクトをファイナライズします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="メッセージキューオブジェクトを定義する構造体です。 ">MessageQueueType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>messageQueue が初期化状態である</li>
<li>messageQueue を待機しているスレッドがいない</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>messageQueue が未初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 <a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="メッセージキューオブジェクトを定義する構造体です。 ">MessageQueueType</a> オブジェクトをファイナライズします。<br />
 メッセージキューにデータが残っていてもファイナライズ可能ですが、<br />
 メッセージキューに対して送信待ち／受信待ちのスレッドがある場合には、 アサートに失敗します。</p>
<p>ファイナライズ完了後は、メッセージキューバッファとして使用していた領域は 他の用途で再利用できます。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 messageQueue に対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_movie_decoder_player_8cpp-example.html#a68">MovieDecoderPlayer.cpp</a>, <a class="el" href="_os_message_queue_8cpp-example.html#a17">OsMessageQueue.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a42">OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_8cpp-example.html#a32">OsMultiWaitUtility.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="afec9c0c3cacf43c7aa82f323da656af5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SendMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッセージキューの最後尾にデータを１つ送信します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="メッセージキューオブジェクトを定義する構造体です。 ">MessageQueueType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>送信データ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>messageQueue が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>messageQueue が NotEmpty 状態である</li>
<li>messageQueue のデータ列の最後尾に data を追加する</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 メッセージキューの最後尾にデータを１つ送信します。<br />
 メッセージキューに空きがある場合、データを送信して即座にリターンします。</p>
<p>メッセージキューに空きがない場合、自スレッドは送信待ちに入ります。<br />
 送信待ちから解除された場合、データを送信してからリターンします。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_movie_decoder_player_8cpp-example.html#a112">MovieDecoderPlayer.cpp</a>, <a class="el" href="_os_message_queue_8cpp-example.html#a2">OsMessageQueue.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a26">OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_8cpp-example.html#a16">OsMultiWaitUtility.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a78cd82954aa87f10f881a7e34fad596b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TrySendMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッセージキューの最後尾にデータを１つ送信します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="メッセージキューオブジェクトを定義する構造体です。 ">MessageQueueType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>送信データ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>メッセージキューへの送信の成否を示します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>messageQueue が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>返値が true の場合<ul>
<li>messageQueue が NotEmpty 状態である</li>
<li>messageQueue のデータ列の最後尾に data を追加</li>
</ul>
</li>
<li>返値が false の場合<ul>
<li>messageQueue が初期化状態である （状態は変化しない）</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 メッセージキューの最後尾にデータを１つ送信します。<br />
 メッセージキューに空きがある場合、データを送信して true を返します。<br />
 メッセージキューに空きがない場合、待ち状態へ移行せずに false を返します。 </p>

</div>
</div>
<a class="anchor" id="ad5e14ae7d5a67147af209a1029991095"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedSendMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッセージキューの最後尾にデータを１つ送信します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="メッセージキューオブジェクトを定義する構造体です。 ">MessageQueueType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>送信データ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>最大待ち時間</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>メッセージキューへの送信の成否を示します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>messageQueue が初期化状態である</li>
<li>timeout &gt;= 0</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>返値が true の場合<ul>
<li>messageQueue が NotEmpty 状態である</li>
<li>messageQueue のデータ列の最後尾に data を追加</li>
</ul>
</li>
<li>返値が false の場合<ul>
<li>messageQueue が初期化状態である （状態は変化しない）</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 メッセージキューの最後尾にデータを１つ送信します。<br />
 メッセージキューに空きがある場合、データを送信して true を返します。</p>
<p>メッセージキューに空きがない場合、自スレッドは送信待ちに入ります。<br />
 その後、メッセージキューに空きが出来た場合、送信待ちが解除され、 データを送信してリターンします。この時、true を返します。</p>
<p>自スレッドが待ちに入った後、timeout 時間経った場合は、 タイムアウトが成立し自動的に待ちが解除されてリターンします。<br />
 この場合には、データは送信されずに false を返します。</p>
<p>タイムアウトの動作に関しては <a class="el" href="_page_notification_os_timeout.html">OS-API のタイムアウトについて</a> の 注意事項も参照して下さい。 </p>

</div>
</div>
<a class="anchor" id="a7a47bc9d914dbdf48011deeb859cb877"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::JamMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッセージキューの先頭にデータを１つ送信します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="メッセージキューオブジェクトを定義する構造体です。 ">MessageQueueType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>送信データ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>messageQueue が初期化状態である </li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>messageQueue が NotEmpty 状態である</li>
<li>messageQueue のデータ列の先頭に data を追加する</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 メッセージキューの先頭にデータを１つ送信します。<br />
 メッセージキューに空きがある場合、データを送信して即座にリターンします。</p>
<p>メッセージキューに空きがない場合、自スレッドは送信待ちに入ります。<br />
 送信待ちから解除された場合、データを送信してからリターンします。 </p>

</div>
</div>
<a class="anchor" id="aa6fd916fb5a94b34c37d2b8faa43ce3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryJamMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッセージキューの先頭にデータを１つ送信します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="メッセージキューオブジェクトを定義する構造体です。 ">MessageQueueType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>送信データ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>メッセージキューへの送信の成否を示します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>messageQueue が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>返値が true の場合<ul>
<li>messageQueue が NotEmpty 状態である</li>
<li>messageQueue のデータ列の先頭に data を追加する</li>
</ul>
</li>
<li>返値が false の場合<ul>
<li>messageQueue が初期化状態である （状態は変化しない）</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 メッセージキューの先頭にデータを１つ送信します。<br />
 メッセージキューに空きがある場合、データを送信して true を返します。<br />
 メッセージキューに空きがない場合、待ち状態へ移行せずに false を返します。 </p>

</div>
</div>
<a class="anchor" id="ad4cfd66c4587832586ee7a50e5fd90b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedJamMessageQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッセージキューの先頭にデータを１つ送信します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="メッセージキューオブジェクトを定義する構造体です。 ">MessageQueueType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>送信データ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>最大待ち時間</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>メッセージキューへの送信の成否を示します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>messageQueue が初期化状態である</li>
<li>timeout &gt;= 0</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>返値が true の場合<ul>
<li>messageQueue が NotEmpty 状態である</li>
<li>messageQueue のデータ列の先頭に data を追加する</li>
</ul>
</li>
<li>返値が false の場合<ul>
<li>messageQueue が初期化状態である （状態は変化しない）</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 メッセージキューの先頭にデータを１つ送信します。<br />
 メッセージキューに空きがある場合、データを送信して true を返します。</p>
<p>メッセージキューに空きがない場合、自スレッドは送信待ちに入ります。<br />
 その後、メッセージキューに空きが出来た場合、送信待ちが解除され、 データを送信してリターンします。この時、true を返します。</p>
<p>自スレッドが待ちに入った後、timeout 時間経った場合、 タイムアウトが成立し自動的に待ちが解除されます。<br />
 この場合には、データは送信されずに false を返します。</p>
<p>タイムアウトの動作に関しては <a class="el" href="_page_notification_os_timeout.html">OS-API のタイムアウトについて</a> の 注意事項も参照して下さい。 </p>

</div>
</div>
<a class="anchor" id="ace7ad0de1da8fdeeeb01e7de7494dc87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ReceiveMessageQueue </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッセージキューの先頭からデータを１つ受信します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outData</td><td>受信データの格納先 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="メッセージキューオブジェクトを定義する構造体です。 ">MessageQueueType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>messageQueue が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>messageQueue が NotFull 状態である</li>
<li>messageQueue のデータ列の先頭のデータを取得し outData に格納する</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 メッセージキューの先頭からデータを１つ受信します。<br />
 メッセージキューにデータが１つ以上ある場合、データを取り出して、 outData の指す領域にデータを格納します。<br />
 メッセージキューにデータが１つもない場合、自スレッドは受信待ちに入ります。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_movie_decoder_player_8cpp-example.html#a114">MovieDecoderPlayer.cpp</a>, <a class="el" href="_os_message_queue_8cpp-example.html#a4">OsMessageQueue.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a7">OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_8cpp-example.html#a7">OsMultiWaitUtility.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a921571e9781d3e6fbf60ca8ee4a1825d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryReceiveMessageQueue </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッセージキューの先頭からデータを１つ受信します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outData</td><td>受信データの格納先 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="メッセージキューオブジェクトを定義する構造体です。 ">MessageQueueType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>メッセージキューからの受信の成否を示します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>messageQueue が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>返値が true の場合<ul>
<li>messageQueue が NotFull 状態である</li>
<li>messageQueue のデータ列の先頭のデータを取得し outData に格納する</li>
</ul>
</li>
<li>返値が false の場合<ul>
<li>messageQueue が初期化状態である （状態は変化しない）</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 メッセージキューの先頭からデータを１つ受信します。<br />
 メッセージキューにデータが１つ以上ある場合、データを取り出して、 outData の指す領域にデータを格納して true を返します。<br />
 メッセージキューにデータが１つもない場合、 自スレッドは待ち状態へ移行せずに false を返します。 </p>

</div>
</div>
<a class="anchor" id="ae0838f36e8391d50f81549950611aeb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedReceiveMessageQueue </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッセージキューの先頭からデータを１つ受信します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outData</td><td>受信データの格納先 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="メッセージキューオブジェクトを定義する構造体です。 ">MessageQueueType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>最大待ち時間</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>メッセージキューからの受信の成否を示します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>messageQueue が初期化状態である</li>
<li>timeout &gt;= 0</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>返値が true の場合<ul>
<li>messageQueue が NotFull 状態である</li>
<li>messageQueue のデータ列の先頭のデータを取得し outData に格納する</li>
</ul>
</li>
<li>返値が false の場合<ul>
<li>messageQueue が初期化状態である （状態は変化しない）</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 メッセージキューの先頭からデータを１つ受信します。<br />
 メッセージキューにデータが１つ以上ある場合、データを取り出して、 outData の指す領域にデータを格納して true を返します。<br />
 メッセージキューにデータが１つもない場合、自スレッドは受信待ちに入ります。</p>
<p>自スレッドが待ちに入った後、timeout 時間経った場合、 タイムアウトが成立し自動的に待ちが解除されます。<br />
 この場合には、データは受信されずに false を返します。</p>
<p>タイムアウトの動作に関しては <a class="el" href="_page_notification_os_timeout.html">OS-API のタイムアウトについて</a> の 注意事項も参照して下さい。 </p>

</div>
</div>
<a class="anchor" id="a7fab6d997fb47451e6c9cd47ef754e99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::PeekMessageQueue </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッセージキューの先頭データを参照します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outData</td><td>参照データの格納先 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="メッセージキューオブジェクトを定義する構造体です。 ">MessageQueueType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>messageQueue が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>messageQueue が初期化状態である （状態は変化しない）</li>
<li>messageQueue のデータ列の先頭のデータを参照し、outData に格納する</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 メッセージキューの先頭にあるデータを参照し、そのデータを outData の 指す領域に格納します。如何なる場合も、データは実際には取り出さず、 メッセージキューの状態は変化しません。</p>
<p>メッセージキューにデータが１つ以上ある場合、データを参照して即座に リターンします。メッセージキューにデータが１つもない場合は、 自スレッドは受信待ちに入ります。 </p>

</div>
</div>
<a class="anchor" id="a6f08aef79a422888383a8ab1d5786fe3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryPeekMessageQueue </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッセージキューの先頭データを参照します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outData</td><td>参照データの格納先 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="メッセージキューオブジェクトを定義する構造体です。 ">MessageQueueType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>メッセージキューからのデータ参照の成否を示します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>messageQueue が初期化状態である </li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>返値が true の場合<ul>
<li>messageQueue が初期化状態である （状態は変化しない）</li>
<li>messageQueue のデータ列の先頭のデータを参照し outData に格納する</li>
</ul>
</li>
<li>返値が false の場合<ul>
<li>messageQueue が初期化状態である （状態は変化しない）</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 メッセージキューの先頭にあるデータを参照し、そのデータを outData の 指す領域に格納します。如何なる場合も、データは実際には取り出さず、 メッセージキューの状態は変化しません。</p>
<p>メッセージキューにデータが１つ以上ある場合、データを参照して true を 返します。メッセージキューにデータが１つもない場合は、 待ち状態へ移行せずに false を返します。 </p>

</div>
</div>
<a class="anchor" id="a0dc5fb4ad2ef7a5dfff029e0128efa55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedPeekMessageQueue </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>outData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッセージキューの先頭データを参照します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outData</td><td>参照データの格納先 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td><a class="el" href="structnn_1_1os_1_1_message_queue_type.html" title="メッセージキューオブジェクトを定義する構造体です。 ">MessageQueueType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>最大待ち時間</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>メッセージキューからのデータ参照の成否を示します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>messageQueue が初期化状態である</li>
<li>timeout &gt;= 0</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>返値が true の場合<ul>
<li>messageQueue が初期化状態である （状態は変化しない）</li>
<li>messageQueue のデータ列の先頭のデータを参照し outData に格納する</li>
</ul>
</li>
<li>返値が false の場合<ul>
<li>messageQueue が初期化状態である （状態は変化しない）</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 メッセージキューの先頭にあるデータを参照し、そのデータを outData の 指す領域に格納します。如何なる場合も、データは実際には取り出さず、 メッセージキューの状態は変化しません。</p>
<p>メッセージキューにデータが１つ以上ある場合、データを参照して true を 返します。メッセージキューにデータが１つもない場合は、 自スレッドは受信待ちに入ります。</p>
<p>自スレッドが待ちに入った後、timeout 時間経った場合、 タイムアウトが成立し自動的に待ちが解除されます。<br />
 この場合には、データは取得されずに false を返します。</p>
<p>タイムアウトの動作に関しては <a class="el" href="_page_notification_os_timeout.html">OS-API のタイムアウトについて</a> の 注意事項も参照して下さい。 </p>

</div>
</div>
<a class="anchor" id="a241484ed12a060d60eeb234db88484d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bc">MessageQueueWaitType</a>&#160;</td>
          <td class="paramname"><em>waitType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWaitHolder を初期化し、messageQueue と関連付けます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>多重待ちオブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>紐付ける先のメッセージキューへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitType</td><td>メッセージキューの待ち種別</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWaitHolder が未初期化状態である</li>
<li>messageQueue が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>multiWaitHolder が初期化状態である（messageQueue に関連付けられる）</li>
<li><a class="el" href="namespacenn_1_1os.html#a9e8c73312415fc00c72808fcc00fea33">nn::os::GetMultiWaitHolderUserData(multiWaitHolder)</a> == 0</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 multiWaitHolder を初期化し、messageQueue オブジェクトと関連付けます。</p>
<p>waitType には以下の２つのいずれかから指定します。</p><ul>
<li><a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bca0fa8f18b62354b68a7838af2bf4e6f01" title="メッセージキューに空きが出来るまで待つ ">nn::os::MessageQueueWaitType_WaitForNotFull</a></li>
<li><a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bca40a79a4dabe0233dd5c21d7c4a718eea" title="メッセージキューが空でなくなるまで待つ ">nn::os::MessageQueueWaitType_WaitForNotEmpty</a></li>
</ul>
<p>waitType が WaitForNotFull の場合、 関連付けされた multiWaitHolder は、対象メッセージキューのバッファに 1 つ以上の空きが出来た時にシグナル状態となります。<br />
 また、対象メッセージキューに既に 1 つ以上の空きがある場合には、 即座にシグナル状態となります。</p>
<p>waitType が WaitForNotEmpty の場合、 関連付けされた multiWaitHolder は、対象メッセージキューのバッファに 1 つ以上のデータが蓄積された時にシグナル状態となります。<br />
 また、対象メッセージキューに既に 1 つ以上のデータが蓄積されている 場合には、即座にシグナル状態となります。</p>
<p>本 API によって初期化された multiWaitHolder オブジェクトを使って多重待ちを 行ない、実際に対象のメッセージキューがシグナル化されることで多重待ちが解除 された場合でも、メッセージキューのバッファの内容は変化しません。<br />
 詳細は <a class="el" href="_page_notification_os_multi_wait.html#PageNotificationOsMultiWait_AboutWakeup">多重待ちの待ち解除について</a> を参照して下さい。</p>
<p>本 API の動作中に対象 multiWaitHolder に対する操作は行なわないで下さい。 </p>

</div>
</div>
<a class="anchor" id="a48e6662e7fdf9f78bcae79ba94d64a93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeMultiWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>multiWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWait オブジェクトヘッダを初期化します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWait</td><td>multiWait オブジェクトヘッダへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWait が未初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>multiWait が初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 multiWait を初期化します。</p>
<p>多重待ち機能では、 <a class="el" href="structnn_1_1os_1_1_multi_wait_type.html" title="多重待ちオブジェクトのヘッダを定義する構造体です。 ">MultiWaitType</a> をリストヘッダとして初期化し、 そこへ、 <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="多重待ちオブジェクトホルダーを定義する構造体です。 ">MultiWaitHolderType</a> をリストの要素としてリンクして使用します。</p>
<p>スレッドやセマフォ、イベント、メッセージキューのいずれかと関連付けられた <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="多重待ちオブジェクトホルダーを定義する構造体です。 ">MultiWaitHolderType</a> オブジェクトを必要なだけ用意しリストとして接続します。<br />
 そのような <a class="el" href="structnn_1_1os_1_1_multi_wait_type.html" title="多重待ちオブジェクトのヘッダを定義する構造体です。 ">MultiWaitType</a> オブジェクトを <a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd" title="multiWait リスト内のいずれかの multiWaitHolder を待機します。 ">WaitAny()</a> に渡すことで、 対象オブジェクトのいずれかがシグナル状態になるまで待機することができます。</p>
<p><a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd" title="multiWait リスト内のいずれかの multiWaitHolder を待機します。 ">WaitAny()</a> はシグナル化したオブジェクトを検知するとスレッドを起床します。<br />
 ただし、対象オブジェクトのリソースの獲得までは行ないません。<br />
 そのため、 <a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd" title="multiWait リスト内のいずれかの multiWaitHolder を待機します。 ">WaitAny()</a> の返値である <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="多重待ちオブジェクトホルダーを定義する構造体です。 ">MultiWaitHolderType</a> オブジェクトに 関連付けられている同期オブジェクトに対して、別途獲得を行なう API を 発行する必要があります。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 multiWait に対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_echoback_8cpp-example.html#a71">AudioEchoback.cpp</a>, <a class="el" href="_ldn_access_point_8cpp-example.html#a17">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a17">LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a60">MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a19">MoviePlayerSimple.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a15">OsMultiWait.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a60873f9b623e014948a9ea53a611da4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeMultiWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>multiWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWait オブジェクトヘッダをファイナライズします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWait</td><td>multiWait オブジェクトヘッダへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWait が初期化状態である</li>
<li>multiWait リストに multiWaitHolder が１つもリンクされていない</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>multiWait が未初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 multiWait をファイナライズします。<br />
 multiWait オブジェクトに、multiWaitHolder オブジェクトが１つでも リンクされている場合は、アサートに失敗します。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 multiWait に対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_access_point_8cpp-example.html#a38">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a31">LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a66">MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a25">MoviePlayerSimple.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a21">OsMultiWait.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab9b837eb53fa2c8a9610cec2b69666fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">nn::os::MultiWaitHolderType</a> * nn::os::WaitAny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>multiWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWait リスト内のいずれかの multiWaitHolder を待機します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWait</td><td>multiWait オブジェクトヘッダへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>シグナル状態に変化した multiWaitHolder オブジェクトへのポインタ</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWait が初期化状態である</li>
<li>multiWait にリンクされた全ての <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="多重待ちオブジェクトホルダーを定義する構造体です。 ">MultiWaitHolderType</a> が初期化状態である</li>
<li>multiWait が他スレッド上で使用されていない</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>いずれかの多重待ちオブジェクトでシグナル化が検知された場合、 シグナル化を検知した <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="多重待ちオブジェクトホルダーを定義する構造体です。 ">MultiWaitHolderType</a> へのポインタを返す</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 multiWait リストヘッダに接続された全ての <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="多重待ちオブジェクトホルダーを定義する構造体です。 ">MultiWaitHolderType</a> オブジェクト について、いずれかのオブジェクトがシグナル状態になるまで待機します。</p>
<p>いずれかのオブジェクトがシグナル状態になったのを検知して待ちが解除されても、 対象オブジェクトの状態はシグナル状態のまま変化しません。<br />
 詳細は <a class="el" href="_page_notification_os_multi_wait.html#PageNotificationOsMultiWait_AboutWakeup">多重待ちの待ち解除について</a> を参照して下さい。</p>
<p>multiWait が他のスレッド上で使用されていてはいけません。 具体的には <a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd" title="multiWait リスト内のいずれかの multiWaitHolder を待機します。 ">WaitAny()</a> から返ってくるまでの間、指定された multiWait を使っての多重待ちや multiWait に対しての操作を他スレッド上で同時に 行なってはいけません。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_echoback_8cpp-example.html#a73">AudioEchoback.cpp</a>, <a class="el" href="_ldn_access_point_8cpp-example.html#a20">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a20">LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a117">MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a30">MoviePlayerSimple.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a17">OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_8cpp-example.html#a10">OsMultiWaitUtility.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="add056696d279031175e9053145c82677"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">nn::os::MultiWaitHolderType</a> * nn::os::TryWaitAny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>multiWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWait リスト内のいずれかの multiWaitHolder をポーリングします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWait</td><td>multiWait オブジェクトヘッダへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>シグナル状態に変化した multiWaitHolder オブジェクトへのポインタ <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000091">戻り値一覧:</a></b></dt><dd><b>NULL</b> ポーリング失敗</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWait が初期化状態である</li>
<li>multiWait にリンクされた全ての <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="多重待ちオブジェクトホルダーを定義する構造体です。 ">MultiWaitHolderType</a> が初期化状態である</li>
<li>multiWait が他スレッド上で使用されていない</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>いずれかの多重待ちオブジェクトでシグナル化が検知された場合<ul>
<li>シグナル化を検知した <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="多重待ちオブジェクトホルダーを定義する構造体です。 ">MultiWaitHolderType</a> へのポインタを返す</li>
</ul>
</li>
<li>全ての多重待ちオブジェクトでシグナル化を検知できなかった場合<ul>
<li>NULL を返す</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 multiWait リストヘッダに接続された全ての <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="多重待ちオブジェクトホルダーを定義する構造体です。 ">MultiWaitHolderType</a> オブジェクト について、いずれかのオブジェクトがシグナル状態か否かをポーリングします。<br />
 全ての <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="多重待ちオブジェクトホルダーを定義する構造体です。 ">MultiWaitHolderType</a> オブジェクトが非シグナル状態だった場合には、 ポーリング失敗として NULL を返します。</p>
<p>いずれかのオブジェクトがシグナル状態であるのを検知して非 NULL が返った 場合でも、対象オブジェクトの状態はシグナル状態のまま変化しません。<br />
 詳細は <a class="el" href="_page_notification_os_multi_wait.html#PageNotificationOsMultiWait_AboutWakeup">多重待ちの待ち解除について</a> を参照して下さい。</p>
<p>multiWait が他のスレッド上で使用されていてはいけません。 具体的には <a class="el" href="namespacenn_1_1os.html#add056696d279031175e9053145c82677" title="multiWait リスト内のいずれかの multiWaitHolder をポーリングします。 ">TryWaitAny()</a> から返ってくるまでの間、指定された multiWait を使っての多重待ちや multiWait に対しての操作を他スレッド上で同時に 行なってはいけません。 </p>

</div>
</div>
<a class="anchor" id="a6a76f1be743cfc8791d2a139c7409470"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">nn::os::MultiWaitHolderType</a> * nn::os::TimedWaitAny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>multiWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWait リスト内のいずれかの multiWaitHolder を待機します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWait</td><td>multiWait オブジェクトヘッダへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>タイムアウト値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>シグナル状態に変化した multiWaitHolder オブジェクトへのポインタ <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000092">戻り値一覧:</a></b></dt><dd><b>NULL</b> タイムアウト</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWait が初期化状態である</li>
<li>multiWait にリンクされた全ての <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="多重待ちオブジェクトホルダーを定義する構造体です。 ">MultiWaitHolderType</a> が初期化状態である</li>
<li>multiWait が他スレッド上で使用されていない</li>
<li>timeout &gt;= 0</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>いずれかの多重待ちオブジェクトでシグナル化が検知された場合<ul>
<li>シグナル化を検知した <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="多重待ちオブジェクトホルダーを定義する構造体です。 ">MultiWaitHolderType</a> へのポインタを返す</li>
</ul>
</li>
<li>全ての多重待ちオブジェクトでシグナル化を検知できなかった場合<ul>
<li>NULL を返す</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 multiWait リストヘッダに接続された全ての <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="多重待ちオブジェクトホルダーを定義する構造体です。 ">MultiWaitHolderType</a> オブジェクト について、いずれかのオブジェクトがシグナル状態になるまで待機します。<br />
 自スレッドが待ちに入った後、timeout 時間経過するとタイムアウトが成立し、 自動的に待ちが解除されます。その場合、返値として NULL を返します。</p>
<p>タイムアウトの動作に関しては <a class="el" href="_page_notification_os_timeout.html">OS-API のタイムアウトについて</a> の 注意事項も参照して下さい。</p>
<p>いずれかのオブジェクトがシグナル状態であるのを検知して非 NULL が返った 場合でも、対象オブジェクトの状態はシグナル状態のまま変化しません。<br />
 詳細は <a class="el" href="_page_notification_os_multi_wait.html#PageNotificationOsMultiWait_AboutWakeup">多重待ちの待ち解除について</a> を参照して下さい。</p>
<p>multiWait が他のスレッド上で使用されていてはいけません。 具体的には <a class="el" href="namespacenn_1_1os.html#a6a76f1be743cfc8791d2a139c7409470" title="multiWait リスト内のいずれかの multiWaitHolder を待機します。 ">TimedWaitAny()</a> から返ってくるまでの間、指定された multiWait を使っての多重待ちや multiWait に対しての操作を他スレッド上で同時に 行なってはいけません。 </p>

</div>
</div>
<a class="anchor" id="a2de358e6bfa261b74c399b5b59c0da1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWaitHolder オブジェクトをファイナライズします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>多重待ちオブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWaitHolder が初期化状態である</li>
<li>multiWaitHolder がどのリストにもリンクされていない</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>multiWaitHolder が未初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 multiWaitHolder をファイナライズします。<br />
 multiWaitHolder オブジェクトが、何かしらのリストに接続されている場合は アサートに失敗します。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 multiWaitHolder に対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_echoback_8cpp-example.html#a67">AudioEchoback.cpp</a>, <a class="el" href="_ldn_access_point_8cpp-example.html#a37">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a30">LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a65">MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a23">MoviePlayerSimple.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a20">OsMultiWait.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a7cd9b25e14bee063959eb9e7f62a4aa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::LinkMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>multiWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWait ヘッダに多重待ちオブジェクト multiWaitHolder をリンクします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWait</td><td>multiWait オブジェクトヘッダへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>多重待ちオブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWait が初期化状態である</li>
<li>multiWaitHolder が初期化状態である</li>
<li>multiWaitHolder がどのリストにもリンクされていない</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>multiWait リストに、multiWaitHolder オブジェクトがリンクされる</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 多重待ちオブジェクトヘッダ multiWait に、多重待ちオブジェクト multiWaitHolder をリンクします。リンクされた multiWaitHolder オブジェクトは、 <a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd" title="multiWait リスト内のいずれかの multiWaitHolder を待機します。 ">WaitAny()</a> 系の API で multiWait が渡された時に、<br />
 シグナル化を待機する対象同期オブジェクトの１つとなります。</p>
<p>本 API はスレッドセーフではありません。 本 API の動作中に対象 multiWait および multiWaitHolder オブジェクトに 対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_echoback_8cpp-example.html#a65">AudioEchoback.cpp</a>, <a class="el" href="_ldn_access_point_8cpp-example.html#a19">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a19">LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a115">MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a33">MoviePlayerSimple.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a16">OsMultiWait.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a07c9c7bbc51249b69dc2361957fd650b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::UnlinkMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWait ヘッダから、多重待ちオブジェクト multiWaitHolder をアンリンクします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>多重待ちオブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWaitHolder が初期化状態である</li>
<li>multiWaitHolder が multiWait リストにリンクされている</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>multiWaitHolder がどのリストにもリンクされていない</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 多重待ちオブジェクトヘッダにリンクされている、多重待ちオブジェクト multiWaitHolder をアンリンクします。アンリンクされた multiWaitHolder オブジェクトは、どこのリストヘッダにもリンクされていない状態になります。</p>
<p>本 API はスレッドセーフではありません。 本 API の動作中に対象 multiWait および multiWaitHolder オブジェクトに 対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_echoback_8cpp-example.html#a66">AudioEchoback.cpp</a>, <a class="el" href="_ldn_access_point_8cpp-example.html#a36">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a29">LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a120">MovieDecoderPlayer.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a21">MoviePlayerSimple.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a19">OsMultiWait.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a7bdfded3152755dfd1fadb8eeea4565e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::UnlinkAllMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>multiWait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWait ヘッダにリンクされている全ての多重待ちオブジェクトホルダーをアンリンクします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWait</td><td>multiWait オブジェクトヘッダへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWait が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>multiWait にリンクされていた多重待ちオブジェクトホルダーがどのリストにもリンクされていない</li>
<li>multiWait リストに多重待ちオブジェクトホルダーが１つもリンクされていない</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 多重待ちオブジェクトヘッダ multiWait にリンクされている、全ての多重待ちオブジェクトホルダー をアンリンクします。アンリンクされた多重待ちオブジェクトホルダーは、 どこのリストヘッダにもリンクされていない状態になります。</p>
<p>本 API はスレッドセーフではありません。 本 API の動作中に対象 multiWait オブジェクトやリンクされている多重待ちオブジェクトホルダーに 対する操作は行なわないで下さい。 </p>

</div>
</div>
<a class="anchor" id="ab8fb5f6b288f3b208f0d4750d0ba079d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::MoveAllMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>dstMultiWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>srcMultiWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>srcMultiWait ヘッダにリンクされている全ての多重待ちオブジェクトホルダーをアンリンクし dstMultiWait にリンクします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dstMultiWait</td><td>リンク先の multiWait オブジェクトヘッダへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcMultiWait</td><td>アンリンク元の multiWait オブジェクトヘッダへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>dstMultiWait が初期化状態である</li>
<li>srcMultiWait が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>dstMultiWait には以下のすべてがリンクされている<ul>
<li>関数の呼び出し前に dstMultiWait にリンクされていた多重待ちオブジェクトホルダー</li>
<li>関数の呼び出し前に srcMultiWait にリンクされていた多重待ちオブジェクトホルダー</li>
</ul>
</li>
<li>srcMultiWait リストに多重待ちオブジェクトホルダーが１つもリンクされていない</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 srcMultiWait でポイントされる多重待ちオブジェクトヘッダにリンクされている、 全ての多重待ちオブジェクトホルダーに関して、<br />
 srcMultiWait からアンリンクし dstMultiWait にリンクしなおします。</p>
<p>本 API はスレッドセーフではありません。 本 API の動作中に対象 dstMultiWait, srcMultiWait オブジェクト、 または、それらにリンクされている多重待ちオブジェクトホルダーに 対する操作は行なわないで下さい。 </p>

</div>
</div>
<a class="anchor" id="a05af1a7e142f1ece42a53fe41085f53b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SetMultiWaitHolderUserData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWaitHolder にユーザデータの値を設定します </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>多重待ちオブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userData</td><td>ユーザデータとして設定する値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWaitHolder が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>multiWaitHolder が初期化状態である（ユーザデータのみが変化）</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 multiWaitHolder にユーザデータの値を設定します。</p>
<p>本 API はスレッドセーフではありません。 本 API の動作中に対象 multiWaitHolder オブジェクトに 対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_echoback_8cpp-example.html#a64">AudioEchoback.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a35">MoviePlayerSimple.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a13">OsMultiWait.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a9e8c73312415fc00c72808fcc00fea33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t nn::os::GetMultiWaitHolderUserData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWaitHolder に設定されているユーザデータ値を取得します </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>多重待ちオブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ユーザデータとして設定されている値</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWaitHolder が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>multiWaitHolder が初期化状態である（変化しない）</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 multiWaitHolder に設定されているユーザデータの値を取得します。 各 <a class="el" href="namespacenn_1_1os.html#a4f8d998425d067cb5fec2604ae7845dc" title="multiWaitHolder を初期化し、event と関連付けます。 ">InitializeMultiWaitHolder()</a> を呼んだ直後の初期値は 0 です。</p>
<p>本 API はスレッドセーフではありません。 本 API の動作中に対象 multiWaitHolder オブジェクトに 対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_echoback_8cpp-example.html#a74">AudioEchoback.cpp</a>, <a class="el" href="_movie_player_simple_8cpp-example.html#a22">MoviePlayerSimple.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a18">OsMultiWait.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a547f598078ce4b3fd6d25f8cf2339631"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a>*, int&gt; nn::os::WaitAny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>pMultiWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWait リスト内のいずれかの multiWaitHolder または指定された複数の待機可能オブジェクトを待機します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>追加待機オブジェクトの可変長型パラメータ</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pMultiWait</td><td>multiWait オブジェクトヘッダへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>待機可能オブジェクトの可変長パラメータ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>pMultiWait にリンクされている <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="多重待ちオブジェクトホルダーを定義する構造体です。 ">MultiWaitHolderType</a> がシグナルされた場合は、そのポインタを p として { p, -1 } を返し、 args に指定されたオブジェクトがシグナルされた場合は、args 内での 0 から始まるインデックスを n として { nullptr, n } を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWait が初期化状態である</li>
<li>multiWait にリンクされた全ての <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="多重待ちオブジェクトホルダーを定義する構造体です。 ">MultiWaitHolderType</a> が初期化状態である</li>
<li>multiWait が他スレッド上で使用されていない</li>
<li>args の各引数 x に対し InitializeMultiWaitHolder(pHolder, x) を正しく呼び出せる</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>返された値に対応した待機可能オブジェクトがシグナルされている</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 待機対象の指定方法や結果の返し方の違いを除いて、詳細な動作は <a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd" title="multiWait リスト内のいずれかの multiWaitHolder を待機します。 ">WaitAny(MultiWaitType*)</a> と同様です。</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd" title="multiWait リスト内のいずれかの multiWaitHolder を待機します。 ">WaitAny(MultiWaitType*)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a13e2d082ce0e2cd4e8eac49ab5a8347d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::WaitAny </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定された複数の待機可能オブジェクトを待機します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>待機オブジェクトの可変長型パラメータ</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>待機可能オブジェクトの可変長パラメータ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>シグナルされたオブジェクトの args 内での 0 から始まるインデックス返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>args の各引数 x に対し InitializeMultiWaitHolder(pHolder, x) を正しく呼び出せる</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>返された値に対応した待機可能オブジェクトがシグナルされている</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 待機対象の指定方法や結果の返し方の違いを除いて、詳細な動作は <a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd" title="multiWait リスト内のいずれかの multiWaitHolder を待機します。 ">WaitAny(MultiWaitType*)</a> と同様です。</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1os.html#ab9b837eb53fa2c8a9610cec2b69666fd" title="multiWait リスト内のいずれかの multiWaitHolder を待機します。 ">WaitAny(MultiWaitType*)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5d5be969099705ab608e826ac52ed6d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a>*, int&gt; nn::os::TryWaitAny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>pMultiWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWait リスト内のいずれかの multiWaitHolder または指定された複数の待機可能オブジェクトをポーリングします。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>追加待機オブジェクトの可変長型パラメータ</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pMultiWait</td><td>multiWait オブジェクトヘッダへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>待機可能オブジェクトの可変長パラメータ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>pMultiWait にリンクされている <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="多重待ちオブジェクトホルダーを定義する構造体です。 ">MultiWaitHolderType</a> がシグナルされていた場合は、そのポインタを p として { p, -1 } を返し、 args に指定されたオブジェクトがシグナルされていた場合は、args 内での 0 から始まるインデックスを n として { nullptr, n } を返します。 いずれもシグナルされていなかった場合には { nullptr, -1 } を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWait が初期化状態である</li>
<li>multiWait にリンクされた全ての <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="多重待ちオブジェクトホルダーを定義する構造体です。 ">MultiWaitHolderType</a> が初期化状態である</li>
<li>multiWait が他スレッド上で使用されていない</li>
<li>args の各引数 x に対し InitializeMultiWaitHolder(pHolder, x) を正しく呼び出せる</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>返り値 != { nullptr, -1 } のとき、返された値に対応した待機可能オブジェクトがシグナルされている</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 待機対象の指定方法や結果の返し方の違いを除いて、詳細な動作は <a class="el" href="namespacenn_1_1os.html#add056696d279031175e9053145c82677" title="multiWait リスト内のいずれかの multiWaitHolder をポーリングします。 ">TryWaitAny(MultiWaitType*)</a> と同様です。</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1os.html#add056696d279031175e9053145c82677" title="multiWait リスト内のいずれかの multiWaitHolder をポーリングします。 ">TryWaitAny(MultiWaitType*)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a76d6121699d50103ea2cb44658122a08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::TryWaitAny </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定された複数の待機可能オブジェクトをポーリングします。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>待機オブジェクトの可変長型パラメータ</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>待機可能オブジェクトの可変長パラメータ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>シグナルされていたオブジェクトの args 内での 0 から始まるインデックス返します。 いずれもシグナルされていなかった場合には -1 を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>args の各引数 x に対し InitializeMultiWaitHolder(pHolder, x) を正しく呼び出せる</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>返り値 &gt;= 0 のとき、返された値に対応した待機可能オブジェクトがシグナルされている</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 待機対象の指定方法や結果の返し方の違いを除いて、詳細な動作は <a class="el" href="namespacenn_1_1os.html#add056696d279031175e9053145c82677" title="multiWait リスト内のいずれかの multiWaitHolder をポーリングします。 ">TryWaitAny(MultiWaitType*)</a> と同様です。</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1os.html#add056696d279031175e9053145c82677" title="multiWait リスト内のいずれかの multiWaitHolder をポーリングします。 ">TryWaitAny(MultiWaitType*)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab3f8a8f45f9e0a8ef118c9fcf81d1d15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a>*, int&gt; nn::os::TimedWaitAny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_type.html">MultiWaitType</a> *&#160;</td>
          <td class="paramname"><em>pMultiWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWait リスト内のいずれかの multiWaitHolder または指定された複数の待機可能オブジェクトをタイムアウト付きで待機します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>追加待機オブジェクトの可変長型パラメータ</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pMultiWait</td><td>multiWait オブジェクトヘッダへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>タイムアウト値 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>待機可能オブジェクトの可変長パラメータ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>pMultiWait にリンクされている <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="多重待ちオブジェクトホルダーを定義する構造体です。 ">MultiWaitHolderType</a> がシグナルされた場合は、そのポインタを p として { p, -1 } を返し、 args に指定されたオブジェクトがシグナルされた場合は、args 内での 0 から始まるインデックスを n として { nullptr, n } を返します。 時間内にいずれもシグナルされていなかった場合には { nullptr, -1 } を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWait が初期化状態である</li>
<li>multiWait にリンクされた全ての <a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html" title="多重待ちオブジェクトホルダーを定義する構造体です。 ">MultiWaitHolderType</a> が初期化状態である</li>
<li>multiWait が他スレッド上で使用されていない</li>
<li>timeout &gt;= 0</li>
<li>args の各引数 x に対し InitializeMultiWaitHolder(pHolder, x) を正しく呼び出せる</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>返り値 != { nullptr, -1 } のとき、返された値に対応した待機可能オブジェクトがシグナルされている</li>
<li>返り値 == { nullptr, -1 } のとき、呼び出してから timeout 以上の時間が経過している</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 待機対象の指定方法や結果の返し方の違いを除いて、詳細な動作は <a class="el" href="namespacenn_1_1os.html#a6a76f1be743cfc8791d2a139c7409470" title="multiWait リスト内のいずれかの multiWaitHolder を待機します。 ">TimedWaitAny(MultiWaitType*, TimeSpan)</a> と同様です。</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1os.html#a6a76f1be743cfc8791d2a139c7409470" title="multiWait リスト内のいずれかの multiWaitHolder を待機します。 ">TimedWaitAny(MultiWaitType*, TimeSpan)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7680123d43331cc6b512cfc4463e072b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::TimedWaitAny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定された複数の待機可能オブジェクトをタイムアウト付きで待機します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>待機オブジェクトの可変長型パラメータ</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>タイムアウト値 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>待機可能オブジェクトの可変長パラメータ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>シグナルされていたオブジェクトの args 内での 0 から始まるインデックス返します。 時間内にいずれもシグナルされていなかった場合には -1 を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>timeout &gt;= 0</li>
<li>args の各引数 x に対し InitializeMultiWaitHolder(pHolder, x) を正しく呼び出せる</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>返り値 &gt;= 0 のとき、返された値に対応した待機可能オブジェクトがシグナルされている</li>
<li>返り値 == -1 のとき、呼び出してから timeout 以上の時間が経過している</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 待機対象の指定方法や結果の返し方の違いを除いて、詳細な動作は <a class="el" href="namespacenn_1_1os.html#a6a76f1be743cfc8791d2a139c7409470" title="multiWait リスト内のいずれかの multiWaitHolder を待機します。 ">TimedWaitAny(MultiWaitType*, TimeSpan)</a> と同様です。</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1os.html#a6a76f1be743cfc8791d2a139c7409470" title="multiWait リスト内のいずれかの multiWaitHolder を待機します。 ">TimedWaitAny(MultiWaitType*, TimeSpan)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0a434b3b646d4fafdc951f63fa3a4689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">detail::MessageQueueWaitMultiWaitHelper nn::os::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_message_queue_type.html">MessageQueueType</a> *&#160;</td>
          <td class="paramname"><em>messageQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#a3271c9fc6c46cffdb076b966f15a80bc">MessageQueueWaitType</a>&#160;</td>
          <td class="paramname"><em>waitType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>多重待ちユーティリティでメッセージキューを指定する際のユーティリティです。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageQueue</td><td>紐付ける先のメッセージキューへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitType</td><td>メッセージキューの待ち種別</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>messageQueue が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section return"><dt>戻り値</dt><dd>多重待ちユーティリティに渡すための値を返します。</dd></dl>
<p><b>詳細</b> <br />
 本関数の返り値を多重待ちユーティリティ関数に渡した際の待機対象は、 messageQueue で指定されたメッセージキューに対する waitType で指定された種別での待機となります。 </p>

</div>
</div>
<a class="anchor" id="a8d0a550df15490a884932a062dc26533"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeMutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recursive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lockLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> オブジェクトを初期化します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recursive</td><td>ミューテックスの再帰ロックの可否指定 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lockLevel</td><td>ロックレベル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>mutex が未初期化状態もしくは初期化されていない状態である</li>
<li>lockLevel == 0 || ( <a class="el" href="namespacenn_1_1os.html#aafb8cce9509759efcb7b1080b20ca960" title="ミューテックスのロックレベルの最小値を表す定数です。 ">nn::os::MutexLockLevelMin</a> &lt;= lockLevel &lt;= <a class="el" href="namespacenn_1_1os.html#a20b0e2596b8091c49374130b049168f6" title="ミューテックスのロックレベルの最大値を表す定数です。 ">nn::os::MutexLockLevelMax</a> )</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>mutex がアンロック状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 ミューテックスオブジェクトを初期化します。</p>
<p>recursive を true にすると再帰ロック可能となり、 false にすると再帰ロック禁止となります。</p>
<p>lockLevel には、対象ミューテックスに設定すべきロックレベルを、 <a class="el" href="namespacenn_1_1os.html#aafb8cce9509759efcb7b1080b20ca960" title="ミューテックスのロックレベルの最小値を表す定数です。 ">nn::os::MutexLockLevelMin</a> （最小値）～ <a class="el" href="namespacenn_1_1os.html#a20b0e2596b8091c49374130b049168f6" title="ミューテックスのロックレベルの最大値を表す定数です。 ">nn::os::MutexLockLevelMax</a> （最大値）の範囲で 指定します。<br />
 0 を指定した場合はロックレベルのチェックを行ないません。 また、Release 版ビルドでは処理速度向上目的のため、ロックレベル機能は無効になります。</p>
<p>ロックレベル機能は、ミューテックスのロック／アンロックの順番を 監視するためのデバッグ機能です。<br />
 各スレッドは、ロック操作時のロックレベル値の履歴を管理しており、 ロック／アンロック時に照合して検査します。</p>
<p>具体的には以下の通りです。</p>
<p>まず、ロック操作時は recursive の設定によって以下のようになります。<br />
 recursive == true の場合は、その lockLevel 値以上の mutex ロックのみ 成功し、<br />
 recursive == false の場合は、その lockLevel 値よりも大きい値の mutex ロックのみ成功します。</p>
<p>いずれの場合も lockLevel 値が、 自スレッドのカレントロックレベルより小さい場合は、<br />
 不正なロック操作を検知したことになり、アサートに失敗します。</p>
<p>一方、アンロック時は lockLevel 値が自スレッドの カレントロックレベルと等しい場合にのみ、<br />
 アンロックは成功し、ロック履歴を 1 つ分ロックする前の状態に戻します。<br />
 カレントロックレベルと等しくない場合には、不正なアンロックを 検知したことになり、アサートに失敗します。</p>
<p>ミューテックスの初期化を行なう方法として、静的に初期化を行なう <a class="el" href="os___mutex_api_8h.html#a90be4df5dbd89de101035979076507a8">NN_OS_MUTEX_INITIALIZER()</a> マクロもあります。</p>
<p>なお、本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 mutex に対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_hid_controller_sequence__main_8cpp-example.html#a12">HidControllerSequence_Main.cpp</a>, <a class="el" href="_ldn_access_point_8cpp-example.html#a108">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a108">LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a54">MovieDecoderPlayer.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a95">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a87">NvnTutorial06.cpp</a>, <a class="el" href="_os_condition_variable_8cpp-example.html#a12">OsConditionVariable.cpp</a>, <a class="el" href="_os_mutex_8cpp-example.html#a8">OsMutex.cpp</a>, <a class="el" href="_render_thread_pool_8cpp-example.html#a6">RenderThreadPool.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8ce43d38754bf3049ab8d60b9d9e0046"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeMutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> オブジェクトを Finalize します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>mutex がアンロック状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>mutex が未初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 <a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> オブジェクトをファイナライズします。<br />
 mutex に対して待機中のスレッドがある場合にはアサートに失敗します。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 mutex に対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_access_point_8cpp-example.html#a110">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a109">LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a67">MovieDecoderPlayer.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a107">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a104">NvnTutorial06.cpp</a>, <a class="el" href="_os_condition_variable_8cpp-example.html#a21">OsConditionVariable.cpp</a>, <a class="el" href="_os_mutex_8cpp-example.html#a17">OsMutex.cpp</a>, <a class="el" href="_render_thread_pool_8cpp-example.html#a0">RenderThreadPool.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8d4678856d87c3faea21f47ced342bb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::LockMutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> をロックします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>mutex が以下のいずれかの状態である<ul>
<li>recursive == false で、mutex が アンロック状態 または 他スレッドロック状態 である</li>
<li>recursive == true で、 mutex が初期化状態である</li>
</ul>
</li>
<li>lockLevel &gt; 0 の場合、以下の事前条件も加わる<ul>
<li>lockLevel が自スレッドのカレントロックレベルより大きい値である</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>mutex が 自スレッドロック状態 である</li>
<li>カレントロックカウンタをインクリメントする</li>
<li>mutex が lockLevel &gt; 0 の場合、以下の事後条件も加わる<ul>
<li>自スレッドのカレントロックレベルが lockLevel になる</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 指定されたミューテックスをロックします。<br />
 対象ミューテックスがアンロック状態の場合はロックに成功します。</p>
<p>対象ミューテックスが既にロック状態で、かつ、ロック所有者が 他スレッドの場合、自スレッドは待機状態となります。</p>
<p>対象ミューテックスが既にロック状態で、かつ、ロック所有者が 自スレッドの場合は、ミューテックス初期化時の recursive によって 以下のように振舞いが異なります。</p>
<p>recursive == true の場合、再帰ロックに成功し即座にリターンます。<br />
 recursive == false の場合、事前条件違反でアサートに失敗します。</p>
<p>mutex の lockLevel が 1 以上 の場合、 ロック時にロックレベル検査が行なわれます。<br />
 ロックレベル機能の詳細は、 <a class="el" href="namespacenn_1_1os.html#a8d0a550df15490a884932a062dc26533" title="MutexType オブジェクトを初期化します。 ">InitializeMutex()</a> を参照して下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_hid_controller_sequence__game_8cpp-example.html#a46">HidControllerSequence_Game.cpp</a>, <a class="el" href="_hid_controller_sequence__main_8cpp-example.html#a31">HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_controller_sequence__start_8cpp-example.html#a2">HidControllerSequence_Start.cpp</a>, <a class="el" href="_hid_controller_sequence__title_8cpp-example.html#a4">HidControllerSequence_Title.cpp</a>, <a class="el" href="_ldn_access_point_8cpp-example.html#a34">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a27">LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a99">MovieDecoderPlayer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a51">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_os_condition_variable_8cpp-example.html#a3">OsConditionVariable.cpp</a>, <a class="el" href="_os_mutex_8cpp-example.html#a3">OsMutex.cpp</a>, <a class="el" href="_render_thread_pool_8cpp-example.html#a9">RenderThreadPool.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af32963cc501eefcb10a0ebb993080b9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryLockMutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> がロック操作を試みます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ミューテックスの獲得の成否を示します</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>mutex が以下のいずれかの状態である<ul>
<li>recursive == false で、mutex が アンロック状態 または 他スレッドロック状態 である</li>
<li>recursive == true で、 mutex が初期化状態である</li>
</ul>
</li>
<li>lockLevel &gt; 0 の場合、以下の事前条件も加わる<ul>
<li>lockLevel が自スレッドのカレントロックレベルより大きい値である</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>返値が true の場合<ul>
<li>mutex が 自スレッドロック状態 である</li>
<li>カレントロックカウンタをインクリメントする</li>
<li>mutex が lockLevel &gt; 0 の場合、以下の事後条件も加わる<ul>
<li>自スレッドのカレントロックレベルが lockLevel になる</li>
</ul>
</li>
</ul>
</li>
<li>返値が false の場合<ul>
<li>mutex の状態は、事前条件の状態から変化しない</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 指定されたミューテックスのロックを試みます。<br />
 対象ミューテックスがアンロック状態の場合はロックに成功し true を返します。</p>
<p>対象ミューテックスが既にロック状態で、かつ、ロック所有者が 他スレッドの場合、自スレッドは待機せずに false を返します。</p>
<p>対象ミューテックスが既にロック状態で、かつ、ロック所有者が 自スレッドの場合は、ミューテックス初期化時の recursive によって 以下のように振舞いが異なります。</p>
<p>recursive == true の場合、再帰ロックに成功し true を返します。<br />
 recursive == false の場合、事前条件違反でアサートに失敗します。</p>
<p>mutex の lockLevel が 1 以上 の場合、 ロック時にロックレベル検査が行なわれます。<br />
 ロックレベル機能の詳細は、 <a class="el" href="namespacenn_1_1os.html#a8d0a550df15490a884932a062dc26533" title="MutexType オブジェクトを初期化します。 ">InitializeMutex()</a> を参照して下さい。 </p>

</div>
</div>
<a class="anchor" id="aa661a7036a18c378a694ad67941cd75e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::UnlockMutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> をアンロックします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>mutex が以下のいずれかの状態である<ul>
<li>recursive == false の場合、mutex が ロック状態 である</li>
<li>recursive == true の場合、mutex が ロック状態 もしくは 再帰ロック状態 である</li>
</ul>
</li>
<li>mutex のロック所有者が自スレッドである</li>
<li>mutex が lockLevel &gt; 0 の場合、以下の事前条件が加わる<ul>
<li>lockLevel が自スレッドのカレントロックレベルに等しい</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>ロックカウンタがデクリメントされる</li>
<li>ロックカウンタが 0 になった場合、mutex がアンロック状態である</li>
<li>mutex が lockLevel &gt; 0 の場合、以下の事前条件が加わる<ul>
<li>自スレッドのカレントロックレベルが、mutex をロックする前のロックレベル値になる</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 指定されたミューテックスをアンロックします。</p>
<p>対象ミューテックスがロック状態でない場合や、 対象ミューテックスがロック状態で、かつ、そのロック所有者が 自スレッドでない場合は、アサートに失敗します。</p>
<p>アンロック成功後、対象ミューテックスを待機しているスレッドがある場合、 そのスレッドは待ち解除されます。</p>
<p>mutex の lockLevel が 1 以上 の場合、 アンロック時にロックレベル検査が行なわれます。<br />
 ロックレベル機能の詳細は、 <a class="el" href="namespacenn_1_1os.html#a8d0a550df15490a884932a062dc26533" title="MutexType オブジェクトを初期化します。 ">InitializeMutex()</a> を参照して下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_hid_controller_sequence__game_8cpp-example.html#a47">HidControllerSequence_Game.cpp</a>, <a class="el" href="_hid_controller_sequence__main_8cpp-example.html#a34">HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_controller_sequence__start_8cpp-example.html#a3">HidControllerSequence_Start.cpp</a>, <a class="el" href="_hid_controller_sequence__title_8cpp-example.html#a5">HidControllerSequence_Title.cpp</a>, <a class="el" href="_ldn_access_point_8cpp-example.html#a35">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a28">LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a100">MovieDecoderPlayer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a52">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_os_condition_variable_8cpp-example.html#a6">OsConditionVariable.cpp</a>, <a class="el" href="_os_mutex_8cpp-example.html#a4">OsMutex.cpp</a>, <a class="el" href="_render_thread_pool_8cpp-example.html#a10">RenderThreadPool.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a3a2107dd611741af2a44adf2dad29c74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::IsMutexLockedByCurrentThread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_mutex_type.html">MutexType</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> が自スレッドによってロックされているかを返します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td><a class="el" href="structnn_1_1os_1_1_mutex_type.html" title="ミューテックスオブジェクトを定義する構造体です。 ">MutexType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>自スレッドによってミューテックスが獲得されているか否かを返します</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>mutex がロック状態もしくはアンロック状態である。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 mutex が自スレッドによってロックされた状態であれば true を、 そうでなければ false を返します。本 API によって mutex の状態が 変化することはありません。</p>
<p>本 API は主に mutex が自スレッドによって確実にロックされていることを アサートする場合などに使用します。 </p>

</div>
</div>
<a class="anchor" id="a1771e01a3ebd2fb3dc464756f7208276"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::GenerateRandomBytes </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pOutBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ランダムなバイト列を生成します </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pOutBuffer</td><td>ランダムなバイト列を格納するバッファを指定します。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>生成するバイト列のサイズを指定します。</td></tr>
  </table>
  </dd>
</dl>
<p><b>詳細</b> <br />
 初期化済の乱数生成器を使用して size バイトのランダムなバイト列を生成し、 pOutBuffer で指定されるバッファに格納します。</p>
<p>乱数生成器のシードを含む比較的少量の乱数生成に使用することを想定しています。 大量の乱数を生成する場合や乱数の再現性が必要な場合には、 別途 C++ 標準ライブラリや <a class="el" href="classnn_1_1util_1_1_tiny_mt.html">nn::util::TinyMt</a> を使用してください。</p>
<p>本関数は暗号用途では利用できません。 暗号用途の乱数生成には <a class="el" href="namespacenn_1_1crypto.html#a6839e351ff9a035fd539ab60904a13d0">nn::crypto::GenerateCryptographicallyRandomBytes</a> が用意されています。</p>
<p>本 API はスレッドセーフです。 </p>

</div>
</div>
<a class="anchor" id="a659d0526afb3df351ed0a95ddc0776fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeReaderWriterLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="Readers-Writer ロックオブジェクトを定義する構造体です。 ">ReaderWriterLockType</a> オブジェクトを初期化します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="Readers-Writer ロックオブジェクトを定義する構造体です。 ">ReaderWriterLockType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>rwlock が未初期化状態もしくは初期化されていない状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>rwlock がアンロック状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 rwlock オブジェクトを初期化します。</p>
<p>Readers-Writer ロック機能は、スレッド間で排他制御を行なうための 同期オブジェクトの一つです。何かしらの共有リソースに対して、 読み込みアクセス目的の複数の Readers スレッドと、 書き込みアクセス目的の単一の Writer スレッドが排他を行なう場面で使用します。</p>
<p><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="Readers-Writer ロックオブジェクトを定義する構造体です。 ">ReaderWriterLockType</a> オブジェクトは以下の状態をとります。 また、排他ロック状態では特定のスレッドがロックオーナーとして管理されます。</p>
<ul>
<li>未初期化状態</li>
<li>アンロック状態</li>
<li>共有ロック状態（ロックオーナーなし）</li>
<li>排他ロック状態（ロックオーナーあり）</li>
</ul>
<p>アンロック状態は、いずれのスレッドもロックを取得していない状態です。</p>
<p>共有ロック状態は、ロックオーナーが未設定の状態で、 一つ以上のスレッドが Readers ロックを獲得済みの状態です。 共有ロック状態は、AcquireReadLock() および <a class="el" href="namespacenn_1_1os.html#ac0ce54963ebf2636dd1c78a0d16125a8" title="Readers ロックの取得を試みます。 ">TryAcquireReadLock()</a> された 回数と同じ数だけ <a class="el" href="namespacenn_1_1os.html#a4d8f51bbfa3341c9678758b191896a05" title="Readers ロックを 1 つだけ解放します。 ">ReleaseReadLock()</a> が呼ばれた時にアンロック状態に戻ります。</p>
<p>排他ロック状態は、ロックオーナーが設定された状態で、 単一のスレッドが Readers ロックもしくは Writer ロックを獲得済みの状態です。 最初にロックオーナーが設定されるのは、単一のスレッドが <a class="el" href="namespacenn_1_1os.html#a97d3e3f946b214bcbf85e4aebb61699f" title="Writer ロックを取得します。 ">AcquireWriteLock()</a> もしくは <a class="el" href="namespacenn_1_1os.html#ad042341aecc3ba00473ab85466fa76a8" title="Writer ロックの取得を試みます。 ">TryAcquireWriteLock()</a> に成功した時で、 呼出元のスレッドが rwlock オブジェクトのロックオーナーとして設定されます。</p>
<p>一旦ロックオーナーとなったスレッドはさらに以下のような制御が可能になります。</p>
<ul>
<li>追加の Readers ロックをブロッキングせずに重ねて取得できます。</li>
<li>追加の Writer ロックをブロッキングせずに重ねて取得できます。</li>
<li>全ての Readers/Writer ロックを解放した時点でロックオーナーが解除され、アンロック状態となります。</li>
<li>上記の Readers/Write ロックの取得順序や解放順序に制限はありません。</li>
</ul>
<p>なお、Readers/Wirte ロックを取得する際にブロッキングされたスレッドは、 次にロックを取得できる条件が整った段階で自動的に再度ロック取得を試みます。 この時、複数のスレッドによって、Readers ロック要求と Writer ロック要求の 両方が存在していた場合、Writer ロック要求が優先されます。</p>
<p>なお、本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 rwlock オブジェクトに対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_reader_writer_lock_8cpp-example.html#a12">OsReaderWriterLock.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6b179b4351145d32ec583bc5a52452bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeReaderWriterLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="Readers-Writer ロックオブジェクトを定義する構造体です。 ">ReaderWriterLockType</a> オブジェクトを破棄します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="Readers-Writer ロックオブジェクトを定義する構造体です。 ">ReaderWriterLockType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>rwlock がアンロック状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>rwlock が未初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 rwlock オブジェクトを破棄します。</p>
<p>なお、本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 rwlock オブジェクトに対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_reader_writer_lock_8cpp-example.html#a19">OsReaderWriterLock.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6fa888b2694902212ebc056ccaa4354b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::AcquireReadLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Readers ロックを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="Readers-Writer ロックオブジェクトを定義する構造体です。 ">ReaderWriterLockType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>rwlock がアンロック、共有ロック、排他ロックのいずれかの状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li><a class="el" href="namespacenn_1_1os.html#a434e0c862bf65234e1eee8756edbabf4" title="いずれかのスレッドで Readers ロックが取得済みか否かを返します。 ">IsReadLockHeld()</a> == true</li>
<li>rwlock が共有ロック状態である（自スレッドがロックオーナーでない場合）</li>
<li>rwlock が排他ロック状態である（自スレッドがロックオーナーの場合）</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 rwlock オブジェクトの Readers ロックを取得します。</p>
<p>rwlock オブジェクトがアンロック状態もしくは共有ロック状態であれば、 Readers ロックの取得に成功します。</p>
<p>rwlock オブジェクトが排他ロック状態の場合、 ロックオーナーが自スレッドであれば、Readers ロックの取得に成功します。 ロックオーナーが他スレッドであれば、自スレッドは Readers ロックの取得に 成功するまでブロッキングします。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_reader_writer_lock_8cpp-example.html#a3">OsReaderWriterLock.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac0ce54963ebf2636dd1c78a0d16125a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryAcquireReadLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Readers ロックの取得を試みます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="Readers-Writer ロックオブジェクトを定義する構造体です。 ">ReaderWriterLockType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Readers ロックに成功したか否か</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>rwlock がアンロック、共有ロック、排他ロックのいずれかの状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>返値が true の場合、以下の状態となる<ul>
<li><a class="el" href="namespacenn_1_1os.html#a434e0c862bf65234e1eee8756edbabf4" title="いずれかのスレッドで Readers ロックが取得済みか否かを返します。 ">IsReadLockHeld()</a> == true</li>
<li>rwlock が共有ロック状態である（自スレッドがロックオーナーでない場合）</li>
<li>rwlock が排他ロック状態である（自スレッドがロックオーナーの場合）</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 rwlock オブジェクトの Readers ロックの取得を試み、 ロックの成否を bool 型で返します。</p>
<p>返値が true の場合、Readers ロックの取得に成功しています。 返値が false の場合、Readers ロックの取得に失敗し、 rwlock オブジェクトの状態は変更されません。 </p>

</div>
</div>
<a class="anchor" id="a4d8f51bbfa3341c9678758b191896a05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ReleaseReadLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Readers ロックを 1 つだけ解放します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="Readers-Writer ロックオブジェクトを定義する構造体です。 ">ReaderWriterLockType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li><a class="el" href="namespacenn_1_1os.html#a434e0c862bf65234e1eee8756edbabf4" title="いずれかのスレッドで Readers ロックが取得済みか否かを返します。 ">IsReadLockHeld()</a> == true</li>
<li>rwlock が共有ロック状態である（自スレッドがロックオーナーでない場合）</li>
<li>rwlock が排他ロック状態である（自スレッドがロックオーナーの場合）</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>rwlock がアンロック、共有ロック、排他ロックのいずれかの状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 rwlock オブジェクトの Readers ロックを 1 つだけ解放します。</p>
<p>全ての Readers/Writer ロックが解放されるとアンロック状態となり、 同時にロック待ちでブロッキングしているスレッドがあればそれらを起床させます。 この時、複数のスレッドによって、Readers ロック要求と Writer ロック要求の 両方が存在していた場合、Writer ロック要求が優先されます。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_reader_writer_lock_8cpp-example.html#a5">OsReaderWriterLock.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a97d3e3f946b214bcbf85e4aebb61699f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::AcquireWriteLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writer ロックを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="Readers-Writer ロックオブジェクトを定義する構造体です。 ">ReaderWriterLockType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>rwlock がアンロック、共有ロック、排他ロックのいずれかの状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li><a class="el" href="namespacenn_1_1os.html#a6658b045d8ca185b5108ddb802f2440e" title="自スレッドで Writer ロックを取得済みか否かを返します。 ">IsWriteLockHeldByCurrentThread()</a> == true</li>
<li><a class="el" href="namespacenn_1_1os.html#ace3bf890340f587ab633cd1804a93e0b" title="自スレッドがロックオーナーか否かを返します。 ">IsReaderWriterLockOwnerThread()</a> == true</li>
<li>rwlock が排他ロック状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 rwlock オブジェクトの Writer ロックを取得します。 ロックに成功した後は、自スレッドがロックオーナーとなります。</p>
<p>Writer ロックが取得できない状態の場合、 自スレッドは Writer ロックの取得に成功するまでブロッキングします。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_reader_writer_lock_8cpp-example.html#a6">OsReaderWriterLock.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad042341aecc3ba00473ab85466fa76a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryAcquireWriteLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writer ロックの取得を試みます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="Readers-Writer ロックオブジェクトを定義する構造体です。 ">ReaderWriterLockType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Writer ロックに成功したか否か</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>rwlock がアンロック、共有ロック、排他ロックのいずれかの状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>返値が true の場合、以下の状態となる<ul>
<li><a class="el" href="namespacenn_1_1os.html#a6658b045d8ca185b5108ddb802f2440e" title="自スレッドで Writer ロックを取得済みか否かを返します。 ">IsWriteLockHeldByCurrentThread()</a> == true</li>
<li><a class="el" href="namespacenn_1_1os.html#ace3bf890340f587ab633cd1804a93e0b" title="自スレッドがロックオーナーか否かを返します。 ">IsReaderWriterLockOwnerThread()</a> == true</li>
<li>rwlock が排他ロック状態である</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 rwlock オブジェクトの Writer ロックの取得を試み、 ロックの成否を bool 型で返します。</p>
<p>返値が true の場合、Writer ロックの取得に成功し、 自スレッドがロックオーナーとなります。 </p>

</div>
</div>
<a class="anchor" id="ae30220320ff7ba5af52183fd5fbe1312"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ReleaseWriteLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writer ロックを 1 つだけ解放します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="Readers-Writer ロックオブジェクトを定義する構造体です。 ">ReaderWriterLockType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li><a class="el" href="namespacenn_1_1os.html#a6658b045d8ca185b5108ddb802f2440e" title="自スレッドで Writer ロックを取得済みか否かを返します。 ">IsWriteLockHeldByCurrentThread()</a> == true</li>
<li><a class="el" href="namespacenn_1_1os.html#ace3bf890340f587ab633cd1804a93e0b" title="自スレッドがロックオーナーか否かを返します。 ">IsReaderWriterLockOwnerThread()</a> == true</li>
<li>rwlock が排他ロック状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>rwlock がアンロック、共有ロック、排他ロックのいずれかの状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 rwlock オブジェクトの Writer ロックを 1 つだけ解放します。</p>
<p>全ての Readers/Writer ロックが解放されるとアンロック状態となり、 同時にロック待ちでブロッキングしているスレッドがあればそれらを起床させます。 この時、複数のスレッドによって、Readers ロック要求と Writer ロック要求の 両方が存在していた場合、Writer ロック要求が優先されます。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_reader_writer_lock_8cpp-example.html#a9">OsReaderWriterLock.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a434e0c862bf65234e1eee8756edbabf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::IsReadLockHeld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>いずれかのスレッドで Readers ロックが取得済みか否かを返します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="Readers-Writer ロックオブジェクトを定義する構造体です。 ">ReaderWriterLockType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Readers ロック取得済みか否か</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>rwlock がアンロック、共有ロック、排他ロックのいずれかの状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 いずれかのスレッドが rwlock オブジェクトの Readers ロックを 取得済みであれば true を、そうでなければ false を返します。 </p>

</div>
</div>
<a class="anchor" id="a6658b045d8ca185b5108ddb802f2440e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::IsWriteLockHeldByCurrentThread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>自スレッドで Writer ロックを取得済みか否かを返します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="Readers-Writer ロックオブジェクトを定義する構造体です。 ">ReaderWriterLockType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>自スレッドで Writer ロックを取得済みか否か</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>rwlock がアンロック、共有ロック、排他ロックのいずれかの状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 自スレッドが rwlock オブジェクトの Writer ロックを 取得済みであれば true を、そうでなければ false を返します。 </p>

</div>
</div>
<a class="anchor" id="ace3bf890340f587ab633cd1804a93e0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::IsReaderWriterLockOwnerThread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html">ReaderWriterLockType</a> *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>自スレッドがロックオーナーか否かを返します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rwlock</td><td><a class="el" href="structnn_1_1os_1_1_reader_writer_lock_type.html" title="Readers-Writer ロックオブジェクトを定義する構造体です。 ">ReaderWriterLockType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>自スレッドがロックオーナーか否か</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>rwlock がアンロック、共有ロック、排他ロックのいずれかの状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 自スレッドが rwlock オブジェクトのロックオーナーなら true を、 そうでなければ false を返します。</p>
<p><a class="el" href="namespacenn_1_1os.html#a6658b045d8ca185b5108ddb802f2440e" title="自スレッドで Writer ロックを取得済みか否かを返します。 ">IsWriteLockHeldByCurrentThread()</a> とは以下のケースにおいて返値が異なります。</p>
<p>ロックオーナーが設定されるのは Writer ロック取得時ですが、 その後、Readers ロックを取得し、Writer ロックだけを解放すると、 ロックオーナーが設定された状態で Readers ロックのみ獲得した状態になります。 これは rwlock オブジェクトが排他ロック状態を維持した状態であり、 この状態での各 API の返値は以下の通りです。</p>
<ul>
<li><a class="el" href="namespacenn_1_1os.html#ace3bf890340f587ab633cd1804a93e0b" title="自スレッドがロックオーナーか否かを返します。 ">IsReaderWriterLockOwnerThread()</a> では true が返る</li>
<li><a class="el" href="namespacenn_1_1os.html#a6658b045d8ca185b5108ddb802f2440e" title="自スレッドで Writer ロックを取得済みか否かを返します。 ">IsWriteLockHeldByCurrentThread()</a> では false が返る</li>
<li><a class="el" href="namespacenn_1_1os.html#a434e0c862bf65234e1eee8756edbabf4" title="いずれかのスレッドで Readers ロックが取得済みか否かを返します。 ">IsReadLockHeld()</a> では true が返る </li>
</ul>

</div>
</div>
<a class="anchor" id="af76bc96a9333f18ed5d7bead209eb4f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>initialCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> オブジェクトを初期化します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initialCount</td><td>セマフォのカウンタ初期値 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxCount</td><td>セマフォのカウンタ最大値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>semaphore が未初期化状態もしくは初期化されていない状態である</li>
<li>maxCount &gt;= 1</li>
<li>0 &lt;= initialCount &lt;= maxCount</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>semaphore が初期化状態である<ul>
<li>initialCount == 0 の場合は 非シグナル状態 である</li>
<li>initialCount &gt;= 1 の場合は シグナル状態 である</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 <a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> オブジェクトを初期化します。<br />
 本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 semaphore に対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_gfx_shader_compile_8cpp-example.html#a241">GfxShaderCompile.cpp</a>, <a class="el" href="_gfx_simple_8cpp-example.html#a173">GfxSimple.cpp</a>, <a class="el" href="_mii_compressed_texture_8cpp-example.html#a128">MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_8cpp-example.html#a126">MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_8cpp-example.html#a129">MiiDynamicMask.cpp</a>, <a class="el" href="_mii_headwear_example_8cpp-example.html#a140">MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_8cpp-example.html#a125">MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_8cpp-example.html#a304">MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_8cpp-example.html#a130">MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_8cpp-example.html#a126">MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_8cpp-example.html#a212">MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_8cpp-example.html#a212">MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_8cpp-example.html#a214">MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_8cpp-example.html#a126">MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_8cpp-example.html#a212">MiiTransparentAdjuster.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a29">OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_8cpp-example.html#a19">OsMultiWaitUtility.cpp</a>, <a class="el" href="_os_semaphore_8cpp-example.html#a9">OsSemaphore.cpp</a> (計18項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="a201a00464d5606e40bef1798cba2ace8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FinalizeSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> オブジェクトをファイナライズします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>semaphore が初期化状態である</li>
<li>semaphore を待機しているスレッドがいない</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>semaphore が未初期化状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 <a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> オブジェクトをファイナライズします。<br />
 既にファイナライズ済みであった場合には何もせずにリターンします。<br />
 対象セマフォを待機しているスレッドがある場合にはアサートに失敗します。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 semaphore に対する操作は行なわないで下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_multi_wait_8cpp-example.html#a40">OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_8cpp-example.html#a30">OsMultiWaitUtility.cpp</a>, <a class="el" href="_os_semaphore_8cpp-example.html#a16">OsSemaphore.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac9e1d42bdb0279e887dc1caef45fcff1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::AcquireSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> を獲得します（Ｐ操作） </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>semaphore が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>semaphore が初期化状態である</li>
<li>セマフォカウンタがデクリメントされる</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 指定されたセマフォから 1 カウント分を獲得します（Ｐ操作）。<br />
 対象セマフォカウントが既に 0 の場合、他のスレッドがセマフォを 返却するまで自スレッドは待機します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_multi_wait_8cpp-example.html#a5">OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_8cpp-example.html#a5">OsMultiWaitUtility.cpp</a>, <a class="el" href="_os_semaphore_8cpp-example.html#a2">OsSemaphore.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af5fa41594b3b3072d78735f366bdb7ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TryAcquireSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> の獲得を試みます（Ｐ操作） </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>セマフォ獲得の成否を示します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>semaphore が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>返値が true の場合<ul>
<li>semaphore が初期化状態である</li>
<li>セマフォカウンタがデクリメントされる</li>
</ul>
</li>
<li>返値が false の場合<ul>
<li>semaphore が非シグナル状態である</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 指定されたセマフォから 1 カウント分を獲得します（Ｐ操作）。 獲得に成功した場合は、true を返します。<br />
 対象セマフォカウントが既に 0 の場合、自スレッドは 待ちに入らずに false を返します。 </p>

</div>
</div>
<a class="anchor" id="a54c8209e58cabbf5ab5173867dcad732"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::TimedAcquireSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> を時限付きで獲得を試みます（Ｐ操作） </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>セマフォ待ちのタイムアウト時間</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>セマフォ獲得の成否を示します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>semaphore が初期化状態である</li>
<li>timeout &gt;= 0</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>返値が true の場合<ul>
<li>semaphore が初期化状態である</li>
<li>セマフォカウンタがデクリメントされる</li>
</ul>
</li>
<li>返値が false の場合<ul>
<li>semaphore が非シグナル状態である</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 指定されたセマフォから１カウント分を獲得します（Ｐ操作）。 獲得に成功した場合は、true を返します。<br />
 対象セマフォカウントが既に 0 の場合、他のスレッドがセマフォを 返却するまで自スレッドは待機します。この時、timeout 時間経過後に タイムアウトが成立し自動的に待ちが解除されます。<br />
 この場合には返値として false を返します。</p>
<p>タイムアウトの動作に関しては <a class="el" href="_page_notification_os_timeout.html">OS-API のタイムアウトについて</a> の 注意事項も参照して下さい。 </p>

</div>
</div>
<a class="anchor" id="acf2cbceb4266858d27387ff2cb29a5ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ReleaseSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> を１カウントだけ返却します（Ｖ操作） </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>semaphore が初期化状態である</li>
<li>semaphore のセマフォカウンタが maxCount 未満である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>semaphore のセマフォカウンタがインクリメントされる</li>
<li>待機スレッドがある場合、待機スレッドを１つだけ待ち解除する</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 指定されたセマフォに 1 カウント分を返却します（Ｖ操作）。<br />
 対象セマフォを待機しているスレッドがある場合、最初の 1 つだけ、 待ちスレッドが解除されます。</p>
<p>対象セマフォカウンタが、 <a class="el" href="namespacenn_1_1os.html#af76bc96a9333f18ed5d7bead209eb4f3" title="SemaphoreType オブジェクトを初期化します。 ">InitializeSemaphore()</a> 時に指定した maxCount を上回るような操作をした場合、本 API はアサートに失敗します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_multi_wait_8cpp-example.html#a24">OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_8cpp-example.html#a14">OsMultiWaitUtility.cpp</a>, <a class="el" href="_os_semaphore_8cpp-example.html#a6">OsSemaphore.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a40039d059051bc9970e072417ac9576d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::ReleaseSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> を複数カウント返却します（Ｖ操作） </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>返却したいセマフォカウント数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>count &gt;= 1</li>
<li>semaphore が初期化状態である</li>
<li>semaphore のセマフォカウンタが maxCount - count 以下である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>semaphore のセマフォカウンタが count 個だけ増加される</li>
<li>待機スレッドがある場合、待機スレッドを全て待ち解除する</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 指定されたセマフォに指定された count 分のセマフォカウントを返却します（Ｖ操作）。<br />
 この時、対象セマフォを待機しているスレッドがある場合、 全ての待ちスレッドが解除されます。</p>
<p>対象セマフォカウンタが、 <a class="el" href="namespacenn_1_1os.html#af76bc96a9333f18ed5d7bead209eb4f3" title="SemaphoreType オブジェクトを初期化します。 ">InitializeSemaphore()</a> 時に指定した maxCount を上回るような操作をした場合、本 API はアサートに失敗します。 </p>

</div>
</div>
<a class="anchor" id="aa6a315a7f4822cee3e62e9912737edfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::GetCurrentSemaphoreCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> の現在のカウンタ値を返します </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td><a class="el" href="structnn_1_1os_1_1_semaphore_type.html" title="セマフォオブジェクトを定義する構造体です。 ">SemaphoreType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>対象セマフォの現在のカウンタ値を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>semaphore が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>semaphore が初期化状態である</li>
<li>semaphore の現在のカウンタ値を返す</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 現在のセマフォカウント値を返します。</p>
<p>セマフォは、他のスレッドによって操作されることでカウンタ値が 変化するため、この API によって取得できるカウンタ値は瞬間的なもの でしかありません。本 API の利用時にはこの点に注意して下さい。 </p>

</div>
</div>
<a class="anchor" id="a0e0b40464c9936df7d8cb77dadffcbd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_semaphore_type.html">SemaphoreType</a> *&#160;</td>
          <td class="paramname"><em>semaphore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWaitHolder を初期化し、semaphore と関連付けます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>多重待ちオブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">semaphore</td><td>紐付ける先のセマフォへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWaitHolder が未初期化状態である</li>
<li>semaphore が初期化状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>multiWaitHolder が初期化状態である（semaphore に関連付けられる）</li>
<li><a class="el" href="namespacenn_1_1os.html#a9e8c73312415fc00c72808fcc00fea33">nn::os::GetMultiWaitHolderUserData(multiWaitHolder)</a> == 0</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 multiWaitHolder を初期化し、semaphore オブジェクトと関連付けます。</p>
<p>関連付けされた multiWaitHolder は、対象セマフォのカウンタが 1 以上の時に シグナル状態となります。また、対象セマフォのカウンタが 予め 1 以上だった場合は、即座にシグナル状態となります。</p>
<p>本 API によって初期化された multiWaitHolder オブジェクトを使って多重待ちを 行ない、実際に対象のセマフォがシグナル状態になることで多重待ちが解除された 場合でも、対象セマフォを自動的に獲得することはありません。<br />
 詳細は <a class="el" href="_page_notification_os_multi_wait.html#PageNotificationOsMultiWait_AboutWakeup">多重待ちの待ち解除について</a> を参照して下さい。</p>
<p>本 API の動作中に対象 multiWaitHolder に対する操作は行なわないで下さい。 </p>

</div>
</div>
<a class="anchor" id="a75f43e1d3c194c0d2173ef5d95785933"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::os::CreateThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#abec974a5d224f7c62cfa9af4af3c954a">ThreadFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idealCoreNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>スレッドを生成します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>スレッドの関数エントリ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argument</td><td>スレッドに渡される引数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>スレッドのスタック領域の先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stackSize</td><td>スレッドのスタックサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>スレッドの優先度 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idealCoreNumber</td><td>スレッドを作成するコア番号</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果を表す <a class="el" href="classnn_1_1_result.html">nn::Result</a> 値を返します。 <ul>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_memory.html">nn::os::ResultOutOfMemory</a> のハンドリングが必要です。 </li>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_resource.html">nn::os::ResultOutOfResource</a> のハンドリングが必要です。</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>thread が NotInitialized 状態もしくは初期化されていない状態である</li>
<li>stack が <a class="el" href="namespacenn_1_1os.html#a8b116319f3d483f3805c193661f22150" title="スレッドのスタック領域のアライメント制約を表す定数です。 ">nn::os::ThreadStackAlignment</a> でアライメントされている</li>
<li>stackSize &gt; 0</li>
<li>stackSize % <a class="el" href="namespacenn_1_1os.html#a8b116319f3d483f3805c193661f22150" title="スレッドのスタック領域のアライメント制約を表す定数です。 ">nn::os::ThreadStackAlignment</a> == 0</li>
<li><a class="el" href="namespacenn_1_1os.html#a20238ce26424ba34876552fb2d53165a" title="指定されたメモリ領域がロックされているかどうかを検査します。 ">nn::os::IsMemoryLocked</a> (stack, stackSize) == false</li>
<li><a class="el" href="namespacenn_1_1os.html#a44ed3b4dddf9ebfb69bc33167369b816" title="スレッドの最高優先度を表す定数です。0 です。 ">nn::os::HighestThreadPriority</a> &lt;= priority &lt;= <a class="el" href="namespacenn_1_1os.html#a88510f5f630a16612aa8d479c10b56de" title="スレッドの最低優先度を表す定数です。31 です。 ">nn::os::LowestThreadPriority</a></li>
<li>idealCoreNumber がターゲット動作環境毎に定義された有効な値である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>thread が Initialized 状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 スレッドを生成すると共に、スレッドオブジェクトを初期化します。<br />
 ただし、本 API 発行後も、スレッドはまだ動作を開始しません。<br />
 スレッドの動作を開始するには、 <a class="el" href="namespacenn_1_1os.html#a18eec7c4c4c298f7abaa9ef41d6de76b" title="スレッドの実行を開始します。 ">StartThread()</a> を発行して下さい。</p>
<p>スタック用のメモリとして、stack ～ (stack + stackSize) 空間上の メモリが利用されます。<br />
 スタック用のメモリがどのように使用されるかは動作環境によって異なります。</p>
<p>stack および stackSize は <a class="el" href="namespacenn_1_1os.html#a895eb281cfb4500d6ac462cec6631613" title="スタック領域のアライメント制約を表す定数です。 ">nn::os::StackRegionAlignment</a> 定数が示す値でアライメント されたものでなければなりません。スタック領域用のバッファをこの定数値相当で アライメントさせて定義するには <a class="el" href="os___thread_common_8h.html#a5ce0c3c0aaceb976178a60a18d90f470">NN_OS_ALIGNAS_THREAD_STACK</a> マクロを ご利用下さい。</p>
<p>スレッド優先度を示す priority は、 <a class="el" href="namespacenn_1_1os.html#a44ed3b4dddf9ebfb69bc33167369b816" title="スレッドの最高優先度を表す定数です。0 です。 ">nn::os::HighestThreadPriority</a> から <a class="el" href="namespacenn_1_1os.html#a88510f5f630a16612aa8d479c10b56de" title="スレッドの最低優先度を表す定数です。31 です。 ">nn::os::LowestThreadPriority</a> の範囲内で指定し、 数値が小さいほど高い優先順位となります。</p>
<p>スレッドを作成するコア番号を示す idealCoreNumber の有効な値は ターゲット環境依存です。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象 thread オブジェクトに対する操作は 行なわないで下さい。</p>
<div id="dynsection-Windows" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-Windows-trigger" src="closed.png"/>
  <b>（Windowsプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-Windows-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-Windows-content" class="dyncontent" style="display:none;"><ul>
<li>スレッドが使用するスタック領域は、指定された stack の場所ではなく、 Windows が独自に確保した領域が使用されます。</li>
<li>ただし、stack 引数には事前条件を満たす一定量のメモリ領域を正しく渡して下さい。<br />
 NULL を指定した場合はアサートに失敗します。</li>
<li>スレッドの優先度は無視され、常に標準的な優先度を持つスレッドとして生成されます。</li>
<li>idealCoreNumber は無視され、スレッドは Windows のスケジューリングに依存して動作します。</li>
</ul>
</div><div id="dynsection-Windows-content" class="dyncontent" style="display:none;"></div><p> <b>実機環境の場合</b> </p>
<ul>
<li>実機環境では指定された stack 領域をそのままスタック領域として使用する ケースと、下記のように一度他の場所にミラーリングするケースがあります。 いずれのケースになるかはプログラムのビルド段階で決定されます。</li>
<li>指定された stack が指すメモリ領域を、他の未使用メモリ空間へミラーリング するケースでは、そのミラーリングした先がスタック領域として使用されます。</li>
<li>ミラーリングした先では、スタック領域の前後に 4KByte のガードページが 用意されます。このガードページへの読み込み、書き込みは出来ません。</li>
<li>対象スレッドが <a class="el" href="namespacenn_1_1os.html#a9dbfcfb82583a9e34431e8c11d2411dd" title="スレッドを削除します。 ">DestroyThread()</a> されると、そのスレッドのスタック領域は ミラーリングが解除され、元のメモリ領域として再度使用することができます。</li>
<li>ミラーリングを行なわないケースでは、前後のガードページは作成されません。 </li>
</ul>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_echoback_8cpp-example.html#a88">AudioEchoback.cpp</a>, <a class="el" href="_audio_multiple_renderer_8cpp-example.html#a65">AudioMultipleRenderer.cpp</a>, <a class="el" href="_bcat_practical_8cpp-example.html#a5">BcatPractical.cpp</a>, <a class="el" href="_hid_vibration_player_8cpp-example.html#a51">HidVibrationPlayer.cpp</a>, <a class="el" href="_ldn_access_point_8cpp-example.html#a73">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a70">LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a71">MovieDecoderPlayer.cpp</a>, <a class="el" href="_nifm_network_connection_simple__main_8cpp-example.html#a5">NifmNetworkConnectionSimple_Main.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a103">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a100">NvnTutorial06.cpp</a>, <a class="el" href="_oe_disable_auto_sleep_8cpp-example.html#a6">OeDisableAutoSleep.cpp</a>, <a class="el" href="_oe_idle_policy_8cpp-example.html#a13">OeIdlePolicy.cpp</a>, <a class="el" href="_os_barrier_8cpp-example.html#a12">OsBarrier.cpp</a>, <a class="el" href="_os_condition_variable_8cpp-example.html#a14">OsConditionVariable.cpp</a>, <a class="el" href="_os_event_8cpp-example.html#a13">OsEvent.cpp</a>, <a class="el" href="_os_message_queue_8cpp-example.html#a10">OsMessageQueue.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a33">OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_8cpp-example.html#a23">OsMultiWaitUtility.cpp</a>, <a class="el" href="_os_mutex_8cpp-example.html#a9">OsMutex.cpp</a>, <a class="el" href="_os_reader_writer_lock_8cpp-example.html#a13">OsReaderWriterLock.cpp</a>, <a class="el" href="_os_semaphore_8cpp-example.html#a11">OsSemaphore.cpp</a>, <a class="el" href="_os_thread_8cpp-example.html#a12">OsThread.cpp</a>, <a class="el" href="_os_thread_local_storage_8cpp-example.html#a11">OsThreadLocalStorage.cpp</a>, <a class="el" href="_os_timer_event_8cpp-example.html#a15">OsTimerEvent.cpp</a>, <a class="el" href="_parallel_8cpp-example.html#a119">Parallel.cpp</a>, <a class="el" href="_perf_simple_8cpp-example.html#a58">PerfSimple.cpp</a>, <a class="el" href="_render_thread_pool_8cpp-example.html#a12">RenderThreadPool.cpp</a> (計27項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1e7db66d31e254873b613d4eadd0d716"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::os::CreateThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#abec974a5d224f7c62cfa9af4af3c954a">ThreadFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>スレッドを生成します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>スレッドの関数エントリ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argument</td><td>スレッドに渡される引数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>スレッドのスタック領域の先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stackSize</td><td>スレッドのスタックサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>スレッドの優先度</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果を表す <a class="el" href="classnn_1_1_result.html">nn::Result</a> 値を返します。 <ul>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_memory.html">nn::os::ResultOutOfMemory</a> のハンドリングが必要です。 </li>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_resource.html">nn::os::ResultOutOfResource</a> のハンドリングが必要です。</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>thread が NotInitialized 状態もしくは初期化されていない状態である</li>
<li>stack が <a class="el" href="namespacenn_1_1os.html#a8b116319f3d483f3805c193661f22150" title="スレッドのスタック領域のアライメント制約を表す定数です。 ">nn::os::ThreadStackAlignment</a> でアライメントされている</li>
<li>stackSize &gt; 0</li>
<li>stackSize % <a class="el" href="namespacenn_1_1os.html#a8b116319f3d483f3805c193661f22150" title="スレッドのスタック領域のアライメント制約を表す定数です。 ">nn::os::ThreadStackAlignment</a> == 0</li>
<li><a class="el" href="namespacenn_1_1os.html#a20238ce26424ba34876552fb2d53165a" title="指定されたメモリ領域がロックされているかどうかを検査します。 ">nn::os::IsMemoryLocked</a> (stack, stackSize) == false</li>
<li><a class="el" href="namespacenn_1_1os.html#a44ed3b4dddf9ebfb69bc33167369b816" title="スレッドの最高優先度を表す定数です。0 です。 ">nn::os::HighestThreadPriority</a> &lt;= priority &lt;= <a class="el" href="namespacenn_1_1os.html#a88510f5f630a16612aa8d479c10b56de" title="スレッドの最低優先度を表す定数です。31 です。 ">nn::os::LowestThreadPriority</a></li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>thread が Initialized 状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 スレッドを生成すると共に、スレッドオブジェクトを初期化します。</p>
<p>基本的にもう１つの <a class="el" href="namespacenn_1_1os.html#a75f43e1d3c194c0d2173ef5d95785933" title="スレッドを生成します。 ">CreateThread()</a> と機能的に等価ですが、こちらはコア番号を 指定できません。コア番号には各ターゲット環境における規定値が適用されます。 </p>

</div>
</div>
<a class="anchor" id="a9dbfcfb82583a9e34431e8c11d2411dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::DestroyThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>スレッドを削除します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>thread が Initialized, Started, Exited のいずれかの状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>thread が NotInitialized 状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 スレッドオブジェクトを破棄すると共に、スレッドを削除します。 スレッドが Started 状態の場合は、Exited になるまで待機してから削除します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_echoback_8cpp-example.html#a106">AudioEchoback.cpp</a>, <a class="el" href="_audio_multiple_renderer_8cpp-example.html#a70">AudioMultipleRenderer.cpp</a>, <a class="el" href="_hid_vibration_player_8cpp-example.html#a58">HidVibrationPlayer.cpp</a>, <a class="el" href="_ldn_access_point_8cpp-example.html#a77">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a73">LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a77">MovieDecoderPlayer.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a108">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a105">NvnTutorial06.cpp</a>, <a class="el" href="_os_barrier_8cpp-example.html#a18">OsBarrier.cpp</a>, <a class="el" href="_os_condition_variable_8cpp-example.html#a20">OsConditionVariable.cpp</a>, <a class="el" href="_os_event_8cpp-example.html#a19">OsEvent.cpp</a>, <a class="el" href="_os_message_queue_8cpp-example.html#a16">OsMessageQueue.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a39">OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_8cpp-example.html#a29">OsMultiWaitUtility.cpp</a>, <a class="el" href="_os_mutex_8cpp-example.html#a16">OsMutex.cpp</a>, <a class="el" href="_os_reader_writer_lock_8cpp-example.html#a18">OsReaderWriterLock.cpp</a>, <a class="el" href="_os_semaphore_8cpp-example.html#a15">OsSemaphore.cpp</a>, <a class="el" href="_os_thread_8cpp-example.html#a17">OsThread.cpp</a>, <a class="el" href="_os_thread_local_storage_8cpp-example.html#a15">OsThreadLocalStorage.cpp</a>, <a class="el" href="_os_timer_event_8cpp-example.html#a25">OsTimerEvent.cpp</a>, <a class="el" href="_parallel_8cpp-example.html#a126">Parallel.cpp</a>, <a class="el" href="_perf_simple_8cpp-example.html#a67">PerfSimple.cpp</a>, <a class="el" href="_render_thread_pool_8cpp-example.html#a18">RenderThreadPool.cpp</a> (計23項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="a18eec7c4c4c298f7abaa9ef41d6de76b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::StartThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>スレッドの実行を開始します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>thread が Initialized 状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>thread が Started 状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 対象スレッドの実行を開始します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_echoback_8cpp-example.html#a90">AudioEchoback.cpp</a>, <a class="el" href="_audio_multiple_renderer_8cpp-example.html#a67">AudioMultipleRenderer.cpp</a>, <a class="el" href="_bcat_practical_8cpp-example.html#a7">BcatPractical.cpp</a>, <a class="el" href="_hid_controller_sequence__main_8cpp-example.html#a33">HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_vibration_player_8cpp-example.html#a53">HidVibrationPlayer.cpp</a>, <a class="el" href="_ldn_access_point_8cpp-example.html#a74">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a71">LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a75">MovieDecoderPlayer.cpp</a>, <a class="el" href="_nifm_network_connection_simple__main_8cpp-example.html#a8">NifmNetworkConnectionSimple_Main.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a105">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a102">NvnTutorial06.cpp</a>, <a class="el" href="_oe_disable_auto_sleep_8cpp-example.html#a12">OeDisableAutoSleep.cpp</a>, <a class="el" href="_oe_idle_policy_8cpp-example.html#a18">OeIdlePolicy.cpp</a>, <a class="el" href="_os_barrier_8cpp-example.html#a16">OsBarrier.cpp</a>, <a class="el" href="_os_condition_variable_8cpp-example.html#a18">OsConditionVariable.cpp</a>, <a class="el" href="_os_event_8cpp-example.html#a17">OsEvent.cpp</a>, <a class="el" href="_os_message_queue_8cpp-example.html#a14">OsMessageQueue.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a37">OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_8cpp-example.html#a27">OsMultiWaitUtility.cpp</a>, <a class="el" href="_os_mutex_8cpp-example.html#a13">OsMutex.cpp</a>, <a class="el" href="_os_reader_writer_lock_8cpp-example.html#a15">OsReaderWriterLock.cpp</a>, <a class="el" href="_os_semaphore_8cpp-example.html#a13">OsSemaphore.cpp</a>, <a class="el" href="_os_thread_8cpp-example.html#a16">OsThread.cpp</a>, <a class="el" href="_os_thread_local_storage_8cpp-example.html#a13">OsThreadLocalStorage.cpp</a>, <a class="el" href="_os_timer_event_8cpp-example.html#a19">OsTimerEvent.cpp</a>, <a class="el" href="_parallel_8cpp-example.html#a123">Parallel.cpp</a>, <a class="el" href="_perf_simple_8cpp-example.html#a158">PerfSimple.cpp</a>, <a class="el" href="_render_thread_pool_8cpp-example.html#a15">RenderThreadPool.cpp</a> (計28項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad106866a5b13bc3d430104333966b479"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a>* nn::os::GetCurrentThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>自スレッドの <a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトへのポインタです。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>なし</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>自スレッドの <a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトへのポインタを返す</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 自スレッドの <a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトへのポインタを返します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_framework_demo_2_main_8cpp-example.html#a36">FrameworkDemo/Main.cpp</a>, <a class="el" href="_gfx_primitive_renderer_8cpp-example.html#a351">GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_hid_controller_sequence__main_8cpp-example.html#a14">HidControllerSequence_Main.cpp</a>, <a class="el" href="_ldn_simple_2_main_8cpp-example.html#a8">LdnSimple/Main.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a7">MovieDecoderPlayer.cpp</a>, <a class="el" href="_os_user_exception_handler_sample_8cpp-example.html#a20">OsUserExceptionHandlerSample.cpp</a>, <a class="el" href="_parallel_8cpp-example.html#a8">Parallel.cpp</a>, <a class="el" href="_perf_simple_8cpp-example.html#a65">PerfSimple.cpp</a>, <a class="el" href="_shape_animation_8cpp-example.html#a144">ShapeAnimation.cpp</a>, <a class="el" href="_skeletal_animation_8cpp-example.html#a99">SkeletalAnimation.cpp</a>, <a class="el" href="_town_8cpp-example.html#a132">Town.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8070c91be85c5ccb36b56e9ff3a75b26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::WaitThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>対象スレッドが終了するのを待ちます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>thread が Initialized, Started, Exited のいずれかの状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>thread が Exited 状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 対象スレッドが終了するまで待機（ブロッキング）します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_echoback_8cpp-example.html#a105">AudioEchoback.cpp</a>, <a class="el" href="_audio_multiple_renderer_8cpp-example.html#a69">AudioMultipleRenderer.cpp</a>, <a class="el" href="_hid_controller_sequence__main_8cpp-example.html#a32">HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_vibration_player_8cpp-example.html#a57">HidVibrationPlayer.cpp</a>, <a class="el" href="_ldn_access_point_8cpp-example.html#a76">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a72">LdnStation.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a76">MovieDecoderPlayer.cpp</a>, <a class="el" href="_nifm_network_connection_simple__main_8cpp-example.html#a10">NifmNetworkConnectionSimple_Main.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a106">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a103">NvnTutorial06.cpp</a>, <a class="el" href="_os_barrier_8cpp-example.html#a17">OsBarrier.cpp</a>, <a class="el" href="_os_condition_variable_8cpp-example.html#a19">OsConditionVariable.cpp</a>, <a class="el" href="_os_event_8cpp-example.html#a18">OsEvent.cpp</a>, <a class="el" href="_os_message_queue_8cpp-example.html#a15">OsMessageQueue.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a38">OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_8cpp-example.html#a28">OsMultiWaitUtility.cpp</a>, <a class="el" href="_os_mutex_8cpp-example.html#a14">OsMutex.cpp</a>, <a class="el" href="_os_reader_writer_lock_8cpp-example.html#a17">OsReaderWriterLock.cpp</a>, <a class="el" href="_os_semaphore_8cpp-example.html#a14">OsSemaphore.cpp</a>, <a class="el" href="_os_thread_8cpp-example.html#a7">OsThread.cpp</a>, <a class="el" href="_os_thread_local_storage_8cpp-example.html#a14">OsThreadLocalStorage.cpp</a>, <a class="el" href="_os_timer_event_8cpp-example.html#a24">OsTimerEvent.cpp</a>, <a class="el" href="_parallel_8cpp-example.html#a125">Parallel.cpp</a>, <a class="el" href="_render_thread_pool_8cpp-example.html#a17">RenderThreadPool.cpp</a> (計24項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8bd5e5e72c058eb7d1b5f0ebfbb2cf6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::YieldThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>同一優先度の他のスレッドに実行機会を譲ります。 </p>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>なし</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>自スレッドと同一優先度を持つ他のスレッドに実行機会を譲る</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 自スレッドが動作しているコアで動作可能なスレッドのうち、 自スレッドと同じ優先度を持つ他のスレッドに実行機会を譲ります。</p>
<p>同一の優先度を持つ他スレッドが同一コアに存在しない場合は、 そのまま自スレッドが動作を継続する場合があります。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_render_thread_pool_8cpp-example.html#a16">RenderThreadPool.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a96b335e87af44c60a0d6dca75f11c9d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SleepThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>自スレッドを指定された時間だけ休止します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>自スレッドを休止させる時間</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>time &gt;= 0</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>time で指定された時間だけ自スレッドを休止し、 その後自動的に起床する</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 自スレッドを指定された時間だけ休止します。<br />
 他スレッドから起床させることは出来ません。<br />
 休止時間の単位は、 <a class="el" href="classnn_1_1_time_span.html" title="時間の長さを表すクラスです。 ">TimeSpan</a> 型に依存します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_album_save_screenshot__main_8cpp-example.html#a10">AlbumSaveScreenshot_Main.cpp</a>, <a class="el" href="_atk_addon_sound_archive_8cpp-example.html#a35">AtkAddonSoundArchive.cpp</a>, <a class="el" href="_atk_effect_8cpp-example.html#a46">AtkEffect.cpp</a>, <a class="el" href="_atk_filter_8cpp-example.html#a23">AtkFilter.cpp</a>, <a class="el" href="_atk_group_8cpp-example.html#a26">AtkGroup.cpp</a>, <a class="el" href="_atk_mix_mode_8cpp-example.html#a38">AtkMixMode.cpp</a>, <a class="el" href="_atk_profile_8cpp-example.html#a35">AtkProfile.cpp</a>, <a class="el" href="_atk_simple_8cpp-example.html#a18">AtkSimple.cpp</a>, <a class="el" href="_atk_sound3_d_8cpp-example.html#a29">AtkSound3D.cpp</a>, <a class="el" href="_atk_sound_actor_8cpp-example.html#a20">AtkSoundActor.cpp</a>, <a class="el" href="_atk_stream_sound_8cpp-example.html#a55">AtkStreamSound.cpp</a>, <a class="el" href="_atk_sub_mix_8cpp-example.html#a14">AtkSubMix.cpp</a>, <a class="el" href="_atk_viewer_8cpp-example.html#a33">AtkViewer.cpp</a>, <a class="el" href="_audio_echoback_8cpp-example.html#a87">AudioEchoback.cpp</a>, <a class="el" href="_audio_multiple_renderer_8cpp-example.html#a55">AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_out_8cpp-example.html#a71">AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_8cpp-example.html#a75">AudioOutWithResampler.cpp</a>, <a class="el" href="_bcat_practical_8cpp-example.html#a12">BcatPractical.cpp</a>, <a class="el" href="_bcat_simple_8cpp-example.html#a9">BcatSimple.cpp</a>, <a class="el" href="_framework_demo_2_main_8cpp-example.html#a42">FrameworkDemo/Main.cpp</a>, <a class="el" href="_friends_simple_8cpp-example.html#a22">FriendsSimple.cpp</a>, <a class="el" href="_hid_controller_sequence__main_8cpp-example.html#a35">HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_npad_integrate__main_8cpp-example.html#a18">HidNpadIntegrate_Main.cpp</a>, <a class="el" href="_hid_npad_simple_8cpp-example.html#a26">HidNpadSimple.cpp</a>, <a class="el" href="_htcs_target_app_8cpp-example.html#a20">HtcsTargetApp.cpp</a>, <a class="el" href="_ir_sensor_clustering_basic_8cpp-example.html#a15">IrSensorClusteringBasic.cpp</a>, <a class="el" href="_ir_sensor_moment_basic_8cpp-example.html#a15">IrSensorMomentBasic.cpp</a>, <a class="el" href="_ldn_access_point_8cpp-example.html#a112">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_simple_2_main_8cpp-example.html#a15">LdnSimple/Main.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a111">LdnStation.cpp</a>, <a class="el" href="_libcurl_basic_8cpp-example.html#a13">LibcurlBasic.cpp</a>, <a class="el" href="_libcurl_speed_test_8cpp-example.html#a44">LibcurlSpeedTest.cpp</a>, <a class="el" href="_libcurl_ssl_context_import_8cpp-example.html#a13">LibcurlSslContextImport.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a51">MovieDecoderPlayer.cpp</a>, <a class="el" href="_nifm_network_connection_simple_8cpp-example.html#a2">NifmNetworkConnectionSimple.cpp</a>, <a class="el" href="_oe_disable_auto_sleep_8cpp-example.html#a24">OeDisableAutoSleep.cpp</a>, <a class="el" href="_oe_idle_policy_8cpp-example.html#a20">OeIdlePolicy.cpp</a>, <a class="el" href="_oe_idle_policy_api_for_application_specific_control_8cpp-example.html#a2">OeIdlePolicyApiForApplicationSpecificControl.cpp</a>, <a class="el" href="_os_barrier_8cpp-example.html#a6">OsBarrier.cpp</a>, <a class="el" href="_os_event_8cpp-example.html#a5">OsEvent.cpp</a>, <a class="el" href="_os_multi_wait_8cpp-example.html#a22">OsMultiWait.cpp</a>, <a class="el" href="_os_multi_wait_utility_8cpp-example.html#a12">OsMultiWaitUtility.cpp</a>, <a class="el" href="_os_reader_writer_lock_8cpp-example.html#a7">OsReaderWriterLock.cpp</a>, <a class="el" href="_os_semaphore_8cpp-example.html#a4">OsSemaphore.cpp</a>, <a class="el" href="_os_tick_and_time_span_8cpp-example.html#a8">OsTickAndTimeSpan.cpp</a>, <a class="el" href="_pcm_basic_8cpp-example.html#a18">PcmBasic.cpp</a>, <a class="el" href="_profiler_simple_8cpp-example.html#a3">ProfilerSimple.cpp</a>, <a class="el" href="_socket_basic_8cpp-example.html#a41">SocketBasic.cpp</a>, <a class="el" href="_socket_resolver_8cpp-example.html#a37">SocketResolver.cpp</a>, <a class="el" href="_spy_atk_8cpp-example.html#a37">SpyAtk.cpp</a>, <a class="el" href="_ssl_simple_8cpp-example.html#a10">SslSimple.cpp</a>, <a class="el" href="_time_calculate_user_system_clock_difference_8cpp-example.html#a6">TimeCalculateUserSystemClockDifference.cpp</a>, <a class="el" href="_time_claim_periodic_benefit_8cpp-example.html#a27">TimeClaimPeriodicBenefit.cpp</a>, <a class="el" href="_time_standard_steady_clock_8cpp-example.html#a6">TimeStandardSteadyClock.cpp</a> (計54項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac7eb0e6eae11777e92308cdee62e6cb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::ChangeThreadPriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>対象スレッドの優先度を変更します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>設定したい優先度</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>優先度変更前のスレッド優先度</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>thread が Initialized, Started, Exited のいずれかの状態である</li>
<li><a class="el" href="namespacenn_1_1os.html#a44ed3b4dddf9ebfb69bc33167369b816" title="スレッドの最高優先度を表す定数です。0 です。 ">nn::os::HighestThreadPriority</a> &lt;= priority &lt;= <a class="el" href="namespacenn_1_1os.html#a88510f5f630a16612aa8d479c10b56de" title="スレッドの最低優先度を表す定数です。31 です。 ">nn::os::LowestThreadPriority</a></li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>thread が初期化状態である</li>
<li>thread の優先度を変更し、その優先度を持つスレッド群 の中で最低の優先順位になる</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 対象スレッドの優先度を変更します。スレッドの優先度を示す priority は、 <a class="el" href="namespacenn_1_1os.html#a44ed3b4dddf9ebfb69bc33167369b816" title="スレッドの最高優先度を表す定数です。0 です。 ">nn::os::HighestThreadPriority</a> ～ <a class="el" href="namespacenn_1_1os.html#a88510f5f630a16612aa8d479c10b56de" title="スレッドの最低優先度を表す定数です。31 です。 ">nn::os::LowestThreadPriority</a> の 範囲内で指定し、数値が小さいほど高い優先順位となります。</p>
<p>対象スレッドが、何かしらの同期オブジェクトを待機している状態の場合、 そのスレッドが待ち行列の中でどのように扱われるかは、 各同期オブジェクトのポリシーに従います。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_thread_8cpp-example.html#a9">OsThread.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a912a6d5e17c206344f177bc192cb1e50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::GetThreadPriority </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>対象スレッドの本来の優先度を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>対象スレッドの本来の優先度です。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>thread が Initialized, Started, Exited のいずれかの状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>thread が Initialized, Started, Exited のいずれかの状態である</li>
<li>thread の本来の優先度を返す</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 対象スレッドの本来の優先度を返します。<br />
</p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_thread_8cpp-example.html#a4">OsThread.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a9b6b2e5e1968e008dde27d6c4762b33d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::GetThreadCurrentPriority </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>対象スレッドの現在の優先度を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>対象スレッドの現在の優先度です。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>thread が Initialized, Started, Exited のいずれかの状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>thread が Initialized, Started, Exited のいずれかの状態である</li>
<li>thread の現在の優先度を返す</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 対象スレッドの現在の優先度を返します。<br />
 ミューテックスの優先度継承が発動している場合は、継承中の優先度を返します。</p>
<p>スレッドの優先度は、他のスレッドによる <a class="el" href="namespacenn_1_1os.html#ac7eb0e6eae11777e92308cdee62e6cb2" title="対象スレッドの優先度を変更します。 ">ChangeThreadPriority()</a> や、 ミューテックス操作による優先度継承などによって、いつ変化するかは 定かではありません。</p>
<p>現在の優先度の参照は、あくまで瞬間的な値を取得するものであるため、 本 API の利用時にはこの点に注意して下さい。 </p>

</div>
</div>
<a class="anchor" id="a05cbcb85bd308694ec37eff49be93cf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SetThreadName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>threadName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>対象スレッドのスレッド名を設定します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threadName</td><td>ヌル文字で終端するスレッド名文字列の格納アドレス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>thread が Initialized, Started, Exited のいずれかの状態である</li>
<li>threadName の文字列の長さが <a class="el" href="namespacenn_1_1os.html#a793a3781900c43f3d8afda6e02ec1b58" title="スレッド名の最大文字数を表す定数です。  文字列終端の &#39;\0&#39; 文字を含んだ文字数です。 ...">nn::os::ThreadNameLengthMax</a> 未満である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>thread が Initialized, Started, Exited のいずれかの状態である</li>
<li>thread のスレッド名が threadName で示される名前に変更される</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 対象スレッドのスレッド名を設定します。<br />
 threadName が NULL の場合、スレッド名を初期状態に戻します。</p>
<p>設定されたスレッド名は、 <a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクト内部に保持されるため、 threadName が指すメモリ領域の内容を保持し続ける必要はありません。 また、本 API で設定したスレッド名は <a class="el" href="namespacenn_1_1os.html#a2941b0122ed1f1af2d7007af285d83b5" title="対象スレッドのスレッド名が格納されているアドレスを取得します。 ">nn::os::GetThreadNamePointer()</a> で その格納先のアドレスを取得することができます。</p>
<p>スレッド名の文字コードは ASCII を想定しています。<br />
 最大文字列長は終端のヌル文字を含め <a class="el" href="namespacenn_1_1os.html#a793a3781900c43f3d8afda6e02ec1b58" title="スレッド名の最大文字数を表す定数です。  文字列終端の &#39;\0&#39; 文字を含んだ文字数です。 ...">nn::os::ThreadNameLengthMax</a> 以下で なければなりません。スレッド名が最大長を超える場合はアサートに失敗します。</p>
<p>この <a class="el" href="namespacenn_1_1os.html#a793a3781900c43f3d8afda6e02ec1b58" title="スレッド名の最大文字数を表す定数です。  文字列終端の &#39;\0&#39; 文字を含んだ文字数です。 ...">nn::os::ThreadNameLengthMax</a> は動作環境によらず一定の値を示します。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象スレッドを削除したり、 <a class="el" href="namespacenn_1_1os.html#a05cbcb85bd308694ec37eff49be93cf1" title="対象スレッドのスレッド名を設定します。 ">nn::os::SetThreadName()</a> や <a class="el" href="namespacenn_1_1os.html#a90f2d7d33024e710d09a2b6d01b15522" title="対象スレッドのスレッド名が格納されているアドレスを設定します。 ">nn::os::SetThreadNamePointer()</a> を同時に呼び出したりしないで下さい。</p>
<div id="dynsection-Windows" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-Windows-trigger" src="closed.png"/>
  <b>（Windowsプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-Windows-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-Windows-content" class="dyncontent" style="display:none;"><ul>
<li>Windows 環境において、本 API を大量に発行し続けるようなプログラムを 実行すると VisualStudio デバッガが異常終了する場合があります。 これは、VisualStudio がスレッド名変更の通知を処理しきれないことが 原因と思われます。そのため、特に VisualStudio デバッガ接続状態では 本 API を大量に発行し続けるような処理を行なわないで下さい。</li>
</ul>
</div><div id="dynsection-Windows-content" class="dyncontent" style="display:none;"></div> <dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_simple_2_main_8cpp-example.html#a7">LdnSimple/Main.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a73">MovieDecoderPlayer.cpp</a>, <a class="el" href="_os_thread_8cpp-example.html#a8">OsThread.cpp</a>, <a class="el" href="_perf_simple_8cpp-example.html#a60">PerfSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a90f2d7d33024e710d09a2b6d01b15522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SetThreadNamePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>threadName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>対象スレッドのスレッド名が格納されているアドレスを設定します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threadName</td><td>ヌル文字で終端するスレッド名文字列の格納アドレス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>thread が Initialized, Started, Exited のいずれかの状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>thread が Initialized, Started, Exited のいずれかの状態である</li>
<li>thread のスレッド名が threadName で示される名前に変更される</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 対象スレッドのスレッド名を設定します。<br />
 threadName が NULL の場合、スレッド名を初期状態に戻します。</p>
<p>指定されたスレッド名は、その先頭アドレスのみを <a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトの 内部で保持します。そのため、スレッド名が格納されているメモリ領域は、 <a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトが破棄されるか、新しいスレッド名が再設定されるまで 利用可能な状態が維持されていなければなりません。</p>
<p>本 API で設定したスレッド名は <a class="el" href="namespacenn_1_1os.html#a2941b0122ed1f1af2d7007af285d83b5" title="対象スレッドのスレッド名が格納されているアドレスを取得します。 ">nn::os::GetThreadNamePointer()</a> で その格納先のアドレスを取得することができます。</p>
<p>本 API はスレッドセーフではありません。<br />
 本 API の動作中に対象スレッドを削除したり、 <a class="el" href="namespacenn_1_1os.html#a05cbcb85bd308694ec37eff49be93cf1" title="対象スレッドのスレッド名を設定します。 ">nn::os::SetThreadName()</a> や <a class="el" href="namespacenn_1_1os.html#a90f2d7d33024e710d09a2b6d01b15522" title="対象スレッドのスレッド名が格納されているアドレスを設定します。 ">nn::os::SetThreadNamePointer()</a> を同時に呼び出したりしないで下さい。</p>
<div id="dynsection-Windows" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-Windows-trigger" src="closed.png"/>
  <b>（Windowsプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-Windows-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-Windows-content" class="dyncontent" style="display:none;"><ul>
<li>Windows 環境において、本 API を大量に発行し続けるようなプログラムを 実行すると VisualStudio デバッガが異常終了する場合があります。 これは、VisualStudio がスレッド名変更の通知を処理しきれないことが 原因と思われます。そのため、特に VisualStudio デバッガ接続状態では 本 API を大量に発行し続けるような処理を行なわないで下さい。</li>
</ul>
</div><div id="dynsection-Windows-content" class="dyncontent" style="display:none;"></div> <dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nifm_network_connection_simple__main_8cpp-example.html#a7">NifmNetworkConnectionSimple_Main.cpp</a>, <a class="el" href="_oe_disable_auto_sleep_8cpp-example.html#a11">OeDisableAutoSleep.cpp</a>, <a class="el" href="_oe_idle_policy_8cpp-example.html#a17">OeIdlePolicy.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a2941b0122ed1f1af2d7007af285d83b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * nn::os::GetThreadNamePointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>対象スレッドのスレッド名が格納されているアドレスを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>対象スレッドのスレッド名が格納されているアドレスです。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>thread が Initialized, Started, Exited のいずれかの状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>thread が Initialized, Started, Exited のいずれかの状態である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 対象スレッドのスレッド名が格納されているアドレスを取得します。</p>
<p>スレッド名を <a class="el" href="namespacenn_1_1os.html#a05cbcb85bd308694ec37eff49be93cf1" title="対象スレッドのスレッド名を設定します。 ">nn::os::SetThreadName()</a> で設定していた場合は、 <a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクト内部で保持しているスレッド名格納領域の 先頭アドレスを返します。<br />
 スレッド名を <a class="el" href="namespacenn_1_1os.html#a90f2d7d33024e710d09a2b6d01b15522" title="対象スレッドのスレッド名が格納されているアドレスを設定します。 ">nn::os::SetThreadNamePointer()</a> で設定していた場合は、 <a class="el" href="namespacenn_1_1os.html#a90f2d7d33024e710d09a2b6d01b15522" title="対象スレッドのスレッド名が格納されているアドレスを設定します。 ">nn::os::SetThreadNamePointer()</a> で設定したスレッド名のアドレスを返します。</p>
<p>スレッド名を変更していない場合や、上記 API にてスレッド名を初期状態に 戻していた場合は、 <a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">nn::os::ThreadType</a> オブジェクト内部のスレッド名格納領域に 初期スレッド名が格納されており、その先頭アドレスを返します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_hid_controller_sequence__main_8cpp-example.html#a41">HidControllerSequence_Main.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#a6">MovieDecoderPlayer.cpp</a>, <a class="el" href="_os_thread_8cpp-example.html#a3">OsThread.cpp</a>, <a class="el" href="_os_user_exception_handler_sample_8cpp-example.html#a21">OsUserExceptionHandlerSample.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a500af81132a0e2b26db7289bbd19942e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::GetCurrentProcessorNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>現在自スレッドが動作しているコア番号を取得します。 </p>
<p>このAPIの利用は非推奨です。代替APIや利用条件の有無については詳細を確認してください。</p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">非推奨:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>戻り値</dt><dd>現在自スレッドが動作しているコア番号です。</dd></dl>
<p><b>詳細</b> <br />
 この API は削除予定です。 <a class="el" href="namespacenn_1_1os.html#a4b94c321b41c4fb4d0a4e87473297c48" title="現在自スレッドが動作しているコア番号を取得します。 ">nn::os::GetCurrentCoreNumber()</a> を使用して下さい。 </p>

</div>
</div>
<a class="anchor" id="a4b94c321b41c4fb4d0a4e87473297c48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::GetCurrentCoreNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>現在自スレッドが動作しているコア番号を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>現在自スレッドが動作しているコア番号です。</dd></dl>
<p><b>詳細</b> <br />
 現在自スレッドが動作しているコア番号を取得します。 コア番号の取りうる範囲はターゲット環境依存です。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_thread_8cpp-example.html#a5">OsThread.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac50b86561c15ee3e8195c83fddc8e732"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SetThreadCoreMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idealCore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bit64&#160;</td>
          <td class="paramname"><em>affinityMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>対象のスレッドのコア割り当てを設定します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idealCore</td><td>優先して動作するコア番号 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">affinityMask</td><td>コアごとのアフィニティマスク</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>idealCore は指定可能な特別な値、もしくは有効なコア番号である</li>
<li>idealCore がコア番号の場合、idealCore で指定されるコアは affinityMask に含まれている</li>
<li>idealCore != <a class="el" href="namespacenn_1_1os.html#a3959f30f2583f83a37ec382f091fd9fa" title="自プログラムに設定された優先コアでのみ動作します。 ">nn::os::IdealCoreUseDefaultValue</a> の場合、 affinityMask には、使用可能なコアのみが 1 つ以上含まれている</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 idealCore で優先して動作するコアを指定します。 idealCore にはコア番号の他、以下の値を指定することが可能です。</p>
<ul>
<li><a class="el" href="namespacenn_1_1os.html#a3959f30f2583f83a37ec382f091fd9fa" title="自プログラムに設定された優先コアでのみ動作します。 ">nn::os::IdealCoreUseDefaultValue</a>: 自プログラムに設定された優先コアのみで動作するように 優先コア、及びアフィニティマスクの両方を設定します。 affinityMask で指定された値は無視されます。</li>
<li><a class="el" href="namespacenn_1_1os.html#a418170f89de31518fdc59c699d78a1b1" title="優先コア番号の更新を行いません ">nn::os::IdealCoreNoUpdate</a>: 優先コア番号の更新を行いません。</li>
<li><a class="el" href="namespacenn_1_1os.html#a333a7029b85a51321a4c79176e91eab3" title="優先コア番号なしに設定します ">nn::os::IdealCoreDontCare</a>: 優先コア番号なしに設定します。</li>
</ul>
<p>また、affinityMask にはスレッドが動作可能なコアを指定します。 affinityMask のビット n が 1 であれば、コア番号 n のコア上で動作可能であることを表します。</p>
<p>idealCore に <a class="el" href="namespacenn_1_1os.html#a418170f89de31518fdc59c699d78a1b1" title="優先コア番号の更新を行いません ">nn::os::IdealCoreNoUpdate</a> を指定した場合、 affinityMask のうち、現在設定されている優先コアを表すビットは 1 である必要があります。</p>
<div id="dynsection-Windows" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-Windows-trigger" src="closed.png"/>
  <b>（Windowsプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-Windows-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-Windows-content" class="dyncontent" style="display:none;"><ul>
<li>Windows 環境では、優先して動作するコアを指定しても無視されるなど、 Windows のスケジューラによる制約を受けます。</li>
</ul>
</div><div id="dynsection-Windows-content" class="dyncontent" style="display:none;"></div><p> <b>実機環境の場合</b> </p>
<ul>
<li>実機環境では、本 API 実行後すぐに対象スレッドのコアが移動するわけではありません。 実際のコア移動は対象スレッドが再度動き出す際に実施されます。 </li>
</ul>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_framework_demo_2_main_8cpp-example.html#a35">FrameworkDemo/Main.cpp</a>, <a class="el" href="_gfx_primitive_renderer_8cpp-example.html#a350">GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_hid_controller_sequence__main_8cpp-example.html#a13">HidControllerSequence_Main.cpp</a>, <a class="el" href="_parallel_8cpp-example.html#a109">Parallel.cpp</a>, <a class="el" href="_perf_simple_8cpp-example.html#a61">PerfSimple.cpp</a>, <a class="el" href="_shape_animation_8cpp-example.html#a143">ShapeAnimation.cpp</a>, <a class="el" href="_skeletal_animation_8cpp-example.html#a98">SkeletalAnimation.cpp</a>, <a class="el" href="_town_8cpp-example.html#a131">Town.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a39edb8f3e676c4bab13047a5ad1894f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::GetThreadCoreMask </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutIdealCore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bit64 *&#160;</td>
          <td class="paramname"><em>pOutAffinityMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>対象のスレッドのコア割り当てを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutIdealCore</td><td>優先して動作するコア番号を格納するバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAffinityMask</td><td>コアごとのアフィニティマスクを格納するバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td><a class="el" href="structnn_1_1os_1_1_thread_type.html" title="スレッドオブジェクトを定義する構造体です。 ">ThreadType</a> オブジェクトへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<p><b>詳細</b> <br />
 pOutIdealCore には優先コアとして指定されているコア番号、または <a class="el" href="namespacenn_1_1os.html#a333a7029b85a51321a4c79176e91eab3" title="優先コア番号なしに設定します ">nn::os::IdealCoreDontCare</a> が格納されます。<br />
 *pOutAffinityMask のビット n が 1 であれば、対象のスレッドがコア番号 n のコア上で動作可能であることを表します。</p>
<p>pOutIdealCore、または pOutAffinityMask に NULL を指定した場合、値は取得しません。 </p>

</div>
</div>
<a class="anchor" id="a91345e6e4543ab561f49480b89ae9a65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nn::Bit64 nn::os::GetThreadAvailableCoreMask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>割り当て可能なコアを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>割り当て可能なコア</dd></dl>
<p><b>詳細</b> <br />
 スレッドに対して割り当て可能なコアを取得します。 割り当て可能なコアは、全てのスレッドで共通です。<br />
 返り値のビット n が 1 であれば、コア番号 n のコア上で動作可能であることを表します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_render_thread_pool_8cpp-example.html#a11">RenderThreadPool.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a72d36b7ef64f2c1e82f03d895fdd5609"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::InitializeMultiWaitHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_multi_wait_holder_type.html">MultiWaitHolderType</a> *&#160;</td>
          <td class="paramname"><em>multiWaitHolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_thread_type.html">ThreadType</a> *&#160;</td>
          <td class="paramname"><em>thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiWaitHolder を初期化し、thread と関連付けます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">multiWaitHolder</td><td>多重待ちオブジェクトへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>紐付ける先のスレッドへのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>multiWaitHolder が未初期化状態である</li>
<li>thread が Initialized, Started, Exited のいずれかの状態である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>multiWaitHolder が初期化状態である（thread に関連付けられる）</li>
<li><a class="el" href="namespacenn_1_1os.html#a9e8c73312415fc00c72808fcc00fea33">nn::os::GetMultiWaitHolderUserData(multiWaitHolder)</a> == 0</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 multiWaitHolder を初期化し、thread オブジェクトと関連付けます。</p>
<p>関連付けされた multiWaitHolder は、対象スレッドが終了すると シグナル状態となります。また、対象スレッドが既に終了していた場合には、 即座にシグナル状態となります。</p>
<p>本 API の動作中に対象 multiWaitHolder に対する操作は行なわないで下さい。 </p>

</div>
</div>
<a class="anchor" id="a2a67ebeb78e5d624b45ec27d66bdf0b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::os::AllocateTlsSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_tls_slot.html">TlsSlot</a> *&#160;</td>
          <td class="paramname"><em>outTlsSlot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#af369e7c06c6548eebe7abda706ec54f3">TlsDestructor</a>&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>空き TLS スロットを確保します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outTlsSlot</td><td>獲得した TLS スロット番号の格納先 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>デストラクタ用コールバック関数エントリ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果を表す <a class="el" href="classnn_1_1_result.html">nn::Result</a> 値を返します。 <ul>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_resource.html">nn::os::ResultOutOfResource</a> のハンドリングが必要です。</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>なし</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>TLS の空きスロットを確保し、そのスロット番号を outTlsSlot に格納する</li>
<li>確保した TLS スロットの TLS 初期値を 0 にする（全スレッド）</li>
<li>function が非 NULL の場合、TLS デストラクタ関数を登録する</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 現在未使用の空き TLS スロットを１つ確保し、そのスロット番号を返します。<br />
 また、確保したスロットの TLS 初期値は 0 であることが保障されています。</p>
<p>function には、スレッド終了時に TLS デストラクタとしてコールバック される関数を指定します。コールバック関数は、終了する各スレッドの コンテキストで呼ばれます。</p>
<p>コールバック関数の型は <a class="el" href="namespacenn_1_1os.html#af369e7c06c6548eebe7abda706ec54f3" title="TLS のデストラクタ関数を表す型です。 ">nn::os::TlsDestructor</a> であり、 引数として当該スロットの TLS 値が渡されます。</p>
<p>POSIX と異なり、TLS 値が 0 の場合でもコールバック関数が呼ばれます。<br />
 なお、コールバック関数が呼ばれるスロットの順番については未規定です。</p>
<p>function には NULL を指定することができます。<br />
 function に NULL を指定すると、TLS デストラクタは未登録になり、 コールバック関数は呼ばれません。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_thread_local_storage_8cpp-example.html#a8">OsThreadLocalStorage.cpp</a>, <a class="el" href="_perf_simple_8cpp-example.html#a55">PerfSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="afded66e76230ba96acc86ba3d48d76c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FreeTlsSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_tls_slot.html">TlsSlot</a>&#160;</td>
          <td class="paramname"><em>tlsSlot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TLS スロットを返却します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tlsSlot</td><td>返却する TLS スロット番号</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>確保済みの tlsSlot を指定する</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>指定された tlsSlot の TLS スロットを返却（未使用状態に）する</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 確保済みの TLS スロットを返却します。<br />
 <a class="el" href="namespacenn_1_1os.html#afded66e76230ba96acc86ba3d48d76c4" title="TLS スロットを返却します。 ">FreeTlsSlot()</a> の内部処理では、 <a class="el" href="namespacenn_1_1os.html#a2a67ebeb78e5d624b45ec27d66bdf0b2" title="空き TLS スロットを確保します。 ">AllocateTlsSlot()</a> で設定された TLS デストラクタのコールバック関数は呼ばれません。<br />
 そのため、TLS デストラクタとして登録したコールバック関数の中から、 <a class="el" href="namespacenn_1_1os.html#afded66e76230ba96acc86ba3d48d76c4" title="TLS スロットを返却します。 ">FreeTlsSlot()</a> を呼ぶことも可能です。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_thread_local_storage_8cpp-example.html#a16">OsThreadLocalStorage.cpp</a>, <a class="el" href="_perf_simple_8cpp-example.html#a68">PerfSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a452445507fba4dc49cb9cfb77b4c88c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t nn::os::GetTlsValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_tls_slot.html">TlsSlot</a>&#160;</td>
          <td class="paramname"><em>tlsSlot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定された TLS スロットから値を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tlsSlot</td><td>TLS スロット番号</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>指定したスロットの TLS 値が返ります</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>確保済みの tlsSlot を指定する</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>指定された tlsSlot の TLS スロットの TLS 値を返す</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 指定された TLS スロットから値を取得します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_thread_local_storage_8cpp-example.html#a2">OsThreadLocalStorage.cpp</a>, <a class="el" href="_perf_simple_8cpp-example.html#a51">PerfSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8f54d6581f3380bc9b6b7d92c9855acd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SetTlsValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_tls_slot.html">TlsSlot</a>&#160;</td>
          <td class="paramname"><em>tlsSlot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定された TLS スロットに値を設定します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tlsSlot</td><td>TLS スロット番号 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>設定したい TLS 値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>確保済みの tlsSlot を指定する</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>指定された tlsSlot の TLS スロットに TLS 値を設定する</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 指定された TLS スロットに値を設定します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_thread_local_storage_8cpp-example.html#a4">OsThreadLocalStorage.cpp</a>, <a class="el" href="_perf_simple_8cpp-example.html#a66">PerfSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa0db5a1ab770f99f96e327aeb5c653ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::os::GetUsedTlsSlotCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>確保済みの TLS スロット数を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>確保済みの TLS スロット数です。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>なし</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>現在確保済みの TLS スロット数を返す</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 現在確保済みの TLS スロット数を取得します。<br />
 また、確保可能な残りの未使用スロット数は、 <a class="el" href="namespacenn_1_1os.html#a59fab4470b957077f8605c71502c9f2f" title="TLS スロットの総数を示す定数です。 ">nn::os::TlsSlotCountMax</a> - <a class="el" href="namespacenn_1_1os.html#aa0db5a1ab770f99f96e327aeb5c653ce" title="確保済みの TLS スロット数を取得します。 ">GetUsedTlsSlotCount()</a> で算出できます。 </p>

</div>
</div>
<a class="anchor" id="a79e29821bfb2b0c3a5c222488e90cc89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a> nn::os::GetSystemTick </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>システムチック値を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>システムチック値です。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>なし</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>現在のシステムチック値を返す</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 現在のシステムチック値を <a class="el" href="classnn_1_1os_1_1_tick.html" title="システムチックを扱う為のクラスです。 ">Tick</a> 型で返します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_account_application_8cpp-example.html#a23">AccountApplication.cpp</a>, <a class="el" href="_account_application_authorization_8cpp-example.html#a21">AccountApplicationAuthorization.cpp</a>, <a class="el" href="_audio_out_8cpp-example.html#a41">AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_8cpp-example.html#a41">AudioOutWithResampler.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_8cpp-example.html#a74">CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_friends_profile_image_8cpp-example.html#a33">FriendsProfileImage.cpp</a>, <a class="el" href="_gl_simple_8cpp-example.html#a7">GlSimple.cpp</a>, <a class="el" href="_hid_npad_six_axis_sensor__main_8cpp-example.html#a50">HidNpadSixAxisSensor_Main.cpp</a>, <a class="el" href="_ldn_simple_2_main_8cpp-example.html#a13">LdnSimple/Main.cpp</a>, <a class="el" href="_libcurl_basic_8cpp-example.html#a4">LibcurlBasic.cpp</a>, <a class="el" href="_libcurl_speed_test_8cpp-example.html#a26">LibcurlSpeedTest.cpp</a>, <a class="el" href="_libcurl_ssl_context_import_8cpp-example.html#a4">LibcurlSslContextImport.cpp</a>, <a class="el" href="_oe_disable_auto_sleep_8cpp-example.html#a17">OeDisableAutoSleep.cpp</a>, <a class="el" href="_os_barrier_8cpp-example.html#a2">OsBarrier.cpp</a>, <a class="el" href="_os_tick_and_time_span_8cpp-example.html#a3">OsTickAndTimeSpan.cpp</a>, <a class="el" href="_os_timer_event_8cpp-example.html#a3">OsTimerEvent.cpp</a>, <a class="el" href="_profiler_simple_8cpp-example.html#a13">ProfilerSimple.cpp</a>, <a class="el" href="_spy_atk_8cpp-example.html#a26">SpyAtk.cpp</a>, <a class="el" href="_spy_audio_8cpp-example.html#a78">SpyAudio.cpp</a>, <a class="el" href="_tutorial_base_class_8_nx_8cpp-example.html#a10">TutorialBaseClass.Nx.cpp</a> (計20項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa64f2523f9e13afef5de6197898afa27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t nn::os::GetSystemTickFrequency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>システムチック値の周波数を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>システムチックの 1 秒あたりのカウント数です。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>なし</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>現在のシステムチックの周波数を返す</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 システムチックの１秒間のカウント数を返します。<br />
 これはつまり、システムチックの周波数（Hz）に相当します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_hid_npad_six_axis_sensor__main_8cpp-example.html#a52">HidNpadSixAxisSensor_Main.cpp</a>, <a class="el" href="_os_tick_and_time_span_8cpp-example.html#a0">OsTickAndTimeSpan.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a53032bee4cfe0f01916e8149c393adad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> nn::os::ConvertToTimeSpan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a>&#160;</td>
          <td class="paramname"><em>tick</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>システムチックを <a class="el" href="classnn_1_1_time_span.html" title="時間の長さを表すクラスです。 ">nn::TimeSpan</a> 型の時間表現に変換して返します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tick</td><td>システムチック値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="classnn_1_1_time_span.html" title="時間の長さを表すクラスです。 ">nn::TimeSpan</a> 型の時間表現です。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>なし</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>指定されたシステムチック値を <a class="el" href="classnn_1_1_time_span.html" title="時間の長さを表すクラスです。 ">nn::TimeSpan</a> 型へ変換したものを返す</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 システム依存の時間表現であるシステムチック値を、<br />
 自然時間表現された <a class="el" href="classnn_1_1_time_span.html" title="時間の長さを表すクラスです。 ">nn::TimeSpan</a> 型のシステム時間に変換します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_libcurl_basic_8cpp-example.html#a5">LibcurlBasic.cpp</a>, <a class="el" href="_libcurl_speed_test_8cpp-example.html#a29">LibcurlSpeedTest.cpp</a>, <a class="el" href="_libcurl_ssl_context_import_8cpp-example.html#a5">LibcurlSslContextImport.cpp</a>, <a class="el" href="_oe_disable_auto_sleep_8cpp-example.html#a21">OeDisableAutoSleep.cpp</a>, <a class="el" href="_os_tick_and_time_span_8cpp-example.html#a5">OsTickAndTimeSpan.cpp</a>, <a class="el" href="_os_timer_event_8cpp-example.html#a4">OsTimerEvent.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8c9b3542885a746dca530490408f78c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1os_1_1_tick.html">Tick</a> nn::os::ConvertToTick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td>
          <td class="paramname"><em>timeSpan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classnn_1_1_time_span.html" title="時間の長さを表すクラスです。 ">nn::TimeSpan</a> 型の時間表現をシステムチックに変換して返します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeSpan</td><td><a class="el" href="classnn_1_1_time_span.html" title="時間の長さを表すクラスです。 ">nn::TimeSpan</a> 型の時間表現です。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>システムチック値です。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>なし</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>指定された <a class="el" href="classnn_1_1_time_span.html" title="時間の長さを表すクラスです。 ">nn::TimeSpan</a> 型の時間表現をシステムチックへ変換したものを返す</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 自然時間表現された <a class="el" href="classnn_1_1_time_span.html" title="時間の長さを表すクラスです。 ">nn::TimeSpan</a> 型の時間表現を、 システム依存の時間表現であるシステムチック値に変換します。 </p>

</div>
</div>
<a class="anchor" id="a347a69381452967e4a51b3c18aae7807"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SetMemoryAllocatorForThreadLocal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn.html#ae292809a1837a548ce8e91c92dd5fac8">nn::AlignedAllocateFunction</a>&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn.html#ac4bc1dec66991644b7abd9f9cd9d0ca6">nn::DeallocateFunction</a>&#160;</td>
          <td class="paramname"><em>deallocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンパイラのスレッドローカル実装で使用されるメモリアロケータ／デアロケータを登録します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>メモリアロケータへの関数ポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deallocator</td><td>メモリデアロケータへの関数ポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>プログラムの中で本 API の呼出しが初めてである</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 コンパイラのスレッドローカル指定子（_Thread_local, thread_local, __thread） の実装で使用されるメモリアロケータおよびデアロケータ関数を登録します。 （ただし、コンパイラがこれらの指定子をサポートしているかどうかは、 別途コンパイラのドキュメントを参照して下さい。）</p>
<p>本関数は各プログラムの起動時、具体的には <a class="el" href="init___startup_8h.html#ac781c07f35d3d9e7a71d21ad25e25f8f" title="スタートアップ初期化用ルーチンです。 ">nninitStartup()</a> の中で一度だけ 呼ばれることを想定しています。デフォルトの <a class="el" href="init___startup_8h.html#ac781c07f35d3d9e7a71d21ad25e25f8f" title="スタートアップ初期化用ルーチンです。 ">nninitStartup()</a> では メモリヒープの初期化を行なった後に本関数が呼ばれ、スレッドローカル用の デフォルトアロケータ関数およびデフォルトデアロケータ関数が登録されます。</p>
<p>上記デフォルトのアロケータ関数、デアロケータ関数は malloc() や free() と 同じメモリ領域を使用します。これらの領域と異なるメモリ領域を使用させたい 場合は、アプリケーションで独自に <a class="el" href="init___startup_8h.html#ac781c07f35d3d9e7a71d21ad25e25f8f" title="スタートアップ初期化用ルーチンです。 ">nninitStartup()</a> を定義し、かつその中で、 別途用意したアロケータ関数、デアロケータ関数を登録して下さい。</p>
<p>なお、アロケータおよびデアロケータの関数には <a class="el" href="namespacenn.html#ae292809a1837a548ce8e91c92dd5fac8" title="メモリ確保関数のインタフェースです。例外を発生させてはいけません。 ">nn::AlignedAllocateFunction</a> 型 および <a class="el" href="namespacenn.html#ac4bc1dec66991644b7abd9f9cd9d0ca6" title="メモリ解放関数のインタフェースです。例外を発生させてはいけません。 ">nn::DeallocateFunction</a> 型の関数ポインタを渡して下さい。</p>
<div id="dynsection-Windows" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-Windows-trigger" src="closed.png"/>
  <b>（Windowsプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-Windows-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-Windows-content" class="dyncontent" style="display:none;"><ul>
<li>Windows 環境では本 API は何も行なわずにリターンし、アロケータ関数および デアロケータ関数は未登録のままとなります。</li>
<li>Windows 環境におけるスレッドローカル指定されたオブジェクトの振舞いは、 Visual C++ の仕様に従います。</li>
</ul>
</div><div id="dynsection-Windows-content" class="dyncontent" style="display:none;"></div> 
</div>
</div>
<a class="anchor" id="a2be8bac50d8d37a91f866d9e0c55886e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::os::SetMemoryHeapSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリヒープ領域のサイズを変更します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>メモリヒープ領域のサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果を表す <a class="el" href="classnn_1_1_result.html">nn::Result</a> 値を返します。 <ul>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_memory.html">nn::os::ResultOutOfMemory</a> のハンドリングが必要です。 </li>
<li><a class="el" href="classnn_1_1os_1_1_result_busy.html">nn::os::ResultBusy</a> のハンドリングが必要です。</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>size &gt;= 0</li>
<li>size が <a class="el" href="namespacenn_1_1os.html#aeed47f05ce9175eb46876c1ddd0512c7" title="メモリヒープ領域の最小単位を格納した定数です。 ">nn::os::MemoryHeapUnitSize</a> の整数倍である</li>
<li>メモリヒープを誰も使用していない</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>メモリヒープ全体のサイズが size バイトである。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 メモリヒープのサイズを変更します。</p>
<p>メモリヒープのサイズを現状よりも大きくする場合、 現状のメモリヒープの末尾に追加分のメモリ領域を確保します。<br />
 この場合、既存のメモリヒープはその一部が <a class="el" href="namespacenn_1_1os.html#a875bf6b3129f06654e641513c63017dd" title="メモリヒープからメモリブロックを獲得します。 ">AllocateMemoryBlock()</a> で確保済みの 状態であっても構いません。</p>
<p>メモリヒープのサイズを現状よりも小さくする場合、 現状のメモリヒープの末尾からメモリ領域を解放します。<br />
 この場合、既存のメモリヒープのうち解放対象となる末尾部分以外は、 <a class="el" href="namespacenn_1_1os.html#a875bf6b3129f06654e641513c63017dd" title="メモリヒープからメモリブロックを獲得します。 ">AllocateMemoryBlock()</a> で確保済みの状態であっても構いません。</p>
<p>メモリヒープ内のメモリ領域を、自前のメモリ管理機構を使って管理したい場合は、 その管理対象領域を <a class="el" href="namespacenn_1_1os.html#a875bf6b3129f06654e641513c63017dd" title="メモリヒープからメモリブロックを獲得します。 ">AllocateMemoryBlock()</a> で確保した上で行なって下さい。<br />
 <a class="el" href="namespacenn_1_1os.html#a875bf6b3129f06654e641513c63017dd" title="メモリヒープからメモリブロックを獲得します。 ">AllocateMemoryBlock()</a> で確保していないメモリヒープ領域を直接メモリアクセス した場合は動作を保障できません。 <a class="el" href="namespacenn_1_1os.html#a875bf6b3129f06654e641513c63017dd" title="メモリヒープからメモリブロックを獲得します。 ">AllocateMemoryBlock()</a> で獲得した メモリ領域に対して <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="メモリ管理のためのクラスです ">nn::mem::StandardAllocator</a> などを使うことで汎用的な メモリアロケータとして利用することができます。</p>
<p>アプリケーションプログラムの中で <a class="el" href="init___startup_8h.html#ac781c07f35d3d9e7a71d21ad25e25f8f" title="スタートアップ初期化用ルーチンです。 ">nninitStartup()</a> を定義しなかった場合は、 SDK のデフォルトの <a class="el" href="init___startup_8h.html#ac781c07f35d3d9e7a71d21ad25e25f8f" title="スタートアップ初期化用ルーチンです。 ">nninitStartup()</a> が呼ばれます。そこではメモリヒープを 可能な限り確保し、その全てを <a class="el" href="namespacenn_1_1init.html#a216ae7a5ca53a1c1e6dc0514f7283974" title="メモリアロケータを初期化します。 ">nn::init::InitializeAllocator()</a> に渡すことで メモリアロケータ用に設定します。メモリヒープの使用方法を変更したい場合は、 必ず独自の <a class="el" href="init___startup_8h.html#ac781c07f35d3d9e7a71d21ad25e25f8f" title="スタートアップ初期化用ルーチンです。 ">nninitStartup()</a> を定義するようにして下さい。</p>
<div id="dynsection-Windows" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-Windows-trigger" src="closed.png"/>
  <b>（Windowsプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-Windows-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-Windows-content" class="dyncontent" style="display:none;"><ul>
<li>Windows 環境では、上記のようにメモリヒープを最大限確保できない場合があります。 そのような場合は 32MB のみ確保するようになっています。</li>
</ul>
</div><div id="dynsection-Windows-content" class="dyncontent" style="display:none;"></div> <dl><dt><b>各種例: </b></dt><dd><a class="el" href="_init_startup_8cpp-example.html#a2">InitStartup.cpp</a>, <a class="el" href="_mifare_simple_8cpp-example.html#a2">MifareSimple.cpp</a>, <a class="el" href="_mii_compressed_texture_8cpp-example.html#a452">MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_8cpp-example.html#a431">MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_8cpp-example.html#a418">MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_8cpp-example.html#a378">MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_8cpp-example.html#a354">MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_8cpp-example.html#a468">MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_8cpp-example.html#a432">MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_8cpp-example.html#a469">MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_8cpp-example.html#a447">MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_8cpp-example.html#a417">MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_8cpp-example.html#a343">MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_8cpp-example.html#a351">MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_8cpp-example.html#a353">MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_8cpp-example.html#a427">MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_8cpp-example.html#a353">MiiTransparentAdjuster.cpp</a>, <a class="el" href="_nfc_pass_through_simple_8cpp-example.html#a2">NfcPassThroughSimple.cpp</a>, <a class="el" href="_nfp_multi_8cpp-example.html#a2">NfpMulti.cpp</a>, <a class="el" href="_nfp_simple_8cpp-example.html#a2">NfpSimple.cpp</a>, <a class="el" href="_ngc_simple_8cpp-example.html#a24">NgcSimple.cpp</a>, <a class="el" href="_oe_launch_parameter_8cpp-example.html#a4">OeLaunchParameter.cpp</a>, <a class="el" href="_os_memory_heap_8cpp-example.html#a1">OsMemoryHeap.cpp</a>, <a class="el" href="_ssl_simple_8cpp-example.html#a48">SslSimple.cpp</a>, <a class="el" href="_swkbd_simple_8cpp-example.html#a5">SwkbdSimple.cpp</a> (計25項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="a875bf6b3129f06654e641513c63017dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::os::AllocateMemoryBlock </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリヒープからメモリブロックを獲得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>獲得したメモリブロックの先頭アドレスの格納先 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>獲得するメモリブロックのサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果を表す <a class="el" href="classnn_1_1_result.html">nn::Result</a> 値を返します。 <ul>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_memory.html">nn::os::ResultOutOfMemory</a> のハンドリングが必要です。</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>size &gt; 0</li>
<li>size が <a class="el" href="namespacenn_1_1os.html#ade84ad9f438e76820510ca0623c5a823" title="メモリブロックの最小単位を格納した定数です。 ">nn::os::MemoryBlockUnitSize</a> の整数倍である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>メモリブロック獲得に成功した場合<ul>
<li>address に獲得したメモリブロックの先頭アドレスが入る</li>
<li>獲得したメモリブロックが <a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9aa57ead1592d9473ac1c22f0b4f75ed2c0" title="メモリは読み書き可能です。 ">nn::os::MemoryPermission_ReadWrite</a> 属性である</li>
</ul>
</li>
<li>メモリブロック獲得に失敗した場合<ul>
<li>メモリヒープ領域は変化しない</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 メモリヒープ領域から size の大きさのメモリブロックを獲得します。<br />
 メモリブロック獲得に成功すると、address にその先頭アドレスが格納されます。</p>
<p>メモリブロックは管理領域等のオーバーヘッドがないため、 細かく確保を行っても合計してメモリヒープのサイズ分のメモリブロックを確保できることが保証されます。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_init_startup_8cpp-example.html#a4">InitStartup.cpp</a>, <a class="el" href="_mifare_simple_8cpp-example.html#a3">MifareSimple.cpp</a>, <a class="el" href="_mii_compressed_texture_8cpp-example.html#a453">MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_8cpp-example.html#a432">MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_8cpp-example.html#a419">MiiDynamicMask.cpp</a>, <a class="el" href="_mii_g3d_headwear_8cpp-example.html#a379">MiiG3dHeadwear.cpp</a>, <a class="el" href="_mii_g3d_simple_8cpp-example.html#a355">MiiG3dSimple.cpp</a>, <a class="el" href="_mii_headwear_example_8cpp-example.html#a469">MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_8cpp-example.html#a433">MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_8cpp-example.html#a470">MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_8cpp-example.html#a448">MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_8cpp-example.html#a418">MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_8cpp-example.html#a344">MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_8cpp-example.html#a352">MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_8cpp-example.html#a354">MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_8cpp-example.html#a428">MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_8cpp-example.html#a354">MiiTransparentAdjuster.cpp</a>, <a class="el" href="_nfc_pass_through_simple_8cpp-example.html#a3">NfcPassThroughSimple.cpp</a>, <a class="el" href="_nfp_multi_8cpp-example.html#a3">NfpMulti.cpp</a>, <a class="el" href="_nfp_simple_8cpp-example.html#a3">NfpSimple.cpp</a>, <a class="el" href="_ngc_simple_8cpp-example.html#a25">NgcSimple.cpp</a>, <a class="el" href="_oe_launch_parameter_8cpp-example.html#a5">OeLaunchParameter.cpp</a>, <a class="el" href="_os_memory_heap_8cpp-example.html#a4">OsMemoryHeap.cpp</a>, <a class="el" href="_ssl_simple_8cpp-example.html#a50">SslSimple.cpp</a>, <a class="el" href="_swkbd_simple_8cpp-example.html#a6">SwkbdSimple.cpp</a> (計25項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="a20fa47e171856fb202b60e6b2a1de719"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FreeMemoryBlock </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリヒープ領域へメモリブロックを返却します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>返却するメモリブロックの先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>返却するメモリブロックのサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>address が <a class="el" href="namespacenn_1_1os.html#ade84ad9f438e76820510ca0623c5a823" title="メモリブロックの最小単位を格納した定数です。 ">nn::os::MemoryBlockUnitSize</a> の整数倍である</li>
<li>size &gt; 0</li>
<li>size が <a class="el" href="namespacenn_1_1os.html#ade84ad9f438e76820510ca0623c5a823" title="メモリブロックの最小単位を格納した定数です。 ">nn::os::MemoryBlockUnitSize</a> の整数倍である</li>
<li>返却するメモリブロックが、メモリヒープ領域内である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>メモリヒープにメモリブロックが返却される</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 address～(address+size) のメモリブロックを、メモリヒープ領域に返却します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_memory_heap_8cpp-example.html#a6">OsMemoryHeap.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ae3d0ddd1807c032d7ab0e0fda9739bef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SetMemoryPermission </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9a">MemoryPermission</a>&#160;</td>
          <td class="paramname"><em>permission</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定されたメモリ領域のメモリアクセス権を変更します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>設定したいメモリ領域の先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>設定したいメモリ領域のサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permission</td><td>設定したいメモリ領域のアクセス権</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>address が <a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="メモリ操作の最小単位を格納した定数です。 ">nn::os::MemoryPageSize</a> の整数倍である</li>
<li>size が <a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="メモリ操作の最小単位を格納した定数です。 ">nn::os::MemoryPageSize</a> の整数倍である</li>
<li>permission が以下のいずれかである<ul>
<li><a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9aaf6942de46447bc0df8294a749a329d08" title="メモリはアクセス禁止です。 ">nn::os::MemoryPermission_None</a></li>
<li><a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9aad0057f9250371335c5b9292ff44e1750" title="メモリは読み込み専用です。 ">nn::os::MemoryPermission_ReadOnly</a></li>
<li><a class="el" href="namespacenn_1_1os.html#a883ab0b53c72a07619d9e83de4836b9aa57ead1592d9473ac1c22f0b4f75ed2c0" title="メモリは読み書き可能です。 ">nn::os::MemoryPermission_ReadWrite</a></li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>指定されたメモリ領域が permission のメモリアクセス権である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 指定されたメモリ領域を permission のメモリアクセス権に変更します。 </p>

</div>
</div>
<a class="anchor" id="a11dca1988a4d23dc773f216847a56ecd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::os::AllocateAddressRegion </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>pOutAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>仮想アドレス空間からアドレス領域を確保します </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAddress</td><td>確保したアドレス領域の先頭アドレスを格納する領域へのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>確保するアドレス領域のサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果を表す <a class="el" href="classnn_1_1_result.html">nn::Result</a> 値を返します。 <ul>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_virtual_address_space.html">nn::os::ResultOutOfVirtualAddressSpace</a> 仮想アドレス空間不足によりアドレス領域の確保に失敗しました。 </li>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_memory.html">nn::os::ResultOutOfMemory</a> 仮想アドレス空間管理に必要な物理メモリの確保に失敗しました。</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> == true</li>
<li>pOutAddress が指す領域が書き込み可能</li>
<li>size &gt; 0</li>
<li>size が <a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="メモリ操作の最小単位を格納した定数です。 ">nn::os::MemoryPageSize</a> の整数倍である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>サイズが size バイトのアドレス領域が確保され、その先頭アドレスが *pOutAddress に格納されている</li>
<li>*pOutAddress に格納されているアドレスが <a class="el" href="namespacenn_1_1os.html#a82acf7f7f39eb127ebffdef2c748c5e6" title="アドレス領域の先頭アドレスが満たすアライメント制約を表す定数です。 ">nn::os::AddressRegionAlignment</a> でアライメントされている</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 size バイトの新たなアドレス領域を仮想アドレス空間上に確保し、その先頭アドレスを返します。 確保されるアドレス領域の先頭アドレスは <a class="el" href="namespacenn_1_1os.html#a82acf7f7f39eb127ebffdef2c748c5e6" title="アドレス領域の先頭アドレスが満たすアライメント制約を表す定数です。 ">nn::os::AddressRegionAlignment</a> 定数が示す値でアライメントされます。</p>
<p>確保したアドレス領域にはまだ物理メモリが割り当てられていません。 物理メモリが割り当てられていない状態でアドレス領域へメモリアクセスするとアクセス例外となります。 確保したアドレス領域には <a class="el" href="namespacenn_1_1os.html#afc2aecae3365f9881e63f3c9a77be239" title="指定の領域に物理メモリを割り当てます ">nn::os::AllocateMemoryPages</a> で物理メモリを割り当てることができます。</p>
<p>確保したアドレス領域は <a class="el" href="namespacenn_1_1os.html#a822e071b5061ef30ce2202d67fad8dd0" title="アドレス領域を解放します。 ">nn::os::FreeAddressRegion</a> で解放することができます。</p>
<p>仮想アドレスメモリ管理機能ではアドレス領域の管理のために OS ライブラリ内部でメモリの動的確保を行っています。 このため <a class="el" href="namespacenn_1_1os.html#a11dca1988a4d23dc773f216847a56ecd" title="仮想アドレス空間からアドレス領域を確保します ">nn::os::AllocateAddressRegion()</a> の呼び出し時に内部でメモリの動的確保が行われることがあります。 OS ライブラリ内部でメモリの動的確保に失敗した場合には <a class="el" href="classnn_1_1os_1_1_result_out_of_memory.html" title="エラー Result (os: 十分な空きメモリ領域がない) を表すクラスです。 ">nn::os::ResultOutOfMemory</a> が返ります。</p>
<p>OS ライブラリ内部で動的確保されたメモリは <a class="el" href="namespacenn_1_1os.html#a79f2a489da0a124ebdc8130595c70b94" title="自プログラムが現在使用しているメモリ使用量などの情報を取得します ">nn::os::QueryMemoryInfo()</a> で取得できる値の totalUsedMemorySize に含まれます。</p>
<p>使用できる仮想アドレス空間は 63GiB です。 管理上のオーバーヘッドが発生するため実際に使用できるアドレス領域の合計はこれよりも少なくなります。</p>
<p>この関数はスレッドセーフです。</p>
<p>この関数は <a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> が true を返す場合にのみ使用可能です。 詳細は <a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> を参照してください。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_virtual_address_memory_8cpp-example.html#a1">OsVirtualAddressMemory.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a822e071b5061ef30ce2202d67fad8dd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::os::FreeAddressRegion </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>アドレス領域を解放します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>解放するアドレス領域の先頭アドレス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果を表す <a class="el" href="classnn_1_1_result.html">nn::Result</a> 値を返します。 <ul>
<li><a class="el" href="classnn_1_1os_1_1_result_invalid_parameter.html">nn::os::ResultInvalidParameter</a> address が有効なアドレス領域の先頭アドレスではありません。 </li>
<li><a class="el" href="classnn_1_1os_1_1_result_busy.html">nn::os::ResultBusy</a> アドレス領域の中に使用中のメモリが含まれています。 </li>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_resource.html">nn::os::ResultOutOfResource</a> 物理メモリ操作に必要なリソースが不足しました。</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> == true</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>address を先頭アドレスとするアドレス領域全体に物理メモリが割り当てられていない</li>
<li>address を先頭アドレスとするアドレス領域が解放されている</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 address を先頭アドレスとするアドレス領域を解放します。 アドレス領域内に物理メモリが割り当てられた領域が存在する場合は アドレス領域の解放前にその割り当てを解除します。</p>
<p>address は <a class="el" href="namespacenn_1_1os.html#a11dca1988a4d23dc773f216847a56ecd" title="仮想アドレス空間からアドレス領域を確保します ">nn::os::AllocateAddressRegion</a> で確保され解放されていないアドレス領域の先頭アドレスでなければなりません。 また、対象となるアドレス領域には SDK の API で使用中のメモリが含まれていてはいけません。</p>
<p>この関数はスレッドセーフです。</p>
<p>この関数は <a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> が true を返す場合にのみ使用可能です。 詳細は <a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> を参照してください。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_virtual_address_memory_8cpp-example.html#a7">OsVirtualAddressMemory.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="afc2aecae3365f9881e63f3c9a77be239"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::os::AllocateMemoryPages </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定の領域に物理メモリを割り当てます </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>物理メモリを割り当てる領域の先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>物理メモリを割り当てる領域のサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果を表す <a class="el" href="classnn_1_1_result.html">nn::Result</a> 値を返します。 <ul>
<li><a class="el" href="classnn_1_1os_1_1_result_invalid_parameter.html">nn::os::ResultInvalidParameter</a> address から size バイトの領域が有効なアドレス領域に含まれていません。 </li>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_memory.html">nn::os::ResultOutOfMemory</a> 割り当てる物理メモリの確保に失敗しました。 </li>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_resource.html">nn::os::ResultOutOfResource</a> 物理メモリ操作に必要なリソースが不足しました。</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> == true</li>
<li>address が <a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="メモリ操作の最小単位を格納した定数です。 ">nn::os::MemoryPageSize</a> の整数倍である</li>
<li>size が <a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="メモリ操作の最小単位を格納した定数です。 ">nn::os::MemoryPageSize</a> の整数倍である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>address から size バイトの領域に物理メモリが割り当てられている</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 address から size バイトの領域に対して、物理メモリを確保して割り当てを行います。</p>
<p>address から size バイトの領域は <a class="el" href="namespacenn_1_1os.html#a11dca1988a4d23dc773f216847a56ecd" title="仮想アドレス空間からアドレス領域を確保します ">nn::os::AllocateAddressRegion</a> で確保され解放されていないアドレス領域に含まれていなければなりません。</p>
<p>address から size バイトの領域に既に物理メモリが割り当てられた領域が存在する場合、 その領域は関数呼び出し前の状態が維持されます。</p>
<p>この関数で割り当てられた物理メモリの割り当てを解除するには <a class="el" href="namespacenn_1_1os.html#aadde176efe5d5ec8352539a4c41cc468" title="指定の領域へのメモリの割り当てを解除します。 ">nn::os::FreeMemoryPages</a> を使用します。</p>
<p>この関数はスレッドセーフです。</p>
<p>この関数は <a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> が true を返す場合にのみ使用可能です。 詳細は <a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> を参照してください。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_virtual_address_memory_8cpp-example.html#a3">OsVirtualAddressMemory.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aadde176efe5d5ec8352539a4c41cc468"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::os::FreeMemoryPages </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定の領域へのメモリの割り当てを解除します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>メモリの割り当てを解除する領域の先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>メモリの割り当てを解除する領域のサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果を表す <a class="el" href="classnn_1_1_result.html">nn::Result</a> 値を返します。 <ul>
<li><a class="el" href="classnn_1_1os_1_1_result_invalid_parameter.html">nn::os::ResultInvalidParameter</a> address から size バイトの領域が有効なアドレス領域に含まれていません。 </li>
<li><a class="el" href="classnn_1_1os_1_1_result_busy.html">nn::os::ResultBusy</a> アドレス領域の中に使用中のメモリが含まれています。 </li>
<li><a class="el" href="classnn_1_1os_1_1_result_out_of_resource.html">nn::os::ResultOutOfResource</a> 物理メモリ操作に必要なリソースが不足しました。</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li><a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> == true</li>
<li>address が <a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="メモリ操作の最小単位を格納した定数です。 ">nn::os::MemoryPageSize</a> の整数倍である</li>
<li>size が <a class="el" href="namespacenn_1_1os.html#ac880b46610757e748d5bd79211af4236" title="メモリ操作の最小単位を格納した定数です。 ">nn::os::MemoryPageSize</a> の整数倍である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>address から size バイトの領域に物理メモリが割り当てられていない</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 address から size バイトの領域への物理メモリの割り当てを解除します。</p>
<p>address と size は、AllocateMemoryPages 呼び出し時と一致している必要はなく、 割り当て済みの物理メモリを部分的に解除することができます。</p>
<p>address から size バイトの領域は <a class="el" href="namespacenn_1_1os.html#a11dca1988a4d23dc773f216847a56ecd" title="仮想アドレス空間からアドレス領域を確保します ">nn::os::AllocateAddressRegion</a> で確保され解放されていないアドレス領域に含まれていなければなりません。 また、この領域には SDK の API で使用中のメモリが含まれてはいてはいけません。</p>
<p>address から size バイトの領域に含まれる物理メモリが割り当てられていない領域は無視されます。</p>
<p>物理メモリが割り当てられていないアドレスへメモリアクセスするとアクセス例外となります。</p>
<p>この関数はスレッドセーフです。</p>
<p>この関数は <a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> が true を返す場合にのみ使用可能です。 詳細は <a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> を参照してください。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_virtual_address_memory_8cpp-example.html#a4">OsVirtualAddressMemory.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a49b13b1f8e6e4fa352192eb9d121ff49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1os_1_1_virtual_address_memory_resource_usage.html">VirtualAddressMemoryResourceUsage</a> nn::os::GetVirtualAddressMemoryResourceUsage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>仮想アドレスメモリ管理用のリソース消費量を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>取得したリソース消費量を返します。</dd></dl>
<p><b>詳細</b> <br />
 この関数はスレッドセーフです。</p>
<div id="dynsection-Windows" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-Windows-trigger" src="closed.png"/>
  <b>（Windowsプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-Windows-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-Windows-content" class="dyncontent" style="display:none;"> 取得できる値は assignedSize も usedSize も 常に 0 となります。 </div> <div id="dynsection-NX" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-NX-trigger" src="closed.png"/>
  <b>（NXプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-NX-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-NX-content" class="dyncontent" style="display:none;"> 取得できる値の assignedSize は .nmeta ファイルで SystemResourceSize に設定した値になります。 この値はプログラムの実行中に変化することはありません。 <br />
 <br />
 取得できる値の usedSize は、これまでに消費されたリソース量が格納されます。 一度消費されたリソースは解放されることがないためプログラムの実行中に この値は単調増加します。 この値が assignedSize と同じ値になっていると仮想アドレスメモリ管理関連 API が <a class="el" href="classnn_1_1os_1_1_result_out_of_resource.html" title="エラー Result (os: 十分な空きリソースがない) を表すクラスです。 ">nn::os::ResultOutOfResource</a> で失敗する可能性があります。 </div> <dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_virtual_address_memory_8cpp-example.html#a6">OsVirtualAddressMemory.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab9e6556970df605db16e5548b9fd188c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::os::IsVirtualAddressMemoryEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>仮想アドレスメモリ管理が使用可能になっているかを判定します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>仮想アドレスメモリ管理が使用可能になっていれば true、そうでなければ false が返ります。</dd></dl>
<p><b>詳細</b> <br />
 32bit プログラムでは仮想アドレスメモリ管理は使用できません。そのため常に false が返ります。</p>
<p>この関数はスレッドセーフです。</p>
<div id="dynsection-Windows" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-Windows-trigger" src="closed.png"/>
  <b>（Windowsプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-Windows-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-Windows-content" class="dyncontent" style="display:none;"> 64bit プログラムでは仮想アドレスメモリ管理は常に使用可能です。 </div> <div id="dynsection-NX" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-NX-trigger" src="closed.png"/>
  <b>（NXプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-NX-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-NX-content" class="dyncontent" style="display:none;"> 64bit プログラムで仮想アドレスメモリ管理を使用可能とするためには .nmeta ファイルで SystemResourceSize に 0 より大きい値を設定する必要があります。 詳細は <a href="../../Package/contents/Pages/Page_83956147.html">「SystemResourceSize の値の決定」</a> を参照してください。 </div> 
</div>
</div>
<a class="anchor" id="a0b9900ac6f5ffc3cceeaf9e4d4628fd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FenceMemoryStoreStore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store-Store メモリフェンスを挿入します。 </p>
<p><b>詳細</b> <br />
 本 API 呼び出しが配置された場所に Store-Store メモリフェンスを挿入します。 詳細は <a class="el" href="_page_notification_os_memory_fence.html">OS-API のメモリーフェンスについて</a> を参照して下さい。 </p>

</div>
</div>
<a class="anchor" id="a89bc7c5ef7a7884fa2cdb771d1050045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FenceMemoryStoreLoad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store-Load メモリフェンスを挿入します。 </p>
<p><b>詳細</b> <br />
 本 API 呼び出しが配置された場所に Store-Load メモリフェンスを挿入します。 詳細は <a class="el" href="_page_notification_os_memory_fence.html">OS-API のメモリーフェンスについて</a> を参照して下さい。 </p>

</div>
</div>
<a class="anchor" id="a8ecf770755dd217ffff4479db6102863"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FenceMemoryStoreAny </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store-Any メモリフェンスを挿入します。 </p>
<p><b>詳細</b> <br />
 本 API 呼び出しが配置された場所に Store-Any メモリフェンスを挿入します。 詳細は <a class="el" href="_page_notification_os_memory_fence.html">OS-API のメモリーフェンスについて</a> を参照して下さい。 </p>

</div>
</div>
<a class="anchor" id="a36d20e99e9c3b0e699b51a13acd3ead6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FenceMemoryLoadStore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load-Store メモリフェンスを挿入します。 </p>
<p><b>詳細</b> <br />
 本 API 呼び出しが配置された場所に Load-Store メモリフェンスを挿入します。 詳細は <a class="el" href="_page_notification_os_memory_fence.html">OS-API のメモリーフェンスについて</a> を参照して下さい。 </p>

</div>
</div>
<a class="anchor" id="a24612da5b069435fc5f1d8f8720adadf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FenceMemoryLoadLoad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load-Load メモリフェンスを挿入します。 </p>
<p><b>詳細</b> <br />
 本 API 呼び出しが配置された場所に Load-Load メモリフェンスを挿入します。 詳細は <a class="el" href="_page_notification_os_memory_fence.html">OS-API のメモリーフェンスについて</a> を参照して下さい。 </p>

</div>
</div>
<a class="anchor" id="a367aa8b77b2ae4d88e358810ef54b973"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FenceMemoryLoadAny </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load-Any メモリフェンスを挿入します。 </p>
<p><b>詳細</b> <br />
 本 API 呼び出しが配置された場所に Load-Any メモリフェンスを挿入します。 詳細は <a class="el" href="_page_notification_os_memory_fence.html">OS-API のメモリーフェンスについて</a> を参照して下さい。 </p>

</div>
</div>
<a class="anchor" id="acebc9c7ff99fc0e1b04a693daeebda8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FenceMemoryAnyStore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Any-Store メモリフェンスを挿入します。 </p>
<p><b>詳細</b> <br />
 本 API 呼び出しが配置された場所に Any-Store メモリフェンスを挿入します。 詳細は <a class="el" href="_page_notification_os_memory_fence.html">OS-API のメモリーフェンスについて</a> を参照して下さい。 </p>

</div>
</div>
<a class="anchor" id="a7bfb421bf54c835b5b731db28d171cf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FenceMemoryAnyLoad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Any-Load メモリフェンスを挿入します。 </p>
<p><b>詳細</b> <br />
 本 API 呼び出しが配置された場所に Any-Load メモリフェンスを挿入します。 詳細は <a class="el" href="_page_notification_os_memory_fence.html">OS-API のメモリーフェンスについて</a> を参照して下さい。 </p>

</div>
</div>
<a class="anchor" id="addf5cd70de75b033bb8ae4eac87f8fe2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::FenceMemoryAnyAny </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Any-Any メモリフェンスを挿入します。 </p>
<p><b>詳細</b> <br />
 本 API 呼び出しが配置された場所に Any-Any メモリフェンスを挿入します。 詳細は <a class="el" href="_page_notification_os_memory_fence.html">OS-API のメモリーフェンスについて</a> を参照して下さい。 </p>

</div>
</div>
<a class="anchor" id="a80a1e659aaba155ff9552f48604aec54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::SetUserExceptionHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#aff433bbe881d0fcb8fbb47fe3e299173">UserExceptionHandler</a>&#160;</td>
          <td class="paramname"><em>pHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_user_exception_info.html">UserExceptionInfo</a> *&#160;</td>
          <td class="paramname"><em>pExceptionInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユーザ例外ハンドラを設定します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pHandler</td><td>例外発生時に呼び出される例外ハンドラの関数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>例外ハンドラで使用するスタック領域の先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stackSize</td><td>例外ハンドラで使用するスタック領域のサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pExceptionInfo</td><td>例外情報を格納するバッファ領域へのポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>stack % <a class="el" href="namespacenn_1_1os.html#ae88f7888a125e3cf4d07f28cf9acb95a" title="ユーザ例外ハンドラのスタックアライメント制約を表す定数です。 ">nn::os::HandlerStackAlignment</a> == 0</li>
<li>stackSize % <a class="el" href="namespacenn_1_1os.html#ae88f7888a125e3cf4d07f28cf9acb95a" title="ユーザ例外ハンドラのスタックアライメント制約を表す定数です。 ">nn::os::HandlerStackAlignment</a> == 0</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 ユーザ例外ハンドラを設定します。</p>
<p>pHandler には例外発生時に呼び出される関数を指定します。 この関数は <a class="el" href="namespacenn_1_1os.html#aff433bbe881d0fcb8fbb47fe3e299173" title="ユーザ例外ハンドラの関数を表す型です。 ">nn::os::UserExceptionHandler</a> 型であり、引数として 例外情報バッファへのポインタ <a class="el" href="structnn_1_1os_1_1_user_exception_info.html" title="例外情報を格納する構造体です。 ">nn::os::UserExceptionInfo</a>* が渡されます。 pHandler に NULL を指定すると、ユーザ例外ハンドラの設定を解除します。</p>
<p>stack および stackSize にて、例外ハンドラが使用するスタック領域を 指定します。stack に <a class="el" href="namespacenn_1_1os.html#ac0ca06939bae41f0ab89eda5be97d4fa" title="ユーザ例外ハンドラのスタックとしてスレッドスタックを指定する定数です。 ">nn::os::HandlerStackUsesThreadStack</a> を指定すると、 例外が発生したスレッドのスタックをそのまま例外ハンドラのスタックとして 継続して使用します。この場合、stackSize 指定は無視されます。</p>
<p>pExceptionInfo には、例外発生時に例外情報を格納するバッファを指定します。 pExceptionInfo に <a class="el" href="namespacenn_1_1os.html#a74b6dc109705a61e232eb0087fbb8720" title="例外情報格納領域として例外ハンドラのスタックを指定する定数です。 ">nn::os::UserExceptionInfoUsesHandlerStack</a> を指定すると、 例外ハンドラのスタック上に動的にバッファ領域を確保します。 pExceptionInfo に <a class="el" href="namespacenn_1_1os.html#ae95b1a34cff3839ca8d8af43ff4512cd" title="例外情報格納領域としてスレッドスタックを指定する定数です。 ">nn::os::UserExceptionInfoUsesThreadStack</a> を指定すると、 例外が発生したスレッドのスタック上に動的にバッファ領域を確保します。</p>
<p>例外ハンドラは、各プロセスに 1 つだけ設定することが出来ます。本 API を 何度も呼んだ場合は、その度に設定が上書きされ最後に設定したものが有効です。 ただし、本関数はスレッドセーフではないため、本関数の動作中に別のスレッドで 本関数を呼び出した場合の動作結果は不定です。</p>
<p>例外ハンドラが設定されている場合に例外が発生すると、例外が発生したスレッド のコンテキストで pHandler が呼び出されます。ただし、スタックは stack および stackSize で指定されたスタック領域に差し替えられています。</p>
<p>例外ハンドラが呼び出される時に、割込み禁止や他のスレッドの実行停止などの 特別な処理は行なわれません。いずれかのスレッドで例外ハンドラが動作している 最中も他のスレッドは動作を続けます。</p>
<p>そのため例外ハンドラのスタックや例外情報を格納するバッファが、複数スレッド で同じメモリ領域を指している場合には、それらの領域が同時に利用されないよう に注意して下さい。例えば、複数のスレッドでほぼ同時に例外ハンドラが起動した 場合に、それらの領域が同時に利用されないように注意しておく必要があります。</p>
<p>例外ハンドラは、デバッグ情報を出力するための手段として用意されています。 ユーザ例外ハンドラから return した場合は、すぐに各システムで定義された パニック状態に遷移し、通常は実行を停止します。</p>
<p>なお、デバッガが Attach された状態では、 ユーザ例外ハンドラが登録されていてもユーザ例外ハンドラは呼ばれません。 ただし、 <a class="el" href="namespacenn_1_1os.html#a52dba2921df0ef2adf203a4b9829a6d6" title="デバッガ接続時にもユーザ例外ハンドラを起動するか否かを設定します。 ">nn::os::EnableUserExceptionHandlerOnDebugging()</a> で true が指定 されている場合には、ユーザ例外ハンドラが呼ばれてからデバッガが停止します。</p>
<div id="dynsection-Windows" onclick="return openclose(this)" class="dynheader closed" style="cursor:pointer;"> <img id="dynsection-Windows-trigger" src="closed.png"/>
  <b>（Windowsプラットフォームのみ）:</b> <br />
</div> <div id="dynsection-Windows-summary" class="dynsummary" style="display:block;"></div> <div id="dynsection-Windows-content" class="dyncontent" style="display:none;"> Windows 環境ではユーザ例外ハンドラ機能はサポートされていません。<br />
 本 API を発行しても例外を捕捉することはできず、設定は無視されます。 </div> <dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_user_exception_handler_sample_8cpp-example.html#a34">OsUserExceptionHandlerSample.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a52dba2921df0ef2adf203a4b9829a6d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::EnableUserExceptionHandlerOnDebugging </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>デバッガ接続時にもユーザ例外ハンドラを起動するか否かを設定します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">isEnabled</td><td>デバッガ接続時にもユーザ例外ハンドラを起動するか否か</td></tr>
  </table>
  </dd>
</dl>
<p><b>詳細</b> <br />
 通常、ユーザ例外ハンドラはデバッガが接続されている場合には起動しませんが、 本 API はそのような状態でもユーザ例外ハンドラが起動するようになります。</p>
<p>isEnabled == true を指定すると、デバッガの接続中にユーザ例外が発生すると、 ユーザ例外ハンドラを起動してからデバッガの接続待ちになります。</p>
<p>そのため、デバッガで停止する位置は、実際に例外が発生した位置ではなく、 例外が発生したコンテキスト上でユーザ例外ハンドラの処理を行なった後の 位置であり、メモリやレジスタ状態が変化した後であることに注意して下さい。</p>
<p>デフォルトでは isEnabled = false となっています。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_user_exception_handler_8cpp-example.html#a2">OsUserExceptionHandler.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa9f112844be928c69600e987eb45980f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::DefaultUserExceptionHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1os_1_1_user_exception_info.html">nn::os::UserExceptionInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>デフォルトユーザー例外ハンドラです。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>発生した例外の情報</td></tr>
  </table>
  </dd>
</dl>
<p><b>詳細</b> <br />
 プログラム起動時に標準で設定されるユーザー例外ハンドラです。 例外発生時に以下の情報をログに出力します。</p>
<ul>
<li>スレッド、もしくはファイバーの情報</li>
<li>レジスタ一覧</li>
<li>スタックトレース</li>
<li>スタックダンプ</li>
<li>メモリ状態一覧</li>
</ul>
<p>このデフォルトユーザ例外ハンドラは、以下の設定相当で登録されています。</p>
<p><a class="el" href="namespacenn_1_1os.html#a80a1e659aaba155ff9552f48604aec54" title="ユーザ例外ハンドラを設定します。 ">nn::os::SetUserExceptionHandler</a>(<a class="el" href="namespacenn_1_1os.html#aa9f112844be928c69600e987eb45980f" title="デフォルトユーザー例外ハンドラです。 ">nn::os::DefaultUserExceptionHandler</a>, <a class="el" href="namespacenn_1_1os.html#ac0ca06939bae41f0ab89eda5be97d4fa" title="ユーザ例外ハンドラのスタックとしてスレッドスタックを指定する定数です。 ">nn::os::HandlerStackUsesThreadStack</a>, 0, <a class="el" href="namespacenn_1_1os.html#a74b6dc109705a61e232eb0087fbb8720" title="例外情報格納領域として例外ハンドラのスタックを指定する定数です。 ">nn::os::UserExceptionInfoUsesHandlerStack</a>);</p>
<p>独自のユーザー例外ハンドラを利用したい場合には、 <a class="el" href="namespacenn_1_1os.html#a80a1e659aaba155ff9552f48604aec54" title="ユーザ例外ハンドラを設定します。 ">SetUserExceptionHandler()</a> によってユーザー例外ハンドラを上書きすることができます。<br />
 独自のユーザー例外ハンドラから本 API を呼び出すこともできます。 </p>

</div>
</div>
<a class="anchor" id="a84abb8d61f9ab227f76ae7b54dcce5d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::os::CloseNativeHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1os.html#a84b48561ef817ac28bde556d321a382e">NativeHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定されたハンドルをクローズします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>クローズするハンドル</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>handle が有効か、もしくは <a class="el" href="namespacenn_1_1os.html#a8beb482b6d0aef56dc4877498abc9756" title="無効なハンドルであることを表す定数です。 ">nn::os::InvalidNativeHandle</a> である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 指定されたハンドルをクローズします。<br />
 handle が <a class="el" href="namespacenn_1_1os.html#a8beb482b6d0aef56dc4877498abc9756" title="無効なハンドルであることを表す定数です。 ">nn::os::InvalidNativeHandle</a> だった場合、何もせずにリターンします。</p>
<p>ハンドルは通常、 CreateSystemEvent() 等のオブジェクト初期化時に システムから取得し、オブジェクトの中で管理されるものです。ただし、 DetachSystemEvent() 等でハンドルをオブジェクトから切り離し、その後 不要になったハンドルがある場合には本 API でクローズするようにして下さい。</p>
<p>本 API は、ハンドルによるカーネルオブジェクトの参照カウントや、 各 OS オブジェクトでの管理状態を正しく把握した上で使用する必要があるため、 主に SDK 開発者が利用することを想定しています。 </p>

</div>
</div>
<h2 class="groupheader">変数詳解</h2>
<a class="anchor" id="ab8818e7de49601e4f83bd6d3ee822449"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t nn::os::FiberStackAlignment = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイバスタック領域のアライメント制約を表す定数です。 </p>
<p><b>詳細</b> <br />
 この定数は、スタックガードを設置しないファイバのスタック領域に対する アライメント制約を示します。<br />
 スタックガードを設置するファイバのスタック領域に対するアライメントは <a class="el" href="namespacenn_1_1os.html#a09b2d95cc4315e16021578c2ba43208d" title="ガード付きスタック領域のアライメント制約を表す定数です。 ">nn::os::GuardedStackAlignment</a> に従って下さい。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_os_fiber_8cpp-example.html#a1">OsFiber.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8b116319f3d483f3805c193661f22150"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t nn::os::ThreadStackAlignment = 4096</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>スレッドのスタック領域のアライメント制約を表す定数です。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_movie_decoder_player_8cpp-example.html#a70">MovieDecoderPlayer.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a895eb281cfb4500d6ac462cec6631613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t nn::os::StackRegionAlignment = <a class="el" href="namespacenn_1_1os.html#a8b116319f3d483f3805c193661f22150">ThreadStackAlignment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>スタック領域のアライメント制約を表す定数です。 </p>
<p>このAPIの利用は非推奨です。代替APIや利用条件の有無については詳細を確認してください。</p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">非推奨:</a></b></dt><dd></dd></dl>
<p><b>詳細</b> <br />
 この定数は削除予定です。 <a class="el" href="namespacenn_1_1os.html#a8b116319f3d483f3805c193661f22150" title="スレッドのスタック領域のアライメント制約を表す定数です。 ">nn::os::ThreadStackAlignment</a> を使用して下さい。 </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
