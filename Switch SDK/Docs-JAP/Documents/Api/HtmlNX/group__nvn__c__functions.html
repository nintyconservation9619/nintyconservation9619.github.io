<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>NintendoSDK API Reference: API Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>総合概要</span></a></li>
      <li><a href="pages.html"><span>諸情報</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>名前空間</span></a></li>
      <li><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">関数</a>  </div>
  <div class="headertitle">
<div class="title">API Functions<div class="ingroups"><a class="el" href="group__nvn__c__interface.html">NVN C API Bindings</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>C Interface API entry points.  
<a href="#details">[詳解]</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
関数</h2></td></tr>
<tr class="memitem:ga347fb2b3121de63e9c3a6b9595ccd2c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga594e8a6aa9642c5542c0a0ee0156c146">NVNblendAdvancedMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga347fb2b3121de63e9c3a6b9595ccd2c0">nvnBlendStateGetAdvancedMode</a> (const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend)</td></tr>
<tr class="memdesc:ga347fb2b3121de63e9c3a6b9595ccd2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the mode for advanced blending equations.  <a href="#ga347fb2b3121de63e9c3a6b9595ccd2c0">[詳解]</a><br /></td></tr>
<tr class="separator:ga347fb2b3121de63e9c3a6b9595ccd2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c2a450326605d61c14c8a888db2fb2b"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4c2a450326605d61c14c8a888db2fb2b">nvnBlendStateGetAdvancedNormalizedDst</a> (const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend)</td></tr>
<tr class="memdesc:ga4c2a450326605d61c14c8a888db2fb2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the destination color target has unsigned normalized components (values in [0,1]).  <a href="#ga4c2a450326605d61c14c8a888db2fb2b">[詳解]</a><br /></td></tr>
<tr class="separator:ga4c2a450326605d61c14c8a888db2fb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a0232ed175b83f4002d237e98eea02c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga49a9399d8c6cc26a7f4b256fe0951699">NVNblendAdvancedOverlap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9a0232ed175b83f4002d237e98eea02c">nvnBlendStateGetAdvancedOverlap</a> (const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend)</td></tr>
<tr class="memdesc:ga9a0232ed175b83f4002d237e98eea02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the blend overlap mode for advanced blending equations.  <a href="#ga9a0232ed175b83f4002d237e98eea02c">[詳解]</a><br /></td></tr>
<tr class="separator:ga9a0232ed175b83f4002d237e98eea02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e8df2c0b7c30848c050cf62da45494d"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8e8df2c0b7c30848c050cf62da45494d">nvnBlendStateGetAdvancedPremultipliedSrc</a> (const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend)</td></tr>
<tr class="memdesc:ga8e8df2c0b7c30848c050cf62da45494d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the source color is considered premultiplied for advanced blending equations.  <a href="#ga8e8df2c0b7c30848c050cf62da45494d">[詳解]</a><br /></td></tr>
<tr class="separator:ga8e8df2c0b7c30848c050cf62da45494d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7473bde2a4b5144923394d2b2b3ebaab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7473bde2a4b5144923394d2b2b3ebaab">nvnBlendStateGetBlendEquation</a> (const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a> *modeRGB, <a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a> *modeAlpha)</td></tr>
<tr class="memdesc:ga7473bde2a4b5144923394d2b2b3ebaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query blend equations for color and alpha channels.  <a href="#ga7473bde2a4b5144923394d2b2b3ebaab">[詳解]</a><br /></td></tr>
<tr class="separator:ga7473bde2a4b5144923394d2b2b3ebaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafac4c143756021848290b54879da1240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafac4c143756021848290b54879da1240">nvnBlendStateGetBlendFunc</a> (const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> *srcFunc, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> *dstFunc, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> *srcFuncAlpha, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> *dstFuncAlpha)</td></tr>
<tr class="memdesc:gafac4c143756021848290b54879da1240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query blend functions for source and destination color and alpha channels.  <a href="#gafac4c143756021848290b54879da1240">[詳解]</a><br /></td></tr>
<tr class="separator:gafac4c143756021848290b54879da1240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67117050f7018fa4eb4f51b7611b743c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga67117050f7018fa4eb4f51b7611b743c">nvnBlendStateGetBlendTarget</a> (const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend)</td></tr>
<tr class="memdesc:ga67117050f7018fa4eb4f51b7611b743c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of the color target to update via the <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object.  <a href="#ga67117050f7018fa4eb4f51b7611b743c">[詳解]</a><br /></td></tr>
<tr class="separator:ga67117050f7018fa4eb4f51b7611b743c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadda20b441c242fbad2fa87c9c441735a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gadda20b441c242fbad2fa87c9c441735a">nvnBlendStateSetAdvancedMode</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__enum.html#ga594e8a6aa9642c5542c0a0ee0156c146">NVNblendAdvancedMode</a> overlap)</td></tr>
<tr class="memdesc:gadda20b441c242fbad2fa87c9c441735a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a mode for advanced blending equations.  <a href="#gadda20b441c242fbad2fa87c9c441735a">[詳解]</a><br /></td></tr>
<tr class="separator:gadda20b441c242fbad2fa87c9c441735a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ae21c2d569e680699ce50ff6d6b3a7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3ae21c2d569e680699ce50ff6d6b3a7b">nvnBlendStateSetAdvancedNormalizedDst</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, NVNboolean normalized)</td></tr>
<tr class="memdesc:ga3ae21c2d569e680699ce50ff6d6b3a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether the destination color target has unsigned normalized components (values in [0,1]).  <a href="#ga3ae21c2d569e680699ce50ff6d6b3a7b">[詳解]</a><br /></td></tr>
<tr class="separator:ga3ae21c2d569e680699ce50ff6d6b3a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e2be1cd8aad18c9d1ba0f9fa4ca7af4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0e2be1cd8aad18c9d1ba0f9fa4ca7af4">nvnBlendStateSetAdvancedOverlap</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__enum.html#ga49a9399d8c6cc26a7f4b256fe0951699">NVNblendAdvancedOverlap</a> overlap)</td></tr>
<tr class="memdesc:ga0e2be1cd8aad18c9d1ba0f9fa4ca7af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify blend overlap mode for advanced blending equations.  <a href="#ga0e2be1cd8aad18c9d1ba0f9fa4ca7af4">[詳解]</a><br /></td></tr>
<tr class="separator:ga0e2be1cd8aad18c9d1ba0f9fa4ca7af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8aae125e2a9006310e3812c99e5f7ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac8aae125e2a9006310e3812c99e5f7ff">nvnBlendStateSetAdvancedPremultipliedSrc</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, NVNboolean premultiplied)</td></tr>
<tr class="memdesc:gac8aae125e2a9006310e3812c99e5f7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether the source color is considered premultiplied for advanced blending equations.  <a href="#gac8aae125e2a9006310e3812c99e5f7ff">[詳解]</a><br /></td></tr>
<tr class="separator:gac8aae125e2a9006310e3812c99e5f7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8c227afe934866f7758f9158ebe1f9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad8c227afe934866f7758f9158ebe1f9f">nvnBlendStateSetBlendEquation</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a> modeRGB, <a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a> modeAlpha)</td></tr>
<tr class="memdesc:gad8c227afe934866f7758f9158ebe1f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify blend equations for color and alpha channels.  <a href="#gad8c227afe934866f7758f9158ebe1f9f">[詳解]</a><br /></td></tr>
<tr class="separator:gad8c227afe934866f7758f9158ebe1f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f1f669fc90892348eb5763a6d173c60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8f1f669fc90892348eb5763a6d173c60">nvnBlendStateSetBlendFunc</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> srcFunc, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> dstFunc, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> srcFuncAlpha, <a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> dstFuncAlpha)</td></tr>
<tr class="memdesc:ga8f1f669fc90892348eb5763a6d173c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify blend functions for source and destination color and alpha channels.  <a href="#ga8f1f669fc90892348eb5763a6d173c60">[詳解]</a><br /></td></tr>
<tr class="separator:ga8f1f669fc90892348eb5763a6d173c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe4427881d956cf1db9fc536bb9586ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafe4427881d956cf1db9fc536bb9586ce">nvnBlendStateSetBlendTarget</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend, int target)</td></tr>
<tr class="memdesc:gafe4427881d956cf1db9fc536bb9586ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the number of the color target to update via the <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object.  <a href="#gafe4427881d956cf1db9fc536bb9586ce">[詳解]</a><br /></td></tr>
<tr class="separator:gafe4427881d956cf1db9fc536bb9586ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0c043334f5f7eb94883fc0465f18e4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad0c043334f5f7eb94883fc0465f18e4f">nvnBlendStateSetDefaults</a> (<a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend)</td></tr>
<tr class="memdesc:gad0c043334f5f7eb94883fc0465f18e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object.  <a href="#gad0c043334f5f7eb94883fc0465f18e4f">[詳解]</a><br /></td></tr>
<tr class="separator:gad0c043334f5f7eb94883fc0465f18e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf799ed12f9ff9d00ec9acdc4ba60ba57"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf799ed12f9ff9d00ec9acdc4ba60ba57">nvnBufferBuilderGetDevice</a> (const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaf799ed12f9ff9d00ec9acdc4ba60ba57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the device associated with this <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object.  <a href="#gaf799ed12f9ff9d00ec9acdc4ba60ba57">[詳解]</a><br /></td></tr>
<tr class="separator:gaf799ed12f9ff9d00ec9acdc4ba60ba57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga205e32b963584eaf5e8c78cdba135e68"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga205e32b963584eaf5e8c78cdba135e68">nvnBufferBuilderGetMemoryOffset</a> (const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga205e32b963584eaf5e8c78cdba135e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool offset used by a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object.  <a href="#ga205e32b963584eaf5e8c78cdba135e68">[詳解]</a><br /></td></tr>
<tr class="separator:ga205e32b963584eaf5e8c78cdba135e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80ec5e6a2f5d90f738de111cef60c5b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga80ec5e6a2f5d90f738de111cef60c5b4">nvnBufferBuilderGetMemoryPool</a> (const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga80ec5e6a2f5d90f738de111cef60c5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool used by a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object.  <a href="#ga80ec5e6a2f5d90f738de111cef60c5b4">[詳解]</a><br /></td></tr>
<tr class="separator:ga80ec5e6a2f5d90f738de111cef60c5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga318db40761633c5e9129be18c1420f9c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga318db40761633c5e9129be18c1420f9c">nvnBufferBuilderGetSize</a> (const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga318db40761633c5e9129be18c1420f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the size (in bytes) of the storage in a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object.  <a href="#ga318db40761633c5e9129be18c1420f9c">[詳解]</a><br /></td></tr>
<tr class="separator:ga318db40761633c5e9129be18c1420f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17550ab21d8136e4f5c48c91c21716f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga17550ab21d8136e4f5c48c91c21716f2">nvnBufferBuilderSetDefaults</a> (<a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga17550ab21d8136e4f5c48c91c21716f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object.  <a href="#ga17550ab21d8136e4f5c48c91c21716f2">[詳解]</a><br /></td></tr>
<tr class="separator:ga17550ab21d8136e4f5c48c91c21716f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f1e5a40cc9b049892a527b95ac9b9fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7f1e5a40cc9b049892a527b95ac9b9fc">nvnBufferBuilderSetDevice</a> (<a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder, <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:ga7f1e5a40cc9b049892a527b95ac9b9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object.  <a href="#ga7f1e5a40cc9b049892a527b95ac9b9fc">[詳解]</a><br /></td></tr>
<tr class="separator:ga7f1e5a40cc9b049892a527b95ac9b9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaa4fd698902c746debccb3fa967e324"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaaaa4fd698902c746debccb3fa967e324">nvnBufferBuilderSetStorage</a> (<a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder, <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, ptrdiff_t offset, size_t size)</td></tr>
<tr class="memdesc:gaaaa4fd698902c746debccb3fa967e324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the range of a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> used for a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object created from the <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a>.  <a href="#gaaaa4fd698902c746debccb3fa967e324">[詳解]</a><br /></td></tr>
<tr class="separator:gaaaa4fd698902c746debccb3fa967e324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e56941d8153c1e1b2ba861189ea993d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3e56941d8153c1e1b2ba861189ea993d">nvnBufferFinalize</a> (<a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer)</td></tr>
<tr class="memdesc:ga3e56941d8153c1e1b2ba861189ea993d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object.  <a href="#ga3e56941d8153c1e1b2ba861189ea993d">[詳解]</a><br /></td></tr>
<tr class="separator:ga3e56941d8153c1e1b2ba861189ea993d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77aee9d827392e1bb7d86a02dd5b8e5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga77aee9d827392e1bb7d86a02dd5b8e5c">nvnBufferFlushMappedRange</a> (const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer, ptrdiff_t offset, size_t size)</td></tr>
<tr class="memdesc:ga77aee9d827392e1bb7d86a02dd5b8e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush previous CPU writes to a range of a buffer to be visible to the GPU.  <a href="#ga77aee9d827392e1bb7d86a02dd5b8e5c">[詳解]</a><br /></td></tr>
<tr class="separator:ga77aee9d827392e1bb7d86a02dd5b8e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac38c964075df642306d6490b8b50ace3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac38c964075df642306d6490b8b50ace3">nvnBufferGetAddress</a> (const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer)</td></tr>
<tr class="memdesc:gac38c964075df642306d6490b8b50ace3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the GPU address of the data store of a buffer object.  <a href="#gac38c964075df642306d6490b8b50ace3">[詳解]</a><br /></td></tr>
<tr class="separator:gac38c964075df642306d6490b8b50ace3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d63ead7e4386863c9d3e250be49ad47"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3d63ead7e4386863c9d3e250be49ad47">nvnBufferGetDebugID</a> (const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer)</td></tr>
<tr class="memdesc:ga3d63ead7e4386863c9d3e250be49ad47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug layer unique ID of this buffer.  <a href="#ga3d63ead7e4386863c9d3e250be49ad47">[詳解]</a><br /></td></tr>
<tr class="separator:ga3d63ead7e4386863c9d3e250be49ad47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga748c3509a17ea343cbee8675d4185f6e"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga748c3509a17ea343cbee8675d4185f6e">nvnBufferGetMemoryOffset</a> (const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer)</td></tr>
<tr class="memdesc:ga748c3509a17ea343cbee8675d4185f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool offset used by a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object.  <a href="#ga748c3509a17ea343cbee8675d4185f6e">[詳解]</a><br /></td></tr>
<tr class="separator:ga748c3509a17ea343cbee8675d4185f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f89923da0518bec56898b2dcddf213d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5f89923da0518bec56898b2dcddf213d">nvnBufferGetMemoryPool</a> (const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer)</td></tr>
<tr class="memdesc:ga5f89923da0518bec56898b2dcddf213d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool used by a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object.  <a href="#ga5f89923da0518bec56898b2dcddf213d">[詳解]</a><br /></td></tr>
<tr class="separator:ga5f89923da0518bec56898b2dcddf213d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9537e164c060a08b95e68caea5c9ba6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad9537e164c060a08b95e68caea5c9ba6">nvnBufferGetSize</a> (const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer)</td></tr>
<tr class="memdesc:gad9537e164c060a08b95e68caea5c9ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the size (in bytes) of the storage of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object.  <a href="#gad9537e164c060a08b95e68caea5c9ba6">[詳解]</a><br /></td></tr>
<tr class="separator:gad9537e164c060a08b95e68caea5c9ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga862eafc1a9c42ce08a7c40ba004d7b57"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga862eafc1a9c42ce08a7c40ba004d7b57">nvnBufferInitialize</a> (<a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer, const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga862eafc1a9c42ce08a7c40ba004d7b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new buffer object from a buffer builder.  <a href="#ga862eafc1a9c42ce08a7c40ba004d7b57">[詳解]</a><br /></td></tr>
<tr class="separator:ga862eafc1a9c42ce08a7c40ba004d7b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7087d787b41f8b07b13ed3a7f1edddc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf7087d787b41f8b07b13ed3a7f1edddc">nvnBufferInvalidateMappedRange</a> (const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer, ptrdiff_t offset, size_t size)</td></tr>
<tr class="memdesc:gaf7087d787b41f8b07b13ed3a7f1edddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate CPU caches for a range of a buffer that may have been written by the GPU.  <a href="#gaf7087d787b41f8b07b13ed3a7f1edddc">[詳解]</a><br /></td></tr>
<tr class="separator:gaf7087d787b41f8b07b13ed3a7f1edddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3a80a57023737b594e83a9fa04282c6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa3a80a57023737b594e83a9fa04282c6">nvnBufferMap</a> (const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer)</td></tr>
<tr class="memdesc:gaa3a80a57023737b594e83a9fa04282c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a CPU pointer to the memory of a previously created <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object.  <a href="#gaa3a80a57023737b594e83a9fa04282c6">[詳解]</a><br /></td></tr>
<tr class="separator:gaa3a80a57023737b594e83a9fa04282c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c0027b477c987c8a8573c7d04d854b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9c0027b477c987c8a8573c7d04d854b1">nvnBufferSetDebugLabel</a> (<a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *buffer, const char *label)</td></tr>
<tr class="memdesc:ga9c0027b477c987c8a8573c7d04d854b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object.  <a href="#ga9c0027b477c987c8a8573c7d04d854b1">[詳解]</a><br /></td></tr>
<tr class="separator:ga9c0027b477c987c8a8573c7d04d854b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc2b78b04c91b5deabcfaf93cdb0e36c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacc2b78b04c91b5deabcfaf93cdb0e36c">nvnChannelMaskStateGetChannelMask</a> (const <a class="el" href="struct_n_v_nchannel_mask_state.html">NVNchannelMaskState</a> *channelMask, int index, NVNboolean *r, NVNboolean *g, NVNboolean *b, NVNboolean *a)</td></tr>
<tr class="memdesc:gacc2b78b04c91b5deabcfaf93cdb0e36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query RGBA channel masks for a single color target.  <a href="#gacc2b78b04c91b5deabcfaf93cdb0e36c">[詳解]</a><br /></td></tr>
<tr class="separator:gacc2b78b04c91b5deabcfaf93cdb0e36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2493330ef54d576b537e2f0b1aadbf24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2493330ef54d576b537e2f0b1aadbf24">nvnChannelMaskStateSetChannelMask</a> (<a class="el" href="struct_n_v_nchannel_mask_state.html">NVNchannelMaskState</a> *channelMask, int index, NVNboolean r, NVNboolean g, NVNboolean b, NVNboolean a)</td></tr>
<tr class="memdesc:ga2493330ef54d576b537e2f0b1aadbf24"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives. ">NVNprogram</a> RGBA channel masks for a single color target.  <a href="#ga2493330ef54d576b537e2f0b1aadbf24">[詳解]</a><br /></td></tr>
<tr class="separator:ga2493330ef54d576b537e2f0b1aadbf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc110d97cce3482f715d26e83413adfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafc110d97cce3482f715d26e83413adfc">nvnChannelMaskStateSetDefaults</a> (<a class="el" href="struct_n_v_nchannel_mask_state.html">NVNchannelMaskState</a> *channelMask)</td></tr>
<tr class="memdesc:gafc110d97cce3482f715d26e83413adfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nchannel_mask_state.html" title="API state object holding per-channel write masks for all color buffers. ">NVNchannelMaskState</a> object.  <a href="#gafc110d97cce3482f715d26e83413adfc">[詳解]</a><br /></td></tr>
<tr class="separator:gafc110d97cce3482f715d26e83413adfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dd303cf6348a6e860f26da1f9219e46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#gaef30ce5d138fb99aee61e09d89d9952e">NVNalphaFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9dd303cf6348a6e860f26da1f9219e46">nvnColorStateGetAlphaTest</a> (const <a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *color)</td></tr>
<tr class="memdesc:ga9dd303cf6348a6e860f26da1f9219e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the comparison function to use for alpha testing.  <a href="#ga9dd303cf6348a6e860f26da1f9219e46">[詳解]</a><br /></td></tr>
<tr class="separator:ga9dd303cf6348a6e860f26da1f9219e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3503d68a40da5ab574a594125f8cef2e"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3503d68a40da5ab574a594125f8cef2e">nvnColorStateGetBlendEnable</a> (const <a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *color, int index)</td></tr>
<tr class="memdesc:ga3503d68a40da5ab574a594125f8cef2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the blending enable for a single color target.  <a href="#ga3503d68a40da5ab574a594125f8cef2e">[詳解]</a><br /></td></tr>
<tr class="separator:ga3503d68a40da5ab574a594125f8cef2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf55951ccbd93d23d1753d4de03d81119"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga13d92b26dc58a3c92b79e217e1d81786">NVNlogicOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf55951ccbd93d23d1753d4de03d81119">nvnColorStateGetLogicOp</a> (const <a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *color)</td></tr>
<tr class="memdesc:gaf55951ccbd93d23d1753d4de03d81119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the logical operation to perform for all color targets.  <a href="#gaf55951ccbd93d23d1753d4de03d81119">[詳解]</a><br /></td></tr>
<tr class="separator:gaf55951ccbd93d23d1753d4de03d81119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cd9f1df52f41fef96e17bbd42facaa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1cd9f1df52f41fef96e17bbd42facaa0">nvnColorStateSetAlphaTest</a> (<a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *color, <a class="el" href="group__nvn__c__enum.html#gaef30ce5d138fb99aee61e09d89d9952e">NVNalphaFunc</a> alphaTest)</td></tr>
<tr class="memdesc:ga1cd9f1df52f41fef96e17bbd42facaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a comparison function to use for alpha testing.  <a href="#ga1cd9f1df52f41fef96e17bbd42facaa0">[詳解]</a><br /></td></tr>
<tr class="separator:ga1cd9f1df52f41fef96e17bbd42facaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c1c99c2ad31d66b2a6c170b8d8b324c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4c1c99c2ad31d66b2a6c170b8d8b324c">nvnColorStateSetBlendEnable</a> (<a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *color, int index, NVNboolean enable)</td></tr>
<tr class="memdesc:ga4c1c99c2ad31d66b2a6c170b8d8b324c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the blending enable for a single color target.  <a href="#ga4c1c99c2ad31d66b2a6c170b8d8b324c">[詳解]</a><br /></td></tr>
<tr class="separator:ga4c1c99c2ad31d66b2a6c170b8d8b324c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b5549b5bc5384456dda61010d85b5c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1b5549b5bc5384456dda61010d85b5c2">nvnColorStateSetDefaults</a> (<a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *color)</td></tr>
<tr class="memdesc:ga1b5549b5bc5384456dda61010d85b5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values. ">NVNcolorState</a> object.  <a href="#ga1b5549b5bc5384456dda61010d85b5c2">[詳解]</a><br /></td></tr>
<tr class="separator:ga1b5549b5bc5384456dda61010d85b5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34d488b77453064ee98fd042c5f8f9df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga34d488b77453064ee98fd042c5f8f9df">nvnColorStateSetLogicOp</a> (<a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *color, <a class="el" href="group__nvn__c__enum.html#ga13d92b26dc58a3c92b79e217e1d81786">NVNlogicOp</a> logicOp)</td></tr>
<tr class="memdesc:ga34d488b77453064ee98fd042c5f8f9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the logical operation to perform for all color targets.  <a href="#ga34d488b77453064ee98fd042c5f8f9df">[詳解]</a><br /></td></tr>
<tr class="separator:ga34d488b77453064ee98fd042c5f8f9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c0d758cfa73c25f2a34486353f46d92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2c0d758cfa73c25f2a34486353f46d92">nvnCommandBufferAddCommandMemory</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, ptrdiff_t offset, size_t size)</td></tr>
<tr class="memdesc:ga2c0d758cfa73c25f2a34486353f46d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add command data memory for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object.  <a href="#ga2c0d758cfa73c25f2a34486353f46d92">[詳解]</a><br /></td></tr>
<tr class="separator:ga2c0d758cfa73c25f2a34486353f46d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8de6ce290ee0180d9bcd700c1d08d0bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8de6ce290ee0180d9bcd700c1d08d0bf">nvnCommandBufferAddControlMemory</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, void *memory, size_t size)</td></tr>
<tr class="memdesc:ga8de6ce290ee0180d9bcd700c1d08d0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add control memory for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object.  <a href="#ga8de6ce290ee0180d9bcd700c1d08d0bf">[詳解]</a><br /></td></tr>
<tr class="separator:ga8de6ce290ee0180d9bcd700c1d08d0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8004a74da7c68a5424ac4466653dce34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8004a74da7c68a5424ac4466653dce34">nvnCommandBufferBarrier</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int barrier)</td></tr>
<tr class="memdesc:ga8004a74da7c68a5424ac4466653dce34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches.  <a href="#ga8004a74da7c68a5424ac4466653dce34">[詳解]</a><br /></td></tr>
<tr class="separator:ga8004a74da7c68a5424ac4466653dce34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb763d2bdad2c058c75802190fef4748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaeb763d2bdad2c058c75802190fef4748">nvnCommandBufferBeginRecording</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:gaeb763d2bdad2c058c75802190fef4748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin recording a new set of commands in this <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object.  <a href="#gaeb763d2bdad2c058c75802190fef4748">[詳解]</a><br /></td></tr>
<tr class="separator:gaeb763d2bdad2c058c75802190fef4748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a5d40804e1ae718dfb71928afc6963e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8a5d40804e1ae718dfb71928afc6963e">nvnCommandBufferBeginTransformFeedback</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer)</td></tr>
<tr class="memdesc:ga8a5d40804e1ae718dfb71928afc6963e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a transform feedback (stream output) operation.  <a href="#ga8a5d40804e1ae718dfb71928afc6963e">[詳解]</a><br /></td></tr>
<tr class="separator:ga8a5d40804e1ae718dfb71928afc6963e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c3895b442dc5055a3ba72b149389a90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7c3895b442dc5055a3ba72b149389a90">nvnCommandBufferBindBlendState</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *blend)</td></tr>
<tr class="memdesc:ga7c3895b442dc5055a3ba72b149389a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object to bind for subsequent commands.  <a href="#ga7c3895b442dc5055a3ba72b149389a90">[詳解]</a><br /></td></tr>
<tr class="separator:ga7c3895b442dc5055a3ba72b149389a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac468cb3593c0a9653515830e19800536"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac468cb3593c0a9653515830e19800536">nvnCommandBufferBindChannelMaskState</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_nchannel_mask_state.html">NVNchannelMaskState</a> *channelMask)</td></tr>
<tr class="memdesc:gac468cb3593c0a9653515830e19800536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new <a class="el" href="struct_n_v_nchannel_mask_state.html" title="API state object holding per-channel write masks for all color buffers. ">NVNchannelMaskState</a> object to bind for subsequent commands.  <a href="#gac468cb3593c0a9653515830e19800536">[詳解]</a><br /></td></tr>
<tr class="separator:gac468cb3593c0a9653515830e19800536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b957807821fbeac2c91ddfc34e9e941"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6b957807821fbeac2c91ddfc34e9e941">nvnCommandBufferBindColorState</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *color)</td></tr>
<tr class="memdesc:ga6b957807821fbeac2c91ddfc34e9e941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new <a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values. ">NVNcolorState</a> object to bind for subsequent commands.  <a href="#ga6b957807821fbeac2c91ddfc34e9e941">[詳解]</a><br /></td></tr>
<tr class="separator:ga6b957807821fbeac2c91ddfc34e9e941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga904b069b58abb45362b69d4373a501fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga904b069b58abb45362b69d4373a501fd">nvnCommandBufferBindCoverageModulationTable</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const float *entries)</td></tr>
<tr class="memdesc:ga904b069b58abb45362b69d4373a501fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds or unbinds a coverage modulation table used for target-independent rasterization.  <a href="#ga904b069b58abb45362b69d4373a501fd">[詳解]</a><br /></td></tr>
<tr class="separator:ga904b069b58abb45362b69d4373a501fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae829ea8fc2209e876f64e9eaa7b21992"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae829ea8fc2209e876f64e9eaa7b21992">nvnCommandBufferBindDepthStencilState</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil)</td></tr>
<tr class="memdesc:gae829ea8fc2209e876f64e9eaa7b21992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new <a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object to bind for subsequent commands.  <a href="#gae829ea8fc2209e876f64e9eaa7b21992">[詳解]</a><br /></td></tr>
<tr class="separator:gae829ea8fc2209e876f64e9eaa7b21992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26915307b6b313db6e592c0b2c9a9aa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga26915307b6b313db6e592c0b2c9a9aa4">nvnCommandBufferBindImage</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int index, <a class="el" href="group__nvn__c__handle.html#gacba3c44a43c05f11bc1b88c49b118606">NVNimageHandle</a> image)</td></tr>
<tr class="memdesc:ga26915307b6b313db6e592c0b2c9a9aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> to use for image loads and stores in shaders.  <a href="#ga26915307b6b313db6e592c0b2c9a9aa4">[詳解]</a><br /></td></tr>
<tr class="separator:ga26915307b6b313db6e592c0b2c9a9aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0451e037db54d61e07c7af605ea6a1c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0451e037db54d61e07c7af605ea6a1c2">nvnCommandBufferBindImages</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, const <a class="el" href="group__nvn__c__handle.html#gacba3c44a43c05f11bc1b88c49b118606">NVNimageHandle</a> *images)</td></tr>
<tr class="memdesc:ga0451e037db54d61e07c7af605ea6a1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more Textures to use for image loads and stores in shaders.  <a href="#ga0451e037db54d61e07c7af605ea6a1c2">[詳解]</a><br /></td></tr>
<tr class="separator:ga0451e037db54d61e07c7af605ea6a1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga463e501c3151aab9e9cb737e6cbaba5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga463e501c3151aab9e9cb737e6cbaba5d">nvnCommandBufferBindMultisampleState</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga463e501c3151aab9e9cb737e6cbaba5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to bind for subsequent commands.  <a href="#ga463e501c3151aab9e9cb737e6cbaba5d">[詳解]</a><br /></td></tr>
<tr class="separator:ga463e501c3151aab9e9cb737e6cbaba5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5bee99214e32842654cbc22dd5f17bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab5bee99214e32842654cbc22dd5f17bd">nvnCommandBufferBindPolygonState</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon)</td></tr>
<tr class="memdesc:gab5bee99214e32842654cbc22dd5f17bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new <a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons. ">NVNpolygonState</a> object to bind for subsequent commands.  <a href="#gab5bee99214e32842654cbc22dd5f17bd">[詳解]</a><br /></td></tr>
<tr class="separator:gab5bee99214e32842654cbc22dd5f17bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f4b9d505338994b172c814ed32565c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1f4b9d505338994b172c814ed32565c8">nvnCommandBufferBindProgram</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *program, int stages)</td></tr>
<tr class="memdesc:ga1f4b9d505338994b172c814ed32565c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind or unbind shaders in a <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives. ">NVNprogram</a> object for subsequent rendering commands.  <a href="#ga1f4b9d505338994b172c814ed32565c8">[詳解]</a><br /></td></tr>
<tr class="separator:ga1f4b9d505338994b172c814ed32565c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee3d37a925075c3b7309519710eba21c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaee3d37a925075c3b7309519710eba21c">nvnCommandBufferBindSeparateSampler</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int index, <a class="el" href="struct_n_v_nseparate_sampler_handle.html">NVNseparateSamplerHandle</a> samplerHandle)</td></tr>
<tr class="memdesc:gaee3d37a925075c3b7309519710eba21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> to use for texture mapping in shaders.  <a href="#gaee3d37a925075c3b7309519710eba21c">[詳解]</a><br /></td></tr>
<tr class="separator:gaee3d37a925075c3b7309519710eba21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf3893f22e69cca544a365b85e9295d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabf3893f22e69cca544a365b85e9295d5">nvnCommandBufferBindSeparateSamplers</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, const <a class="el" href="struct_n_v_nseparate_sampler_handle.html">NVNseparateSamplerHandle</a> *samplerHandles)</td></tr>
<tr class="memdesc:gabf3893f22e69cca544a365b85e9295d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more Samplers to use for texture mapping in shaders.  <a href="#gabf3893f22e69cca544a365b85e9295d5">[詳解]</a><br /></td></tr>
<tr class="separator:gabf3893f22e69cca544a365b85e9295d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b5b85ce0b512e73c9d3b5ad067c3bbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9b5b85ce0b512e73c9d3b5ad067c3bbe">nvnCommandBufferBindSeparateTexture</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int index, <a class="el" href="struct_n_v_nseparate_texture_handle.html">NVNseparateTextureHandle</a> textureHandle)</td></tr>
<tr class="memdesc:ga9b5b85ce0b512e73c9d3b5ad067c3bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> to use for texture mapping in shaders.  <a href="#ga9b5b85ce0b512e73c9d3b5ad067c3bbe">[詳解]</a><br /></td></tr>
<tr class="separator:ga9b5b85ce0b512e73c9d3b5ad067c3bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa9403fe47ad6ca243c10cbd12562464"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafa9403fe47ad6ca243c10cbd12562464">nvnCommandBufferBindSeparateTextures</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, const <a class="el" href="struct_n_v_nseparate_texture_handle.html">NVNseparateTextureHandle</a> *textureHandles)</td></tr>
<tr class="memdesc:gafa9403fe47ad6ca243c10cbd12562464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more separate textures to use for texture mapping in shaders.  <a href="#gafa9403fe47ad6ca243c10cbd12562464">[詳解]</a><br /></td></tr>
<tr class="separator:gafa9403fe47ad6ca243c10cbd12562464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18f58558537f39f4d427bd09c99de607"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga18f58558537f39f4d427bd09c99de607">nvnCommandBufferBindStorageBuffer</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int index, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer, size_t size)</td></tr>
<tr class="memdesc:ga18f58558537f39f4d427bd09c99de607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to use for random-access reads and writes in shaders.  <a href="#ga18f58558537f39f4d427bd09c99de607">[詳解]</a><br /></td></tr>
<tr class="separator:ga18f58558537f39f4d427bd09c99de607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4717fd2c3476689066d49079e21ed781"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4717fd2c3476689066d49079e21ed781">nvnCommandBufferBindStorageBuffers</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *buffers)</td></tr>
<tr class="memdesc:ga4717fd2c3476689066d49079e21ed781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object ranges to use for random-access reads and writes in shaders.  <a href="#ga4717fd2c3476689066d49079e21ed781">[詳解]</a><br /></td></tr>
<tr class="separator:ga4717fd2c3476689066d49079e21ed781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad89eb87dde4d1dba6444ea4f8f79e66b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad89eb87dde4d1dba6444ea4f8f79e66b">nvnCommandBufferBindTexture</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int index, <a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a> texture)</td></tr>
<tr class="memdesc:gad89eb87dde4d1dba6444ea4f8f79e66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a NVNtexture/NVNsampler pair to use for texture mapping in shaders.  <a href="#gad89eb87dde4d1dba6444ea4f8f79e66b">[詳解]</a><br /></td></tr>
<tr class="separator:gad89eb87dde4d1dba6444ea4f8f79e66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e4a4a182413079203513c4cdaa3a83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga11e4a4a182413079203513c4cdaa3a83">nvnCommandBufferBindTextures</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, const <a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a> *textures)</td></tr>
<tr class="memdesc:ga11e4a4a182413079203513c4cdaa3a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more NVNtexture/NVNsampler pairs to use for texture mapping in shaders.  <a href="#ga11e4a4a182413079203513c4cdaa3a83">[詳解]</a><br /></td></tr>
<tr class="separator:ga11e4a4a182413079203513c4cdaa3a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadacbd5a1b83b888949d3374015019a39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gadacbd5a1b83b888949d3374015019a39">nvnCommandBufferBindTransformFeedbackBuffer</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int index, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer, size_t size)</td></tr>
<tr class="memdesc:gadacbd5a1b83b888949d3374015019a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to use for capturing transformed vertex data.  <a href="#gadacbd5a1b83b888949d3374015019a39">[詳解]</a><br /></td></tr>
<tr class="separator:gadacbd5a1b83b888949d3374015019a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d491ae584fb9cb1bbb9c53976d20c26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8d491ae584fb9cb1bbb9c53976d20c26">nvnCommandBufferBindTransformFeedbackBuffers</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int first, int count, const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *buffers)</td></tr>
<tr class="memdesc:ga8d491ae584fb9cb1bbb9c53976d20c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object ranges to use for capturing transformed vertex data.  <a href="#ga8d491ae584fb9cb1bbb9c53976d20c26">[詳解]</a><br /></td></tr>
<tr class="separator:ga8d491ae584fb9cb1bbb9c53976d20c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50631d9a85aca68db2ede52b0d13521e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga50631d9a85aca68db2ede52b0d13521e">nvnCommandBufferBindUniformBuffer</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int index, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer, size_t size)</td></tr>
<tr class="memdesc:ga50631d9a85aca68db2ede52b0d13521e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to use for fetching shader uniform values.  <a href="#ga50631d9a85aca68db2ede52b0d13521e">[詳解]</a><br /></td></tr>
<tr class="separator:ga50631d9a85aca68db2ede52b0d13521e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga970a3c1387ee642760b7db22b848a46b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga970a3c1387ee642760b7db22b848a46b">nvnCommandBufferBindUniformBuffers</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, int first, int count, const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *buffers)</td></tr>
<tr class="memdesc:ga970a3c1387ee642760b7db22b848a46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object ranges to use for fetching shader uniform values.  <a href="#ga970a3c1387ee642760b7db22b848a46b">[詳解]</a><br /></td></tr>
<tr class="separator:ga970a3c1387ee642760b7db22b848a46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f0e28ea8b574b0b7d3ee6bd2e94dcac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4f0e28ea8b574b0b7d3ee6bd2e94dcac">nvnCommandBufferBindVertexAttribState</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int numAttribs, const <a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *attribs)</td></tr>
<tr class="memdesc:ga4f0e28ea8b574b0b7d3ee6bd2e94dcac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a vertex attribute layout for subsequent commands.  <a href="#ga4f0e28ea8b574b0b7d3ee6bd2e94dcac">[詳解]</a><br /></td></tr>
<tr class="separator:ga4f0e28ea8b574b0b7d3ee6bd2e94dcac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga328bba22810a4467865b444d17bec8e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga328bba22810a4467865b444d17bec8e9">nvnCommandBufferBindVertexBuffer</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int index, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer, size_t size)</td></tr>
<tr class="memdesc:ga328bba22810a4467865b444d17bec8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to use for fetching vertex attributes.  <a href="#ga328bba22810a4467865b444d17bec8e9">[詳解]</a><br /></td></tr>
<tr class="separator:ga328bba22810a4467865b444d17bec8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae37fd304d3aa02d4773a74d2ce843b8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae37fd304d3aa02d4773a74d2ce843b8d">nvnCommandBufferBindVertexBuffers</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int first, int count, const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *buffers)</td></tr>
<tr class="memdesc:gae37fd304d3aa02d4773a74d2ce843b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object ranges to use for fetching vertex attributes.  <a href="#gae37fd304d3aa02d4773a74d2ce843b8d">[詳解]</a><br /></td></tr>
<tr class="separator:gae37fd304d3aa02d4773a74d2ce843b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8540a860937580eaa607cfa549667083"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8540a860937580eaa607cfa549667083">nvnCommandBufferBindVertexStreamState</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int numStreams, const <a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *streams)</td></tr>
<tr class="memdesc:ga8540a860937580eaa607cfa549667083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a vertex stream layout for subsequent commands.  <a href="#ga8540a860937580eaa607cfa549667083">[詳解]</a><br /></td></tr>
<tr class="separator:ga8540a860937580eaa607cfa549667083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa47b42c6deb95e59c6eae4c49645d4bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa47b42c6deb95e59c6eae4c49645d4bd">nvnCommandBufferCallCommands</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int numCommands, const <a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> *handles)</td></tr>
<tr class="memdesc:gaa47b42c6deb95e59c6eae4c49645d4bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert calls to previously recorded command sets into the command set under construction.  <a href="#gaa47b42c6deb95e59c6eae4c49645d4bd">[詳解]</a><br /></td></tr>
<tr class="separator:gaa47b42c6deb95e59c6eae4c49645d4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0d38dd93f857f1242072e0fc1d3aa05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab0d38dd93f857f1242072e0fc1d3aa05">nvnCommandBufferClearBuffer</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> dst, size_t size, uint32_t value)</td></tr>
<tr class="memdesc:gab0d38dd93f857f1242072e0fc1d3aa05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a buffer to a 32-bit integer value.  <a href="#gab0d38dd93f857f1242072e0fc1d3aa05">[詳解]</a><br /></td></tr>
<tr class="separator:gab0d38dd93f857f1242072e0fc1d3aa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab857894818dcd7f7a58d0358a9e44100"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab857894818dcd7f7a58d0358a9e44100">nvnCommandBufferClearColor</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int index, const float *color, int mask)</td></tr>
<tr class="memdesc:gab857894818dcd7f7a58d0358a9e44100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color buffer using floating-point clear color values.  <a href="#gab857894818dcd7f7a58d0358a9e44100">[詳解]</a><br /></td></tr>
<tr class="separator:gab857894818dcd7f7a58d0358a9e44100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7b84424af2bf2f2eb00730c8fb2f1dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae7b84424af2bf2f2eb00730c8fb2f1dd">nvnCommandBufferClearColori</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int index, const int *color, int mask)</td></tr>
<tr class="memdesc:gae7b84424af2bf2f2eb00730c8fb2f1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color buffer using signed integer clear color values.  <a href="#gae7b84424af2bf2f2eb00730c8fb2f1dd">[詳解]</a><br /></td></tr>
<tr class="separator:gae7b84424af2bf2f2eb00730c8fb2f1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e558a6f5a75f2ca927361818c65d1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad4e558a6f5a75f2ca927361818c65d1d">nvnCommandBufferClearColorui</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int index, const uint32_t *color, int mask)</td></tr>
<tr class="memdesc:gad4e558a6f5a75f2ca927361818c65d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color buffer using unsigned integer clear color values.  <a href="#gad4e558a6f5a75f2ca927361818c65d1d">[詳解]</a><br /></td></tr>
<tr class="separator:gad4e558a6f5a75f2ca927361818c65d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5f7adad6751d801a89cd1101253fa85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae5f7adad6751d801a89cd1101253fa85">nvnCommandBufferClearDepthStencil</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, float depthValue, NVNboolean depthMask, int stencilValue, int stencilMask)</td></tr>
<tr class="memdesc:gae5f7adad6751d801a89cd1101253fa85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a depth/stencil buffer.  <a href="#gae5f7adad6751d801a89cd1101253fa85">[詳解]</a><br /></td></tr>
<tr class="separator:gae5f7adad6751d801a89cd1101253fa85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad95f1a98899a4036008ac16e011bd2e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad95f1a98899a4036008ac16e011bd2e4">nvnCommandBufferClearTexture</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *dstTexture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *dstView, const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *dstRegion, const float *color, int mask)</td></tr>
<tr class="memdesc:gad95f1a98899a4036008ac16e011bd2e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color buffer using floating point clear color values.  <a href="#gad95f1a98899a4036008ac16e011bd2e4">[詳解]</a><br /></td></tr>
<tr class="separator:gad95f1a98899a4036008ac16e011bd2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga713cc9cb373ffda6953aa73511de626f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga713cc9cb373ffda6953aa73511de626f">nvnCommandBufferClearTexturei</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *dstTexture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *dstView, const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *dstRegion, const int *color, int mask)</td></tr>
<tr class="memdesc:ga713cc9cb373ffda6953aa73511de626f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color buffer using signed integer clear color values.  <a href="#ga713cc9cb373ffda6953aa73511de626f">[詳解]</a><br /></td></tr>
<tr class="separator:ga713cc9cb373ffda6953aa73511de626f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga608d429e488f09ead4879c28995767d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga608d429e488f09ead4879c28995767d9">nvnCommandBufferClearTextureui</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *dstTexture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *dstView, const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *dstRegion, const uint32_t *color, int mask)</td></tr>
<tr class="memdesc:ga608d429e488f09ead4879c28995767d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color buffer using unsigned integer clear color values.  <a href="#ga608d429e488f09ead4879c28995767d9">[詳解]</a><br /></td></tr>
<tr class="separator:ga608d429e488f09ead4879c28995767d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd877eff408eaf5795b2e6affa58d2c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafd877eff408eaf5795b2e6affa58d2c7">nvnCommandBufferCopyBufferToBuffer</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> src, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> dst, size_t size, int flags)</td></tr>
<tr class="memdesc:gafd877eff408eaf5795b2e6affa58d2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a copy of data from one <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object into another <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object.  <a href="#gafd877eff408eaf5795b2e6affa58d2c7">[詳解]</a><br /></td></tr>
<tr class="separator:gafd877eff408eaf5795b2e6affa58d2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8c77d09aa827fbbced85deecec671e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaaa8c77d09aa827fbbced85deecec671e">nvnCommandBufferCopyBufferToTexture</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> src, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *dstTexture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *dstView, const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *dstRegion, int flags)</td></tr>
<tr class="memdesc:gaaa8c77d09aa827fbbced85deecec671e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy texture data from buffer memory into a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#gaaa8c77d09aa827fbbced85deecec671e">[詳解]</a><br /></td></tr>
<tr class="separator:gaaa8c77d09aa827fbbced85deecec671e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe98746c7c6c6d0a0fef2e1b8d9381d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafe98746c7c6c6d0a0fef2e1b8d9381d8">nvnCommandBufferCopyCommands</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int numCommands, const <a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> *handles)</td></tr>
<tr class="memdesc:gafe98746c7c6c6d0a0fef2e1b8d9381d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert copies of previously recorded command sets into the command set under construction.  <a href="#gafe98746c7c6c6d0a0fef2e1b8d9381d8">[詳解]</a><br /></td></tr>
<tr class="separator:gafe98746c7c6c6d0a0fef2e1b8d9381d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga769cb5c27cfad2fd8bbe61b5277122af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga769cb5c27cfad2fd8bbe61b5277122af">nvnCommandBufferCopyTextureToBuffer</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *srcTexture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *srcView, const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *srcRegion, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> dst, int flags)</td></tr>
<tr class="memdesc:ga769cb5c27cfad2fd8bbe61b5277122af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy texture data from a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object into buffer memory.  <a href="#ga769cb5c27cfad2fd8bbe61b5277122af">[詳解]</a><br /></td></tr>
<tr class="separator:ga769cb5c27cfad2fd8bbe61b5277122af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7137adca4ad85a28917d01374c09219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf7137adca4ad85a28917d01374c09219">nvnCommandBufferCopyTextureToTexture</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *srcTexture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *srcView, const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *srcRegion, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *dstTexture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *dstView, const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *dstRegion, int flags)</td></tr>
<tr class="memdesc:gaf7137adca4ad85a28917d01374c09219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy texture data from a region of one <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object into a region of another <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#gaf7137adca4ad85a28917d01374c09219">[詳解]</a><br /></td></tr>
<tr class="separator:gaf7137adca4ad85a28917d01374c09219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae319235f09374fb2e5968d09cfbba7f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae319235f09374fb2e5968d09cfbba7f7">nvnCommandBufferDiscardColor</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int index)</td></tr>
<tr class="memdesc:gae319235f09374fb2e5968d09cfbba7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard the contents of the specified bound color render target.  <a href="#gae319235f09374fb2e5968d09cfbba7f7">[詳解]</a><br /></td></tr>
<tr class="separator:gae319235f09374fb2e5968d09cfbba7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga883170655ee34cb170ebe9475679c946"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga883170655ee34cb170ebe9475679c946">nvnCommandBufferDiscardDepthStencil</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga883170655ee34cb170ebe9475679c946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard the contents of the currently bound depth/stencil render target.  <a href="#ga883170655ee34cb170ebe9475679c946">[詳解]</a><br /></td></tr>
<tr class="separator:ga883170655ee34cb170ebe9475679c946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1e19b7700460afce5817b7c9d7bee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga32b1e19b7700460afce5817b7c9d7bee">nvnCommandBufferDispatchCompute</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int groupsX, int groupsY, int groupsZ)</td></tr>
<tr class="memdesc:ga32b1e19b7700460afce5817b7c9d7bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch a new grid of compute shader work groups for processing.  <a href="#ga32b1e19b7700460afce5817b7c9d7bee">[詳解]</a><br /></td></tr>
<tr class="separator:ga32b1e19b7700460afce5817b7c9d7bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa16fbe913a0dc193ff71d835abcf404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafa16fbe913a0dc193ff71d835abcf404">nvnCommandBufferDispatchComputeIndirect</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indirectBuffer)</td></tr>
<tr class="memdesc:gafa16fbe913a0dc193ff71d835abcf404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch a new grid of compute shader work groups for processing.  <a href="#gafa16fbe913a0dc193ff71d835abcf404">[詳解]</a><br /></td></tr>
<tr class="separator:gafa16fbe913a0dc193ff71d835abcf404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd85afea943735121bd9ce1755d65623"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gadd85afea943735121bd9ce1755d65623">nvnCommandBufferDownsample</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *src, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *dst)</td></tr>
<tr class="memdesc:gadd85afea943735121bd9ce1755d65623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a filtered version of a multisample source texture to produce a single-sample destination texture.  <a href="#gadd85afea943735121bd9ce1755d65623">[詳解]</a><br /></td></tr>
<tr class="separator:gadd85afea943735121bd9ce1755d65623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94e7b8993c4327a89c561af942a22388"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga94e7b8993c4327a89c561af942a22388">nvnCommandBufferDownsampleTextureView</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *src, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *srcView, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *dst, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *dstView)</td></tr>
<tr class="memdesc:ga94e7b8993c4327a89c561af942a22388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a filtered version of a multisample source texture and texture view to produce a single-sample destination texture through a texture view.  <a href="#ga94e7b8993c4327a89c561af942a22388">[詳解]</a><br /></td></tr>
<tr class="separator:ga94e7b8993c4327a89c561af942a22388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a1a1002239aa2f5f61e79308c99a84a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7a1a1002239aa2f5f61e79308c99a84a">nvnCommandBufferDrawArrays</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, int first, int count)</td></tr>
<tr class="memdesc:ga7a1a1002239aa2f5f61e79308c99a84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a primitive with consecutive vertex indices.  <a href="#ga7a1a1002239aa2f5f61e79308c99a84a">[詳解]</a><br /></td></tr>
<tr class="separator:ga7a1a1002239aa2f5f61e79308c99a84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7266e9a35bb52a07df08a09333b1e2e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7266e9a35bb52a07df08a09333b1e2e8">nvnCommandBufferDrawArraysIndirect</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indirectBuffer)</td></tr>
<tr class="memdesc:ga7266e9a35bb52a07df08a09333b1e2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render primitives with consecutive vertex indices, using draw parameters fetched from an indirect data buffer.  <a href="#ga7266e9a35bb52a07df08a09333b1e2e8">[詳解]</a><br /></td></tr>
<tr class="separator:ga7266e9a35bb52a07df08a09333b1e2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga990fb401259b83e26716733dd581d5d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga990fb401259b83e26716733dd581d5d8">nvnCommandBufferDrawArraysInstanced</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, int first, int count, int baseInstance, int instanceCount)</td></tr>
<tr class="memdesc:ga990fb401259b83e26716733dd581d5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render multiple copies (instances) of a primitive with consecutive vertex indices.  <a href="#ga990fb401259b83e26716733dd581d5d8">[詳解]</a><br /></td></tr>
<tr class="separator:ga990fb401259b83e26716733dd581d5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06f4d4765bf74d01809661766ac7df80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga06f4d4765bf74d01809661766ac7df80">nvnCommandBufferDrawElements</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, <a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a> type, int count, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indexBuffer)</td></tr>
<tr class="memdesc:ga06f4d4765bf74d01809661766ac7df80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a primitive with vertex indices fetched from an index buffer.  <a href="#ga06f4d4765bf74d01809661766ac7df80">[詳解]</a><br /></td></tr>
<tr class="separator:ga06f4d4765bf74d01809661766ac7df80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24c189bbc5765d6e8e7c862156417baf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga24c189bbc5765d6e8e7c862156417baf">nvnCommandBufferDrawElementsBaseVertex</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, <a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a> type, int count, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indexBuffer, int baseVertex)</td></tr>
<tr class="memdesc:ga24c189bbc5765d6e8e7c862156417baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a primitive with vertex indices fetched from an index buffer, with a base vertex value added to each fetched index.  <a href="#ga24c189bbc5765d6e8e7c862156417baf">[詳解]</a><br /></td></tr>
<tr class="separator:ga24c189bbc5765d6e8e7c862156417baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ea4fb762b38faa6bce7d27c075011e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0ea4fb762b38faa6bce7d27c075011e4">nvnCommandBufferDrawElementsIndirect</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, <a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a> type, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indexBuffer, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indirectBuffer)</td></tr>
<tr class="memdesc:ga0ea4fb762b38faa6bce7d27c075011e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render primitives with vertex indices fetched from an index buffer, using draw parameters fetched from an indirect data buffer.  <a href="#ga0ea4fb762b38faa6bce7d27c075011e4">[詳解]</a><br /></td></tr>
<tr class="separator:ga0ea4fb762b38faa6bce7d27c075011e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe27aeb078f485947d4c4454182c8fde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabe27aeb078f485947d4c4454182c8fde">nvnCommandBufferDrawElementsInstanced</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, <a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a> type, int count, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indexBuffer, int baseVertex, int baseInstance, int instanceCount)</td></tr>
<tr class="memdesc:gabe27aeb078f485947d4c4454182c8fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render multiple copies (instances) of a primitive with vertex indices fetched from an index buffer.  <a href="#gabe27aeb078f485947d4c4454182c8fde">[詳解]</a><br /></td></tr>
<tr class="separator:gabe27aeb078f485947d4c4454182c8fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95fc32406d14d9b4674ffc3dba52e465"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga95fc32406d14d9b4674ffc3dba52e465">nvnCommandBufferDrawTexture</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a> texture, const <a class="el" href="struct_n_v_ndraw_texture_region.html">NVNdrawTextureRegion</a> *dstRegion, const <a class="el" href="struct_n_v_ndraw_texture_region.html">NVNdrawTextureRegion</a> *srcRegion)</td></tr>
<tr class="memdesc:ga95fc32406d14d9b4674ffc3dba52e465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an on-screen rectangle displaying the contents of a provided texture.  <a href="#ga95fc32406d14d9b4674ffc3dba52e465">[詳解]</a><br /></td></tr>
<tr class="separator:ga95fc32406d14d9b4674ffc3dba52e465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c7d4cceeb20e66d10503c868a05a99d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0c7d4cceeb20e66d10503c868a05a99d">nvnCommandBufferDrawTransformFeedback</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer)</td></tr>
<tr class="memdesc:ga0c7d4cceeb20e66d10503c868a05a99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw primitives captured in a previous transform feedback (stream output) operation.  <a href="#ga0c7d4cceeb20e66d10503c868a05a99d">[詳解]</a><br /></td></tr>
<tr class="separator:ga0c7d4cceeb20e66d10503c868a05a99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d97d4cbf72259b6e867f3080f223b95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7d97d4cbf72259b6e867f3080f223b95">nvnCommandBufferEndRecording</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga7d97d4cbf72259b6e867f3080f223b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete recording a new set of commands in this <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object.  <a href="#ga7d97d4cbf72259b6e867f3080f223b95">[詳解]</a><br /></td></tr>
<tr class="separator:ga7d97d4cbf72259b6e867f3080f223b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1f8deb2cc863867218ce25789684809"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa1f8deb2cc863867218ce25789684809">nvnCommandBufferEndTransformFeedback</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer)</td></tr>
<tr class="memdesc:gaa1f8deb2cc863867218ce25789684809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete a transform feedback (stream output) operation.  <a href="#gaa1f8deb2cc863867218ce25789684809">[詳解]</a><br /></td></tr>
<tr class="separator:gaa1f8deb2cc863867218ce25789684809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7649fa38fde42a6fc9ec32b1133d5528"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7649fa38fde42a6fc9ec32b1133d5528">nvnCommandBufferFenceSync</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *sync, <a class="el" href="group__nvn__c__enum.html#ga6ab26a343b68da722799167ea97ec69d">NVNsyncCondition</a> condition, int flags)</td></tr>
<tr class="memdesc:ga7649fa38fde42a6fc9ec32b1133d5528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object as signaled when all previous commands have completed in the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object.  <a href="#ga7649fa38fde42a6fc9ec32b1133d5528">[詳解]</a><br /></td></tr>
<tr class="separator:ga7649fa38fde42a6fc9ec32b1133d5528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga014c41d2335d4d9ff6c776c99bc70bfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga014c41d2335d4d9ff6c776c99bc70bfb">nvnCommandBufferFinalize</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga014c41d2335d4d9ff6c776c99bc70bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object.  <a href="#ga014c41d2335d4d9ff6c776c99bc70bfb">[詳解]</a><br /></td></tr>
<tr class="separator:ga014c41d2335d4d9ff6c776c99bc70bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211e559b84b562b34d26b809a9316ff2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga211e559b84b562b34d26b809a9316ff2">nvnCommandBufferGetCommandMemoryFree</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga211e559b84b562b34d26b809a9316ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the amount of free command memory in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object.  <a href="#ga211e559b84b562b34d26b809a9316ff2">[詳解]</a><br /></td></tr>
<tr class="separator:ga211e559b84b562b34d26b809a9316ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c33bb9cd401c44be336bdcb915d9e70"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7c33bb9cd401c44be336bdcb915d9e70">nvnCommandBufferGetCommandMemorySize</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga7c33bb9cd401c44be336bdcb915d9e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total amount of command memory programmed in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object.  <a href="#ga7c33bb9cd401c44be336bdcb915d9e70">[詳解]</a><br /></td></tr>
<tr class="separator:ga7c33bb9cd401c44be336bdcb915d9e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7976af012dd82485da7127beca93e2ff"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7976af012dd82485da7127beca93e2ff">nvnCommandBufferGetCommandMemoryUsed</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga7976af012dd82485da7127beca93e2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the amount of command memory used in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object.  <a href="#ga7976af012dd82485da7127beca93e2ff">[詳解]</a><br /></td></tr>
<tr class="separator:ga7976af012dd82485da7127beca93e2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fe9b2e839389d1a7396b54edb86ca77"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3fe9b2e839389d1a7396b54edb86ca77">nvnCommandBufferGetControlMemoryFree</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga3fe9b2e839389d1a7396b54edb86ca77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the amount of free control memory in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object.  <a href="#ga3fe9b2e839389d1a7396b54edb86ca77">[詳解]</a><br /></td></tr>
<tr class="separator:ga3fe9b2e839389d1a7396b54edb86ca77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c82ac4fededbf48d55179b57248de7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga93c82ac4fededbf48d55179b57248de7">nvnCommandBufferGetControlMemorySize</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga93c82ac4fededbf48d55179b57248de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total amount of control memory programmed in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object.  <a href="#ga93c82ac4fededbf48d55179b57248de7">[詳解]</a><br /></td></tr>
<tr class="separator:ga93c82ac4fededbf48d55179b57248de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef36338c2d889d846bf1fbbe3efd25df"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaef36338c2d889d846bf1fbbe3efd25df">nvnCommandBufferGetControlMemoryUsed</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:gaef36338c2d889d846bf1fbbe3efd25df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the amount of control memory used in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object.  <a href="#gaef36338c2d889d846bf1fbbe3efd25df">[詳解]</a><br /></td></tr>
<tr class="separator:gaef36338c2d889d846bf1fbbe3efd25df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e2b27a9a418f0eb48b0675c47809b4"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga72e2b27a9a418f0eb48b0675c47809b4">nvnCommandBufferGetCopyImageStride</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga72e2b27a9a418f0eb48b0675c47809b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current copy image stride stored in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object.  <a href="#ga72e2b27a9a418f0eb48b0675c47809b4">[詳解]</a><br /></td></tr>
<tr class="separator:ga72e2b27a9a418f0eb48b0675c47809b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca29ca51ef0664b03280efdcc1e36323"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaca29ca51ef0664b03280efdcc1e36323">nvnCommandBufferGetCopyRowStride</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:gaca29ca51ef0664b03280efdcc1e36323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current copy row stride stored in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object.  <a href="#gaca29ca51ef0664b03280efdcc1e36323">[詳解]</a><br /></td></tr>
<tr class="separator:gaca29ca51ef0664b03280efdcc1e36323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b241dbc3db41646a27cf4fe10ef3538"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__funcptrs.html#gab918942b035dac79abd29dfb506823d9">PFNNVNCOMMANDBUFFERMEMORYCALLBACKPROC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1b241dbc3db41646a27cf4fe10ef3538">nvnCommandBufferGetMemoryCallback</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga1b241dbc3db41646a27cf4fe10ef3538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a callback function for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object that will be called if it runs out of memory.  <a href="#ga1b241dbc3db41646a27cf4fe10ef3538">[詳解]</a><br /></td></tr>
<tr class="separator:ga1b241dbc3db41646a27cf4fe10ef3538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf726c18072c4b8ece85794276cfd991"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaaf726c18072c4b8ece85794276cfd991">nvnCommandBufferGetMemoryCallbackData</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:gaaf726c18072c4b8ece85794276cfd991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a generic pointer that will be passed to a callback function if the command buffer runs out of memory.  <a href="#gaaf726c18072c4b8ece85794276cfd991">[詳解]</a><br /></td></tr>
<tr class="separator:gaaf726c18072c4b8ece85794276cfd991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab146b70a699dfee69d0724e430d5694e"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab146b70a699dfee69d0724e430d5694e">nvnCommandBufferInitialize</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:gab146b70a699dfee69d0724e430d5694e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object for the specified device.  <a href="#gab146b70a699dfee69d0724e430d5694e">[詳解]</a><br /></td></tr>
<tr class="separator:gab146b70a699dfee69d0724e430d5694e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d91848e0c99bad0ca343ba3710278e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4d91848e0c99bad0ca343ba3710278e0">nvnCommandBufferInsertDebugMarker</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const char *description)</td></tr>
<tr class="memdesc:ga4d91848e0c99bad0ca343ba3710278e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a debug event marker to the command stream.  <a href="#ga4d91848e0c99bad0ca343ba3710278e0">[詳解]</a><br /></td></tr>
<tr class="separator:ga4d91848e0c99bad0ca343ba3710278e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c7249b1f6594352ac6ab0acb35703a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5c7249b1f6594352ac6ab0acb35703a5">nvnCommandBufferInsertDebugMarkerDynamic</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, uint32_t domainId, const char *description)</td></tr>
<tr class="memdesc:ga5c7249b1f6594352ac6ab0acb35703a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a debug event marker to the command stream.  <a href="#ga5c7249b1f6594352ac6ab0acb35703a5">[詳解]</a><br /></td></tr>
<tr class="separator:ga5c7249b1f6594352ac6ab0acb35703a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68f148606bec51c995b3b86f851c5b09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga68f148606bec51c995b3b86f851c5b09">nvnCommandBufferInsertDebugMarkerStatic</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, uint32_t domainId, const char *description)</td></tr>
<tr class="memdesc:ga68f148606bec51c995b3b86f851c5b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a debug event marker to the command stream.  <a href="#ga68f148606bec51c995b3b86f851c5b09">[詳解]</a><br /></td></tr>
<tr class="separator:ga68f148606bec51c995b3b86f851c5b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0790bc37a5893867aa5258dfbfe7923"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf0790bc37a5893867aa5258dfbfe7923">nvnCommandBufferIsRecording</a> (const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:gaf0790bc37a5893867aa5258dfbfe7923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the command buffer is currently recording.  <a href="#gaf0790bc37a5893867aa5258dfbfe7923">[詳解]</a><br /></td></tr>
<tr class="separator:gaf0790bc37a5893867aa5258dfbfe7923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06413e93f9e3d29a45fa878540947a8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga06413e93f9e3d29a45fa878540947a8f">nvnCommandBufferMultiDrawArraysIndirectCount</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indirectBuffer, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> parameterBuffer, int maxDrawCount, ptrdiff_t stride)</td></tr>
<tr class="memdesc:ga06413e93f9e3d29a45fa878540947a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render multiple primitives with vertices fetched from a vertex buffer, using draw parameters fetched from an indirect data buffer and the number of primitives fetched from a parameter buffer.  <a href="#ga06413e93f9e3d29a45fa878540947a8f">[詳解]</a><br /></td></tr>
<tr class="separator:ga06413e93f9e3d29a45fa878540947a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga181160adcfe4ed4870196d02ff457a72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga181160adcfe4ed4870196d02ff457a72">nvnCommandBufferMultiDrawElementsIndirectCount</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a> mode, <a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a> type, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indexBuffer, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> indirectBuffer, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> parameterBuffer, int maxDrawCount, ptrdiff_t stride)</td></tr>
<tr class="memdesc:ga181160adcfe4ed4870196d02ff457a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render multiple primitives with vertex indices fetched from an index buffer, using draw parameters fetched from an indirect data buffer and the number of primitives fetched from a parameter buffer.  <a href="#ga181160adcfe4ed4870196d02ff457a72">[詳解]</a><br /></td></tr>
<tr class="separator:ga181160adcfe4ed4870196d02ff457a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36606b1759b3b79a8844de9ff4072b49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga36606b1759b3b79a8844de9ff4072b49">nvnCommandBufferPauseTransformFeedback</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer)</td></tr>
<tr class="memdesc:ga36606b1759b3b79a8844de9ff4072b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause a transform feedback (stream output) operation.  <a href="#ga36606b1759b3b79a8844de9ff4072b49">[詳解]</a><br /></td></tr>
<tr class="separator:ga36606b1759b3b79a8844de9ff4072b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e093d931066afbd07f7dc62f728a1d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9e093d931066afbd07f7dc62f728a1d3">nvnCommandBufferPopDebugGroup</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga9e093d931066afbd07f7dc62f728a1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the active debug group off the command stream.  <a href="#ga9e093d931066afbd07f7dc62f728a1d3">[詳解]</a><br /></td></tr>
<tr class="separator:ga9e093d931066afbd07f7dc62f728a1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9a3654de302a8d7725d78a793f47571"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab9a3654de302a8d7725d78a793f47571">nvnCommandBufferPopDebugGroupId</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, uint32_t domainId)</td></tr>
<tr class="memdesc:gab9a3654de302a8d7725d78a793f47571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the active debug group off the command stream.  <a href="#gab9a3654de302a8d7725d78a793f47571">[詳解]</a><br /></td></tr>
<tr class="separator:gab9a3654de302a8d7725d78a793f47571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac328ee49a5aecdaf097da8d156837955"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac328ee49a5aecdaf097da8d156837955">nvnCommandBufferPushDebugGroup</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const char *description)</td></tr>
<tr class="memdesc:gac328ee49a5aecdaf097da8d156837955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a debug group into the command stream.  <a href="#gac328ee49a5aecdaf097da8d156837955">[詳解]</a><br /></td></tr>
<tr class="separator:gac328ee49a5aecdaf097da8d156837955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4877bd1b7b58d555d274260de7bae4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf4877bd1b7b58d555d274260de7bae4a">nvnCommandBufferPushDebugGroupDynamic</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, uint32_t domainId, const char *description)</td></tr>
<tr class="memdesc:gaf4877bd1b7b58d555d274260de7bae4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a debug group into the command stream.  <a href="#gaf4877bd1b7b58d555d274260de7bae4a">[詳解]</a><br /></td></tr>
<tr class="separator:gaf4877bd1b7b58d555d274260de7bae4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54bb644ef7005a664579254b47587c93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga54bb644ef7005a664579254b47587c93">nvnCommandBufferPushDebugGroupStatic</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, uint32_t domainId, const char *description)</td></tr>
<tr class="memdesc:ga54bb644ef7005a664579254b47587c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a debug group into the command stream.  <a href="#ga54bb644ef7005a664579254b47587c93">[詳解]</a><br /></td></tr>
<tr class="separator:ga54bb644ef7005a664579254b47587c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade6b81268dfab6d9e22de06bbd170951"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gade6b81268dfab6d9e22de06bbd170951">nvnCommandBufferReportCounter</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#ga280033bdac9f8e19de62817c8d200773">NVNcounterType</a> counter, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer)</td></tr>
<tr class="memdesc:gade6b81268dfab6d9e22de06bbd170951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a GPU counter and timestamp into buffer object memory.  <a href="#gade6b81268dfab6d9e22de06bbd170951">[詳解]</a><br /></td></tr>
<tr class="separator:gade6b81268dfab6d9e22de06bbd170951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9642c6dc30a8a0f71464a7de155c0f2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9642c6dc30a8a0f71464a7de155c0f2e">nvnCommandBufferReportValue</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, uint32_t value, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer)</td></tr>
<tr class="memdesc:ga9642c6dc30a8a0f71464a7de155c0f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a GPU counter report and timestamp into buffer object memory using an application-provided value.  <a href="#ga9642c6dc30a8a0f71464a7de155c0f2e">[詳解]</a><br /></td></tr>
<tr class="separator:ga9642c6dc30a8a0f71464a7de155c0f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49ee8eb6d0cecd901d9de38d983ceb1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga49ee8eb6d0cecd901d9de38d983ceb1a">nvnCommandBufferResetCounter</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#ga280033bdac9f8e19de62817c8d200773">NVNcounterType</a> counter)</td></tr>
<tr class="memdesc:ga49ee8eb6d0cecd901d9de38d983ceb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a GPU counter to zero.  <a href="#ga49ee8eb6d0cecd901d9de38d983ceb1a">[詳解]</a><br /></td></tr>
<tr class="separator:ga49ee8eb6d0cecd901d9de38d983ceb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f474458657c1fea18b88dd48777b581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2f474458657c1fea18b88dd48777b581">nvnCommandBufferResolveDepthBuffer</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf)</td></tr>
<tr class="memdesc:ga2f474458657c1fea18b88dd48777b581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve depth values in a compressible depth render target.  <a href="#ga2f474458657c1fea18b88dd48777b581">[詳解]</a><br /></td></tr>
<tr class="separator:ga2f474458657c1fea18b88dd48777b581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6f7056d3e1f5a0c04ebfb301bf26a22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad6f7056d3e1f5a0c04ebfb301bf26a22">nvnCommandBufferRestoreZCullData</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> src, size_t size)</td></tr>
<tr class="memdesc:gad6f7056d3e1f5a0c04ebfb301bf26a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the current ZCull state to use saved state from a previous render target.  <a href="#gad6f7056d3e1f5a0c04ebfb301bf26a22">[詳解]</a><br /></td></tr>
<tr class="separator:gad6f7056d3e1f5a0c04ebfb301bf26a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ad2246e89cf77b1a4cf41c38ff43527"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3ad2246e89cf77b1a4cf41c38ff43527">nvnCommandBufferResumeTransformFeedback</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer)</td></tr>
<tr class="memdesc:ga3ad2246e89cf77b1a4cf41c38ff43527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a transform feedback (stream output) operation.  <a href="#ga3ad2246e89cf77b1a4cf41c38ff43527">[詳解]</a><br /></td></tr>
<tr class="separator:ga3ad2246e89cf77b1a4cf41c38ff43527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf22d0bc677beea73eac74721ddfb325"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaaf22d0bc677beea73eac74721ddfb325">nvnCommandBufferSaveZCullData</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> dst, size_t size)</td></tr>
<tr class="memdesc:gaaf22d0bc677beea73eac74721ddfb325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the current ZCull state for the current depth render target.  <a href="#gaaf22d0bc677beea73eac74721ddfb325">[詳解]</a><br /></td></tr>
<tr class="separator:gaaf22d0bc677beea73eac74721ddfb325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab298722737de06614902b5e15ffadea6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab298722737de06614902b5e15ffadea6">nvnCommandBufferSetAlphaRef</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, float ref)</td></tr>
<tr class="memdesc:gab298722737de06614902b5e15ffadea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a reference value to use for alpha testing.  <a href="#gab298722737de06614902b5e15ffadea6">[詳解]</a><br /></td></tr>
<tr class="separator:gab298722737de06614902b5e15ffadea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae80cb65cbc04a34f6892023d529526f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae80cb65cbc04a34f6892023d529526f7">nvnCommandBufferSetBlendColor</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const float *blendColor)</td></tr>
<tr class="memdesc:gae80cb65cbc04a34f6892023d529526f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a constant color that may be used by blending functions.  <a href="#gae80cb65cbc04a34f6892023d529526f7">[詳解]</a><br /></td></tr>
<tr class="separator:gae80cb65cbc04a34f6892023d529526f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41c02cd9b5c931fd6b233b48ca245daa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga41c02cd9b5c931fd6b233b48ca245daa">nvnCommandBufferSetColorReductionEnable</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, NVNboolean enable)</td></tr>
<tr class="memdesc:ga41c02cd9b5c931fd6b233b48ca245daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable color reduction.  <a href="#ga41c02cd9b5c931fd6b233b48ca245daa">[詳解]</a><br /></td></tr>
<tr class="separator:ga41c02cd9b5c931fd6b233b48ca245daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75a746908aa8a2688d6269f5441bf758"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga75a746908aa8a2688d6269f5441bf758">nvnCommandBufferSetColorReductionThresholds</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gac983c7ec7de25e7b97dacc14b163b5a5">NVNformatClass</a> formatClass, int thresholdConservative, int thresholdAggressive)</td></tr>
<tr class="memdesc:ga75a746908aa8a2688d6269f5441bf758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify new color reduction thresholds for a format class.  <a href="#ga75a746908aa8a2688d6269f5441bf758">[詳解]</a><br /></td></tr>
<tr class="separator:ga75a746908aa8a2688d6269f5441bf758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaced655069ef6e505fddd493fb0d33606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaced655069ef6e505fddd493fb0d33606">nvnCommandBufferSetConservativeRasterDilate</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, float dilate)</td></tr>
<tr class="memdesc:gaced655069ef6e505fddd493fb0d33606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the degree of primitive dilation when conservative rasterization is enabled.  <a href="#gaced655069ef6e505fddd493fb0d33606">[詳解]</a><br /></td></tr>
<tr class="separator:gaced655069ef6e505fddd493fb0d33606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e231e88d224fc168ca94e22252be6e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1e231e88d224fc168ca94e22252be6e3">nvnCommandBufferSetConservativeRasterEnable</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, NVNboolean enable)</td></tr>
<tr class="memdesc:ga1e231e88d224fc168ca94e22252be6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable conservative rasterization of rendered primitives.  <a href="#ga1e231e88d224fc168ca94e22252be6e3">[詳解]</a><br /></td></tr>
<tr class="separator:ga1e231e88d224fc168ca94e22252be6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58fb857e055afc2512209f671e3d89ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga58fb857e055afc2512209f671e3d89ca">nvnCommandBufferSetCopyImageStride</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, ptrdiff_t stride)</td></tr>
<tr class="memdesc:ga58fb857e055afc2512209f671e3d89ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the image stride used for copies between buffer and texture memory.  <a href="#ga58fb857e055afc2512209f671e3d89ca">[詳解]</a><br /></td></tr>
<tr class="separator:ga58fb857e055afc2512209f671e3d89ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6face2746fa0f109f61ba3d3b349fb9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6face2746fa0f109f61ba3d3b349fb9f">nvnCommandBufferSetCopyRowStride</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, ptrdiff_t stride)</td></tr>
<tr class="memdesc:ga6face2746fa0f109f61ba3d3b349fb9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the row stride used for copies between buffer and texture memory.  <a href="#ga6face2746fa0f109f61ba3d3b349fb9f">[詳解]</a><br /></td></tr>
<tr class="separator:ga6face2746fa0f109f61ba3d3b349fb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ecae66d8ac5f623d7a1abae492fc243"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3ecae66d8ac5f623d7a1abae492fc243">nvnCommandBufferSetDebugLabel</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const char *label)</td></tr>
<tr class="memdesc:ga3ecae66d8ac5f623d7a1abae492fc243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object.  <a href="#ga3ecae66d8ac5f623d7a1abae492fc243">[詳解]</a><br /></td></tr>
<tr class="separator:ga3ecae66d8ac5f623d7a1abae492fc243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b174a2678de189471d5466ca2bfd4d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4b174a2678de189471d5466ca2bfd4d3">nvnCommandBufferSetDepthBounds</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, NVNboolean enable, float n, float f)</td></tr>
<tr class="memdesc:ga4b174a2678de189471d5466ca2bfd4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the operation of the depth bounds test.  <a href="#ga4b174a2678de189471d5466ca2bfd4d3">[詳解]</a><br /></td></tr>
<tr class="separator:ga4b174a2678de189471d5466ca2bfd4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ddab005c7a86e3b0b29a62932893cb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5ddab005c7a86e3b0b29a62932893cb4">nvnCommandBufferSetDepthClamp</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, NVNboolean clamp)</td></tr>
<tr class="memdesc:ga5ddab005c7a86e3b0b29a62932893cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable depth clamping of rendered primitives.  <a href="#ga5ddab005c7a86e3b0b29a62932893cb4">[詳解]</a><br /></td></tr>
<tr class="separator:ga5ddab005c7a86e3b0b29a62932893cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82e8dc14164ab8018898a76e07e6e86a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga82e8dc14164ab8018898a76e07e6e86a">nvnCommandBufferSetDepthRange</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, float n, float f)</td></tr>
<tr class="memdesc:ga82e8dc14164ab8018898a76e07e6e86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the range of depth values for rendered primitives.  <a href="#ga82e8dc14164ab8018898a76e07e6e86a">[詳解]</a><br /></td></tr>
<tr class="separator:ga82e8dc14164ab8018898a76e07e6e86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d653ea55400bfbb48101628878f782"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga72d653ea55400bfbb48101628878f782">nvnCommandBufferSetDepthRanges</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int first, int count, const float *ranges)</td></tr>
<tr class="memdesc:ga72d653ea55400bfbb48101628878f782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets multiple ranges of depth values for rendered primitives.  <a href="#ga72d653ea55400bfbb48101628878f782">[詳解]</a><br /></td></tr>
<tr class="separator:ga72d653ea55400bfbb48101628878f782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69c2614e24b04c147e05abf5e4bf6757"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga69c2614e24b04c147e05abf5e4bf6757">nvnCommandBufferSetInnerTessellationLevels</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const float *levels)</td></tr>
<tr class="memdesc:ga69c2614e24b04c147e05abf5e4bf6757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify default inner tessellation levels when rendering patch primitives.  <a href="#ga69c2614e24b04c147e05abf5e4bf6757">[詳解]</a><br /></td></tr>
<tr class="separator:ga69c2614e24b04c147e05abf5e4bf6757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb4bb0bdb2ac78ee60e2e3e5138ce22e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafb4bb0bdb2ac78ee60e2e3e5138ce22e">nvnCommandBufferSetLineWidth</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, float lineWidth)</td></tr>
<tr class="memdesc:gafb4bb0bdb2ac78ee60e2e3e5138ce22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the width (in pixels) of line primitives to render.  <a href="#gafb4bb0bdb2ac78ee60e2e3e5138ce22e">[詳解]</a><br /></td></tr>
<tr class="separator:gafb4bb0bdb2ac78ee60e2e3e5138ce22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69eb92c349d648988d02b9b7a7a94a75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga69eb92c349d648988d02b9b7a7a94a75">nvnCommandBufferSetMemoryCallback</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__funcptrs.html#gab918942b035dac79abd29dfb506823d9">PFNNVNCOMMANDBUFFERMEMORYCALLBACKPROC</a> callback)</td></tr>
<tr class="memdesc:ga69eb92c349d648988d02b9b7a7a94a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a callback function for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object that will be called if it runs out of memory.  <a href="#ga69eb92c349d648988d02b9b7a7a94a75">[詳解]</a><br /></td></tr>
<tr class="separator:ga69eb92c349d648988d02b9b7a7a94a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8656f3468c263124963216458569ec07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8656f3468c263124963216458569ec07">nvnCommandBufferSetMemoryCallbackData</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, void *callbackData)</td></tr>
<tr class="memdesc:ga8656f3468c263124963216458569ec07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a generic pointer that will be passed to a callback function if the command buffer runs out of memory.  <a href="#ga8656f3468c263124963216458569ec07">[詳解]</a><br /></td></tr>
<tr class="separator:ga8656f3468c263124963216458569ec07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48be9a09e423781b7c466c3b1516daef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga48be9a09e423781b7c466c3b1516daef">nvnCommandBufferSetOuterTessellationLevels</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const float *levels)</td></tr>
<tr class="memdesc:ga48be9a09e423781b7c466c3b1516daef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify default outer tessellation levels when rendering patch primitives.  <a href="#ga48be9a09e423781b7c466c3b1516daef">[詳解]</a><br /></td></tr>
<tr class="separator:ga48be9a09e423781b7c466c3b1516daef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0030496de8749dee42285b464f59f066"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0030496de8749dee42285b464f59f066">nvnCommandBufferSetPatchSize</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int size)</td></tr>
<tr class="memdesc:ga0030496de8749dee42285b464f59f066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the number of vertices in each patch when rendering patch primitives.  <a href="#ga0030496de8749dee42285b464f59f066">[詳解]</a><br /></td></tr>
<tr class="separator:ga0030496de8749dee42285b464f59f066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3a20e6577e2780cf1de7487730a2086"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf3a20e6577e2780cf1de7487730a2086">nvnCommandBufferSetPointSize</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, float pointSize)</td></tr>
<tr class="memdesc:gaf3a20e6577e2780cf1de7487730a2086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the size (in pixels) of point primitives to render.  <a href="#gaf3a20e6577e2780cf1de7487730a2086">[詳解]</a><br /></td></tr>
<tr class="separator:gaf3a20e6577e2780cf1de7487730a2086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81867da9e1301f27904dae46435c931b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga81867da9e1301f27904dae46435c931b">nvnCommandBufferSetPolygonOffsetClamp</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, float factor, float units, float clamp)</td></tr>
<tr class="memdesc:ga81867da9e1301f27904dae46435c931b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies values used to compute a depth offset value when polygon offset is enabled.  <a href="#ga81867da9e1301f27904dae46435c931b">[詳解]</a><br /></td></tr>
<tr class="separator:ga81867da9e1301f27904dae46435c931b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fe0e7f03b40e90dc870c706d6432d8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9fe0e7f03b40e90dc870c706d6432d8f">nvnCommandBufferSetPrimitiveRestart</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, NVNboolean enable, int index)</td></tr>
<tr class="memdesc:ga9fe0e7f03b40e90dc870c706d6432d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable and disable primitive restart and specify a primitive restart index.  <a href="#ga9fe0e7f03b40e90dc870c706d6432d8f">[詳解]</a><br /></td></tr>
<tr class="separator:ga9fe0e7f03b40e90dc870c706d6432d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b099e33e61c1f1f74d4b827c1751f00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8b099e33e61c1f1f74d4b827c1751f00">nvnCommandBufferSetProgramSubroutines</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *program, <a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a> stage, const int first, const int count, const int *values)</td></tr>
<tr class="memdesc:ga8b099e33e61c1f1f74d4b827c1751f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the subroutine uniform parameters.  <a href="#ga8b099e33e61c1f1f74d4b827c1751f00">[詳解]</a><br /></td></tr>
<tr class="separator:ga8b099e33e61c1f1f74d4b827c1751f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacff1db19e51d3dec85a952263345dcff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacff1db19e51d3dec85a952263345dcff">nvnCommandBufferSetRasterizerDiscard</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, NVNboolean discard)</td></tr>
<tr class="memdesc:gacff1db19e51d3dec85a952263345dcff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable rasterizer discard.  <a href="#gacff1db19e51d3dec85a952263345dcff">[詳解]</a><br /></td></tr>
<tr class="separator:gacff1db19e51d3dec85a952263345dcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada2e0273010f55fc9c3a44e57320a0d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gada2e0273010f55fc9c3a44e57320a0d2">nvnCommandBufferSetRenderEnable</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, NVNboolean enable)</td></tr>
<tr class="memdesc:gada2e0273010f55fc9c3a44e57320a0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the render enable for a queue.  <a href="#gada2e0273010f55fc9c3a44e57320a0d2">[詳解]</a><br /></td></tr>
<tr class="separator:gada2e0273010f55fc9c3a44e57320a0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa29e43ea6dbe7c77ea050ae7ae95758c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa29e43ea6dbe7c77ea050ae7ae95758c">nvnCommandBufferSetRenderEnableConditional</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gae555b5b8ce83bd8c76b77f40481adc8b">NVNconditionalRenderMode</a> mode, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> counters)</td></tr>
<tr class="memdesc:gaa29e43ea6dbe7c77ea050ae7ae95758c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables rendering for a queue, depending on the equality of counters.  <a href="#gaa29e43ea6dbe7c77ea050ae7ae95758c">[詳解]</a><br /></td></tr>
<tr class="separator:gaa29e43ea6dbe7c77ea050ae7ae95758c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3e9cdfa2eaad5ed0f5363598fa0ce7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae3e9cdfa2eaad5ed0f5363598fa0ce7c">nvnCommandBufferSetRenderTargets</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int numColors, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *const *colors, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *const *colorViews, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *depthStencil, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *depthStencilView)</td></tr>
<tr class="memdesc:gae3e9cdfa2eaad5ed0f5363598fa0ce7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets color and depth/stencil textures in the framebuffer.  <a href="#gae3e9cdfa2eaad5ed0f5363598fa0ce7c">[詳解]</a><br /></td></tr>
<tr class="separator:gae3e9cdfa2eaad5ed0f5363598fa0ce7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcba5a3b987a3f421ca0566a48dbf62e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gadcba5a3b987a3f421ca0566a48dbf62e">nvnCommandBufferSetSampleMask</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int mask)</td></tr>
<tr class="memdesc:gadcba5a3b987a3f421ca0566a48dbf62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a mask of samples that may be covered by rendered primitives.  <a href="#gadcba5a3b987a3f421ca0566a48dbf62e">[詳解]</a><br /></td></tr>
<tr class="separator:gadcba5a3b987a3f421ca0566a48dbf62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71cd4e0a83ae73c92c76333d3adc6212"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga71cd4e0a83ae73c92c76333d3adc6212">nvnCommandBufferSetSamplerPool</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *samplerPool)</td></tr>
<tr class="memdesc:ga71cd4e0a83ae73c92c76333d3adc6212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new sampler pool used for subsequent rendering operations.  <a href="#ga71cd4e0a83ae73c92c76333d3adc6212">[詳解]</a><br /></td></tr>
<tr class="separator:ga71cd4e0a83ae73c92c76333d3adc6212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6c38cac9330ae402f2f911d1e1aa757"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac6c38cac9330ae402f2f911d1e1aa757">nvnCommandBufferSetScissor</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int x, int y, int w, int h)</td></tr>
<tr class="memdesc:gac6c38cac9330ae402f2f911d1e1aa757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the scissor rectangle used for clipping primitives and clears.  <a href="#gac6c38cac9330ae402f2f911d1e1aa757">[詳解]</a><br /></td></tr>
<tr class="separator:gac6c38cac9330ae402f2f911d1e1aa757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51fff8146007887cfd821c3e82dc11f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga51fff8146007887cfd821c3e82dc11f3">nvnCommandBufferSetScissors</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int first, int count, const int *rects)</td></tr>
<tr class="memdesc:ga51fff8146007887cfd821c3e82dc11f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify one or more scissor rectangles.  <a href="#ga51fff8146007887cfd821c3e82dc11f3">[詳解]</a><br /></td></tr>
<tr class="separator:ga51fff8146007887cfd821c3e82dc11f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafccbb352a6e0b28138c1a1e727fc1f83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafccbb352a6e0b28138c1a1e727fc1f83">nvnCommandBufferSetShaderScratchMemory</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, ptrdiff_t offset, size_t size)</td></tr>
<tr class="memdesc:gafccbb352a6e0b28138c1a1e727fc1f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify scratch memory required for shader execution.  <a href="#gafccbb352a6e0b28138c1a1e727fc1f83">[詳解]</a><br /></td></tr>
<tr class="separator:gafccbb352a6e0b28138c1a1e727fc1f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fdbe92539c8703c2e92cec46a3ce654"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3fdbe92539c8703c2e92cec46a3ce654">nvnCommandBufferSetStencilCullCriteria</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gab50861ff9b46503782bb66c4edb734ae">NVNstencilFunc</a> func, int ref, int mask)</td></tr>
<tr class="memdesc:ga3fdbe92539c8703c2e92cec46a3ce654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the criteria that is used by the ZCull HW for stencil culling.  <a href="#ga3fdbe92539c8703c2e92cec46a3ce654">[詳解]</a><br /></td></tr>
<tr class="separator:ga3fdbe92539c8703c2e92cec46a3ce654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f084072b85bde09e40e4920fce1be65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5f084072b85bde09e40e4920fce1be65">nvnCommandBufferSetStencilMask</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a> faces, int mask)</td></tr>
<tr class="memdesc:ga5f084072b85bde09e40e4920fce1be65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a mask to apply to stencil values written by the stencil test.  <a href="#ga5f084072b85bde09e40e4920fce1be65">[詳解]</a><br /></td></tr>
<tr class="separator:ga5f084072b85bde09e40e4920fce1be65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3670a8f6d5e0a5267dfb69919d46d8d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3670a8f6d5e0a5267dfb69919d46d8d5">nvnCommandBufferSetStencilRef</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a> faces, int ref)</td></tr>
<tr class="memdesc:ga3670a8f6d5e0a5267dfb69919d46d8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a stencil reference value used by the stencil test.  <a href="#ga3670a8f6d5e0a5267dfb69919d46d8d5">[詳解]</a><br /></td></tr>
<tr class="separator:ga3670a8f6d5e0a5267dfb69919d46d8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab057345ad441b37deda70d0434d0cb5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab057345ad441b37deda70d0434d0cb5f">nvnCommandBufferSetStencilValueMask</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a> faces, int mask)</td></tr>
<tr class="memdesc:gab057345ad441b37deda70d0434d0cb5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a mask that will be applied to the stencil index and reference values prior to performing the stencil test.  <a href="#gab057345ad441b37deda70d0434d0cb5f">[詳解]</a><br /></td></tr>
<tr class="separator:gab057345ad441b37deda70d0434d0cb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c5fe84c110d0a48de87c2f6f83eb6e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6c5fe84c110d0a48de87c2f6f83eb6e3">nvnCommandBufferSetSubpixelPrecisionBias</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int xBits, int yBits)</td></tr>
<tr class="memdesc:ga6c5fe84c110d0a48de87c2f6f83eb6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the number of additional bits of subpixel precision to be used for primitive rasterization when conservative rasterization is enabled.  <a href="#ga6c5fe84c110d0a48de87c2f6f83eb6e3">[詳解]</a><br /></td></tr>
<tr class="separator:ga6c5fe84c110d0a48de87c2f6f83eb6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43781240fe1741acfa122ad4fd63b802"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga43781240fe1741acfa122ad4fd63b802">nvnCommandBufferSetTexturePool</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *texturePool)</td></tr>
<tr class="memdesc:ga43781240fe1741acfa122ad4fd63b802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a new texture pool used for subsequent rendering operations.  <a href="#ga43781240fe1741acfa122ad4fd63b802">[詳解]</a><br /></td></tr>
<tr class="separator:ga43781240fe1741acfa122ad4fd63b802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2e294bc785c1a41a874f71fe5b277d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae2e294bc785c1a41a874f71fe5b277d4">nvnCommandBufferSetTiledCacheAction</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__enum.html#gaa34a73b0ed878a1ee610efb60d5bbb9c">NVNtiledCacheAction</a> action)</td></tr>
<tr class="memdesc:gae2e294bc785c1a41a874f71fe5b277d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a specified operation related to tiled caching.  <a href="#gae2e294bc785c1a41a874f71fe5b277d4">[詳解]</a><br /></td></tr>
<tr class="separator:gae2e294bc785c1a41a874f71fe5b277d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga682b6f01fe95daff5aa16c5b044fca32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga682b6f01fe95daff5aa16c5b044fca32">nvnCommandBufferSetTiledCacheTileSize</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int tileWidth, int tileHeight)</td></tr>
<tr class="memdesc:ga682b6f01fe95daff5aa16c5b044fca32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the tile size used for tiled caching.  <a href="#ga682b6f01fe95daff5aa16c5b044fca32">[詳解]</a><br /></td></tr>
<tr class="separator:ga682b6f01fe95daff5aa16c5b044fca32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4cadef7ff012bc4d218bfd9e510a888"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac4cadef7ff012bc4d218bfd9e510a888">nvnCommandBufferSetViewport</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int x, int y, int w, int h)</td></tr>
<tr class="memdesc:gac4cadef7ff012bc4d218bfd9e510a888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the rectangle for viewport 0.  <a href="#gac4cadef7ff012bc4d218bfd9e510a888">[詳解]</a><br /></td></tr>
<tr class="separator:gac4cadef7ff012bc4d218bfd9e510a888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28fd845211c4219f176ee89e8a3d948d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga28fd845211c4219f176ee89e8a3d948d">nvnCommandBufferSetViewports</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int first, int count, const float *ranges)</td></tr>
<tr class="memdesc:ga28fd845211c4219f176ee89e8a3d948d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify one or more viewport rectangles.  <a href="#ga28fd845211c4219f176ee89e8a3d948d">[詳解]</a><br /></td></tr>
<tr class="separator:ga28fd845211c4219f176ee89e8a3d948d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ffac06ea80ba1df6d07234615c0ae66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6ffac06ea80ba1df6d07234615c0ae66">nvnCommandBufferSetViewportSwizzles</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, int first, int count, const <a class="el" href="group__nvn__c__enum.html#ga00e92e1d7e5fff49496f813b6288ec0f">NVNviewportSwizzle</a> *swizzles)</td></tr>
<tr class="memdesc:ga6ffac06ea80ba1df6d07234615c0ae66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a set of viewport swizzle selectors for one or more viewport rectangles.  <a href="#ga6ffac06ea80ba1df6d07234615c0ae66">[詳解]</a><br /></td></tr>
<tr class="separator:ga6ffac06ea80ba1df6d07234615c0ae66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae26f02577d10f5b39bb432d34d4b8649"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae26f02577d10f5b39bb432d34d4b8649">nvnCommandBufferSignalEvent</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *event, <a class="el" href="group__nvn__c__enum.html#gae0c7c9637d4f93ea56fc315c97f17a7e">NVNeventSignalMode</a> mode, <a class="el" href="group__nvn__c__enum.html#ga46d20cb478c11853f23d27890c28f4ee">NVNeventSignalLocation</a> location, int flags, uint32_t value)</td></tr>
<tr class="memdesc:gae26f02577d10f5b39bb432d34d4b8649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the GPU to signal an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object.  <a href="#gae26f02577d10f5b39bb432d34d4b8649">[詳解]</a><br /></td></tr>
<tr class="separator:gae26f02577d10f5b39bb432d34d4b8649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09ac3a51249e04fe24e778d62fa0717b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga09ac3a51249e04fe24e778d62fa0717b">nvnCommandBufferTiledDownsample</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *src, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *dst)</td></tr>
<tr class="memdesc:ga09ac3a51249e04fe24e778d62fa0717b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a filtered version of a multisample source texture to produce a single-sample destination texture.  <a href="#ga09ac3a51249e04fe24e778d62fa0717b">[詳解]</a><br /></td></tr>
<tr class="separator:ga09ac3a51249e04fe24e778d62fa0717b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04940df32b22af5553e256021e876f26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga04940df32b22af5553e256021e876f26">nvnCommandBufferTiledDownsampleTextureView</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *src, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *srcView, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *dst, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *dstView)</td></tr>
<tr class="memdesc:ga04940df32b22af5553e256021e876f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a filtered version of a multisample source texture texture view to produce a single-sample destination texture view.  <a href="#ga04940df32b22af5553e256021e876f26">[詳解]</a><br /></td></tr>
<tr class="separator:ga04940df32b22af5553e256021e876f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d1a1fe5fa1806e89138de41ee9c601f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2d1a1fe5fa1806e89138de41ee9c601f">nvnCommandBufferUpdateUniformBuffer</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, <a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> buffer, size_t bufferSize, ptrdiff_t updateOffset, size_t updateSize, const void *data)</td></tr>
<tr class="memdesc:ga2d1a1fe5fa1806e89138de41ee9c601f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the contents of a uniform buffer.  <a href="#ga2d1a1fe5fa1806e89138de41ee9c601f">[詳解]</a><br /></td></tr>
<tr class="separator:ga2d1a1fe5fa1806e89138de41ee9c601f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81d0bfe6252b8f44e1b0a3607856d71c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga81d0bfe6252b8f44e1b0a3607856d71c">nvnCommandBufferWaitEvent</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *event, <a class="el" href="group__nvn__c__enum.html#ga6062c139aaf05b84d9c59913ff914cad">NVNeventWaitMode</a> waitMode, uint32_t value)</td></tr>
<tr class="memdesc:ga81d0bfe6252b8f44e1b0a3607856d71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause work on the GPU until an event is signaled.  <a href="#ga81d0bfe6252b8f44e1b0a3607856d71c">[詳解]</a><br /></td></tr>
<tr class="separator:ga81d0bfe6252b8f44e1b0a3607856d71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e5ab25595c79c070fc8dd7442a69d6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7e5ab25595c79c070fc8dd7442a69d6d">nvnCommandBufferWaitSync</a> (<a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *cmdBuf, const <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *sync)</td></tr>
<tr class="memdesc:ga7e5ab25595c79c070fc8dd7442a69d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object to be signaled on the GPU before processing any further commands in the specified <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object.  <a href="#ga7e5ab25595c79c070fc8dd7442a69d6d">[詳解]</a><br /></td></tr>
<tr class="separator:ga7e5ab25595c79c070fc8dd7442a69d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga988a86f1527afdfb7cd08e79b5ac600a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga14f57c18bdbcc7517a24b723743e61e6">NVNdepthFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga988a86f1527afdfb7cd08e79b5ac600a">nvnDepthStencilStateGetDepthFunc</a> (const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil)</td></tr>
<tr class="memdesc:ga988a86f1527afdfb7cd08e79b5ac600a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the comparison function used when depth testing is enabled.  <a href="#ga988a86f1527afdfb7cd08e79b5ac600a">[詳解]</a><br /></td></tr>
<tr class="separator:ga988a86f1527afdfb7cd08e79b5ac600a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e0c9f60146ff3dce4ae5377e5dea5df"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0e0c9f60146ff3dce4ae5377e5dea5df">nvnDepthStencilStateGetDepthTestEnable</a> (const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil)</td></tr>
<tr class="memdesc:ga0e0c9f60146ff3dce4ae5377e5dea5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether depth testing is enabled or disabled.  <a href="#ga0e0c9f60146ff3dce4ae5377e5dea5df">[詳解]</a><br /></td></tr>
<tr class="separator:ga0e0c9f60146ff3dce4ae5377e5dea5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dbfe16804066f2acf2127e1b36fadb3"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2dbfe16804066f2acf2127e1b36fadb3">nvnDepthStencilStateGetDepthWriteEnable</a> (const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil)</td></tr>
<tr class="memdesc:ga2dbfe16804066f2acf2127e1b36fadb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the depth buffer should be updated by the depth test.  <a href="#ga2dbfe16804066f2acf2127e1b36fadb3">[詳解]</a><br /></td></tr>
<tr class="separator:ga2dbfe16804066f2acf2127e1b36fadb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11ef77b998e4d4ca6bff2e8721a18ae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#gab50861ff9b46503782bb66c4edb734ae">NVNstencilFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga11ef77b998e4d4ca6bff2e8721a18ae7">nvnDepthStencilStateGetStencilFunc</a> (const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, <a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a> face)</td></tr>
<tr class="memdesc:ga11ef77b998e4d4ca6bff2e8721a18ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the comparison function used when stencil testing is enabled.  <a href="#ga11ef77b998e4d4ca6bff2e8721a18ae7">[詳解]</a><br /></td></tr>
<tr class="separator:ga11ef77b998e4d4ca6bff2e8721a18ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f44de3d7815edec84bc5773e4bf6b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf1f44de3d7815edec84bc5773e4bf6b7">nvnDepthStencilStateGetStencilOp</a> (const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, <a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a> face, <a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a> *fail, <a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a> *depthFail, <a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a> *depthPass)</td></tr>
<tr class="memdesc:gaf1f44de3d7815edec84bc5773e4bf6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query operations performed on stored stencil values by the stencil test.  <a href="#gaf1f44de3d7815edec84bc5773e4bf6b7">[詳解]</a><br /></td></tr>
<tr class="separator:gaf1f44de3d7815edec84bc5773e4bf6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22358a58ee07fdefd11993f6929ac9d7"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga22358a58ee07fdefd11993f6929ac9d7">nvnDepthStencilStateGetStencilTestEnable</a> (const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil)</td></tr>
<tr class="memdesc:ga22358a58ee07fdefd11993f6929ac9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the stencil testing is enabled or disabled.  <a href="#ga22358a58ee07fdefd11993f6929ac9d7">[詳解]</a><br /></td></tr>
<tr class="separator:ga22358a58ee07fdefd11993f6929ac9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f659011ea2a0c713e64022959b865e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2f659011ea2a0c713e64022959b865e2">nvnDepthStencilStateSetDefaults</a> (<a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil)</td></tr>
<tr class="memdesc:ga2f659011ea2a0c713e64022959b865e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object.  <a href="#ga2f659011ea2a0c713e64022959b865e2">[詳解]</a><br /></td></tr>
<tr class="separator:ga2f659011ea2a0c713e64022959b865e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdbe8e6bc4bfb62a304d831a919d9890"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafdbe8e6bc4bfb62a304d831a919d9890">nvnDepthStencilStateSetDepthFunc</a> (<a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, <a class="el" href="group__nvn__c__enum.html#ga14f57c18bdbcc7517a24b723743e61e6">NVNdepthFunc</a> func)</td></tr>
<tr class="memdesc:gafdbe8e6bc4bfb62a304d831a919d9890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the comparison function used when depth testing is enabled.  <a href="#gafdbe8e6bc4bfb62a304d831a919d9890">[詳解]</a><br /></td></tr>
<tr class="separator:gafdbe8e6bc4bfb62a304d831a919d9890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a0a2454a1b00a8889d1d34fd8a7da69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8a0a2454a1b00a8889d1d34fd8a7da69">nvnDepthStencilStateSetDepthTestEnable</a> (<a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, NVNboolean enable)</td></tr>
<tr class="memdesc:ga8a0a2454a1b00a8889d1d34fd8a7da69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether depth testing is enabled or disabled.  <a href="#ga8a0a2454a1b00a8889d1d34fd8a7da69">[詳解]</a><br /></td></tr>
<tr class="separator:ga8a0a2454a1b00a8889d1d34fd8a7da69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga363282d1d17b72e5553651d7b2c367cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga363282d1d17b72e5553651d7b2c367cf">nvnDepthStencilStateSetDepthWriteEnable</a> (<a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, NVNboolean enable)</td></tr>
<tr class="memdesc:ga363282d1d17b72e5553651d7b2c367cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether the depth buffer should be updated by the depth test.  <a href="#ga363282d1d17b72e5553651d7b2c367cf">[詳解]</a><br /></td></tr>
<tr class="separator:ga363282d1d17b72e5553651d7b2c367cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6c290c610aa9daf1a2ece3e18065e32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa6c290c610aa9daf1a2ece3e18065e32">nvnDepthStencilStateSetStencilFunc</a> (<a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, <a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a> faces, <a class="el" href="group__nvn__c__enum.html#gab50861ff9b46503782bb66c4edb734ae">NVNstencilFunc</a> func)</td></tr>
<tr class="memdesc:gaa6c290c610aa9daf1a2ece3e18065e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the comparison function used when stencil testing is enabled.  <a href="#gaa6c290c610aa9daf1a2ece3e18065e32">[詳解]</a><br /></td></tr>
<tr class="separator:gaa6c290c610aa9daf1a2ece3e18065e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36095f921d11664dbe4b3139b8bf7793"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga36095f921d11664dbe4b3139b8bf7793">nvnDepthStencilStateSetStencilOp</a> (<a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, <a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a> faces, <a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a> fail, <a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a> depthFail, <a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a> depthPass)</td></tr>
<tr class="memdesc:ga36095f921d11664dbe4b3139b8bf7793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies operations performed on stored stencil values by the stencil test.  <a href="#ga36095f921d11664dbe4b3139b8bf7793">[詳解]</a><br /></td></tr>
<tr class="separator:ga36095f921d11664dbe4b3139b8bf7793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0127f672494691efb62b594091eeddee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0127f672494691efb62b594091eeddee">nvnDepthStencilStateSetStencilTestEnable</a> (<a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *depthStencil, NVNboolean enable)</td></tr>
<tr class="memdesc:ga0127f672494691efb62b594091eeddee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether the stencil testing is enabled or disabled.  <a href="#ga0127f672494691efb62b594091eeddee">[詳解]</a><br /></td></tr>
<tr class="separator:ga0127f672494691efb62b594091eeddee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07e26faaa8d6569f115906735d337b36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga07e26faaa8d6569f115906735d337b36">nvnDeviceApplyDeferredFinalizes</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, int age)</td></tr>
<tr class="memdesc:ga07e26faaa8d6569f115906735d337b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize buffers, textures, and samplers previously scheduled for finalization.  <a href="#ga07e26faaa8d6569f115906735d337b36">[詳解]</a><br /></td></tr>
<tr class="separator:ga07e26faaa8d6569f115906735d337b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfe3e96f8b8ef13acb9008e4098196d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga9c68350bf64f2e7a90a23290c26872d3">NVNdeviceFlagBits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacfe3e96f8b8ef13acb9008e4098196d3">nvnDeviceBuilderGetFlags</a> (const <a class="el" href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a> *builder)</td></tr>
<tr class="memdesc:gacfe3e96f8b8ef13acb9008e4098196d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flags associated with this <a class="el" href="struct_n_v_ndevice_builder.html" title="Object specifying state used to construct new device objects. ">NVNdeviceBuilder</a> object.  <a href="#gacfe3e96f8b8ef13acb9008e4098196d3">[詳解]</a><br /></td></tr>
<tr class="separator:gacfe3e96f8b8ef13acb9008e4098196d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa042629cf4bc5ef1fab4bc7bf37b6f4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa042629cf4bc5ef1fab4bc7bf37b6f4f">nvnDeviceBuilderSetDefaults</a> (<a class="el" href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaa042629cf4bc5ef1fab4bc7bf37b6f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_ndevice_builder.html" title="Object specifying state used to construct new device objects. ">NVNdeviceBuilder</a> object.  <a href="#gaa042629cf4bc5ef1fab4bc7bf37b6f4f">[詳解]</a><br /></td></tr>
<tr class="separator:gaa042629cf4bc5ef1fab4bc7bf37b6f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga918d154a1d1f156eb61e6a3e402cbf1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga918d154a1d1f156eb61e6a3e402cbf1c">nvnDeviceBuilderSetFlags</a> (<a class="el" href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a> *builder, int flags)</td></tr>
<tr class="memdesc:ga918d154a1d1f156eb61e6a3e402cbf1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flags used for during device initialzation.  <a href="#ga918d154a1d1f156eb61e6a3e402cbf1c">[詳解]</a><br /></td></tr>
<tr class="separator:ga918d154a1d1f156eb61e6a3e402cbf1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fccd6ba67cd2d269900832d3b7e82ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5fccd6ba67cd2d269900832d3b7e82ff">nvnDeviceFinalize</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:ga5fccd6ba67cd2d269900832d3b7e82ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> object.  <a href="#ga5fccd6ba67cd2d269900832d3b7e82ff">[詳解]</a><br /></td></tr>
<tr class="separator:ga5fccd6ba67cd2d269900832d3b7e82ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5babbe756bd750bf3fd41c2b4049a730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5babbe756bd750bf3fd41c2b4049a730">nvnDeviceFinalizeCommandHandle</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, <a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> handles)</td></tr>
<tr class="memdesc:ga5babbe756bd750bf3fd41c2b4049a730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a command handle.  <a href="#ga5babbe756bd750bf3fd41c2b4049a730">[詳解]</a><br /></td></tr>
<tr class="separator:ga5babbe756bd750bf3fd41c2b4049a730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fb39752d0d8dd9d254667f3042c42b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga721dd09710079ec7e1d153842dbc7665">NVNdebugDomainId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7fb39752d0d8dd9d254667f3042c42b6">nvnDeviceGenerateDebugDomainId</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, const char *name)</td></tr>
<tr class="memdesc:ga7fb39752d0d8dd9d254667f3042c42b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a unique ID by atomically incrementing a global counter on each request.  <a href="#ga7fb39752d0d8dd9d254667f3042c42b6">[詳解]</a><br /></td></tr>
<tr class="separator:ga7fb39752d0d8dd9d254667f3042c42b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae11fb2040aadb9ab716ffc31d5f21e43"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae11fb2040aadb9ab716ffc31d5f21e43">nvnDeviceGetCurrentTimestampInNanoseconds</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:gae11fb2040aadb9ab716ffc31d5f21e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get timestamp from the device, without queuing like the ReportCounter functions.  <a href="#gae11fb2040aadb9ab716ffc31d5f21e43">[詳解]</a><br /></td></tr>
<tr class="separator:gae11fb2040aadb9ab716ffc31d5f21e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga764b1be2fcce7a44895399a46646bb14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga0e55de1522658c843016e8b24a8ecabd">NVNdepthMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga764b1be2fcce7a44895399a46646bb14">nvnDeviceGetDepthMode</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:ga764b1be2fcce7a44895399a46646bb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth mode for a device.  <a href="#ga764b1be2fcce7a44895399a46646bb14">[詳解]</a><br /></td></tr>
<tr class="separator:ga764b1be2fcce7a44895399a46646bb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c42db1b24a512270afa6abd615fae01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__handle.html#gacba3c44a43c05f11bc1b88c49b118606">NVNimageHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9c42db1b24a512270afa6abd615fae01">nvnDeviceGetImageHandle</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, int imageID)</td></tr>
<tr class="memdesc:ga9c42db1b24a512270afa6abd615fae01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to use for image loads and stores to a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#ga9c42db1b24a512270afa6abd615fae01">[詳解]</a><br /></td></tr>
<tr class="separator:ga9c42db1b24a512270afa6abd615fae01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f739de39c3818a65b190be3a82cf891"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6f739de39c3818a65b190be3a82cf891">nvnDeviceGetInteger</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, <a class="el" href="group__nvn__c__enum.html#gac887e20e2474bb76b87943b0f0be7a50">NVNdeviceInfo</a> pname, int *v)</td></tr>
<tr class="memdesc:ga6f739de39c3818a65b190be3a82cf891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query properties of a device.  <a href="#ga6f739de39c3818a65b190be3a82cf891">[詳解]</a><br /></td></tr>
<tr class="separator:ga6f739de39c3818a65b190be3a82cf891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacddfe3caf2f24874b617cd696e3a4305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__funcptrs.html#ga181fc0ee0f3ee509c16ca8e0c93b08cf">PFNNVNGENERICFUNCPTRPROC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacddfe3caf2f24874b617cd696e3a4305">nvnDeviceGetProcAddress</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, const char *name)</td></tr>
<tr class="memdesc:gacddfe3caf2f24874b617cd696e3a4305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query a function pointer for a specified C interface entry point for a device.  <a href="#gacddfe3caf2f24874b617cd696e3a4305">[詳解]</a><br /></td></tr>
<tr class="separator:gacddfe3caf2f24874b617cd696e3a4305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c15b1de83a8fe22f4ef03b74d8f946a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_n_v_nseparate_sampler_handle.html">NVNseparateSamplerHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2c15b1de83a8fe22f4ef03b74d8f946a">nvnDeviceGetSeparateSamplerHandle</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, int samplerID)</td></tr>
<tr class="memdesc:ga2c15b1de83a8fe22f4ef03b74d8f946a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object.  <a href="#ga2c15b1de83a8fe22f4ef03b74d8f946a">[詳解]</a><br /></td></tr>
<tr class="separator:ga2c15b1de83a8fe22f4ef03b74d8f946a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f3dbb400d79d6d8dc64c052226ba809"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_n_v_nseparate_texture_handle.html">NVNseparateTextureHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0f3dbb400d79d6d8dc64c052226ba809">nvnDeviceGetSeparateTextureHandle</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, int textureID)</td></tr>
<tr class="memdesc:ga0f3dbb400d79d6d8dc64c052226ba809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#ga0f3dbb400d79d6d8dc64c052226ba809">[詳解]</a><br /></td></tr>
<tr class="separator:ga0f3dbb400d79d6d8dc64c052226ba809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0b754403b7c24211f204fd7667466da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab0b754403b7c24211f204fd7667466da">nvnDeviceGetTexelFetchHandle</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, int textureID)</td></tr>
<tr class="memdesc:gab0b754403b7c24211f204fd7667466da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object for use in texel fetches.  <a href="#gab0b754403b7c24211f204fd7667466da">[詳解]</a><br /></td></tr>
<tr class="separator:gab0b754403b7c24211f204fd7667466da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ca6fe7fc102170723f5eccb14a25046"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0ca6fe7fc102170723f5eccb14a25046">nvnDeviceGetTextureHandle</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, int textureID, int samplerID)</td></tr>
<tr class="memdesc:ga0ca6fe7fc102170723f5eccb14a25046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle for a combined pair of <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> and <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects.  <a href="#ga0ca6fe7fc102170723f5eccb14a25046">[詳解]</a><br /></td></tr>
<tr class="separator:ga0ca6fe7fc102170723f5eccb14a25046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dad3a471fcb5313fd4aab24e8062f1c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9dad3a471fcb5313fd4aab24e8062f1c">nvnDeviceGetTimestampInNanoseconds</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, const <a class="el" href="struct_n_v_ncounter_data.html">NVNcounterData</a> *counterData)</td></tr>
<tr class="memdesc:ga9dad3a471fcb5313fd4aab24e8062f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the timestamp contained in a counter report, with time values converted from the platform-specific timestamp resolution to nanoseconds.  <a href="#ga9dad3a471fcb5313fd4aab24e8062f1c">[詳解]</a><br /></td></tr>
<tr class="separator:ga9dad3a471fcb5313fd4aab24e8062f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f3e9684e49790ad324c33e38a07276b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga52db1bf3e182ec089c43db5a02baecd6">NVNwindowOriginMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1f3e9684e49790ad324c33e38a07276b">nvnDeviceGetWindowOriginMode</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:ga1f3e9684e49790ad324c33e38a07276b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the window origin mode for a device.  <a href="#ga1f3e9684e49790ad324c33e38a07276b">[詳解]</a><br /></td></tr>
<tr class="separator:ga1f3e9684e49790ad324c33e38a07276b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac05386acab686b7614d353c9a4ea4d96"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac05386acab686b7614d353c9a4ea4d96">nvnDeviceInitialize</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, const <a class="el" href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a> *builder)</td></tr>
<tr class="memdesc:gac05386acab686b7614d353c9a4ea4d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> object from a device builder.  <a href="#gac05386acab686b7614d353c9a4ea4d96">[詳解]</a><br /></td></tr>
<tr class="separator:gac05386acab686b7614d353c9a4ea4d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab73dcc0df1012caf66620aa7c56b2592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab73dcc0df1012caf66620aa7c56b2592">nvnDeviceInstallDebugCallback</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, const <a class="el" href="group__nvn__c__funcptrs.html#ga23608b4a63e52475d42d90101108cdf1">PFNNVNDEBUGCALLBACKPROC</a> callback, void *callbackData, NVNboolean enable)</td></tr>
<tr class="memdesc:gab73dcc0df1012caf66620aa7c56b2592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install or remove a callback function to be called whenever the debug layer generates a message.  <a href="#gab73dcc0df1012caf66620aa7c56b2592">[詳解]</a><br /></td></tr>
<tr class="separator:gab73dcc0df1012caf66620aa7c56b2592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9291748f30602dc5655cd1556fc2eb01"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9291748f30602dc5655cd1556fc2eb01">nvnDeviceIsExternalDebuggerAttached</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:ga9291748f30602dc5655cd1556fc2eb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an external debugger is attached when running an NVN application.  <a href="#ga9291748f30602dc5655cd1556fc2eb01">[詳解]</a><br /></td></tr>
<tr class="separator:ga9291748f30602dc5655cd1556fc2eb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace7813b0e44d122d452df918525ef8a1"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gace7813b0e44d122d452df918525ef8a1">nvnDeviceRegisterFastClearColor</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, const float *color, <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> format)</td></tr>
<tr class="memdesc:gace7813b0e44d122d452df918525ef8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a fast clear color value.  <a href="#gace7813b0e44d122d452df918525ef8a1">[詳解]</a><br /></td></tr>
<tr class="separator:gace7813b0e44d122d452df918525ef8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c2df0951b28828873afc21370d7c010"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1c2df0951b28828873afc21370d7c010">nvnDeviceRegisterFastClearColori</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, const int *color, <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> format)</td></tr>
<tr class="memdesc:ga1c2df0951b28828873afc21370d7c010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a signed integer fast clear color value.  <a href="#ga1c2df0951b28828873afc21370d7c010">[詳解]</a><br /></td></tr>
<tr class="separator:ga1c2df0951b28828873afc21370d7c010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cfafa315b6bea064d93dd963eb7b891"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9cfafa315b6bea064d93dd963eb7b891">nvnDeviceRegisterFastClearColorui</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, const uint32_t *color, <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> format)</td></tr>
<tr class="memdesc:ga9cfafa315b6bea064d93dd963eb7b891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an unsigned integer fast clear color value.  <a href="#ga9cfafa315b6bea064d93dd963eb7b891">[詳解]</a><br /></td></tr>
<tr class="separator:ga9cfafa315b6bea064d93dd963eb7b891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c9adc51dc192c3e48dc4c0e2e6f2e86"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2c9adc51dc192c3e48dc4c0e2e6f2e86">nvnDeviceRegisterFastClearDepth</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, float depth)</td></tr>
<tr class="memdesc:ga2c9adc51dc192c3e48dc4c0e2e6f2e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a fast clear depth value.  <a href="#ga2c9adc51dc192c3e48dc4c0e2e6f2e86">[詳解]</a><br /></td></tr>
<tr class="separator:ga2c9adc51dc192c3e48dc4c0e2e6f2e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bfa6529d97f627325bd9ac84605a9b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6bfa6529d97f627325bd9ac84605a9b1">nvnDeviceSetDebugLabel</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, const char *label)</td></tr>
<tr class="memdesc:ga6bfa6529d97f627325bd9ac84605a9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> object.  <a href="#ga6bfa6529d97f627325bd9ac84605a9b1">[詳解]</a><br /></td></tr>
<tr class="separator:ga6bfa6529d97f627325bd9ac84605a9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b42972a78ea6d7180106f97a8ef1eec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8b42972a78ea6d7180106f97a8ef1eec">nvnDeviceSetDepthMode</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, <a class="el" href="group__nvn__c__enum.html#ga0e55de1522658c843016e8b24a8ecabd">NVNdepthMode</a> depthMode)</td></tr>
<tr class="memdesc:ga8b42972a78ea6d7180106f97a8ef1eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global clipping range for normalized depth in clip space.  <a href="#ga8b42972a78ea6d7180106f97a8ef1eec">[詳解]</a><br /></td></tr>
<tr class="separator:ga8b42972a78ea6d7180106f97a8ef1eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc2c6dd07f2db4dddff39bcd0eff76a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafc2c6dd07f2db4dddff39bcd0eff76a3">nvnDeviceSetIntermediateShaderCache</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, int numMaxEntries)</td></tr>
<tr class="memdesc:gafc2c6dd07f2db4dddff39bcd0eff76a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the shader cache for the Windows reference platform to store fat binary intermediate results.  <a href="#gafc2c6dd07f2db4dddff39bcd0eff76a3">[詳解]</a><br /></td></tr>
<tr class="separator:gafc2c6dd07f2db4dddff39bcd0eff76a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24c4fdcf11f6dc0bf042566b4da7bba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga24c4fdcf11f6dc0bf042566b4da7bba4">nvnDeviceSetWindowOriginMode</a> (<a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, <a class="el" href="group__nvn__c__enum.html#ga52db1bf3e182ec089c43db5a02baecd6">NVNwindowOriginMode</a> windowOriginMode)</td></tr>
<tr class="memdesc:ga24c4fdcf11f6dc0bf042566b4da7bba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global location for window coordinates (0,0).  <a href="#ga24c4fdcf11f6dc0bf042566b4da7bba4">[詳解]</a><br /></td></tr>
<tr class="separator:ga24c4fdcf11f6dc0bf042566b4da7bba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf12100926a7307bf74d86ab68dd59e65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf12100926a7307bf74d86ab68dd59e65">nvnDeviceWalkDebugDatabase</a> (const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device, <a class="el" href="group__nvn__c__enum.html#ga1ad0f9413adde3e3c46751c0312564ea">NVNdebugObjectType</a> type, <a class="el" href="group__nvn__c__funcptrs.html#ga3a91188b67a504893ce16e6f4febce03">PFNNVNWALKDEBUGDATABASECALLBACKPROC</a> callback, void *userParam)</td></tr>
<tr class="memdesc:gaf12100926a7307bf74d86ab68dd59e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk through the debug layer object database.  <a href="#gaf12100926a7307bf74d86ab68dd59e65">[詳解]</a><br /></td></tr>
<tr class="separator:gaf12100926a7307bf74d86ab68dd59e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga798a91d0cfa6b69b33678a78631f6d38"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga798a91d0cfa6b69b33678a78631f6d38">nvnEventBuilderGetStorage</a> (const <a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *builder, int64_t *offset)</td></tr>
<tr class="memdesc:ga798a91d0cfa6b69b33678a78631f6d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory pool and the offset associated with this <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects. ">NVNeventBuilder</a> object.  <a href="#ga798a91d0cfa6b69b33678a78631f6d38">[詳解]</a><br /></td></tr>
<tr class="separator:ga798a91d0cfa6b69b33678a78631f6d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9cbb0430ea71279858b791e61bbddae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf9cbb0430ea71279858b791e61bbddae">nvnEventBuilderSetDefaults</a> (<a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaf9cbb0430ea71279858b791e61bbddae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects. ">NVNeventBuilder</a> object.  <a href="#gaf9cbb0430ea71279858b791e61bbddae">[詳解]</a><br /></td></tr>
<tr class="separator:gaf9cbb0430ea71279858b791e61bbddae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga220c8fbd5686a7d0bb8629205ad0ce7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga220c8fbd5686a7d0bb8629205ad0ce7d">nvnEventBuilderSetStorage</a> (<a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *builder, const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, int64_t offset)</td></tr>
<tr class="memdesc:ga220c8fbd5686a7d0bb8629205ad0ce7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the location in a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> used to hold the state of an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> created from the <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects. ">NVNeventBuilder</a>.  <a href="#ga220c8fbd5686a7d0bb8629205ad0ce7d">[詳解]</a><br /></td></tr>
<tr class="separator:ga220c8fbd5686a7d0bb8629205ad0ce7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3396c994019a4149ee5cf81d6fdf368c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3396c994019a4149ee5cf81d6fdf368c">nvnEventFinalize</a> (<a class="el" href="struct_n_v_nevent.html">NVNevent</a> *event)</td></tr>
<tr class="memdesc:ga3396c994019a4149ee5cf81d6fdf368c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object.  <a href="#ga3396c994019a4149ee5cf81d6fdf368c">[詳解]</a><br /></td></tr>
<tr class="separator:ga3396c994019a4149ee5cf81d6fdf368c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95d214178cd0d00385e74cba7b2c2b76"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga95d214178cd0d00385e74cba7b2c2b76">nvnEventGetValue</a> (const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *event)</td></tr>
<tr class="memdesc:ga95d214178cd0d00385e74cba7b2c2b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value associated with an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object.  <a href="#ga95d214178cd0d00385e74cba7b2c2b76">[詳解]</a><br /></td></tr>
<tr class="separator:ga95d214178cd0d00385e74cba7b2c2b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga969cdf368faed960c33d23f25d72e16b"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga969cdf368faed960c33d23f25d72e16b">nvnEventInitialize</a> (<a class="el" href="struct_n_v_nevent.html">NVNevent</a> *event, const <a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga969cdf368faed960c33d23f25d72e16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object.  <a href="#ga969cdf368faed960c33d23f25d72e16b">[詳解]</a><br /></td></tr>
<tr class="separator:ga969cdf368faed960c33d23f25d72e16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ea5599a30f15446978d9b535e3aabf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8ea5599a30f15446978d9b535e3aabf9">nvnEventSignal</a> (<a class="el" href="struct_n_v_nevent.html">NVNevent</a> *event, <a class="el" href="group__nvn__c__enum.html#gae0c7c9637d4f93ea56fc315c97f17a7e">NVNeventSignalMode</a> mode, uint32_t value)</td></tr>
<tr class="memdesc:ga8ea5599a30f15446978d9b535e3aabf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the CPU to signal an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object.  <a href="#ga8ea5599a30f15446978d9b535e3aabf9">[詳解]</a><br /></td></tr>
<tr class="separator:ga8ea5599a30f15446978d9b535e3aabf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40a50e5352cccfa1ba2c2569777b85fa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga40a50e5352cccfa1ba2c2569777b85fa">nvnMemoryPoolBuilderGetDevice</a> (const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga40a50e5352cccfa1ba2c2569777b85fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the device associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a>.  <a href="#ga40a50e5352cccfa1ba2c2569777b85fa">[詳解]</a><br /></td></tr>
<tr class="separator:ga40a50e5352cccfa1ba2c2569777b85fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68a5197066d35e0f2bb74afc79fc0020"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#gaa7df4970255609d7a317631bcb37d654">NVNmemoryPoolFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga68a5197066d35e0f2bb74afc79fc0020">nvnMemoryPoolBuilderGetFlags</a> (const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga68a5197066d35e0f2bb74afc79fc0020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the flags associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a>.  <a href="#ga68a5197066d35e0f2bb74afc79fc0020">[詳解]</a><br /></td></tr>
<tr class="separator:ga68a5197066d35e0f2bb74afc79fc0020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5dd6a5d6a9164d1bddf18cdef18502a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac5dd6a5d6a9164d1bddf18cdef18502a">nvnMemoryPoolBuilderGetMemory</a> (const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder)</td></tr>
<tr class="memdesc:gac5dd6a5d6a9164d1bddf18cdef18502a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory allocation associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a>.  <a href="#gac5dd6a5d6a9164d1bddf18cdef18502a">[詳解]</a><br /></td></tr>
<tr class="separator:gac5dd6a5d6a9164d1bddf18cdef18502a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga692de7a3a6d9d318a39ea376a096097e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga692de7a3a6d9d318a39ea376a096097e">nvnMemoryPoolBuilderGetSize</a> (const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga692de7a3a6d9d318a39ea376a096097e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the size associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a>.  <a href="#ga692de7a3a6d9d318a39ea376a096097e">[詳解]</a><br /></td></tr>
<tr class="separator:ga692de7a3a6d9d318a39ea376a096097e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa17de90ba16494d5076a9a0dba9185d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaaa17de90ba16494d5076a9a0dba9185d">nvnMemoryPoolBuilderSetDefaults</a> (<a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaaa17de90ba16494d5076a9a0dba9185d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a> object.  <a href="#gaaa17de90ba16494d5076a9a0dba9185d">[詳解]</a><br /></td></tr>
<tr class="separator:gaaa17de90ba16494d5076a9a0dba9185d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacafb3b85111e530155835f1048360d59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacafb3b85111e530155835f1048360d59">nvnMemoryPoolBuilderSetDevice</a> (<a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder, <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:gacafb3b85111e530155835f1048360d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a> object.  <a href="#gacafb3b85111e530155835f1048360d59">[詳解]</a><br /></td></tr>
<tr class="separator:gacafb3b85111e530155835f1048360d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga332d877a6825cf3af6904c9615935daa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga332d877a6825cf3af6904c9615935daa">nvnMemoryPoolBuilderSetFlags</a> (<a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder, int flags)</td></tr>
<tr class="memdesc:ga332d877a6825cf3af6904c9615935daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set properties of <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> objects created from the builder.  <a href="#ga332d877a6825cf3af6904c9615935daa">[詳解]</a><br /></td></tr>
<tr class="separator:ga332d877a6825cf3af6904c9615935daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86c5f0efe19800f8571930177679853f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga86c5f0efe19800f8571930177679853f">nvnMemoryPoolBuilderSetStorage</a> (<a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder, void *memory, size_t size)</td></tr>
<tr class="memdesc:ga86c5f0efe19800f8571930177679853f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides memory to be used by memory pools initialized using a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a>.  <a href="#ga86c5f0efe19800f8571930177679853f">[詳解]</a><br /></td></tr>
<tr class="separator:ga86c5f0efe19800f8571930177679853f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cc130f7dcc64cd765e0b74a8c10e448"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4cc130f7dcc64cd765e0b74a8c10e448">nvnMemoryPoolFinalize</a> (<a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool)</td></tr>
<tr class="memdesc:ga4cc130f7dcc64cd765e0b74a8c10e448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object.  <a href="#ga4cc130f7dcc64cd765e0b74a8c10e448">[詳解]</a><br /></td></tr>
<tr class="separator:ga4cc130f7dcc64cd765e0b74a8c10e448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f76c329bcb4a9420bc4c6bc29f762e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9f76c329bcb4a9420bc4c6bc29f762e3">nvnMemoryPoolFlushMappedRange</a> (const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, ptrdiff_t offset, size_t size)</td></tr>
<tr class="memdesc:ga9f76c329bcb4a9420bc4c6bc29f762e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush previous CPU writes to a range of the memory pool to be visible to the GPU.  <a href="#ga9f76c329bcb4a9420bc4c6bc29f762e3">[詳解]</a><br /></td></tr>
<tr class="separator:ga9f76c329bcb4a9420bc4c6bc29f762e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1c21d6dc85c6325013b0e782998fbdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac1c21d6dc85c6325013b0e782998fbdb">nvnMemoryPoolGetBufferAddress</a> (const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool)</td></tr>
<tr class="memdesc:gac1c21d6dc85c6325013b0e782998fbdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the GPU address of the data store of a memory pool object.  <a href="#gac1c21d6dc85c6325013b0e782998fbdb">[詳解]</a><br /></td></tr>
<tr class="separator:gac1c21d6dc85c6325013b0e782998fbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaae82797756975754c0e3f141c66a524"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#gaa7df4970255609d7a317631bcb37d654">NVNmemoryPoolFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaaae82797756975754c0e3f141c66a524">nvnMemoryPoolGetFlags</a> (const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool)</td></tr>
<tr class="memdesc:gaaae82797756975754c0e3f141c66a524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the flags associated with a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object.  <a href="#gaaae82797756975754c0e3f141c66a524">[詳解]</a><br /></td></tr>
<tr class="separator:gaaae82797756975754c0e3f141c66a524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ab20a3416a36855861741c3305c2d80"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1ab20a3416a36855861741c3305c2d80">nvnMemoryPoolGetSize</a> (const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool)</td></tr>
<tr class="memdesc:ga1ab20a3416a36855861741c3305c2d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the size associated with a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object.  <a href="#ga1ab20a3416a36855861741c3305c2d80">[詳解]</a><br /></td></tr>
<tr class="separator:ga1ab20a3416a36855861741c3305c2d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae78de6694c8b1b054050dcc1b82bb20d"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae78de6694c8b1b054050dcc1b82bb20d">nvnMemoryPoolInitialize</a> (<a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *builder)</td></tr>
<tr class="memdesc:gae78de6694c8b1b054050dcc1b82bb20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object using a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a> object.  <a href="#gae78de6694c8b1b054050dcc1b82bb20d">[詳解]</a><br /></td></tr>
<tr class="separator:gae78de6694c8b1b054050dcc1b82bb20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc7ba26caa615b7f4abb81de4ed6205e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabc7ba26caa615b7f4abb81de4ed6205e">nvnMemoryPoolInvalidateMappedRange</a> (const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, ptrdiff_t offset, size_t size)</td></tr>
<tr class="memdesc:gabc7ba26caa615b7f4abb81de4ed6205e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate CPU caches for a range of the memory pool that may have been written by the GPU.  <a href="#gabc7ba26caa615b7f4abb81de4ed6205e">[詳解]</a><br /></td></tr>
<tr class="separator:gabc7ba26caa615b7f4abb81de4ed6205e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga072ffc85fe3f8ae544f3c788b192be77"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga072ffc85fe3f8ae544f3c788b192be77">nvnMemoryPoolMap</a> (const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool)</td></tr>
<tr class="memdesc:ga072ffc85fe3f8ae544f3c788b192be77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a CPU pointer to the memory owned by the <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object.  <a href="#ga072ffc85fe3f8ae544f3c788b192be77">[詳解]</a><br /></td></tr>
<tr class="separator:ga072ffc85fe3f8ae544f3c788b192be77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6dac6504ee2c716377f6dce9cede4e1"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae6dac6504ee2c716377f6dce9cede4e1">nvnMemoryPoolMapVirtual</a> (<a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *virtualPool, int numRequests, const <a class="el" href="struct_n_v_nmapping_request.html">NVNmappingRequest</a> *requests)</td></tr>
<tr class="memdesc:gae6dac6504ee2c716377f6dce9cede4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map memory pages from physical memory pools into a virtual memory pool.  <a href="#gae6dac6504ee2c716377f6dce9cede4e1">[詳解]</a><br /></td></tr>
<tr class="separator:gae6dac6504ee2c716377f6dce9cede4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d256413a09dc0163d78749b7e8756b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6d256413a09dc0163d78749b7e8756b6">nvnMemoryPoolSetDebugLabel</a> (<a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, const char *label)</td></tr>
<tr class="memdesc:ga6d256413a09dc0163d78749b7e8756b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object.  <a href="#ga6d256413a09dc0163d78749b7e8756b6">[詳解]</a><br /></td></tr>
<tr class="separator:ga6d256413a09dc0163d78749b7e8756b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga172c7ccc42da8dbc211c9d8f8dc383dd"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga172c7ccc42da8dbc211c9d8f8dc383dd">nvnMultisampleStateGetAlphaToCoverageDither</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga172c7ccc42da8dbc211c9d8f8dc383dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the alpha-to-coverage dithering enable.  <a href="#ga172c7ccc42da8dbc211c9d8f8dc383dd">[詳解]</a><br /></td></tr>
<tr class="separator:ga172c7ccc42da8dbc211c9d8f8dc383dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga709089315b48eb90eb3cf781957c9dc9"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga709089315b48eb90eb3cf781957c9dc9">nvnMultisampleStateGetAlphaToCoverageEnable</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga709089315b48eb90eb3cf781957c9dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the alpha-to-coverage enable.  <a href="#ga709089315b48eb90eb3cf781957c9dc9">[詳解]</a><br /></td></tr>
<tr class="separator:ga709089315b48eb90eb3cf781957c9dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfac452c21527aeb1043008e5924564d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga26f01c2daca8e41b2961de31a9079501">NVNcoverageModulationMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabfac452c21527aeb1043008e5924564d">nvnMultisampleStateGetCoverageModulationMode</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:gabfac452c21527aeb1043008e5924564d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the coverage modulation mode for target-independent rasterization.  <a href="#gabfac452c21527aeb1043008e5924564d">[詳解]</a><br /></td></tr>
<tr class="separator:gabfac452c21527aeb1043008e5924564d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0713e246ce816f781da8e21ab070194a"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0713e246ce816f781da8e21ab070194a">nvnMultisampleStateGetCoverageToColorEnable</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga0713e246ce816f781da8e21ab070194a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the enable for the fragment coverage-to-color feature.  <a href="#ga0713e246ce816f781da8e21ab070194a">[詳解]</a><br /></td></tr>
<tr class="separator:ga0713e246ce816f781da8e21ab070194a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e1d59807858c15163a9b4be1959b8e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9e1d59807858c15163a9b4be1959b8e8">nvnMultisampleStateGetCoverageToColorOutput</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga9e1d59807858c15163a9b4be1959b8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the color output updated by the fragment coverage-to-color feature.  <a href="#ga9e1d59807858c15163a9b4be1959b8e8">[詳解]</a><br /></td></tr>
<tr class="separator:ga9e1d59807858c15163a9b4be1959b8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7f67824bc1e151868f8d1cd2a1ce1c6"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab7f67824bc1e151868f8d1cd2a1ce1c6">nvnMultisampleStateGetMultisampleEnable</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:gab7f67824bc1e151868f8d1cd2a1ce1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the multisample rasterization enable.  <a href="#gab7f67824bc1e151868f8d1cd2a1ce1c6">[詳解]</a><br /></td></tr>
<tr class="separator:gab7f67824bc1e151868f8d1cd2a1ce1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga313e2131ca507a3133a1aa1d85e68cdb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga313e2131ca507a3133a1aa1d85e68cdb">nvnMultisampleStateGetRasterSamples</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga313e2131ca507a3133a1aa1d85e68cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the raster sample count for target-independent rasterization.  <a href="#ga313e2131ca507a3133a1aa1d85e68cdb">[詳解]</a><br /></td></tr>
<tr class="separator:ga313e2131ca507a3133a1aa1d85e68cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf91e203d2f30a7a960993c14826b3a2f"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf91e203d2f30a7a960993c14826b3a2f">nvnMultisampleStateGetSampleLocationsEnable</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:gaf91e203d2f30a7a960993c14826b3a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the programmable sample locations enable.  <a href="#gaf91e203d2f30a7a960993c14826b3a2f">[詳解]</a><br /></td></tr>
<tr class="separator:gaf91e203d2f30a7a960993c14826b3a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41a34fd884435c3a3de1089633068740"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga41a34fd884435c3a3de1089633068740">nvnMultisampleStateGetSampleLocationsGrid</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, int *width, int *height)</td></tr>
<tr class="memdesc:ga41a34fd884435c3a3de1089633068740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the size of a pixel grid used for programmable sample locations.  <a href="#ga41a34fd884435c3a3de1089633068740">[詳解]</a><br /></td></tr>
<tr class="separator:ga41a34fd884435c3a3de1089633068740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e1af29088e21596f0e4d5744777498"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga87e1af29088e21596f0e4d5744777498">nvnMultisampleStateGetSampleLocationsGridEnable</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga87e1af29088e21596f0e4d5744777498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the programmable sample locations grid enable.  <a href="#ga87e1af29088e21596f0e4d5744777498">[詳解]</a><br /></td></tr>
<tr class="separator:ga87e1af29088e21596f0e4d5744777498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aa20b9525683eeca5f07d1c40db4078"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8aa20b9525683eeca5f07d1c40db4078">nvnMultisampleStateGetSamples</a> (const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga8aa20b9525683eeca5f07d1c40db4078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of samples in a <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object.  <a href="#ga8aa20b9525683eeca5f07d1c40db4078">[詳解]</a><br /></td></tr>
<tr class="separator:ga8aa20b9525683eeca5f07d1c40db4078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc12eb75e49cd73800ac71eac99e4008"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabc12eb75e49cd73800ac71eac99e4008">nvnMultisampleStateSetAlphaToCoverageDither</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, NVNboolean dither)</td></tr>
<tr class="memdesc:gabc12eb75e49cd73800ac71eac99e4008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable dithering in the alpha-to-coverage operation.  <a href="#gabc12eb75e49cd73800ac71eac99e4008">[詳解]</a><br /></td></tr>
<tr class="separator:gabc12eb75e49cd73800ac71eac99e4008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3837dd1e28700073cfd34479a6a2e677"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3837dd1e28700073cfd34479a6a2e677">nvnMultisampleStateSetAlphaToCoverageEnable</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, NVNboolean enable)</td></tr>
<tr class="memdesc:ga3837dd1e28700073cfd34479a6a2e677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable alpha-to-coverage operation.  <a href="#ga3837dd1e28700073cfd34479a6a2e677">[詳解]</a><br /></td></tr>
<tr class="separator:ga3837dd1e28700073cfd34479a6a2e677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab15dd40cc4d6671ec613598a489f99ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab15dd40cc4d6671ec613598a489f99ef">nvnMultisampleStateSetCoverageModulationMode</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, <a class="el" href="group__nvn__c__enum.html#ga26f01c2daca8e41b2961de31a9079501">NVNcoverageModulationMode</a> mode)</td></tr>
<tr class="memdesc:gab15dd40cc4d6671ec613598a489f99ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the coverage modulation mode for target-independent rasterization.  <a href="#gab15dd40cc4d6671ec613598a489f99ef">[詳解]</a><br /></td></tr>
<tr class="separator:gab15dd40cc4d6671ec613598a489f99ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbf2410e5a0f923e692f3223cf49935c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabbf2410e5a0f923e692f3223cf49935c">nvnMultisampleStateSetCoverageToColorEnable</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, NVNboolean enable)</td></tr>
<tr class="memdesc:gabbf2410e5a0f923e692f3223cf49935c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the fragment coverage-to-color feature.  <a href="#gabbf2410e5a0f923e692f3223cf49935c">[詳解]</a><br /></td></tr>
<tr class="separator:gabbf2410e5a0f923e692f3223cf49935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09d3ac530fffb5efaac50748ff4873f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga09d3ac530fffb5efaac50748ff4873f9">nvnMultisampleStateSetCoverageToColorOutput</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, int color)</td></tr>
<tr class="memdesc:ga09d3ac530fffb5efaac50748ff4873f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the color output updated by the fragment coverage-to-color feature.  <a href="#ga09d3ac530fffb5efaac50748ff4873f9">[詳解]</a><br /></td></tr>
<tr class="separator:ga09d3ac530fffb5efaac50748ff4873f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d649ca21de18dd8b544c8006d6612d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0d649ca21de18dd8b544c8006d6612d8">nvnMultisampleStateSetDefaults</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample)</td></tr>
<tr class="memdesc:ga0d649ca21de18dd8b544c8006d6612d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object.  <a href="#ga0d649ca21de18dd8b544c8006d6612d8">[詳解]</a><br /></td></tr>
<tr class="separator:ga0d649ca21de18dd8b544c8006d6612d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f1d552844cb1b2388d012cb80d094ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7f1d552844cb1b2388d012cb80d094ea">nvnMultisampleStateSetMultisampleEnable</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, NVNboolean enable)</td></tr>
<tr class="memdesc:ga7f1d552844cb1b2388d012cb80d094ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable multisample rasterization.  <a href="#ga7f1d552844cb1b2388d012cb80d094ea">[詳解]</a><br /></td></tr>
<tr class="separator:ga7f1d552844cb1b2388d012cb80d094ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae00fe1081ea4ab7c88803a66283990d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae00fe1081ea4ab7c88803a66283990d2">nvnMultisampleStateSetRasterSamples</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, int rasterSamples)</td></tr>
<tr class="memdesc:gae00fe1081ea4ab7c88803a66283990d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the raster sample count for target-independent rasterization.  <a href="#gae00fe1081ea4ab7c88803a66283990d2">[詳解]</a><br /></td></tr>
<tr class="separator:gae00fe1081ea4ab7c88803a66283990d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab91f126da720035da293ef8bd7f527b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab91f126da720035da293ef8bd7f527b1">nvnMultisampleStateSetSampleLocations</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, int start, int count, const float *values)</td></tr>
<tr class="memdesc:gab91f126da720035da293ef8bd7f527b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies programmable sample locations for rasterization.  <a href="#gab91f126da720035da293ef8bd7f527b1">[詳解]</a><br /></td></tr>
<tr class="separator:gab91f126da720035da293ef8bd7f527b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga882228d131ff8d2ca6f0ba72d4a9182c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga882228d131ff8d2ca6f0ba72d4a9182c">nvnMultisampleStateSetSampleLocationsEnable</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, NVNboolean enable)</td></tr>
<tr class="memdesc:ga882228d131ff8d2ca6f0ba72d4a9182c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable programmable sample locations.  <a href="#ga882228d131ff8d2ca6f0ba72d4a9182c">[詳解]</a><br /></td></tr>
<tr class="separator:ga882228d131ff8d2ca6f0ba72d4a9182c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga705b9946424e5f6e727adae9eae7ace5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga705b9946424e5f6e727adae9eae7ace5">nvnMultisampleStateSetSampleLocationsGridEnable</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, NVNboolean enable)</td></tr>
<tr class="memdesc:ga705b9946424e5f6e727adae9eae7ace5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the programmable sample locations grid enable.  <a href="#ga705b9946424e5f6e727adae9eae7ace5">[詳解]</a><br /></td></tr>
<tr class="separator:ga705b9946424e5f6e727adae9eae7ace5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc59ccbfdafe205cd8ba04f1795ada6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafc59ccbfdafe205cd8ba04f1795ada6d">nvnMultisampleStateSetSamples</a> (<a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *multisample, int samples)</td></tr>
<tr class="memdesc:gafc59ccbfdafe205cd8ba04f1795ada6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the number of samples in the framebuffer.  <a href="#gafc59ccbfdafe205cd8ba04f1795ada6d">[詳解]</a><br /></td></tr>
<tr class="separator:gafc59ccbfdafe205cd8ba04f1795ada6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bbd7972e1b1ed778eddbf09ff967b32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8bbd7972e1b1ed778eddbf09ff967b32">nvnPolygonStateGetCullFace</a> (const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon)</td></tr>
<tr class="memdesc:ga8bbd7972e1b1ed778eddbf09ff967b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the control for culling of front- and back-facing polygons.  <a href="#ga8bbd7972e1b1ed778eddbf09ff967b32">[詳解]</a><br /></td></tr>
<tr class="separator:ga8bbd7972e1b1ed778eddbf09ff967b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga462e3ea6a04c604d1fd83a7ef7c4508c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga77dcac47ffba6330842afbc0c57db3c3">NVNfrontFace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga462e3ea6a04c604d1fd83a7ef7c4508c">nvnPolygonStateGetFrontFace</a> (const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon)</td></tr>
<tr class="memdesc:ga462e3ea6a04c604d1fd83a7ef7c4508c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether clockwise or counter-clockwise polygons are considered front-facing.  <a href="#ga462e3ea6a04c604d1fd83a7ef7c4508c">[詳解]</a><br /></td></tr>
<tr class="separator:ga462e3ea6a04c604d1fd83a7ef7c4508c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6b72dd688c4c3e432aacb9af6305520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#gae34b6e4f02d0dae7198337f940340ec6">NVNpolygonMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac6b72dd688c4c3e432aacb9af6305520">nvnPolygonStateGetPolygonMode</a> (const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon)</td></tr>
<tr class="memdesc:gac6b72dd688c4c3e432aacb9af6305520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether polygons are rendered as points, lines, or triangles.  <a href="#gac6b72dd688c4c3e432aacb9af6305520">[詳解]</a><br /></td></tr>
<tr class="separator:gac6b72dd688c4c3e432aacb9af6305520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27a048c2d766c7f3f46f828eb9d963de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga04590c619164a552f5c23b8f096b3d73">NVNpolygonOffsetEnable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga27a048c2d766c7f3f46f828eb9d963de">nvnPolygonStateGetPolygonOffsetEnables</a> (const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon)</td></tr>
<tr class="memdesc:ga27a048c2d766c7f3f46f828eb9d963de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether polygon offset is applied for point-mode, line-mode, and filled polygons.  <a href="#ga27a048c2d766c7f3f46f828eb9d963de">[詳解]</a><br /></td></tr>
<tr class="separator:ga27a048c2d766c7f3f46f828eb9d963de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3520bbbee9b5089521912dacdbdbb4b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3520bbbee9b5089521912dacdbdbb4b6">nvnPolygonStateSetCullFace</a> (<a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon, <a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a> face)</td></tr>
<tr class="memdesc:ga3520bbbee9b5089521912dacdbdbb4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify controls for culling of front- and back-facing polygons.  <a href="#ga3520bbbee9b5089521912dacdbdbb4b6">[詳解]</a><br /></td></tr>
<tr class="separator:ga3520bbbee9b5089521912dacdbdbb4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47c2200da77cbb2c0d7279ecb9311525"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga47c2200da77cbb2c0d7279ecb9311525">nvnPolygonStateSetDefaults</a> (<a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon)</td></tr>
<tr class="memdesc:ga47c2200da77cbb2c0d7279ecb9311525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons. ">NVNpolygonState</a> object.  <a href="#ga47c2200da77cbb2c0d7279ecb9311525">[詳解]</a><br /></td></tr>
<tr class="separator:ga47c2200da77cbb2c0d7279ecb9311525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0de647048323e5c7b6fe8d93a0875cca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0de647048323e5c7b6fe8d93a0875cca">nvnPolygonStateSetFrontFace</a> (<a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon, <a class="el" href="group__nvn__c__enum.html#ga77dcac47ffba6330842afbc0c57db3c3">NVNfrontFace</a> face)</td></tr>
<tr class="memdesc:ga0de647048323e5c7b6fe8d93a0875cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether clockwise or counter-clockwise polygons are considered front-facing.  <a href="#ga0de647048323e5c7b6fe8d93a0875cca">[詳解]</a><br /></td></tr>
<tr class="separator:ga0de647048323e5c7b6fe8d93a0875cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d89993b3e9b7adcee98d5846052cb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae5d89993b3e9b7adcee98d5846052cb5">nvnPolygonStateSetPolygonMode</a> (<a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon, <a class="el" href="group__nvn__c__enum.html#gae34b6e4f02d0dae7198337f940340ec6">NVNpolygonMode</a> polygonMode)</td></tr>
<tr class="memdesc:gae5d89993b3e9b7adcee98d5846052cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether polygons are rendered as points, lines, or triangles.  <a href="#gae5d89993b3e9b7adcee98d5846052cb5">[詳解]</a><br /></td></tr>
<tr class="separator:gae5d89993b3e9b7adcee98d5846052cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5351a8bc94ba8da9a23a17d5e01ff2d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5351a8bc94ba8da9a23a17d5e01ff2d8">nvnPolygonStateSetPolygonOffsetEnables</a> (<a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *polygon, int enables)</td></tr>
<tr class="memdesc:ga5351a8bc94ba8da9a23a17d5e01ff2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether polygon offset is applied for point-mode, line-mode, and filled polygons.  <a href="#ga5351a8bc94ba8da9a23a17d5e01ff2d8">[詳解]</a><br /></td></tr>
<tr class="separator:ga5351a8bc94ba8da9a23a17d5e01ff2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24bd32154585c557cea6e061aecb6000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga24bd32154585c557cea6e061aecb6000">nvnProgramFinalize</a> (<a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *program)</td></tr>
<tr class="memdesc:ga24bd32154585c557cea6e061aecb6000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives. ">NVNprogram</a> object.  <a href="#ga24bd32154585c557cea6e061aecb6000">[詳解]</a><br /></td></tr>
<tr class="separator:ga24bd32154585c557cea6e061aecb6000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94b5dc5a5043495db9e6c3bc41ed6098"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga94b5dc5a5043495db9e6c3bc41ed6098">nvnProgramInitialize</a> (<a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *program, <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:ga94b5dc5a5043495db9e6c3bc41ed6098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives. ">NVNprogram</a> object for the specified device.  <a href="#ga94b5dc5a5043495db9e6c3bc41ed6098">[詳解]</a><br /></td></tr>
<tr class="separator:ga94b5dc5a5043495db9e6c3bc41ed6098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cae86887480bb2aac1d98a5a4f94f68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5cae86887480bb2aac1d98a5a4f94f68">nvnProgramSetDebugLabel</a> (<a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *program, const char *label)</td></tr>
<tr class="memdesc:ga5cae86887480bb2aac1d98a5a4f94f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives. ">NVNprogram</a> object.  <a href="#ga5cae86887480bb2aac1d98a5a4f94f68">[詳解]</a><br /></td></tr>
<tr class="separator:ga5cae86887480bb2aac1d98a5a4f94f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6a517c8312bcaea2bafddfdf59f426a"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad6a517c8312bcaea2bafddfdf59f426a">nvnProgramSetShaders</a> (<a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *program, int count, const <a class="el" href="struct_n_v_nshader_data.html">NVNshaderData</a> *stageData)</td></tr>
<tr class="memdesc:gad6a517c8312bcaea2bafddfdf59f426a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a program object to use pre-compiled GPU code from one or multiple shaders.  <a href="#gad6a517c8312bcaea2bafddfdf59f426a">[詳解]</a><br /></td></tr>
<tr class="separator:gad6a517c8312bcaea2bafddfdf59f426a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe101d51f91200d5c59c756b8f754961"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gafe101d51f91200d5c59c756b8f754961">nvnProgramSetSubroutineLinkage</a> (<a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *program, int count, const <a class="el" href="group__nvn__c__api__typedefs.html#gab66e1162e92eb9ed7611be8e01118116">NVNsubroutineLinkageMapPtr</a> *linkageMapPtrs)</td></tr>
<tr class="memdesc:gafe101d51f91200d5c59c756b8f754961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the program's subroutine linkage maps for future use with nvnCommandBufferSetProgramSubroutines.  <a href="#gafe101d51f91200d5c59c756b8f754961">[詳解]</a><br /></td></tr>
<tr class="separator:gafe101d51f91200d5c59c756b8f754961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae29950b5f011bc5cbc190659c4e335ab"><td class="memItemLeft" align="right" valign="top">NVN_PRE_DEPRECATED <a class="el" href="group__nvn__c__enum.html#gad3bc319f6ddc7241c7001442771fcb8f">NVNqueueAcquireTextureResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae29950b5f011bc5cbc190659c4e335ab">nvnQueueAcquireTexture</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue, <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window, int *textureIndex) NVN_POST_DEPRECATED</td></tr>
<tr class="memdesc:gae29950b5f011bc5cbc190659c4e335ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire a texture from the window.  <a href="#gae29950b5f011bc5cbc190659c4e335ab">[詳解]</a><br /></td></tr>
<tr class="separator:gae29950b5f011bc5cbc190659c4e335ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga620c9128e6758213a4fecaf7ce6fccea"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga620c9128e6758213a4fecaf7ce6fccea">nvnQueueBuilderGetCommandFlushThreshold</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, int *flushThreshold)</td></tr>
<tr class="memdesc:ga620c9128e6758213a4fecaf7ce6fccea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the command flush threshold associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object.  <a href="#ga620c9128e6758213a4fecaf7ce6fccea">[詳解]</a><br /></td></tr>
<tr class="separator:ga620c9128e6758213a4fecaf7ce6fccea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12df64513ce3e52474dc6a091cd3616d"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga12df64513ce3e52474dc6a091cd3616d">nvnQueueBuilderGetCommandMemorySize</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, int *size)</td></tr>
<tr class="memdesc:ga12df64513ce3e52474dc6a091cd3616d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the command memory size associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object.  <a href="#ga12df64513ce3e52474dc6a091cd3616d">[詳解]</a><br /></td></tr>
<tr class="separator:ga12df64513ce3e52474dc6a091cd3616d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf728cfa48fe1665b195f0bbcb7ece385"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf728cfa48fe1665b195f0bbcb7ece385">nvnQueueBuilderGetComputeMemorySize</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, int *size)</td></tr>
<tr class="memdesc:gaf728cfa48fe1665b195f0bbcb7ece385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the compute memory size associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object.  <a href="#gaf728cfa48fe1665b195f0bbcb7ece385">[詳解]</a><br /></td></tr>
<tr class="separator:gaf728cfa48fe1665b195f0bbcb7ece385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0be1544f07aa9d9c50f0d7a6261df8f3"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0be1544f07aa9d9c50f0d7a6261df8f3">nvnQueueBuilderGetControlMemorySize</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, int *size)</td></tr>
<tr class="memdesc:ga0be1544f07aa9d9c50f0d7a6261df8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the control memory size associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object.  <a href="#ga0be1544f07aa9d9c50f0d7a6261df8f3">[詳解]</a><br /></td></tr>
<tr class="separator:ga0be1544f07aa9d9c50f0d7a6261df8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea2b90419b41e5ece6af3edd45129d32"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaea2b90419b41e5ece6af3edd45129d32">nvnQueueBuilderGetDevice</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaea2b90419b41e5ece6af3edd45129d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object.  <a href="#gaea2b90419b41e5ece6af3edd45129d32">[詳解]</a><br /></td></tr>
<tr class="separator:gaea2b90419b41e5ece6af3edd45129d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bbd3d283a12e7b08f06f006dbebee66"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7bbd3d283a12e7b08f06f006dbebee66">nvnQueueBuilderGetFlags</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga7bbd3d283a12e7b08f06f006dbebee66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get queue flags associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object.  <a href="#ga7bbd3d283a12e7b08f06f006dbebee66">[詳解]</a><br /></td></tr>
<tr class="separator:ga7bbd3d283a12e7b08f06f006dbebee66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga272f5fc06e59a8c193abb2ad86ad6900"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga272f5fc06e59a8c193abb2ad86ad6900">nvnQueueBuilderGetMemory</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga272f5fc06e59a8c193abb2ad86ad6900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object.  <a href="#ga272f5fc06e59a8c193abb2ad86ad6900">[詳解]</a><br /></td></tr>
<tr class="separator:ga272f5fc06e59a8c193abb2ad86ad6900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8ddabb30dcd2193f80184a22a395b13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf8ddabb30dcd2193f80184a22a395b13">nvnQueueBuilderGetMemorySize</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaf8ddabb30dcd2193f80184a22a395b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the memory associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object.  <a href="#gaf8ddabb30dcd2193f80184a22a395b13">[詳解]</a><br /></td></tr>
<tr class="separator:gaf8ddabb30dcd2193f80184a22a395b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2903b2910d9471307595962237d3c578"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2903b2910d9471307595962237d3c578">nvnQueueBuilderGetQueueMemorySize</a> (const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga2903b2910d9471307595962237d3c578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the amount of extra memory needed for a queue initialized using a <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a>.  <a href="#ga2903b2910d9471307595962237d3c578">[詳解]</a><br /></td></tr>
<tr class="separator:ga2903b2910d9471307595962237d3c578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4de1469ce962b138ca454c034f6e649b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4de1469ce962b138ca454c034f6e649b">nvnQueueBuilderSetCommandFlushThreshold</a> (<a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, size_t threshold)</td></tr>
<tr class="memdesc:ga4de1469ce962b138ca454c034f6e649b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a flush threshold for a new <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object.  <a href="#ga4de1469ce962b138ca454c034f6e649b">[詳解]</a><br /></td></tr>
<tr class="separator:ga4de1469ce962b138ca454c034f6e649b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4291be788552aa888e9551d0e1084bfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4291be788552aa888e9551d0e1084bfb">nvnQueueBuilderSetCommandMemorySize</a> (<a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, size_t size)</td></tr>
<tr class="memdesc:ga4291be788552aa888e9551d0e1084bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the size of the internal command buffer used by a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object.  <a href="#ga4291be788552aa888e9551d0e1084bfb">[詳解]</a><br /></td></tr>
<tr class="separator:ga4291be788552aa888e9551d0e1084bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga161b2d39535ffac2829d972058391bb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga161b2d39535ffac2829d972058391bb6">nvnQueueBuilderSetComputeMemorySize</a> (<a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, size_t size)</td></tr>
<tr class="memdesc:ga161b2d39535ffac2829d972058391bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the size of the internal buffers used for compute dispatches in a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object.  <a href="#ga161b2d39535ffac2829d972058391bb6">[詳解]</a><br /></td></tr>
<tr class="separator:ga161b2d39535ffac2829d972058391bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef123992e515f2eac2af9fecad8634a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaef123992e515f2eac2af9fecad8634a9">nvnQueueBuilderSetControlMemorySize</a> (<a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, size_t size)</td></tr>
<tr class="memdesc:gaef123992e515f2eac2af9fecad8634a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the size of the control memory buffer used by a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object.  <a href="#gaef123992e515f2eac2af9fecad8634a9">[詳解]</a><br /></td></tr>
<tr class="separator:gaef123992e515f2eac2af9fecad8634a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20bc093a367e06cd1f1f273289354b75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga20bc093a367e06cd1f1f273289354b75">nvnQueueBuilderSetDefaults</a> (<a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga20bc093a367e06cd1f1f273289354b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object.  <a href="#ga20bc093a367e06cd1f1f273289354b75">[詳解]</a><br /></td></tr>
<tr class="separator:ga20bc093a367e06cd1f1f273289354b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fdbe1fc82e21cf370aa7f1fa0a6141a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7fdbe1fc82e21cf370aa7f1fa0a6141a">nvnQueueBuilderSetDevice</a> (<a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:ga7fdbe1fc82e21cf370aa7f1fa0a6141a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object.  <a href="#ga7fdbe1fc82e21cf370aa7f1fa0a6141a">[詳解]</a><br /></td></tr>
<tr class="separator:ga7fdbe1fc82e21cf370aa7f1fa0a6141a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1665885cd6a9f8b9c3fbac546243b440"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1665885cd6a9f8b9c3fbac546243b440">nvnQueueBuilderSetFlags</a> (<a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, int flags)</td></tr>
<tr class="memdesc:ga1665885cd6a9f8b9c3fbac546243b440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set properties of <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> objects created from the builder.  <a href="#ga1665885cd6a9f8b9c3fbac546243b440">[詳解]</a><br /></td></tr>
<tr class="separator:ga1665885cd6a9f8b9c3fbac546243b440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0403d233aff80ce9cc6548b5dbe24ca2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0403d233aff80ce9cc6548b5dbe24ca2">nvnQueueBuilderSetQueueMemory</a> (<a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder, void *memory, size_t size)</td></tr>
<tr class="memdesc:ga0403d233aff80ce9cc6548b5dbe24ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides memory to be used by queues pools initialized using a <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a>.  <a href="#ga0403d233aff80ce9cc6548b5dbe24ca2">[詳解]</a><br /></td></tr>
<tr class="separator:ga0403d233aff80ce9cc6548b5dbe24ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae646129720b27503c239a22db9653fa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae646129720b27503c239a22db9653fa0">nvnQueueFenceSync</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue, <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *sync, <a class="el" href="group__nvn__c__enum.html#ga6ab26a343b68da722799167ea97ec69d">NVNsyncCondition</a> condition, int flags)</td></tr>
<tr class="memdesc:gae646129720b27503c239a22db9653fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object as signaled when all previous commands have completed in the <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object.  <a href="#gae646129720b27503c239a22db9653fa0">[詳解]</a><br /></td></tr>
<tr class="separator:gae646129720b27503c239a22db9653fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54ac57de39c708eb9758bae7770d5ccc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga54ac57de39c708eb9758bae7770d5ccc">nvnQueueFinalize</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue)</td></tr>
<tr class="memdesc:ga54ac57de39c708eb9758bae7770d5ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object.  <a href="#ga54ac57de39c708eb9758bae7770d5ccc">[詳解]</a><br /></td></tr>
<tr class="separator:ga54ac57de39c708eb9758bae7770d5ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab3c15f657cefdff33dab453795ff38f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaab3c15f657cefdff33dab453795ff38f">nvnQueueFinish</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue)</td></tr>
<tr class="memdesc:gaab3c15f657cefdff33dab453795ff38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until all commands previously submitted to a queue have completed execution.  <a href="#gaab3c15f657cefdff33dab453795ff38f">[詳解]</a><br /></td></tr>
<tr class="separator:gaab3c15f657cefdff33dab453795ff38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98feac9fc906eb1a9a5eb19ef4381b46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga98feac9fc906eb1a9a5eb19ef4381b46">nvnQueueFlush</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue)</td></tr>
<tr class="memdesc:ga98feac9fc906eb1a9a5eb19ef4381b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush commands previously submitted to a queue for processing.  <a href="#ga98feac9fc906eb1a9a5eb19ef4381b46">[詳解]</a><br /></td></tr>
<tr class="separator:ga98feac9fc906eb1a9a5eb19ef4381b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81cb87eb9eba8acd7de1fa80ab673ab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga2a36e1011d80409e1d1cd7c87e81035c">NVNqueueGetErrorResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga81cb87eb9eba8acd7de1fa80ab673ab7">nvnQueueGetError</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue, <a class="el" href="union_n_v_nqueue_error_info.html">NVNqueueErrorInfo</a> *errorInfo)</td></tr>
<tr class="memdesc:ga81cb87eb9eba8acd7de1fa80ab673ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get GPU error status of the queue.  <a href="#ga81cb87eb9eba8acd7de1fa80ab673ab7">[詳解]</a><br /></td></tr>
<tr class="separator:ga81cb87eb9eba8acd7de1fa80ab673ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc96e4b44f4c1fa2540ecbcb37c4fe62"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacc96e4b44f4c1fa2540ecbcb37c4fe62">nvnQueueGetTotalCommandMemoryUsed</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue)</td></tr>
<tr class="memdesc:gacc96e4b44f4c1fa2540ecbcb37c4fe62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query total queue command memory usage.  <a href="#gacc96e4b44f4c1fa2540ecbcb37c4fe62">[詳解]</a><br /></td></tr>
<tr class="separator:gacc96e4b44f4c1fa2540ecbcb37c4fe62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70fb17ac6a5d34a7e8eb17a8d1e9a28e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga70fb17ac6a5d34a7e8eb17a8d1e9a28e">nvnQueueGetTotalComputeMemoryUsed</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue)</td></tr>
<tr class="memdesc:ga70fb17ac6a5d34a7e8eb17a8d1e9a28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query total queue compute memory usage.  <a href="#ga70fb17ac6a5d34a7e8eb17a8d1e9a28e">[詳解]</a><br /></td></tr>
<tr class="separator:ga70fb17ac6a5d34a7e8eb17a8d1e9a28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f0889104e9531bc404a133456bad956"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1f0889104e9531bc404a133456bad956">nvnQueueGetTotalControlMemoryUsed</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue)</td></tr>
<tr class="memdesc:ga1f0889104e9531bc404a133456bad956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query total queue control memory usage.  <a href="#ga1f0889104e9531bc404a133456bad956">[詳解]</a><br /></td></tr>
<tr class="separator:ga1f0889104e9531bc404a133456bad956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga512027cc783d925feb7261915130e2ca"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga512027cc783d925feb7261915130e2ca">nvnQueueInitialize</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue, const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga512027cc783d925feb7261915130e2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object from a queue builder.  <a href="#ga512027cc783d925feb7261915130e2ca">[詳解]</a><br /></td></tr>
<tr class="separator:ga512027cc783d925feb7261915130e2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad317e78382b7f51a7a6f0504193d90c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad317e78382b7f51a7a6f0504193d90c7">nvnQueuePresentTexture</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue, <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window, int textureIndex)</td></tr>
<tr class="memdesc:gad317e78382b7f51a7a6f0504193d90c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display the contents of a texture into the window.  <a href="#gad317e78382b7f51a7a6f0504193d90c7">[詳解]</a><br /></td></tr>
<tr class="separator:gad317e78382b7f51a7a6f0504193d90c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae59349fe88c0a1e539a891b79e1bff72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae59349fe88c0a1e539a891b79e1bff72">nvnQueueResetMemoryUsageCounts</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue)</td></tr>
<tr class="memdesc:gae59349fe88c0a1e539a891b79e1bff72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset usage counters for command, control and compute memory.  <a href="#gae59349fe88c0a1e539a891b79e1bff72">[詳解]</a><br /></td></tr>
<tr class="separator:gae59349fe88c0a1e539a891b79e1bff72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c90495a1a43ec403d590ee7603057ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0c90495a1a43ec403d590ee7603057ec">nvnQueueSetDebugLabel</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue, const char *label)</td></tr>
<tr class="memdesc:ga0c90495a1a43ec403d590ee7603057ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object.  <a href="#ga0c90495a1a43ec403d590ee7603057ec">[詳解]</a><br /></td></tr>
<tr class="separator:ga0c90495a1a43ec403d590ee7603057ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga095fabdb4c81459bbe496ba45528211b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga095fabdb4c81459bbe496ba45528211b">nvnQueueSubmitCommands</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue, int numCommands, const <a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> *handles)</td></tr>
<tr class="memdesc:ga095fabdb4c81459bbe496ba45528211b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit commands encapsulated in command buffers to a queue for processing.  <a href="#ga095fabdb4c81459bbe496ba45528211b">[詳解]</a><br /></td></tr>
<tr class="separator:ga095fabdb4c81459bbe496ba45528211b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad28b8279c1f539d143c1902212df11f"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaad28b8279c1f539d143c1902212df11f">nvnQueueWaitSync</a> (<a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *queue, const <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *sync)</td></tr>
<tr class="memdesc:gaad28b8279c1f539d143c1902212df11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object to be signaled on the GPU before processing any further commands in the specified <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object.  <a href="#gaad28b8279c1f539d143c1902212df11f">[詳解]</a><br /></td></tr>
<tr class="separator:gaad28b8279c1f539d143c1902212df11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83e8344bbc081cb9ba7464b5e3436c47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga83e8344bbc081cb9ba7464b5e3436c47">nvnSamplerBuilderGetBorderColor</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, float *borderColor)</td></tr>
<tr class="memdesc:ga83e8344bbc081cb9ba7464b5e3436c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query floating-point border color values for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object.  <a href="#ga83e8344bbc081cb9ba7464b5e3436c47">[詳解]</a><br /></td></tr>
<tr class="separator:ga83e8344bbc081cb9ba7464b5e3436c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fd5ad1183b027c260ec36d73c6ee3bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7fd5ad1183b027c260ec36d73c6ee3bf">nvnSamplerBuilderGetBorderColori</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, int *borderColor)</td></tr>
<tr class="memdesc:ga7fd5ad1183b027c260ec36d73c6ee3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query signed integer border color values for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object.  <a href="#ga7fd5ad1183b027c260ec36d73c6ee3bf">[詳解]</a><br /></td></tr>
<tr class="separator:ga7fd5ad1183b027c260ec36d73c6ee3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8354e069c30e1e18a0581471daf66409"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8354e069c30e1e18a0581471daf66409">nvnSamplerBuilderGetBorderColorui</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, uint32_t *borderColor)</td></tr>
<tr class="memdesc:ga8354e069c30e1e18a0581471daf66409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query unsigned integer border color values for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object.  <a href="#ga8354e069c30e1e18a0581471daf66409">[詳解]</a><br /></td></tr>
<tr class="separator:ga8354e069c30e1e18a0581471daf66409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga759f6c95513d59fe4239f85eeac0a534"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga759f6c95513d59fe4239f85eeac0a534">nvnSamplerBuilderGetCompare</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#gaa5f726f373cd522aa586a0b26a34fb3d">NVNcompareMode</a> *mode, <a class="el" href="group__nvn__c__enum.html#ga83d020997abcffbd763d2ca9e7b1aff6">NVNcompareFunc</a> *func)</td></tr>
<tr class="memdesc:ga759f6c95513d59fe4239f85eeac0a534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth comparison modes for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object.  <a href="#ga759f6c95513d59fe4239f85eeac0a534">[詳解]</a><br /></td></tr>
<tr class="separator:ga759f6c95513d59fe4239f85eeac0a534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8362d8f866fe4e0f19bf075d801f7220"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8362d8f866fe4e0f19bf075d801f7220">nvnSamplerBuilderGetDevice</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga8362d8f866fe4e0f19bf075d801f7220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the device associated with this <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object.  <a href="#ga8362d8f866fe4e0f19bf075d801f7220">[詳解]</a><br /></td></tr>
<tr class="separator:ga8362d8f866fe4e0f19bf075d801f7220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae616d8490657704e4afae4dce930f03f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae616d8490657704e4afae4dce930f03f">nvnSamplerBuilderGetLodBias</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:gae616d8490657704e4afae4dce930f03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the level-of-detail bias for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object.  <a href="#gae616d8490657704e4afae4dce930f03f">[詳解]</a><br /></td></tr>
<tr class="separator:gae616d8490657704e4afae4dce930f03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe25c536260b86ccfde63a91d187c6c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabe25c536260b86ccfde63a91d187c6c9">nvnSamplerBuilderGetLodClamp</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, float *min, float *max)</td></tr>
<tr class="memdesc:gabe25c536260b86ccfde63a91d187c6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the minimum and maximum level of detail in a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object.  <a href="#gabe25c536260b86ccfde63a91d187c6c9">[詳解]</a><br /></td></tr>
<tr class="separator:gabe25c536260b86ccfde63a91d187c6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4da85e68ee693bfffd871cace32923c0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4da85e68ee693bfffd871cace32923c0">nvnSamplerBuilderGetLodSnap</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga4da85e68ee693bfffd871cace32923c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the LOD snap for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object.  <a href="#ga4da85e68ee693bfffd871cace32923c0">[詳解]</a><br /></td></tr>
<tr class="separator:ga4da85e68ee693bfffd871cace32923c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ee3fc56d9b39c67402c04802437976f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1ee3fc56d9b39c67402c04802437976f">nvnSamplerBuilderGetMaxAnisotropy</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga1ee3fc56d9b39c67402c04802437976f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the maximum level of anisotropy for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object.  <a href="#ga1ee3fc56d9b39c67402c04802437976f">[詳解]</a><br /></td></tr>
<tr class="separator:ga1ee3fc56d9b39c67402c04802437976f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a7a2b46cc8ada75360ac6b0bd73257"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab3a7a2b46cc8ada75360ac6b0bd73257">nvnSamplerBuilderGetMinMagFilter</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#ga41610125d2ee1e59db15c26f9a1288c5">NVNminFilter</a> *min, <a class="el" href="group__nvn__c__enum.html#ga7f4e9b2ce71bbd9c4c2de6b3cfc293dc">NVNmagFilter</a> *mag)</td></tr>
<tr class="memdesc:gab3a7a2b46cc8ada75360ac6b0bd73257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the minification and magnification filters for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object.  <a href="#gab3a7a2b46cc8ada75360ac6b0bd73257">[詳解]</a><br /></td></tr>
<tr class="separator:gab3a7a2b46cc8ada75360ac6b0bd73257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabefac5ca39cb0fb81d4fc8b53a031515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga867b21c764db6c0573e9fc68e1b83437">NVNsamplerReduction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabefac5ca39cb0fb81d4fc8b53a031515">nvnSamplerBuilderGetReductionFilter</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:gabefac5ca39cb0fb81d4fc8b53a031515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the reduction filter for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object.  <a href="#gabefac5ca39cb0fb81d4fc8b53a031515">[詳解]</a><br /></td></tr>
<tr class="separator:gabefac5ca39cb0fb81d4fc8b53a031515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86f90d77048555a8d81b586536752299"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga86f90d77048555a8d81b586536752299">nvnSamplerBuilderGetWrapMode</a> (const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *s, <a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *t, <a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *r)</td></tr>
<tr class="memdesc:ga86f90d77048555a8d81b586536752299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the coordinate wrap modes for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object.  <a href="#ga86f90d77048555a8d81b586536752299">[詳解]</a><br /></td></tr>
<tr class="separator:ga86f90d77048555a8d81b586536752299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58d007814dbbe79756a873c62077f8f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga58d007814dbbe79756a873c62077f8f0">nvnSamplerBuilderSetBorderColor</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, const float *borderColor)</td></tr>
<tr class="memdesc:ga58d007814dbbe79756a873c62077f8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set floating-point border color values used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>.  <a href="#ga58d007814dbbe79756a873c62077f8f0">[詳解]</a><br /></td></tr>
<tr class="separator:ga58d007814dbbe79756a873c62077f8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae65d26314f7fcc219ac81cd331037cee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae65d26314f7fcc219ac81cd331037cee">nvnSamplerBuilderSetBorderColori</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, const int *borderColor)</td></tr>
<tr class="memdesc:gae65d26314f7fcc219ac81cd331037cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set signed integer border color values used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>.  <a href="#gae65d26314f7fcc219ac81cd331037cee">[詳解]</a><br /></td></tr>
<tr class="separator:gae65d26314f7fcc219ac81cd331037cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga620e4e3a9f487eaaab3b1ff4e7854bde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga620e4e3a9f487eaaab3b1ff4e7854bde">nvnSamplerBuilderSetBorderColorui</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, const uint32_t *borderColor)</td></tr>
<tr class="memdesc:ga620e4e3a9f487eaaab3b1ff4e7854bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set unsigned integer border color values used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>.  <a href="#ga620e4e3a9f487eaaab3b1ff4e7854bde">[詳解]</a><br /></td></tr>
<tr class="separator:ga620e4e3a9f487eaaab3b1ff4e7854bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61212f6d7e261272b3f3d8a2bedb7fd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga61212f6d7e261272b3f3d8a2bedb7fd4">nvnSamplerBuilderSetCompare</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#gaa5f726f373cd522aa586a0b26a34fb3d">NVNcompareMode</a> mode, <a class="el" href="group__nvn__c__enum.html#ga83d020997abcffbd763d2ca9e7b1aff6">NVNcompareFunc</a> func)</td></tr>
<tr class="memdesc:ga61212f6d7e261272b3f3d8a2bedb7fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the depth comparison mode used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>.  <a href="#ga61212f6d7e261272b3f3d8a2bedb7fd4">[詳解]</a><br /></td></tr>
<tr class="separator:ga61212f6d7e261272b3f3d8a2bedb7fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga889b306858059648c66e88a226391acc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga889b306858059648c66e88a226391acc">nvnSamplerBuilderSetDefaults</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga889b306858059648c66e88a226391acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object.  <a href="#ga889b306858059648c66e88a226391acc">[詳解]</a><br /></td></tr>
<tr class="separator:ga889b306858059648c66e88a226391acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7504233cce44b1f5a7223f322b76a84d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7504233cce44b1f5a7223f322b76a84d">nvnSamplerBuilderSetDevice</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:ga7504233cce44b1f5a7223f322b76a84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object.  <a href="#ga7504233cce44b1f5a7223f322b76a84d">[詳解]</a><br /></td></tr>
<tr class="separator:ga7504233cce44b1f5a7223f322b76a84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21c8ec90c03a9ba5c53824bfb9c1eee6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga21c8ec90c03a9ba5c53824bfb9c1eee6">nvnSamplerBuilderSetLodBias</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, float bias)</td></tr>
<tr class="memdesc:ga21c8ec90c03a9ba5c53824bfb9c1eee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the level-of-detail bias used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>.  <a href="#ga21c8ec90c03a9ba5c53824bfb9c1eee6">[詳解]</a><br /></td></tr>
<tr class="separator:ga21c8ec90c03a9ba5c53824bfb9c1eee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd10e1f2dc492fdf600365ef94945170"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacd10e1f2dc492fdf600365ef94945170">nvnSamplerBuilderSetLodClamp</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, float min, float max)</td></tr>
<tr class="memdesc:gacd10e1f2dc492fdf600365ef94945170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum and maximum level of detail used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>.  <a href="#gacd10e1f2dc492fdf600365ef94945170">[詳解]</a><br /></td></tr>
<tr class="separator:gacd10e1f2dc492fdf600365ef94945170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7165b9753b8ce20db7f8658c918fb686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7165b9753b8ce20db7f8658c918fb686">nvnSamplerBuilderSetLodSnap</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, float lodSnap)</td></tr>
<tr class="memdesc:ga7165b9753b8ce20db7f8658c918fb686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set LOD snap used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>.  <a href="#ga7165b9753b8ce20db7f8658c918fb686">[詳解]</a><br /></td></tr>
<tr class="separator:ga7165b9753b8ce20db7f8658c918fb686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211345dfd517cb8458313d2bd00df0a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga211345dfd517cb8458313d2bd00df0a9">nvnSamplerBuilderSetMaxAnisotropy</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, float maxAniso)</td></tr>
<tr class="memdesc:ga211345dfd517cb8458313d2bd00df0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum level of anisotropy used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>.  <a href="#ga211345dfd517cb8458313d2bd00df0a9">[詳解]</a><br /></td></tr>
<tr class="separator:ga211345dfd517cb8458313d2bd00df0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f634bd122e2b47cbebfeb16cda8352f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0f634bd122e2b47cbebfeb16cda8352f">nvnSamplerBuilderSetMinMagFilter</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#ga41610125d2ee1e59db15c26f9a1288c5">NVNminFilter</a> min, <a class="el" href="group__nvn__c__enum.html#ga7f4e9b2ce71bbd9c4c2de6b3cfc293dc">NVNmagFilter</a> mag)</td></tr>
<tr class="memdesc:ga0f634bd122e2b47cbebfeb16cda8352f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minification and magnification filters for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>.  <a href="#ga0f634bd122e2b47cbebfeb16cda8352f">[詳解]</a><br /></td></tr>
<tr class="separator:ga0f634bd122e2b47cbebfeb16cda8352f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c077843893df456f4abff6862b4d467"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3c077843893df456f4abff6862b4d467">nvnSamplerBuilderSetReductionFilter</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#ga867b21c764db6c0573e9fc68e1b83437">NVNsamplerReduction</a> filter)</td></tr>
<tr class="memdesc:ga3c077843893df456f4abff6862b4d467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reduction filter used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>.  <a href="#ga3c077843893df456f4abff6862b4d467">[詳解]</a><br /></td></tr>
<tr class="separator:ga3c077843893df456f4abff6862b4d467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63aec39a3ab8401a6e287d2024c74e2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga63aec39a3ab8401a6e287d2024c74e2f">nvnSamplerBuilderSetWrapMode</a> (<a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> s, <a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> t, <a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> r)</td></tr>
<tr class="memdesc:ga63aec39a3ab8401a6e287d2024c74e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the coordinate wrap modes for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>.  <a href="#ga63aec39a3ab8401a6e287d2024c74e2f">[詳解]</a><br /></td></tr>
<tr class="separator:ga63aec39a3ab8401a6e287d2024c74e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga530d7f40e1ddc78fcb447d1950f2b471"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga530d7f40e1ddc78fcb447d1950f2b471">nvnSamplerCompare</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *otherSampler)</td></tr>
<tr class="memdesc:ga530d7f40e1ddc78fcb447d1950f2b471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if sampler objects are equivalent.  <a href="#ga530d7f40e1ddc78fcb447d1950f2b471">[詳解]</a><br /></td></tr>
<tr class="separator:ga530d7f40e1ddc78fcb447d1950f2b471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82945a36dea04505dcd29e03442ed5a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga82945a36dea04505dcd29e03442ed5a6">nvnSamplerFinalize</a> (<a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler)</td></tr>
<tr class="memdesc:ga82945a36dea04505dcd29e03442ed5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object.  <a href="#ga82945a36dea04505dcd29e03442ed5a6">[詳解]</a><br /></td></tr>
<tr class="separator:ga82945a36dea04505dcd29e03442ed5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05bf524362b220a01368041d936a5473"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga05bf524362b220a01368041d936a5473">nvnSamplerGetBorderColor</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, float *borderColor)</td></tr>
<tr class="memdesc:ga05bf524362b220a01368041d936a5473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query floating-point border color values for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object.  <a href="#ga05bf524362b220a01368041d936a5473">[詳解]</a><br /></td></tr>
<tr class="separator:ga05bf524362b220a01368041d936a5473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42f49191e28dd92309cd80f79c71d325"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga42f49191e28dd92309cd80f79c71d325">nvnSamplerGetBorderColori</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, int *borderColor)</td></tr>
<tr class="memdesc:ga42f49191e28dd92309cd80f79c71d325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query signed integer border color values for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object.  <a href="#ga42f49191e28dd92309cd80f79c71d325">[詳解]</a><br /></td></tr>
<tr class="separator:ga42f49191e28dd92309cd80f79c71d325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09cffaeae4405d2a9b3b8b2054002c29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga09cffaeae4405d2a9b3b8b2054002c29">nvnSamplerGetBorderColorui</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, uint32_t *borderColor)</td></tr>
<tr class="memdesc:ga09cffaeae4405d2a9b3b8b2054002c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query unsigned integer border color values for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object.  <a href="#ga09cffaeae4405d2a9b3b8b2054002c29">[詳解]</a><br /></td></tr>
<tr class="separator:ga09cffaeae4405d2a9b3b8b2054002c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf974179c68b5aeebac1e821b757235da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf974179c68b5aeebac1e821b757235da">nvnSamplerGetCompare</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, <a class="el" href="group__nvn__c__enum.html#gaa5f726f373cd522aa586a0b26a34fb3d">NVNcompareMode</a> *mode, <a class="el" href="group__nvn__c__enum.html#ga83d020997abcffbd763d2ca9e7b1aff6">NVNcompareFunc</a> *func)</td></tr>
<tr class="memdesc:gaf974179c68b5aeebac1e821b757235da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth comparison modes for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object.  <a href="#gaf974179c68b5aeebac1e821b757235da">[詳解]</a><br /></td></tr>
<tr class="separator:gaf974179c68b5aeebac1e821b757235da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bedba0ca7bda287c734f16e1124d303"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7bedba0ca7bda287c734f16e1124d303">nvnSamplerGetDebugID</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler)</td></tr>
<tr class="memdesc:ga7bedba0ca7bda287c734f16e1124d303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug layer unique ID of this sampler.  <a href="#ga7bedba0ca7bda287c734f16e1124d303">[詳解]</a><br /></td></tr>
<tr class="separator:ga7bedba0ca7bda287c734f16e1124d303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94a996072e4bfcf92d86b6866a28d511"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga94a996072e4bfcf92d86b6866a28d511">nvnSamplerGetLodBias</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler)</td></tr>
<tr class="memdesc:ga94a996072e4bfcf92d86b6866a28d511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the level-of-detail bias for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object.  <a href="#ga94a996072e4bfcf92d86b6866a28d511">[詳解]</a><br /></td></tr>
<tr class="separator:ga94a996072e4bfcf92d86b6866a28d511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3ffb490c3ac760043e8fd7539344341"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae3ffb490c3ac760043e8fd7539344341">nvnSamplerGetLodClamp</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, float *min, float *max)</td></tr>
<tr class="memdesc:gae3ffb490c3ac760043e8fd7539344341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the minimum and maximum level of detail in a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object.  <a href="#gae3ffb490c3ac760043e8fd7539344341">[詳解]</a><br /></td></tr>
<tr class="separator:gae3ffb490c3ac760043e8fd7539344341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25e6287ab1146df61fe42a501d93abaf"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga25e6287ab1146df61fe42a501d93abaf">nvnSamplerGetMaxAnisotropy</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler)</td></tr>
<tr class="memdesc:ga25e6287ab1146df61fe42a501d93abaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the maximum level of anisotropy for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object.  <a href="#ga25e6287ab1146df61fe42a501d93abaf">[詳解]</a><br /></td></tr>
<tr class="separator:ga25e6287ab1146df61fe42a501d93abaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bacdf25415f1169fff22060eae02d85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2bacdf25415f1169fff22060eae02d85">nvnSamplerGetMinMagFilter</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, <a class="el" href="group__nvn__c__enum.html#ga41610125d2ee1e59db15c26f9a1288c5">NVNminFilter</a> *min, <a class="el" href="group__nvn__c__enum.html#ga7f4e9b2ce71bbd9c4c2de6b3cfc293dc">NVNmagFilter</a> *mag)</td></tr>
<tr class="memdesc:ga2bacdf25415f1169fff22060eae02d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the minification and magnification filters for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object.  <a href="#ga2bacdf25415f1169fff22060eae02d85">[詳解]</a><br /></td></tr>
<tr class="separator:ga2bacdf25415f1169fff22060eae02d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga476d91292dcfa379c72a31f17bb1e1bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga867b21c764db6c0573e9fc68e1b83437">NVNsamplerReduction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga476d91292dcfa379c72a31f17bb1e1bd">nvnSamplerGetReductionFilter</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler)</td></tr>
<tr class="memdesc:ga476d91292dcfa379c72a31f17bb1e1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the reduction filter for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object.  <a href="#ga476d91292dcfa379c72a31f17bb1e1bd">[詳解]</a><br /></td></tr>
<tr class="separator:ga476d91292dcfa379c72a31f17bb1e1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2f6cd6c8e394fb4357615ae4d6e6590"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae2f6cd6c8e394fb4357615ae4d6e6590">nvnSamplerGetWrapMode</a> (const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, <a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *s, <a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *t, <a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *r)</td></tr>
<tr class="memdesc:gae2f6cd6c8e394fb4357615ae4d6e6590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the coordinate wrap modes for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object.  <a href="#gae2f6cd6c8e394fb4357615ae4d6e6590">[詳解]</a><br /></td></tr>
<tr class="separator:gae2f6cd6c8e394fb4357615ae4d6e6590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f3728966dc1ce72231c88bd3bca94ad"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5f3728966dc1ce72231c88bd3bca94ad">nvnSamplerInitialize</a> (<a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga5f3728966dc1ce72231c88bd3bca94ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object using the specified <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object.  <a href="#ga5f3728966dc1ce72231c88bd3bca94ad">[詳解]</a><br /></td></tr>
<tr class="separator:ga5f3728966dc1ce72231c88bd3bca94ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f34faa24cf7902685de6c5c58e3b370"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0f34faa24cf7902685de6c5c58e3b370">nvnSamplerPoolFinalize</a> (<a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *pool)</td></tr>
<tr class="memdesc:ga0f34faa24cf7902685de6c5c58e3b370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object.  <a href="#ga0f34faa24cf7902685de6c5c58e3b370">[詳解]</a><br /></td></tr>
<tr class="separator:ga0f34faa24cf7902685de6c5c58e3b370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ab7ea81536b1e2cf80ad042e8f862a7"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7ab7ea81536b1e2cf80ad042e8f862a7">nvnSamplerPoolGetMemoryOffset</a> (const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *pool)</td></tr>
<tr class="memdesc:ga7ab7ea81536b1e2cf80ad042e8f862a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool offset used by a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object.  <a href="#ga7ab7ea81536b1e2cf80ad042e8f862a7">[詳解]</a><br /></td></tr>
<tr class="separator:ga7ab7ea81536b1e2cf80ad042e8f862a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee878a9e546d6c2b6325cf0be61ae41c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaee878a9e546d6c2b6325cf0be61ae41c">nvnSamplerPoolGetMemoryPool</a> (const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *pool)</td></tr>
<tr class="memdesc:gaee878a9e546d6c2b6325cf0be61ae41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool used by a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object.  <a href="#gaee878a9e546d6c2b6325cf0be61ae41c">[詳解]</a><br /></td></tr>
<tr class="separator:gaee878a9e546d6c2b6325cf0be61ae41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc23370e8330ae3727bb03f26f5d097c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gadc23370e8330ae3727bb03f26f5d097c">nvnSamplerPoolGetSize</a> (const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *pool)</td></tr>
<tr class="memdesc:gadc23370e8330ae3727bb03f26f5d097c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of descriptors in the memory of a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object.  <a href="#gadc23370e8330ae3727bb03f26f5d097c">[詳解]</a><br /></td></tr>
<tr class="separator:gadc23370e8330ae3727bb03f26f5d097c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac78aeeebf55a677fa61bdceebc46ef5b"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac78aeeebf55a677fa61bdceebc46ef5b">nvnSamplerPoolInitialize</a> (<a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *samplerPool, const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *memoryPool, ptrdiff_t offset, int numDescriptors)</td></tr>
<tr class="memdesc:gac78aeeebf55a677fa61bdceebc46ef5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object.  <a href="#gac78aeeebf55a677fa61bdceebc46ef5b">[詳解]</a><br /></td></tr>
<tr class="separator:gac78aeeebf55a677fa61bdceebc46ef5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga534898b94679ef42198d21f4a3bd966e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga534898b94679ef42198d21f4a3bd966e">nvnSamplerPoolRegisterSampler</a> (const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *samplerPool, int id, const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler)</td></tr>
<tr class="memdesc:ga534898b94679ef42198d21f4a3bd966e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a sampler descriptor in a sampler pool for use via texture handles, using a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object.  <a href="#ga534898b94679ef42198d21f4a3bd966e">[詳解]</a><br /></td></tr>
<tr class="separator:ga534898b94679ef42198d21f4a3bd966e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33025ca24e76ce3cc2df1844cad3bca8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga33025ca24e76ce3cc2df1844cad3bca8">nvnSamplerPoolRegisterSamplerBuilder</a> (const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *samplerPool, int id, const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga33025ca24e76ce3cc2df1844cad3bca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a sampler descriptor in a sampler pool for use via texture handles, using <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> state.  <a href="#ga33025ca24e76ce3cc2df1844cad3bca8">[詳解]</a><br /></td></tr>
<tr class="separator:ga33025ca24e76ce3cc2df1844cad3bca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5a4a7a3602ace4ed28a8249bdaf249f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad5a4a7a3602ace4ed28a8249bdaf249f">nvnSamplerPoolSetDebugLabel</a> (<a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *pool, const char *label)</td></tr>
<tr class="memdesc:gad5a4a7a3602ace4ed28a8249bdaf249f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object.  <a href="#gad5a4a7a3602ace4ed28a8249bdaf249f">[詳解]</a><br /></td></tr>
<tr class="separator:gad5a4a7a3602ace4ed28a8249bdaf249f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf992a842dafe3db3a3d68c36a7f89b1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf992a842dafe3db3a3d68c36a7f89b1a">nvnSamplerSetDebugLabel</a> (<a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *sampler, const char *label)</td></tr>
<tr class="memdesc:gaf992a842dafe3db3a3d68c36a7f89b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object.  <a href="#gaf992a842dafe3db3a3d68c36a7f89b1a">[詳解]</a><br /></td></tr>
<tr class="separator:gaf992a842dafe3db3a3d68c36a7f89b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga918f1f02b17ba89d048372ead736a929"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga918f1f02b17ba89d048372ead736a929">nvnSyncFinalize</a> (<a class="el" href="struct_n_v_nsync.html">NVNsync</a> *sync)</td></tr>
<tr class="memdesc:ga918f1f02b17ba89d048372ead736a929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object.  <a href="#ga918f1f02b17ba89d048372ead736a929">[詳解]</a><br /></td></tr>
<tr class="separator:ga918f1f02b17ba89d048372ead736a929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8eeff0f19eaa7bb9b57ea8134411baa"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad8eeff0f19eaa7bb9b57ea8134411baa">nvnSyncInitialize</a> (<a class="el" href="struct_n_v_nsync.html">NVNsync</a> *sync, <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:gad8eeff0f19eaa7bb9b57ea8134411baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object for the specified device.  <a href="#gad8eeff0f19eaa7bb9b57ea8134411baa">[詳解]</a><br /></td></tr>
<tr class="separator:gad8eeff0f19eaa7bb9b57ea8134411baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga052a5bc70782ffe27301d0e317e6382b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga052a5bc70782ffe27301d0e317e6382b">nvnSyncSetDebugLabel</a> (<a class="el" href="struct_n_v_nsync.html">NVNsync</a> *sync, const char *label)</td></tr>
<tr class="memdesc:ga052a5bc70782ffe27301d0e317e6382b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object.  <a href="#ga052a5bc70782ffe27301d0e317e6382b">[詳解]</a><br /></td></tr>
<tr class="separator:ga052a5bc70782ffe27301d0e317e6382b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e9deb5d068866fe0c32929a3f82baf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga52ff133a79fc03ef1f60a3e7946332a1">NVNsyncWaitResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2e9deb5d068866fe0c32929a3f82baf3">nvnSyncWait</a> (const <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *sync, uint64_t timeoutNs)</td></tr>
<tr class="memdesc:ga2e9deb5d068866fe0c32929a3f82baf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object to be signaled on the CPU before returning.  <a href="#ga2e9deb5d068866fe0c32929a3f82baf3">[詳解]</a><br /></td></tr>
<tr class="separator:ga2e9deb5d068866fe0c32929a3f82baf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab08075b4fd422c5586f418ec95432ca8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab08075b4fd422c5586f418ec95432ca8">nvnTextureBuilderGetDepth</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gab08075b4fd422c5586f418ec95432ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#gab08075b4fd422c5586f418ec95432ca8">[詳解]</a><br /></td></tr>
<tr class="separator:gab08075b4fd422c5586f418ec95432ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae190535d6c7660700220beee28fabb20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae190535d6c7660700220beee28fabb20">nvnTextureBuilderGetDepthStencilMode</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gae190535d6c7660700220beee28fabb20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth/stencil mode for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#gae190535d6c7660700220beee28fabb20">[詳解]</a><br /></td></tr>
<tr class="separator:gae190535d6c7660700220beee28fabb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf602e9d491bac3c2389d3f62e5fc3a82"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf602e9d491bac3c2389d3f62e5fc3a82">nvnTextureBuilderGetDevice</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaf602e9d491bac3c2389d3f62e5fc3a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the device associated with this <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#gaf602e9d491bac3c2389d3f62e5fc3a82">[詳解]</a><br /></td></tr>
<tr class="separator:gaf602e9d491bac3c2389d3f62e5fc3a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e8501ec354c364fc84ac787a1b29042"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga57ab2536473c8e62f621554a2618121b">NVNtextureFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5e8501ec354c364fc84ac787a1b29042">nvnTextureBuilderGetFlags</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga5e8501ec354c364fc84ac787a1b29042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the flags for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#ga5e8501ec354c364fc84ac787a1b29042">[詳解]</a><br /></td></tr>
<tr class="separator:ga5e8501ec354c364fc84ac787a1b29042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8882c4fa3c8f9f232bcc966516005a2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8882c4fa3c8f9f232bcc966516005a2f">nvnTextureBuilderGetFormat</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga8882c4fa3c8f9f232bcc966516005a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the format for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#ga8882c4fa3c8f9f232bcc966516005a2f">[詳解]</a><br /></td></tr>
<tr class="separator:ga8882c4fa3c8f9f232bcc966516005a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad49dafe49d8e52a12518c8dc492fe71"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaad49dafe49d8e52a12518c8dc492fe71">nvnTextureBuilderGetGLTextureName</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaad49dafe49d8e52a12518c8dc492fe71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the OpenGL or OpenGL ES texture to use as an external texture source.  <a href="#gaad49dafe49d8e52a12518c8dc492fe71">[詳解]</a><br /></td></tr>
<tr class="separator:gaad49dafe49d8e52a12518c8dc492fe71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33852e99c26e6d9ca7cce5faf24b55ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga33852e99c26e6d9ca7cce5faf24b55ec">nvnTextureBuilderGetHeight</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga33852e99c26e6d9ca7cce5faf24b55ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the height for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#ga33852e99c26e6d9ca7cce5faf24b55ec">[詳解]</a><br /></td></tr>
<tr class="separator:ga33852e99c26e6d9ca7cce5faf24b55ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga203060aa64e2655e160e502337c80345"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga203060aa64e2655e160e502337c80345">nvnTextureBuilderGetLevels</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga203060aa64e2655e160e502337c80345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the level count for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#ga203060aa64e2655e160e502337c80345">[詳解]</a><br /></td></tr>
<tr class="separator:ga203060aa64e2655e160e502337c80345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac22e6e0c78a09ad5348b8e6b3e7c5c1a"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac22e6e0c78a09ad5348b8e6b3e7c5c1a">nvnTextureBuilderGetMemoryOffset</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gac22e6e0c78a09ad5348b8e6b3e7c5c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool offset used by a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#gac22e6e0c78a09ad5348b8e6b3e7c5c1a">[詳解]</a><br /></td></tr>
<tr class="separator:gac22e6e0c78a09ad5348b8e6b3e7c5c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeade4627ca9fc552f5c5b8584a7cd514"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaeade4627ca9fc552f5c5b8584a7cd514">nvnTextureBuilderGetMemoryPool</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaeade4627ca9fc552f5c5b8584a7cd514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool used by a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#gaeade4627ca9fc552f5c5b8584a7cd514">[詳解]</a><br /></td></tr>
<tr class="separator:gaeade4627ca9fc552f5c5b8584a7cd514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c64f715837363c1e2920cae77be92da"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4c64f715837363c1e2920cae77be92da">nvnTextureBuilderGetPackagedTextureData</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga4c64f715837363c1e2920cae77be92da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the packaged texture data pointer for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#ga4c64f715837363c1e2920cae77be92da">[詳解]</a><br /></td></tr>
<tr class="separator:ga4c64f715837363c1e2920cae77be92da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d4eab4f6bf7d1b48e53dfa1ee035058"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8d4eab4f6bf7d1b48e53dfa1ee035058">nvnTextureBuilderGetPackagedTextureLayout</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="struct_n_v_npackaged_texture_layout.html">NVNpackagedTextureLayout</a> *data)</td></tr>
<tr class="memdesc:ga8d4eab4f6bf7d1b48e53dfa1ee035058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the packaged texture layout associated with this <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#ga8d4eab4f6bf7d1b48e53dfa1ee035058">[詳解]</a><br /></td></tr>
<tr class="separator:ga8d4eab4f6bf7d1b48e53dfa1ee035058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga838dc1cd980379c39027331f1390169f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga838dc1cd980379c39027331f1390169f">nvnTextureBuilderGetSamples</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga838dc1cd980379c39027331f1390169f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the sample count for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#ga838dc1cd980379c39027331f1390169f">[詳解]</a><br /></td></tr>
<tr class="separator:ga838dc1cd980379c39027331f1390169f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade45e847441bcf19b57835e7b30e3dbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gade45e847441bcf19b57835e7b30e3dbe">nvnTextureBuilderGetSparseTileLayout</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="struct_n_v_ntexture_sparse_tile_layout.html">NVNtextureSparseTileLayout</a> *layout)</td></tr>
<tr class="memdesc:gade45e847441bcf19b57835e7b30e3dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns properties of the sparse memory layout for a texture to be created using the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#gade45e847441bcf19b57835e7b30e3dbe">[詳解]</a><br /></td></tr>
<tr class="separator:gade45e847441bcf19b57835e7b30e3dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05c4e80a256b37ed63e1478ffd680eab"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga05c4e80a256b37ed63e1478ffd680eab">nvnTextureBuilderGetStorageAlignment</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga05c4e80a256b37ed63e1478ffd680eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum alignment in bytes (in bytes) required to hold a texture to be created using the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#ga05c4e80a256b37ed63e1478ffd680eab">[詳解]</a><br /></td></tr>
<tr class="separator:ga05c4e80a256b37ed63e1478ffd680eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4136c92f14cf364c1776814c31d098a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga4e21960c2b9244bbd2753954b23580d3">NVNstorageClass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad4136c92f14cf364c1776814c31d098a">nvnTextureBuilderGetStorageClass</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gad4136c92f14cf364c1776814c31d098a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the storage class needed for virtual memory mappings for a texture to be created using the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#gad4136c92f14cf364c1776814c31d098a">[詳解]</a><br /></td></tr>
<tr class="separator:gad4136c92f14cf364c1776814c31d098a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ba9cfd0600643dbb909eaa9c36abe26"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1ba9cfd0600643dbb909eaa9c36abe26">nvnTextureBuilderGetStorageSize</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga1ba9cfd0600643dbb909eaa9c36abe26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of memory (in bytes) required to hold a texture to be created using the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#ga1ba9cfd0600643dbb909eaa9c36abe26">[詳解]</a><br /></td></tr>
<tr class="separator:ga1ba9cfd0600643dbb909eaa9c36abe26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9939e7f8604b5c1c58eade93a8c6f2df"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9939e7f8604b5c1c58eade93a8c6f2df">nvnTextureBuilderGetStride</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga9939e7f8604b5c1c58eade93a8c6f2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the stride for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#ga9939e7f8604b5c1c58eade93a8c6f2df">[詳解]</a><br /></td></tr>
<tr class="separator:ga9939e7f8604b5c1c58eade93a8c6f2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad00012a5e2ba6e63b8c022fff5d233c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad00012a5e2ba6e63b8c022fff5d233c8">nvnTextureBuilderGetSwizzle</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *r, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *g, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *b, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *a)</td></tr>
<tr class="memdesc:gad00012a5e2ba6e63b8c022fff5d233c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the swizzles for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#gad00012a5e2ba6e63b8c022fff5d233c8">[詳解]</a><br /></td></tr>
<tr class="separator:gad00012a5e2ba6e63b8c022fff5d233c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0202b12c55ce5a46f3c023266d8c454"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf0202b12c55ce5a46f3c023266d8c454">nvnTextureBuilderGetTarget</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaf0202b12c55ce5a46f3c023266d8c454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the target for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#gaf0202b12c55ce5a46f3c023266d8c454">[詳解]</a><br /></td></tr>
<tr class="separator:gaf0202b12c55ce5a46f3c023266d8c454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga386847eb4289c7cd7ad45ee0d2b62918"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga386847eb4289c7cd7ad45ee0d2b62918">nvnTextureBuilderGetWidth</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga386847eb4289c7cd7ad45ee0d2b62918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the width for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#ga386847eb4289c7cd7ad45ee0d2b62918">[詳解]</a><br /></td></tr>
<tr class="separator:ga386847eb4289c7cd7ad45ee0d2b62918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa00aaba8acd99e423733589231ac411a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa00aaba8acd99e423733589231ac411a">nvnTextureBuilderGetZCullStorageSize</a> (const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gaa00aaba8acd99e423733589231ac411a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth texture.  <a href="#gaa00aaba8acd99e423733589231ac411a">[詳解]</a><br /></td></tr>
<tr class="separator:gaa00aaba8acd99e423733589231ac411a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6287f82327692478ee9040e4fe73dd36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6287f82327692478ee9040e4fe73dd36">nvnTextureBuilderSetDefaults</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga6287f82327692478ee9040e4fe73dd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#ga6287f82327692478ee9040e4fe73dd36">[詳解]</a><br /></td></tr>
<tr class="separator:ga6287f82327692478ee9040e4fe73dd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad86f04179d66882fe758554678311e42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad86f04179d66882fe758554678311e42">nvnTextureBuilderSetDepth</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int depth)</td></tr>
<tr class="memdesc:gad86f04179d66882fe758554678311e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the depth (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>.  <a href="#gad86f04179d66882fe758554678311e42">[詳解]</a><br /></td></tr>
<tr class="separator:gad86f04179d66882fe758554678311e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1f0c27399978e0f15954533cc4763bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad1f0c27399978e0f15954533cc4763bd">nvnTextureBuilderSetDepthStencilMode</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a> mode)</td></tr>
<tr class="memdesc:gad1f0c27399978e0f15954533cc4763bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the values returned for depth/stencil <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>.  <a href="#gad1f0c27399978e0f15954533cc4763bd">[詳解]</a><br /></td></tr>
<tr class="separator:gad1f0c27399978e0f15954533cc4763bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3125b10128cdf01e0c489ebf9644cc36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3125b10128cdf01e0c489ebf9644cc36">nvnTextureBuilderSetDevice</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:ga3125b10128cdf01e0c489ebf9644cc36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> associated with a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object.  <a href="#ga3125b10128cdf01e0c489ebf9644cc36">[詳解]</a><br /></td></tr>
<tr class="separator:ga3125b10128cdf01e0c489ebf9644cc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga249280b0e8c57ead0fa7a82a8ebc56f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga249280b0e8c57ead0fa7a82a8ebc56f9">nvnTextureBuilderSetFlags</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int flags)</td></tr>
<tr class="memdesc:ga249280b0e8c57ead0fa7a82a8ebc56f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flags indentifying special properties of <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>.  <a href="#ga249280b0e8c57ead0fa7a82a8ebc56f9">[詳解]</a><br /></td></tr>
<tr class="separator:ga249280b0e8c57ead0fa7a82a8ebc56f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad83f59e208a24b5843543e1d0c7aec8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad83f59e208a24b5843543e1d0c7aec8a">nvnTextureBuilderSetFormat</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> format)</td></tr>
<tr class="memdesc:gad83f59e208a24b5843543e1d0c7aec8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded. ">NVNformat</a> for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>.  <a href="#gad83f59e208a24b5843543e1d0c7aec8a">[詳解]</a><br /></td></tr>
<tr class="separator:gad83f59e208a24b5843543e1d0c7aec8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8382ee09ab0b9f65b84368aa3aa8fef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae8382ee09ab0b9f65b84368aa3aa8fef">nvnTextureBuilderSetGLTextureName</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, uint32_t name)</td></tr>
<tr class="memdesc:gae8382ee09ab0b9f65b84368aa3aa8fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the OpenGL texture to use as an external texture source.  <a href="#gae8382ee09ab0b9f65b84368aa3aa8fef">[詳解]</a><br /></td></tr>
<tr class="separator:gae8382ee09ab0b9f65b84368aa3aa8fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6c93fbfa974a07606f5c398adb4a080"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad6c93fbfa974a07606f5c398adb4a080">nvnTextureBuilderSetHeight</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int height)</td></tr>
<tr class="memdesc:gad6c93fbfa974a07606f5c398adb4a080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the height (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>.  <a href="#gad6c93fbfa974a07606f5c398adb4a080">[詳解]</a><br /></td></tr>
<tr class="separator:gad6c93fbfa974a07606f5c398adb4a080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b84b7b97960b702cd6e8438e0bc303b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7b84b7b97960b702cd6e8438e0bc303b">nvnTextureBuilderSetLevels</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int numLevels)</td></tr>
<tr class="memdesc:ga7b84b7b97960b702cd6e8438e0bc303b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of mipmap levels for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>.  <a href="#ga7b84b7b97960b702cd6e8438e0bc303b">[詳解]</a><br /></td></tr>
<tr class="separator:ga7b84b7b97960b702cd6e8438e0bc303b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ccd08d4bafb09088fb0c39aea731354"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6ccd08d4bafb09088fb0c39aea731354">nvnTextureBuilderSetPackagedTextureData</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, const void *data)</td></tr>
<tr class="memdesc:ga6ccd08d4bafb09088fb0c39aea731354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify optional packaged texture data used to initialize texture storage.  <a href="#ga6ccd08d4bafb09088fb0c39aea731354">[詳解]</a><br /></td></tr>
<tr class="separator:ga6ccd08d4bafb09088fb0c39aea731354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9c504fb68daac897da16e9161e61eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab9c504fb68daac897da16e9161e61eb7">nvnTextureBuilderSetPackagedTextureLayout</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, const <a class="el" href="struct_n_v_npackaged_texture_layout.html">NVNpackagedTextureLayout</a> *layout)</td></tr>
<tr class="memdesc:gab9c504fb68daac897da16e9161e61eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the layout of packaged texture data used for texture storage.  <a href="#gab9c504fb68daac897da16e9161e61eb7">[詳解]</a><br /></td></tr>
<tr class="separator:gab9c504fb68daac897da16e9161e61eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d9a12fdb214af17acac6536d23cd911"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0d9a12fdb214af17acac6536d23cd911">nvnTextureBuilderSetSamples</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int samples)</td></tr>
<tr class="memdesc:ga0d9a12fdb214af17acac6536d23cd911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sample count for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>.  <a href="#ga0d9a12fdb214af17acac6536d23cd911">[詳解]</a><br /></td></tr>
<tr class="separator:ga0d9a12fdb214af17acac6536d23cd911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff26847111e7f31129495f9211db22d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaff26847111e7f31129495f9211db22d6">nvnTextureBuilderSetSize1D</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int width)</td></tr>
<tr class="memdesc:gaff26847111e7f31129495f9211db22d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the width (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>.  <a href="#gaff26847111e7f31129495f9211db22d6">[詳解]</a><br /></td></tr>
<tr class="separator:gaff26847111e7f31129495f9211db22d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eb945f455f851adf9b738be38cfb0bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1eb945f455f851adf9b738be38cfb0bc">nvnTextureBuilderSetSize2D</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int width, int height)</td></tr>
<tr class="memdesc:ga1eb945f455f851adf9b738be38cfb0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the width and height (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>.  <a href="#ga1eb945f455f851adf9b738be38cfb0bc">[詳解]</a><br /></td></tr>
<tr class="separator:ga1eb945f455f851adf9b738be38cfb0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1295ca18055627e3128e6ec7f0be5439"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1295ca18055627e3128e6ec7f0be5439">nvnTextureBuilderSetSize3D</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int width, int height, int depth)</td></tr>
<tr class="memdesc:ga1295ca18055627e3128e6ec7f0be5439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the width, height, and depth (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>.  <a href="#ga1295ca18055627e3128e6ec7f0be5439">[詳解]</a><br /></td></tr>
<tr class="separator:ga1295ca18055627e3128e6ec7f0be5439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6530c01a016b836ad82434f6a793cd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf6530c01a016b836ad82434f6a793cd8">nvnTextureBuilderSetStorage</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *pool, ptrdiff_t offset)</td></tr>
<tr class="memdesc:gaf6530c01a016b836ad82434f6a793cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the location in a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> used for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>.  <a href="#gaf6530c01a016b836ad82434f6a793cd8">[詳解]</a><br /></td></tr>
<tr class="separator:gaf6530c01a016b836ad82434f6a793cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaadb0c9f8190a0f8dbc4e637f593636"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabaadb0c9f8190a0f8dbc4e637f593636">nvnTextureBuilderSetStride</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, ptrdiff_t stride)</td></tr>
<tr class="memdesc:gabaadb0c9f8190a0f8dbc4e637f593636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the stride for linear textures.  <a href="#gabaadb0c9f8190a0f8dbc4e637f593636">[詳解]</a><br /></td></tr>
<tr class="separator:gabaadb0c9f8190a0f8dbc4e637f593636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc101b1093b409c29b8db4a6f144d968"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabc101b1093b409c29b8db4a6f144d968">nvnTextureBuilderSetSwizzle</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> r, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> g, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> b, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> a)</td></tr>
<tr class="memdesc:gabc101b1093b409c29b8db4a6f144d968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the texture swizzle for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>.  <a href="#gabc101b1093b409c29b8db4a6f144d968">[詳解]</a><br /></td></tr>
<tr class="separator:gabc101b1093b409c29b8db4a6f144d968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7e80e3d31c6cffc51d255cbe86694b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa7e80e3d31c6cffc51d255cbe86694b3">nvnTextureBuilderSetTarget</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, <a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a> target)</td></tr>
<tr class="memdesc:gaa7e80e3d31c6cffc51d255cbe86694b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the target (texture type) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>.  <a href="#gaa7e80e3d31c6cffc51d255cbe86694b3">[詳解]</a><br /></td></tr>
<tr class="separator:gaa7e80e3d31c6cffc51d255cbe86694b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb74efcd860292768c1ee95c09c647c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaeb74efcd860292768c1ee95c09c647c7">nvnTextureBuilderSetWidth</a> (<a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder, int width)</td></tr>
<tr class="memdesc:gaeb74efcd860292768c1ee95c09c647c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the width (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>.  <a href="#gaeb74efcd860292768c1ee95c09c647c7">[詳解]</a><br /></td></tr>
<tr class="separator:gaeb74efcd860292768c1ee95c09c647c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga236976f3597cb6595dc0703c6a8e7dae"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga236976f3597cb6595dc0703c6a8e7dae">nvnTextureCompare</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *otherTexture)</td></tr>
<tr class="memdesc:ga236976f3597cb6595dc0703c6a8e7dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if texture objects are equivalent.  <a href="#ga236976f3597cb6595dc0703c6a8e7dae">[詳解]</a><br /></td></tr>
<tr class="separator:ga236976f3597cb6595dc0703c6a8e7dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5741253f7ab5c9075a6821a68cfa351"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa5741253f7ab5c9075a6821a68cfa351">nvnTextureFinalize</a> (<a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:gaa5741253f7ab5c9075a6821a68cfa351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#gaa5741253f7ab5c9075a6821a68cfa351">[詳解]</a><br /></td></tr>
<tr class="separator:gaa5741253f7ab5c9075a6821a68cfa351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga955c791dfe86ae65b7e87903575c0cfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga955c791dfe86ae65b7e87903575c0cfa">nvnTextureFlushTexels</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *textureView, const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *region)</td></tr>
<tr class="memdesc:ga955c791dfe86ae65b7e87903575c0cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush CPU cache lines holding portions of a texture.  <a href="#ga955c791dfe86ae65b7e87903575c0cfa">[詳解]</a><br /></td></tr>
<tr class="separator:ga955c791dfe86ae65b7e87903575c0cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89c5c4383243a7679a4d4d9977ffc365"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga89c5c4383243a7679a4d4d9977ffc365">nvnTextureGetDebugID</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga89c5c4383243a7679a4d4d9977ffc365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug layer unique ID of this texture.  <a href="#ga89c5c4383243a7679a4d4d9977ffc365">[詳解]</a><br /></td></tr>
<tr class="separator:ga89c5c4383243a7679a4d4d9977ffc365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1949a4d4cb3eaf94f805beae5748209d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1949a4d4cb3eaf94f805beae5748209d">nvnTextureGetDepth</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga1949a4d4cb3eaf94f805beae5748209d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#ga1949a4d4cb3eaf94f805beae5748209d">[詳解]</a><br /></td></tr>
<tr class="separator:ga1949a4d4cb3eaf94f805beae5748209d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga745f91a439a4c7ab71f1e58cd2e2246b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga745f91a439a4c7ab71f1e58cd2e2246b">nvnTextureGetDepthStencilMode</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga745f91a439a4c7ab71f1e58cd2e2246b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth/stencil mode for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#ga745f91a439a4c7ab71f1e58cd2e2246b">[詳解]</a><br /></td></tr>
<tr class="separator:ga745f91a439a4c7ab71f1e58cd2e2246b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b2185123abcb5454ce65f662c34e166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga57ab2536473c8e62f621554a2618121b">NVNtextureFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2b2185123abcb5454ce65f662c34e166">nvnTextureGetFlags</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga2b2185123abcb5454ce65f662c34e166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the flags for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#ga2b2185123abcb5454ce65f662c34e166">[詳解]</a><br /></td></tr>
<tr class="separator:ga2b2185123abcb5454ce65f662c34e166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d6ee5609a77cbcc3d7af85edf1ea76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaa1d6ee5609a77cbcc3d7af85edf1ea76">nvnTextureGetFormat</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:gaa1d6ee5609a77cbcc3d7af85edf1ea76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the format for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#gaa1d6ee5609a77cbcc3d7af85edf1ea76">[詳解]</a><br /></td></tr>
<tr class="separator:gaa1d6ee5609a77cbcc3d7af85edf1ea76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53c4d11d01059c6d3d875ecf85ede8a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga53c4d11d01059c6d3d875ecf85ede8a5">nvnTextureGetHeight</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga53c4d11d01059c6d3d875ecf85ede8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the height for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#ga53c4d11d01059c6d3d875ecf85ede8a5">[詳解]</a><br /></td></tr>
<tr class="separator:ga53c4d11d01059c6d3d875ecf85ede8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab847c77fff2d7ff0597ba6138da6dae5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab847c77fff2d7ff0597ba6138da6dae5">nvnTextureGetLevels</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:gab847c77fff2d7ff0597ba6138da6dae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the level count for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#gab847c77fff2d7ff0597ba6138da6dae5">[詳解]</a><br /></td></tr>
<tr class="separator:gab847c77fff2d7ff0597ba6138da6dae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec925c37d4094927b8e9fc1d9808545a"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaec925c37d4094927b8e9fc1d9808545a">nvnTextureGetMemoryOffset</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:gaec925c37d4094927b8e9fc1d9808545a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool offset used by a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#gaec925c37d4094927b8e9fc1d9808545a">[詳解]</a><br /></td></tr>
<tr class="separator:gaec925c37d4094927b8e9fc1d9808545a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15b7941491a88ad4abf82bdc145216f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga15b7941491a88ad4abf82bdc145216f7">nvnTextureGetMemoryPool</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga15b7941491a88ad4abf82bdc145216f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool used by a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#ga15b7941491a88ad4abf82bdc145216f7">[詳解]</a><br /></td></tr>
<tr class="separator:ga15b7941491a88ad4abf82bdc145216f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05bc2d539e76dd0f5daaf6faccc8d718"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga05bc2d539e76dd0f5daaf6faccc8d718">nvnTextureGetSamples</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga05bc2d539e76dd0f5daaf6faccc8d718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the sample count for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#ga05bc2d539e76dd0f5daaf6faccc8d718">[詳解]</a><br /></td></tr>
<tr class="separator:ga05bc2d539e76dd0f5daaf6faccc8d718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92054c4c5f509f4be2e4b5536f755344"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga92054c4c5f509f4be2e4b5536f755344">nvnTextureGetSparseTileLayout</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, <a class="el" href="struct_n_v_ntexture_sparse_tile_layout.html">NVNtextureSparseTileLayout</a> *layout)</td></tr>
<tr class="memdesc:ga92054c4c5f509f4be2e4b5536f755344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns properties of the sparse memory layout for a texture.  <a href="#ga92054c4c5f509f4be2e4b5536f755344">[詳解]</a><br /></td></tr>
<tr class="separator:ga92054c4c5f509f4be2e4b5536f755344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga290d7f9e06d3eb2618b601f83d3bbbb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga4e21960c2b9244bbd2753954b23580d3">NVNstorageClass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga290d7f9e06d3eb2618b601f83d3bbbb9">nvnTextureGetStorageClass</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga290d7f9e06d3eb2618b601f83d3bbbb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the storage class needed for virtual memory mappings for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#ga290d7f9e06d3eb2618b601f83d3bbbb9">[詳解]</a><br /></td></tr>
<tr class="separator:ga290d7f9e06d3eb2618b601f83d3bbbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74382bb40eec4fcbd761e8c76e0bbd3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga74382bb40eec4fcbd761e8c76e0bbd3f">nvnTextureGetStorageSize</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga74382bb40eec4fcbd761e8c76e0bbd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the storage size for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#ga74382bb40eec4fcbd761e8c76e0bbd3f">[詳解]</a><br /></td></tr>
<tr class="separator:ga74382bb40eec4fcbd761e8c76e0bbd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4813ee9097b828190f3b6098fb3c3ab0"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4813ee9097b828190f3b6098fb3c3ab0">nvnTextureGetStride</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga4813ee9097b828190f3b6098fb3c3ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the stride for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#ga4813ee9097b828190f3b6098fb3c3ab0">[詳解]</a><br /></td></tr>
<tr class="separator:ga4813ee9097b828190f3b6098fb3c3ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8a208369ab9e5f3c15794f023893a5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad8a208369ab9e5f3c15794f023893a5c">nvnTextureGetSwizzle</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *r, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *g, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *b, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *a)</td></tr>
<tr class="memdesc:gad8a208369ab9e5f3c15794f023893a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the swizzles for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#gad8a208369ab9e5f3c15794f023893a5c">[詳解]</a><br /></td></tr>
<tr class="separator:gad8a208369ab9e5f3c15794f023893a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga785889a42583d3e442610a7385ec2f3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga785889a42583d3e442610a7385ec2f3f">nvnTextureGetTarget</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga785889a42583d3e442610a7385ec2f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the target for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#ga785889a42583d3e442610a7385ec2f3f">[詳解]</a><br /></td></tr>
<tr class="separator:ga785889a42583d3e442610a7385ec2f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1830936e33236e3808dbf70c8bd076f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__handle.html#ga25907f5565e57af5a1f3f2fef4493887">NVNtextureAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga1830936e33236e3808dbf70c8bd076f7">nvnTextureGetTextureAddress</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga1830936e33236e3808dbf70c8bd076f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the GPU address of the first byte of memory used by a texture.  <a href="#ga1830936e33236e3808dbf70c8bd076f7">[詳解]</a><br /></td></tr>
<tr class="separator:ga1830936e33236e3808dbf70c8bd076f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f538a9539abbb991fd0c42089293105"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4f538a9539abbb991fd0c42089293105">nvnTextureGetViewOffset</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *textureView)</td></tr>
<tr class="memdesc:ga4f538a9539abbb991fd0c42089293105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset (in bytes) of the first byte of storage used by a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#ga4f538a9539abbb991fd0c42089293105">[詳解]</a><br /></td></tr>
<tr class="separator:ga4f538a9539abbb991fd0c42089293105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga529f99644886d9a725ef2bf7b9108a27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga529f99644886d9a725ef2bf7b9108a27">nvnTextureGetWidth</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga529f99644886d9a725ef2bf7b9108a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the width for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#ga529f99644886d9a725ef2bf7b9108a27">[詳解]</a><br /></td></tr>
<tr class="separator:ga529f99644886d9a725ef2bf7b9108a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73cb447f019bda7152e2ab27a5a9156d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga73cb447f019bda7152e2ab27a5a9156d">nvnTextureGetZCullStorageSize</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture)</td></tr>
<tr class="memdesc:ga73cb447f019bda7152e2ab27a5a9156d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth texture.  <a href="#ga73cb447f019bda7152e2ab27a5a9156d">[詳解]</a><br /></td></tr>
<tr class="separator:ga73cb447f019bda7152e2ab27a5a9156d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8c5cbaa3292721f1de9d521a66aac3e"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad8c5cbaa3292721f1de9d521a66aac3e">nvnTextureInitialize</a> (<a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *builder)</td></tr>
<tr class="memdesc:gad8c5cbaa3292721f1de9d521a66aac3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a texture object from a texture builder using storage provided by a memory pool.  <a href="#gad8c5cbaa3292721f1de9d521a66aac3e">[詳解]</a><br /></td></tr>
<tr class="separator:gad8c5cbaa3292721f1de9d521a66aac3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec4e878f1036375ad23ff57ceafe53f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaec4e878f1036375ad23ff57ceafe53f2">nvnTextureInvalidateTexels</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *textureView, const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *region)</td></tr>
<tr class="memdesc:gaec4e878f1036375ad23ff57ceafe53f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate CPU cache lines holding portions of a texture.  <a href="#gaec4e878f1036375ad23ff57ceafe53f2">[詳解]</a><br /></td></tr>
<tr class="separator:gaec4e878f1036375ad23ff57ceafe53f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef9948023397e7c1c3294fba08135f68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaef9948023397e7c1c3294fba08135f68">nvnTexturePoolFinalize</a> (<a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *pool)</td></tr>
<tr class="memdesc:gaef9948023397e7c1c3294fba08135f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object.  <a href="#gaef9948023397e7c1c3294fba08135f68">[詳解]</a><br /></td></tr>
<tr class="separator:gaef9948023397e7c1c3294fba08135f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga235dc3565dd2c666c1162229b58c9d36"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga235dc3565dd2c666c1162229b58c9d36">nvnTexturePoolGetMemoryOffset</a> (const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *pool)</td></tr>
<tr class="memdesc:ga235dc3565dd2c666c1162229b58c9d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool offset used by a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object.  <a href="#ga235dc3565dd2c666c1162229b58c9d36">[詳解]</a><br /></td></tr>
<tr class="separator:ga235dc3565dd2c666c1162229b58c9d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc56cdaa4e3572684ac54699776459f0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabc56cdaa4e3572684ac54699776459f0">nvnTexturePoolGetMemoryPool</a> (const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *pool)</td></tr>
<tr class="memdesc:gabc56cdaa4e3572684ac54699776459f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the memory pool used by a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object.  <a href="#gabc56cdaa4e3572684ac54699776459f0">[詳解]</a><br /></td></tr>
<tr class="separator:gabc56cdaa4e3572684ac54699776459f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94185c1c4011d6a6cf9343fa5b923701"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga94185c1c4011d6a6cf9343fa5b923701">nvnTexturePoolGetSize</a> (const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *pool)</td></tr>
<tr class="memdesc:ga94185c1c4011d6a6cf9343fa5b923701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of descriptors in the memory of a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object.  <a href="#ga94185c1c4011d6a6cf9343fa5b923701">[詳解]</a><br /></td></tr>
<tr class="separator:ga94185c1c4011d6a6cf9343fa5b923701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3b22a7104a3c1cb6c0ab5c46e753587"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf3b22a7104a3c1cb6c0ab5c46e753587">nvnTexturePoolInitialize</a> (<a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *texturePool, const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *memoryPool, ptrdiff_t offset, int numDescriptors)</td></tr>
<tr class="memdesc:gaf3b22a7104a3c1cb6c0ab5c46e753587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object.  <a href="#gaf3b22a7104a3c1cb6c0ab5c46e753587">[詳解]</a><br /></td></tr>
<tr class="separator:gaf3b22a7104a3c1cb6c0ab5c46e753587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9357d2ef95b193039fab87192187845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab9357d2ef95b193039fab87192187845">nvnTexturePoolRegisterImage</a> (const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *texturePool, int id, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view)</td></tr>
<tr class="memdesc:gab9357d2ef95b193039fab87192187845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an image descriptor in a texture pool for use via image loads and stores.  <a href="#gab9357d2ef95b193039fab87192187845">[詳解]</a><br /></td></tr>
<tr class="separator:gab9357d2ef95b193039fab87192187845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae68c38ccc4963fcdefa710b993104364"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae68c38ccc4963fcdefa710b993104364">nvnTexturePoolRegisterTexture</a> (const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *texturePool, int id, const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view)</td></tr>
<tr class="memdesc:gae68c38ccc4963fcdefa710b993104364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a texture descriptor in a texture pool for use via texture handles.  <a href="#gae68c38ccc4963fcdefa710b993104364">[詳解]</a><br /></td></tr>
<tr class="separator:gae68c38ccc4963fcdefa710b993104364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58691b87b17bce83845582aa218982f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga58691b87b17bce83845582aa218982f2">nvnTexturePoolSetDebugLabel</a> (<a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *pool, const char *label)</td></tr>
<tr class="memdesc:ga58691b87b17bce83845582aa218982f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object.  <a href="#ga58691b87b17bce83845582aa218982f2">[詳解]</a><br /></td></tr>
<tr class="separator:ga58691b87b17bce83845582aa218982f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a3763d942005f48eaa467571ff8ad8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0a3763d942005f48eaa467571ff8ad8b">nvnTextureReadTexels</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *textureView, const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *region, void *data)</td></tr>
<tr class="memdesc:ga0a3763d942005f48eaa467571ff8ad8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read texture data from a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object into memory.  <a href="#ga0a3763d942005f48eaa467571ff8ad8b">[詳解]</a><br /></td></tr>
<tr class="separator:ga0a3763d942005f48eaa467571ff8ad8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3284bbe008a0f733024a6a041579632e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3284bbe008a0f733024a6a041579632e">nvnTextureReadTexelsStrided</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *textureView, const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *region, void *data, ptrdiff_t rowStride, ptrdiff_t imageStride)</td></tr>
<tr class="memdesc:ga3284bbe008a0f733024a6a041579632e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read texture data from a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object into memory.  <a href="#ga3284bbe008a0f733024a6a041579632e">[詳解]</a><br /></td></tr>
<tr class="separator:ga3284bbe008a0f733024a6a041579632e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38af53eeec445c9775f1b4715c707570"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga38af53eeec445c9775f1b4715c707570">nvnTextureSetDebugLabel</a> (<a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const char *label)</td></tr>
<tr class="memdesc:ga38af53eeec445c9775f1b4715c707570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#ga38af53eeec445c9775f1b4715c707570">[詳解]</a><br /></td></tr>
<tr class="separator:ga38af53eeec445c9775f1b4715c707570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab95e7a5cd51184f9578614b4ec442b78"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab95e7a5cd51184f9578614b4ec442b78">nvnTextureViewCompare</a> (const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *otherView)</td></tr>
<tr class="memdesc:gab95e7a5cd51184f9578614b4ec442b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> objects are equivalent.  <a href="#gab95e7a5cd51184f9578614b4ec442b78">[詳解]</a><br /></td></tr>
<tr class="separator:gab95e7a5cd51184f9578614b4ec442b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2176ce574e0478a456a9a87022a25532"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2176ce574e0478a456a9a87022a25532">nvnTextureViewGetDepthStencilMode</a> (const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, <a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a> *mode)</td></tr>
<tr class="memdesc:ga2176ce574e0478a456a9a87022a25532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the depth/stencil mode associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object.  <a href="#ga2176ce574e0478a456a9a87022a25532">[詳解]</a><br /></td></tr>
<tr class="separator:ga2176ce574e0478a456a9a87022a25532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf06b460df83524343f9092f1c50d50ab"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf06b460df83524343f9092f1c50d50ab">nvnTextureViewGetFormat</a> (const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> *format)</td></tr>
<tr class="memdesc:gaf06b460df83524343f9092f1c50d50ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the format associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object.  <a href="#gaf06b460df83524343f9092f1c50d50ab">[詳解]</a><br /></td></tr>
<tr class="separator:gaf06b460df83524343f9092f1c50d50ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9f4f92177b7a7801a6a6d7c829ec00"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacf9f4f92177b7a7801a6a6d7c829ec00">nvnTextureViewGetLayers</a> (const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, int *minLayer, int *numLayers)</td></tr>
<tr class="memdesc:gacf9f4f92177b7a7801a6a6d7c829ec00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the set of layers associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object.  <a href="#gacf9f4f92177b7a7801a6a6d7c829ec00">[詳解]</a><br /></td></tr>
<tr class="separator:gacf9f4f92177b7a7801a6a6d7c829ec00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga367cd40a7a0c3ebfa548291f93bfd4fd"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga367cd40a7a0c3ebfa548291f93bfd4fd">nvnTextureViewGetLevels</a> (const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, int *baseLevel, int *numLevels)</td></tr>
<tr class="memdesc:ga367cd40a7a0c3ebfa548291f93bfd4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the set of levels associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object.  <a href="#ga367cd40a7a0c3ebfa548291f93bfd4fd">[詳解]</a><br /></td></tr>
<tr class="separator:ga367cd40a7a0c3ebfa548291f93bfd4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e112fd45346310739045b94eeef908f"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3e112fd45346310739045b94eeef908f">nvnTextureViewGetSwizzle</a> (const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *r, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *g, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *b, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *a)</td></tr>
<tr class="memdesc:ga3e112fd45346310739045b94eeef908f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the swizzles associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object.  <a href="#ga3e112fd45346310739045b94eeef908f">[詳解]</a><br /></td></tr>
<tr class="separator:ga3e112fd45346310739045b94eeef908f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aa74261dd204238deca7932be67bdb1"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga5aa74261dd204238deca7932be67bdb1">nvnTextureViewGetTarget</a> (const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, <a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a> *target)</td></tr>
<tr class="memdesc:ga5aa74261dd204238deca7932be67bdb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the target associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object.  <a href="#ga5aa74261dd204238deca7932be67bdb1">[詳解]</a><br /></td></tr>
<tr class="separator:ga5aa74261dd204238deca7932be67bdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c88faa3760e867dc363f64b46ad3487"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3c88faa3760e867dc363f64b46ad3487">nvnTextureViewSetDefaults</a> (<a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view)</td></tr>
<tr class="memdesc:ga3c88faa3760e867dc363f64b46ad3487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object.  <a href="#ga3c88faa3760e867dc363f64b46ad3487">[詳解]</a><br /></td></tr>
<tr class="separator:ga3c88faa3760e867dc363f64b46ad3487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f34ef29814d767bb2347759358832db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga2f34ef29814d767bb2347759358832db">nvnTextureViewSetDepthStencilMode</a> (<a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, <a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a> mode)</td></tr>
<tr class="memdesc:ga2f34ef29814d767bb2347759358832db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a texture view to select an alternate depth/stencil mode.  <a href="#ga2f34ef29814d767bb2347759358832db">[詳解]</a><br /></td></tr>
<tr class="separator:ga2f34ef29814d767bb2347759358832db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33693bbcbc48e8dd365fa40627d8fc93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga33693bbcbc48e8dd365fa40627d8fc93">nvnTextureViewSetFormat</a> (<a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> format)</td></tr>
<tr class="memdesc:ga33693bbcbc48e8dd365fa40627d8fc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a texture view to select an alternate texture format.  <a href="#ga33693bbcbc48e8dd365fa40627d8fc93">[詳解]</a><br /></td></tr>
<tr class="separator:ga33693bbcbc48e8dd365fa40627d8fc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad854d7dac2c34ed9bf7258d5083d12b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gad854d7dac2c34ed9bf7258d5083d12b8">nvnTextureViewSetLayers</a> (<a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, int minLayer, int numLayers)</td></tr>
<tr class="memdesc:gad854d7dac2c34ed9bf7258d5083d12b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a texture view to select a subset of the layers in a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#gad854d7dac2c34ed9bf7258d5083d12b8">[詳解]</a><br /></td></tr>
<tr class="separator:gad854d7dac2c34ed9bf7258d5083d12b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0bf0a7949e2e49f628bbba2358ef86e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae0bf0a7949e2e49f628bbba2358ef86e">nvnTextureViewSetLevels</a> (<a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, int baseLevel, int numLevels)</td></tr>
<tr class="memdesc:gae0bf0a7949e2e49f628bbba2358ef86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a texture view to select a subset of the mipmap levels in a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#gae0bf0a7949e2e49f628bbba2358ef86e">[詳解]</a><br /></td></tr>
<tr class="separator:gae0bf0a7949e2e49f628bbba2358ef86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga034326c7ada555fedcd5ddb4ed1eeef9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga034326c7ada555fedcd5ddb4ed1eeef9">nvnTextureViewSetSwizzle</a> (<a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> r, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> g, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> b, <a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> a)</td></tr>
<tr class="memdesc:ga034326c7ada555fedcd5ddb4ed1eeef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a texture view to select an alternate component swizzle.  <a href="#ga034326c7ada555fedcd5ddb4ed1eeef9">[詳解]</a><br /></td></tr>
<tr class="separator:ga034326c7ada555fedcd5ddb4ed1eeef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb89f522ce35d06d0067032ab0e42b0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gabb89f522ce35d06d0067032ab0e42b0f">nvnTextureViewSetTarget</a> (<a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *view, <a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a> target)</td></tr>
<tr class="memdesc:gabb89f522ce35d06d0067032ab0e42b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a texture view to select an alternate texture target.  <a href="#gabb89f522ce35d06d0067032ab0e42b0f">[詳解]</a><br /></td></tr>
<tr class="separator:gabb89f522ce35d06d0067032ab0e42b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e4a235dac08f14ecbaf8e566df8444e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga0e4a235dac08f14ecbaf8e566df8444e">nvnTextureWriteTexels</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *textureView, const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *region, const void *data)</td></tr>
<tr class="memdesc:ga0e4a235dac08f14ecbaf8e566df8444e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy texture data from memory into a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.  <a href="#ga0e4a235dac08f14ecbaf8e566df8444e">[詳解]</a><br /></td></tr>
<tr class="separator:ga0e4a235dac08f14ecbaf8e566df8444e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaa6b82b65f0aa146a786e5f08e762ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacaa6b82b65f0aa146a786e5f08e762ba">nvnTextureWriteTexelsStrided</a> (const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *texture, const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *textureView, const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *region, const void *data, ptrdiff_t rowStride, ptrdiff_t imageStride)</td></tr>
<tr class="memdesc:gacaa6b82b65f0aa146a786e5f08e762ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy texture data from memory into a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object with user-specified stride.  <a href="#gacaa6b82b65f0aa146a786e5f08e762ba">[詳解]</a><br /></td></tr>
<tr class="separator:gacaa6b82b65f0aa146a786e5f08e762ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ff90c3673688217dba1c0cb18084031"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9ff90c3673688217dba1c0cb18084031">nvnVertexAttribStateGetFormat</a> (const <a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *attrib, <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> *format, ptrdiff_t *relativeOffset)</td></tr>
<tr class="memdesc:ga9ff90c3673688217dba1c0cb18084031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the format (in memory) for values for a single vertex attribute.  <a href="#ga9ff90c3673688217dba1c0cb18084031">[詳解]</a><br /></td></tr>
<tr class="separator:ga9ff90c3673688217dba1c0cb18084031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6633a58ae913e3de782d0d2af524e2f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga6633a58ae913e3de782d0d2af524e2f7">nvnVertexAttribStateGetStreamIndex</a> (const <a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *attrib)</td></tr>
<tr class="memdesc:ga6633a58ae913e3de782d0d2af524e2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the vertex attribute stream binding index.  <a href="#ga6633a58ae913e3de782d0d2af524e2f7">[詳解]</a><br /></td></tr>
<tr class="separator:ga6633a58ae913e3de782d0d2af524e2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e71254f0f8cd7eb8fa2aa8e8909779f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8e71254f0f8cd7eb8fa2aa8e8909779f">nvnVertexAttribStateSetDefaults</a> (<a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *attrib)</td></tr>
<tr class="memdesc:ga8e71254f0f8cd7eb8fa2aa8e8909779f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nvertex_attrib_state.html" title="API state object controlling vertex attrib state. ">NVNvertexAttribState</a> object.  <a href="#ga8e71254f0f8cd7eb8fa2aa8e8909779f">[詳解]</a><br /></td></tr>
<tr class="separator:ga8e71254f0f8cd7eb8fa2aa8e8909779f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga447b6bbe81e21c3bff3dbf10bc15d80e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga447b6bbe81e21c3bff3dbf10bc15d80e">nvnVertexAttribStateSetFormat</a> (<a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *attrib, <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> format, ptrdiff_t relativeOffset)</td></tr>
<tr class="memdesc:ga447b6bbe81e21c3bff3dbf10bc15d80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the format (in memory) for values for a single vertex attribute.  <a href="#ga447b6bbe81e21c3bff3dbf10bc15d80e">[詳解]</a><br /></td></tr>
<tr class="separator:ga447b6bbe81e21c3bff3dbf10bc15d80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab96f74226c1d22d01c186d908eff14ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gab96f74226c1d22d01c186d908eff14ab">nvnVertexAttribStateSetStreamIndex</a> (<a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *attrib, int streamIndex)</td></tr>
<tr class="memdesc:gab96f74226c1d22d01c186d908eff14ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the vertex attribute stream binding index.  <a href="#gab96f74226c1d22d01c186d908eff14ab">[詳解]</a><br /></td></tr>
<tr class="separator:gab96f74226c1d22d01c186d908eff14ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a99fed1a389e1a231314215842674e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3a99fed1a389e1a231314215842674e9">nvnVertexStreamStateGetDivisor</a> (const <a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *stream)</td></tr>
<tr class="memdesc:ga3a99fed1a389e1a231314215842674e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the frequency divisor in a <a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state. ">NVNvertexStreamState</a> object.  <a href="#ga3a99fed1a389e1a231314215842674e9">[詳解]</a><br /></td></tr>
<tr class="separator:ga3a99fed1a389e1a231314215842674e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebbf25d7f5c74f49b0b3635d3f8d78bc"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaebbf25d7f5c74f49b0b3635d3f8d78bc">nvnVertexStreamStateGetStride</a> (const <a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *stream)</td></tr>
<tr class="memdesc:gaebbf25d7f5c74f49b0b3635d3f8d78bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the stride (in bytes) for a <a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state. ">NVNvertexStreamState</a> object.  <a href="#gaebbf25d7f5c74f49b0b3635d3f8d78bc">[詳解]</a><br /></td></tr>
<tr class="separator:gaebbf25d7f5c74f49b0b3635d3f8d78bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dca0133939bd660957dd5de2a56d240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9dca0133939bd660957dd5de2a56d240">nvnVertexStreamStateSetDefaults</a> (<a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *stream)</td></tr>
<tr class="memdesc:ga9dca0133939bd660957dd5de2a56d240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state. ">NVNvertexStreamState</a> object.  <a href="#ga9dca0133939bd660957dd5de2a56d240">[詳解]</a><br /></td></tr>
<tr class="separator:ga9dca0133939bd660957dd5de2a56d240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6f8d41933935967cde1cadcc328c8da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac6f8d41933935967cde1cadcc328c8da">nvnVertexStreamStateSetDivisor</a> (<a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *stream, int divisor)</td></tr>
<tr class="memdesc:gac6f8d41933935967cde1cadcc328c8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the frequency divisor for vertices in vertex binding N.  <a href="#gac6f8d41933935967cde1cadcc328c8da">[詳解]</a><br /></td></tr>
<tr class="separator:gac6f8d41933935967cde1cadcc328c8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a72c7499ec4a36d8cc38d0b5d575c90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9a72c7499ec4a36d8cc38d0b5d575c90">nvnVertexStreamStateSetStride</a> (<a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *stream, ptrdiff_t stride)</td></tr>
<tr class="memdesc:ga9a72c7499ec4a36d8cc38d0b5d575c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the stride (in bytes) for vertex attribute records fetched from a single vertex binding point.  <a href="#ga9a72c7499ec4a36d8cc38d0b5d575c90">[詳解]</a><br /></td></tr>
<tr class="separator:ga9a72c7499ec4a36d8cc38d0b5d575c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fa0b45affa2e04d77e3c1ad11a03c32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__enum.html#ga58e9b155d7f2272b95044eed1f40415e">NVNwindowAcquireTextureResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga7fa0b45affa2e04d77e3c1ad11a03c32">nvnWindowAcquireTexture</a> (<a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window, <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *textureAvailableSync, int *textureIndex)</td></tr>
<tr class="memdesc:ga7fa0b45affa2e04d77e3c1ad11a03c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire a texture from the window.  <a href="#ga7fa0b45affa2e04d77e3c1ad11a03c32">[詳解]</a><br /></td></tr>
<tr class="separator:ga7fa0b45affa2e04d77e3c1ad11a03c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a123578bac4b0a41cd7601cc53b84f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga8a123578bac4b0a41cd7601cc53b84f5">nvnWindowBuilderGetDevice</a> (const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga8a123578bac4b0a41cd7601cc53b84f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the device associated with this <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object.  <a href="#ga8a123578bac4b0a41cd7601cc53b84f5">[詳解]</a><br /></td></tr>
<tr class="separator:ga8a123578bac4b0a41cd7601cc53b84f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20d7c6255438597f1e6ff33a17bc1028"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga20d7c6255438597f1e6ff33a17bc1028">nvnWindowBuilderGetNativeWindow</a> (const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga20d7c6255438597f1e6ff33a17bc1028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the native window for a <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object.  <a href="#ga20d7c6255438597f1e6ff33a17bc1028">[詳解]</a><br /></td></tr>
<tr class="separator:ga20d7c6255438597f1e6ff33a17bc1028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad10a6368b14ab7ba7d98f2855c800f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gacad10a6368b14ab7ba7d98f2855c800f">nvnWindowBuilderGetNumTextures</a> (const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder)</td></tr>
<tr class="memdesc:gacad10a6368b14ab7ba7d98f2855c800f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of textures associated with this <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object.  <a href="#gacad10a6368b14ab7ba7d98f2855c800f">[詳解]</a><br /></td></tr>
<tr class="separator:gacad10a6368b14ab7ba7d98f2855c800f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23b4fc7396418e24deb8286cdb74da8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga23b4fc7396418e24deb8286cdb74da8f">nvnWindowBuilderGetPresentInterval</a> (const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga23b4fc7396418e24deb8286cdb74da8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the present interval for a <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object.  <a href="#ga23b4fc7396418e24deb8286cdb74da8f">[詳解]</a><br /></td></tr>
<tr class="separator:ga23b4fc7396418e24deb8286cdb74da8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02e84bd3df0a6dd2bc27e9775f959da2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga02e84bd3df0a6dd2bc27e9775f959da2">nvnWindowBuilderGetTexture</a> (const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder, int textureId)</td></tr>
<tr class="memdesc:ga02e84bd3df0a6dd2bc27e9775f959da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the texture with index textureId associated with this <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object.  <a href="#ga02e84bd3df0a6dd2bc27e9775f959da2">[詳解]</a><br /></td></tr>
<tr class="separator:ga02e84bd3df0a6dd2bc27e9775f959da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3924f2d40fa227e1b405df3755ad46e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3924f2d40fa227e1b405df3755ad46e7">nvnWindowBuilderSetDefaults</a> (<a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder)</td></tr>
<tr class="memdesc:ga3924f2d40fa227e1b405df3755ad46e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object.  <a href="#ga3924f2d40fa227e1b405df3755ad46e7">[詳解]</a><br /></td></tr>
<tr class="separator:ga3924f2d40fa227e1b405df3755ad46e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf93ec4cee4147e9cc004b7b16c802621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf93ec4cee4147e9cc004b7b16c802621">nvnWindowBuilderSetDevice</a> (<a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder, <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *device)</td></tr>
<tr class="memdesc:gaf93ec4cee4147e9cc004b7b16c802621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object.  <a href="#gaf93ec4cee4147e9cc004b7b16c802621">[詳解]</a><br /></td></tr>
<tr class="separator:gaf93ec4cee4147e9cc004b7b16c802621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac518ddbead9eac057d3578c6195166b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac518ddbead9eac057d3578c6195166b2">nvnWindowBuilderSetNativeWindow</a> (<a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder, <a class="el" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a> nativeWindow)</td></tr>
<tr class="memdesc:gac518ddbead9eac057d3578c6195166b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the native window where the textures of this window will be presented to.  <a href="#gac518ddbead9eac057d3578c6195166b2">[詳解]</a><br /></td></tr>
<tr class="separator:gac518ddbead9eac057d3578c6195166b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c80a6fc0718d28e05c183a8110b9f07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga9c80a6fc0718d28e05c183a8110b9f07">nvnWindowBuilderSetPresentInterval</a> (<a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder, int presentInterval)</td></tr>
<tr class="memdesc:ga9c80a6fc0718d28e05c183a8110b9f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the present interval used when presenting to this window.  <a href="#ga9c80a6fc0718d28e05c183a8110b9f07">[詳解]</a><br /></td></tr>
<tr class="separator:ga9c80a6fc0718d28e05c183a8110b9f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga610c7f233b7bb1e02f4926fe554df5db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga610c7f233b7bb1e02f4926fe554df5db">nvnWindowBuilderSetTextures</a> (<a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder, int numTextures, <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *const *textures)</td></tr>
<tr class="memdesc:ga610c7f233b7bb1e02f4926fe554df5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the textures used for presenting to this window.  <a href="#ga610c7f233b7bb1e02f4926fe554df5db">[詳解]</a><br /></td></tr>
<tr class="separator:ga610c7f233b7bb1e02f4926fe554df5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53660a4abfffea411f62415c79a65cdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga53660a4abfffea411f62415c79a65cdf">nvnWindowFinalize</a> (<a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window)</td></tr>
<tr class="memdesc:ga53660a4abfffea411f62415c79a65cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object.  <a href="#ga53660a4abfffea411f62415c79a65cdf">[詳解]</a><br /></td></tr>
<tr class="separator:ga53660a4abfffea411f62415c79a65cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0857c62a4ddce422c4aed104c607ac4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gae0857c62a4ddce422c4aed104c607ac4">nvnWindowGetCrop</a> (const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window, <a class="el" href="struct_n_v_nrectangle.html">NVNrectangle</a> *crop)</td></tr>
<tr class="memdesc:gae0857c62a4ddce422c4aed104c607ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimensions of the crop rectangle that defines the region inside the window texture which gets displayed.  <a href="#gae0857c62a4ddce422c4aed104c607ac4">[詳解]</a><br /></td></tr>
<tr class="separator:gae0857c62a4ddce422c4aed104c607ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35e25752c0757803fdb19b8b9584af9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga35e25752c0757803fdb19b8b9584af9a">nvnWindowGetNativeWindow</a> (const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window)</td></tr>
<tr class="memdesc:ga35e25752c0757803fdb19b8b9584af9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the native window for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object.  <a href="#ga35e25752c0757803fdb19b8b9584af9a">[詳解]</a><br /></td></tr>
<tr class="separator:ga35e25752c0757803fdb19b8b9584af9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga759e5d9a7bd29dda539893cfd23d3ca2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga759e5d9a7bd29dda539893cfd23d3ca2">nvnWindowGetPresentInterval</a> (const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window)</td></tr>
<tr class="memdesc:ga759e5d9a7bd29dda539893cfd23d3ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the present interval for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object.  <a href="#ga759e5d9a7bd29dda539893cfd23d3ca2">[詳解]</a><br /></td></tr>
<tr class="separator:ga759e5d9a7bd29dda539893cfd23d3ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5c388ac1ed70cb34ea4d71d23af9a73"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gac5c388ac1ed70cb34ea4d71d23af9a73">nvnWindowInitialize</a> (<a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window, const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *builder)</td></tr>
<tr class="memdesc:gac5c388ac1ed70cb34ea4d71d23af9a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new window object from a window builder.  <a href="#gac5c388ac1ed70cb34ea4d71d23af9a73">[詳解]</a><br /></td></tr>
<tr class="separator:gac5c388ac1ed70cb34ea4d71d23af9a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf961e88cbeee4c0612548c40e7db432d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#gaf961e88cbeee4c0612548c40e7db432d">nvnWindowSetCrop</a> (<a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window, int x, int y, int w, int h)</td></tr>
<tr class="memdesc:gaf961e88cbeee4c0612548c40e7db432d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the rectangle inside the window texture that gets displayed.  <a href="#gaf961e88cbeee4c0612548c40e7db432d">[詳解]</a><br /></td></tr>
<tr class="separator:gaf961e88cbeee4c0612548c40e7db432d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e7fcf2ce10cbe51af72130cacac4840"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga4e7fcf2ce10cbe51af72130cacac4840">nvnWindowSetDebugLabel</a> (<a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window, const char *label)</td></tr>
<tr class="memdesc:ga4e7fcf2ce10cbe51af72130cacac4840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object.  <a href="#ga4e7fcf2ce10cbe51af72130cacac4840">[詳解]</a><br /></td></tr>
<tr class="separator:ga4e7fcf2ce10cbe51af72130cacac4840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b735c095396aabd05d437bd2bda1ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvn__c__functions.html#ga3b735c095396aabd05d437bd2bda1ded">nvnWindowSetPresentInterval</a> (<a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *window, int presentInterval)</td></tr>
<tr class="memdesc:ga3b735c095396aabd05d437bd2bda1ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the present interval for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object.  <a href="#ga3b735c095396aabd05d437bd2bda1ded">[詳解]</a><br /></td></tr>
<tr class="separator:ga3b735c095396aabd05d437bd2bda1ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<p>C Interface API entry points. </p>
<h2 class="groupheader">関数詳解</h2>
<a class="anchor" id="gaa042629cf4bc5ef1fab4bc7bf37b6f4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceBuilderSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_ndevice_builder.html" title="Object specifying state used to construct new device objects. ">NVNdeviceBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ndevice_builder.html" title="Object specifying state used to construct new device objects. ">NVNdeviceBuilder</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a21">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a34">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a34">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a30">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a30">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a22">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a22">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a21">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a21">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a28">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga918d154a1d1f156eb61e6a3e402cbf1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceBuilderSetFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set flags used for during device initialzation. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ndevice_builder.html" title="Object specifying state used to construct new device objects. ">NVNdeviceBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">flags</td><td>Flags to use during device initialization. See <a class="el" href="group__nvn__c__enum.html#ga9c68350bf64f2e7a90a23290c26872d3" title="Specifies additional flags when creating a device. ">NVNdeviceFlagBits</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a22">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a35">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a35">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a31">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a31">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a23">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a23">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a22">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a22">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a29">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gacfe3e96f8b8ef13acb9008e4098196d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga9c68350bf64f2e7a90a23290c26872d3">NVNdeviceFlagBits</a> nvnDeviceBuilderGetFlags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get flags associated with this <a class="el" href="struct_n_v_ndevice_builder.html" title="Object specifying state used to construct new device objects. ">NVNdeviceBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ndevice_builder.html" title="Object specifying state used to construct new device objects. ">NVNdeviceBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac05386acab686b7614d353c9a4ea4d96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnDeviceInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice_builder.html">NVNdeviceBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> object from a device builder. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> object to initialize.</td></tr>
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ndevice_builder.html" title="Object specifying state used to construct new device objects. ">NVNdeviceBuilder</a> object holding properties of the new <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a23">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a36">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a36">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a32">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a32">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a24">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a24">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a23">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a23">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a30">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga5fccd6ba67cd2d269900832d3b7e82ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a68">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a107">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a116">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a155">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a113">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a84">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a84">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a95">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a61">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a144">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga6bfa6529d97f627325bd9ac84605a9b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacddfe3caf2f24874b617cd696e3a4305"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__funcptrs.html#ga181fc0ee0f3ee509c16ca8e0c93b08cf">PFNNVNGENERICFUNCPTRPROC</a> nvnDeviceGetProcAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query a function pointer for a specified C interface entry point for a device. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> object to query.</td></tr>
    <tr><td class="paramname">name</td><td>Name of the C entry point to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6f739de39c3818a65b190be3a82cf891"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceGetInteger </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac887e20e2474bb76b87943b0f0be7a50">NVNdeviceInfo</a>&#160;</td>
          <td class="paramname"><em>pname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query properties of a device. </p>
<dl class="section note"><dt>覚え書き</dt><dd><em>device</em> may be NULL when querying supported API or GPU shader code versions prior to creating a device object. For all other queries, <em>device</em> must point at a valid NVN device object.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> to query.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pname</td><td>Property to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Value associated with the property, returned to the application. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a77">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a2">DebugTextRenderer.cpp</a>, <a class="el" href="_gfx_primitive_renderer_8cpp-example.html#a187">GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_gfx_shader_compile_8cpp-example.html#a247">GfxShaderCompile.cpp</a>, <a class="el" href="_gfx_simple_8cpp-example.html#a199">GfxSimple.cpp</a>, <a class="el" href="_managed_command_buffer_8cpp-example.html#a2">ManagedCommandBuffer.cpp</a>, <a class="el" href="_mii_compressed_texture_8cpp-example.html#a140">MiiCompressedTexture.cpp</a>, <a class="el" href="_mii_database_8cpp-example.html#a138">MiiDatabase.cpp</a>, <a class="el" href="_mii_dynamic_mask_8cpp-example.html#a141">MiiDynamicMask.cpp</a>, <a class="el" href="_mii_headwear_example_8cpp-example.html#a152">MiiHeadwearExample.cpp</a>, <a class="el" href="_mii_mip_map_8cpp-example.html#a137">MiiMipMap.cpp</a>, <a class="el" href="_mii_premultiplied_alpha_icon_8cpp-example.html#a316">MiiPremultipliedAlphaIcon.cpp</a>, <a class="el" href="_mii_shader_example_8cpp-example.html#a142">MiiShaderExample.cpp</a>, <a class="el" href="_mii_simple_8cpp-example.html#a138">MiiSimple.cpp</a>, <a class="el" href="_mii_simple_icon_8cpp-example.html#a224">MiiSimpleIcon.cpp</a>, <a class="el" href="_mii_simple_icon_body_8cpp-example.html#a224">MiiSimpleIconBody.cpp</a>, <a class="el" href="_mii_simple_variable_icon_body_8cpp-example.html#a226">MiiSimpleVariableIconBody.cpp</a>, <a class="el" href="_mii_system_resource_8cpp-example.html#a138">MiiSystemResource.cpp</a>, <a class="el" href="_mii_transparent_adjuster_8cpp-example.html#a224">MiiTransparentAdjuster.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a14">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a14">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a21">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a21">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a23">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a23">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a15">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a15">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a14">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a14">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a21">NvnTutorial11.cpp</a>, <a class="el" href="_render_thread_pool_8cpp-example.html#a3">RenderThreadPool.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a1">StatTracker.cpp</a>, <a class="el" href="_texture_i_d_manager_8cpp-example.html#a1">TextureIDManager.cpp</a>, <a class="el" href="_uniform_buffer_8cpp-example.html#a2">UniformBuffer.cpp</a>, <a class="el" href="_uniform_buffer_manager_8cpp-example.html#a12">UniformBufferManager.cpp</a> (計35項目).</dd>
</dl>
</div>
</div>
<a class="anchor" id="gae11fb2040aadb9ab716ffc31d5f21e43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nvnDeviceGetCurrentTimestampInNanoseconds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get timestamp from the device, without queuing like the ReportCounter functions. </p>
<p>See the <a class="el" href="nvn_index.html#nvn_guide_counters">Counters</a> section of the NVN Programming Guide for more detail.</p>
<dl class="section note"><dt>覚え書き</dt><dd><em>device</em> must point at a valid NVN device object.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafc2c6dd07f2db4dddff39bcd0eff76a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceSetIntermediateShaderCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numMaxEntries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the shader cache for the Windows reference platform to store fat binary intermediate results. </p>
<p>If the NVN platform is NX, this function does nothing.</p>
<p>On the Windows reference implemenetation, nvnProgramSetShaders will compile machine code that can run on the attached GPU, using intermediate shader code and specialization information stored in the provided control data. If the same shader is compiled with different specialization information (via glslcCompileSpecialized) using this cache can avoid re-processing the same shader code on each call to nvnProgramSetShaders.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device owning the programs to cache.</td></tr>
    <tr><td class="paramname">numMaxEntries</td><td>Maximum number of entries that the intermediate shader cache can hold. If this is 0, the cache will be disabled and any previous cache resources will be cleaned up. If a non-zero value is used, the cache will hold intermediate code for up to <em>numMaxEntries</em> unique shaders. Programs containing multiple shader stages will consume multiple entries in this cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0ca6fe7fc102170723f5eccb14a25046"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a> nvnDeviceGetTextureHandle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samplerID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a combined pair of <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> and <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device owning the texture and sampler objects.</td></tr>
    <tr><td class="paramname">textureID</td><td>Registered ID of the <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a513596e8b2dc04714d6478aed173a891" title="Number of entries reserved at the beginning of the texture pool for internal driver usage...">NVN_DEVICE_INFO_RESERVED_TEXTURE_DESCRIPTORS</a>).</td></tr>
    <tr><td class="paramname">samplerID</td><td>Registered ID of the <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5b9a26a5aadab05c4a9f8a286718fbc7" title="Number of samplers that must be reserved for use by the driver. ">NVN_DEVICE_INFO_RESERVED_SAMPLER_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_data_holder_8cpp-example.html#a19">AssetFileDataHolder.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a99">DebugTextRenderer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a43">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a88">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gab0b754403b7c24211f204fd7667466da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a> nvnDeviceGetTexelFetchHandle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object for use in texel fetches. </p>
<p>A handle produced by this entry point can be used for texel fetches via the texelFetch() GLSL built-in function. Using such handles in texture lookups will use undefined sampler state.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device owning the texture object.</td></tr>
    <tr><td class="paramname">textureID</td><td>Registered ID of the <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a513596e8b2dc04714d6478aed173a891" title="Number of entries reserved at the beginning of the texture pool for internal driver usage...">NVN_DEVICE_INFO_RESERVED_TEXTURE_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9c42db1b24a512270afa6abd615fae01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__handle.html#gacba3c44a43c05f11bc1b88c49b118606">NVNimageHandle</a> nvnDeviceGetImageHandle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>imageID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle to use for image loads and stores to a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device owning the texture and sampler objects.</td></tr>
    <tr><td class="paramname">imageID</td><td>Registered image ID of the <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a513596e8b2dc04714d6478aed173a891" title="Number of entries reserved at the beginning of the texture pool for internal driver usage...">NVN_DEVICE_INFO_RESERVED_TEXTURE_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab73dcc0df1012caf66620aa7c56b2592"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceInstallDebugCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__c__funcptrs.html#ga23608b4a63e52475d42d90101108cdf1">PFNNVNDEBUGCALLBACKPROC</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install or remove a callback function to be called whenever the debug layer generates a message. </p>
<p>Multiple callback functions (each with separate callback data) are supported.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> used for the callback.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">callback</td><td>Pointer to a callback function to call.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">callbackData</td><td>Pointer to arbitrary data to pass in each call to the callback function.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) the specified callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a24">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a37">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a37">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a33">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a33">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a25">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a25">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a24">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a24">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a31">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga7fb39752d0d8dd9d254667f3042c42b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga721dd09710079ec7e1d153842dbc7665">NVNdebugDomainId</a> nvnDeviceGenerateDebugDomainId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a unique ID by atomically incrementing a global counter on each request. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> used.</td></tr>
    <tr><td class="paramname">name</td><td>Name to associate to new domain id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga24c4fdcf11f6dc0bf042566b4da7bba4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceSetWindowOriginMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga52db1bf3e182ec089c43db5a02baecd6">NVNwindowOriginMode</a>&#160;</td>
          <td class="paramname"><em>windowOriginMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global location for window coordinates (0,0). </p>
<p>Applications should set the window origin mode in the device before creating any queues or command buffers, and should use that mode for the lifetime of the application. Rendering results are undefined if there are any inconsistencies between the window origin mode (a) currently set for the device, (b) set when creating the command buffer used to create rendering commands, or (c) set when creating the queue used to submit rendering commands.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">windowOriginMode</td><td>New location for the window origin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8b42972a78ea6d7180106f97a8ef1eec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceSetDepthMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga0e55de1522658c843016e8b24a8ecabd">NVNdepthMode</a>&#160;</td>
          <td class="paramname"><em>depthMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global clipping range for normalized depth in clip space. </p>
<p>Applications should set the depth mode in the device before creating any queues or command buffers, and should use that mode for the lifetime of the application. Rendering results are undefined if there are any inconsistencies between the depth mode (a) currently set for the device, (b) set when creating the command buffer used to create rendering commands, or (c) set when creating the queue used to submit rendering commands.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">depthMode</td><td>New policy for depth clipping. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gace7813b0e44d122d452df918525ef8a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnDeviceRegisterFastClearColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a fast clear color value. </p>
<p>Applications can register specific combinations of clear values and formats that it expects to use for future framebuffer clears. Clearing the framebuffer using one of these registered clear colors will result in reduced memory bandwidth usage and increased performance when used with compressible textures.</p>
<p>The number of clear values that can be registered is limited. Additionally, this command is supported only for formats with more than 16 bits per pixel and floating-point or normalized components. If a clear value or format can not be registered, NVN_FALSE is returned. If registration is successful, NVN_TRUE is returned.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">color</td><td>Array of four floating-point (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">format</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> format to encode the value into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1c2df0951b28828873afc21370d7c010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnDeviceRegisterFastClearColori </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a signed integer fast clear color value. </p>
<p>Applications can register specific combinations of clear values and formats that it expects to use for future framebuffer clears. Clearing the framebuffer using one of these registered clear colors will result in reduced memory bandwidth usage and increased performance when used with compressible textures.</p>
<p>The number of clear values that can be registered is limited. Additionally, this command is supported only for formats with more than 16 bits per pixel and signed integer components. If a clear value or format can not be registered, NVN_FALSE is returned. If registration is successful, NVN_TRUE is returned.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">color</td><td>Array of four signed integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">format</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> format to encode the value into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9cfafa315b6bea064d93dd963eb7b891"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnDeviceRegisterFastClearColorui </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an unsigned integer fast clear color value. </p>
<p>Applications can register specific combinations of clear values and formats that it expects to use for future framebuffer clears. Clearing the framebuffer using one of these registered clear colors will result in reduced memory bandwidth usage and increased performance when used with compressible textures.</p>
<p>The number of clear values that can be registered is limited. Additionally, this command is supported only for formats with more than 16 bits per pixel and unsigned integer components. If a clear value or format can not be registered, NVN_FALSE is returned. If registration is successful, NVN_TRUE is returned.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">color</td><td>Array of four unsigned integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">format</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> format to encode the value into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2c9adc51dc192c3e48dc4c0e2e6f2e86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnDeviceRegisterFastClearDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a fast clear depth value. </p>
<p>Applications can register specific clear values that it expects to use for future depth buffer clears. Clearing the depth buffer using one of these registered clear depth values will result in reduced memory bandwidth usage and increased performance when used with compressible textures.</p>
<p>The number of clear values that can be registered is finite. If a clear value can not be registered, NVN_FALSE is returned. If registration is successful, NVN_TRUE is returned. </p><dl class="section note"><dt>覚え書き</dt><dd>16-bit depth textures (<a class="el" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecaba66e178062c6e76540621006c44c82ba9" title="A 16-bit unsigned normalized depth component. ">NVN_FORMAT_DEPTH16</a>) have limited support for fast clears. See documentation on <a class="el" href="group__nvn__c__enum.html#gga57ab2536473c8e62f621554a2618121bad04da7f2ffe131d7103cd9de47be2227" title="Favor fast clear over depth compression for DEPTH16 depth textures. ">NVN_TEXTURE_FLAGS_DEPTH16_PREFER_FAST_CLEAR_BIT</a> for more information.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be modified.</td></tr>
    <tr><td class="paramname">depth</td><td>Depth value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1f3e9684e49790ad324c33e38a07276b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga52db1bf3e182ec089c43db5a02baecd6">NVNwindowOriginMode</a> nvnDeviceGetWindowOriginMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the window origin mode for a device. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga764b1be2fcce7a44895399a46646bb14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga0e55de1522658c843016e8b24a8ecabd">NVNdepthMode</a> nvnDeviceGetDepthMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth mode for a device. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9dad3a471fcb5313fd4aab24e8062f1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nvnDeviceGetTimestampInNanoseconds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncounter_data.html">NVNcounterData</a> *&#160;</td>
          <td class="paramname"><em>counterData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the timestamp contained in a counter report, with time values converted from the platform-specific timestamp resolution to nanoseconds. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> used to perform the counter report operation.</td></tr>
    <tr><td class="paramname">counterData</td><td>Pointer to a full <a class="el" href="struct_n_v_ncounter_data.html" title="Data structure describing how counter values are written to buffer memory. ">NVNcounterData</a> structure containing the timestamp value to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga07e26faaa8d6569f115906735d337b36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceApplyDeferredFinalizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>age</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize buffers, textures, and samplers previously scheduled for finalization. </p>
<p>When a device is initialized with <a class="el" href="group__nvn__c__enum.html#gga9c68350bf64f2e7a90a23290c26872d3a7d8aa2addc09bed76cbf0a10a35abb7c" title="Enable deferred finalization of textures, buffers and sampler objects. ">NVN_DEVICE_FLAG_DEFERRED_FINALIZE_BIT</a> set, calls to nvnBufferFinalize, nvnTextureFinalize, and nvnSamplerFinalize don't immediately finalize buffer, texture, and sampler objects, but instead schedule them for future finalization. This command finalizes such objects, where the set of objects finalized by this command depends on the <em>age</em> parameter. This command has no effect if deferred finalization is not enabled in <em>device</em>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> used to apply deferred finalizes.</td></tr>
    <tr><td class="paramname">age</td><td>Minimum age for deferred finalizations. Objects scheduled for finalization have an 'age' that is initially set to zero and incremented each time nvnDeviceApplyDeferredFinalizes is called. Each object scheduled for finalization will be finalized by this call if and only if its age (before incrementing) is greater than or equal to <em>age</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5babbe756bd750bf3fd41c2b4049a730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceFinalizeCommandHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a>&#160;</td>
          <td class="paramname"><em>handles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a command handle. </p>
<p>This command can be used to free any memory associated with a command handle that may have been allocated by the debug layer or other developer tools that track the contents of a command set. If command handles are not explicitly finalized, associated memory will be freed only when the command or control memory associated with the command set is freed or reused.</p>
<p>This command has no effect if the debug layer and other developer tools are disabled.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> associated with the command handle.</td></tr>
    <tr><td class="paramname">handles</td><td>Command handle to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf12100926a7307bf74d86ab68dd59e65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDeviceWalkDebugDatabase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga1ad0f9413adde3e3c46751c0312564ea">NVNdebugObjectType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__funcptrs.html#ga3a91188b67a504893ce16e6f4febce03">PFNNVNWALKDEBUGDATABASECALLBACKPROC</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk through the debug layer object database. </p>
<p>Debug layer must be enabled.</p>
<p>Reports the debug layer's list of objects of the given type through the callback function. At least Level 1 debug layer must be enabled, as object tracking is not done at debug layer level 0. See <a class="el" href="nvn_index.html#nvn_guide_api_object_tracking">API Object Tracking</a> for detail.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> associated with list of objects to be reported.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">type</td><td>Type of objects to walk through.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">callback</td><td>Callback function to be called for every object matching the given device and object type.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">userParam</td><td>Value to be passed to the callback holding a 'user pointer' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0f3dbb400d79d6d8dc64c052226ba809"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_n_v_nseparate_texture_handle.html">NVNseparateTextureHandle</a> nvnDeviceGetSeparateTextureHandle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device owning the texture object.</td></tr>
    <tr><td class="paramname">textureID</td><td>Registered ID of the <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a513596e8b2dc04714d6478aed173a891" title="Number of entries reserved at the beginning of the texture pool for internal driver usage...">NVN_DEVICE_INFO_RESERVED_TEXTURE_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2c15b1de83a8fe22f4ef03b74d8f946a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_n_v_nseparate_sampler_handle.html">NVNseparateSamplerHandle</a> nvnDeviceGetSeparateSamplerHandle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samplerID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle for a separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device owning the sampler object.</td></tr>
    <tr><td class="paramname">samplerID</td><td>Registered ID of the <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5b9a26a5aadab05c4a9f8a286718fbc7" title="Number of samplers that must be reserved for use by the driver. ">NVN_DEVICE_INFO_RESERVED_SAMPLER_DESCRIPTORS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9291748f30602dc5655cd1556fc2eb01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnDeviceIsExternalDebuggerAttached </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if an external debugger is attached when running an NVN application. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga81cb87eb9eba8acd7de1fa80ab673ab7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga2a36e1011d80409e1d1cd7c87e81035c">NVNqueueGetErrorResult</a> nvnQueueGetError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_n_v_nqueue_error_info.html">NVNqueueErrorInfo</a> *&#160;</td>
          <td class="paramname"><em>errorInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get GPU error status of the queue. </p>
<p>Applications can use this function to check if queue encountered unrecoverable GPU error such as invalid GPU memory accesses, invalid command, timeout or other errors. After GPU error queue is in faulted state and following behavior is expected:</p><ol type="1">
<li><a class="el" href="group__nvn__c__functions.html#gaab3c15f657cefdff33dab453795ff38f" title="Wait until all commands previously submitted to a queue have completed execution. ...">nvnQueueFinish()</a> returns immediately.</li>
<li><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> objects placed into faulted queue signal completion.</li>
<li>Faulted queue can be finalized to free resources.</li>
<li>Remaining nvnQueue API calls for faulted queue are ignored or return error.</li>
<li>Other device queues are not affected or blocked by faulted queue.</li>
</ol>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> whose status should be checked for GPU error.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errorInfo</td><td>Pointer to structure to save information about error. If set to NULL, information will not be retrieved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacc96e4b44f4c1fa2540ecbcb37c4fe62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnQueueGetTotalCommandMemoryUsed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query total queue command memory usage. </p>
<p>This command returns the total amount of queue command memory (in bytes) used by queue commands since the queue was initialized or since usage counts were last reset by nvnQueueResetMemoryUsageCounts. The total memory usage count can be used by application developers to determine the amount of memory to provide when initializing a queue. Note that memory usage counts may exceed the total amount of memory provided to the queue since the NVN driver will automatically reuse queue memory when required.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1f0889104e9531bc404a133456bad956"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnQueueGetTotalControlMemoryUsed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query total queue control memory usage. </p>
<p>This command returns the total amount of queue control memory (in bytes) used by queue commands since the queue was initialized or since usage counts were last reset by nvnQueueResetMemoryUsageCounts. The total memory usage count can be used by application developers to determine the amount of memory to provide when initializing a queue. Note that memory usage counts may exceed the total amount of memory provided to the queue since the NVN driver will automatically reuse queue memory when required.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga70fb17ac6a5d34a7e8eb17a8d1e9a28e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnQueueGetTotalComputeMemoryUsed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query total queue compute memory usage. </p>
<p>This command returns the total amount of queue compute memory (in bytes) used by queue commands since the queue was initialized or since usage counts were last reset by nvnQueueResetMemoryUsageCounts. The total memory usage count can be used by application developers to determine the amount of memory to provide when initializing a queue. Note that memory usage counts may exceed the total amount of memory provided to the queue since the NVN driver will automatically reuse queue memory when required.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae59349fe88c0a1e539a891b79e1bff72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueResetMemoryUsageCounts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset usage counters for command, control and compute memory. </p>
<p>This command resets the accumulated usage counters for queue command, control, and compute memory.</p>
<dl class="section note"><dt>覚え書き</dt><dd><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> memory consumed by GPU commands may not be added to the usage counters reset by this command until the queue is next flushed. When total queue memory usage is queried, any memory used by unflushed commands will be added to the total usage counters. As a result, querying memory usage immediately after resetting counters may return non-zero values if the queue has unflushed commands.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object with counters to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7fdbe1fc82e21cf370aa7f1fa0a6141a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueBuilderSetDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> owning <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> objects created by the <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a27">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a40">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a40">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a36">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a36">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a28">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a28">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a27">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a27">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a34">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga20bc093a367e06cd1f1f273289354b75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueBuilderSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object. </p>
<p>This method does not modify the device associated with the builder, which is programmed by SetDevice.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a28">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a41">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a41">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a37">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a37">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a29">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a29">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a28">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a28">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a35">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga1665885cd6a9f8b9c3fbac546243b440"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueBuilderSetFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set properties of <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> objects created from the builder. </p>
<p>The default value for queue flags is <a class="el" href="group__nvn__c__enum.html#gga23e18ba1a4734288fff6c67afd04df14a3b2769b009642157d73235802a1a7ad4" title="No special operation behavior is required by the queue. ">NVN_QUEUE_FLAGS_NONE</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">flags</td><td>Flags controlling the behavior of queues initialized using the builder. See <a class="el" href="group__nvn__c__enum.html#ga23e18ba1a4734288fff6c67afd04df14" title="Flags controlling the behavior of NVNqueue objects. ">NVNqueueFlags</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4291be788552aa888e9551d0e1084bfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueBuilderSetCommandMemorySize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the size of the internal command buffer used by a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object. </p>
<p>Each NVN queue has an internal command buffer used to send commands to the GPU. This command buffer is used by some <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> class methods and is also used for any required submit-time processing of command sets sent by nvnQueueSubmitCommands. Most queue commands do not require a large amount of command memory. However, compute dispatches and shader subroutine uniform updates can require a substantial amount of per-queue command memory. The internal queue command buffer memory is managed automatically by the NVN driver, and internal queue flushes may be required if a significant amount of command memory is used since the last explicit queue flush. For workloads requiring a significant amount of command memory, applications can specify a command memory size larger than the 64KB default size.</p>
<p>The default command memory size can be queried using the property <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a1275409c693a426d639a6460b42a9cb9" title="Default size for per-queue command memory. ">NVN_DEVICE_INFO_QUEUE_COMMAND_MEMORY_DEFAULT_SIZE</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the queue's internal command memory. Must be greater than or equal to 65536 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50af620633087a96a544b6c2ff6741a7697" title="Minimum allowed size for per-queue command memory. ">NVN_DEVICE_INFO_QUEUE_COMMAND_MEMORY_MIN_SIZE</a>). Must be a multiple of 4096 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ade5c93496a7e3c7830b2b9c961901816" title="Required granularity for per-queue command memory. ">NVN_DEVICE_INFO_QUEUE_COMMAND_MEMORY_GRANULARITY</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a31">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a44">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a44">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a40">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a40">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a32">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a32">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a31">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a31">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a38">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga161b2d39535ffac2829d972058391bb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueBuilderSetComputeMemorySize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the size of the internal buffers used for compute dispatches in a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object. </p>
<p>Each NVN queue may have an internal ring buffer used to hold information on compute dispatches that have been submitted to the queue but have not completed execution. The queue compute memory is managed automatically by the NVN driver, but the total size of this ring buffer can limit the number of compute dispatches in flight. Applications using a large number of compute dispatches per frame may benefit from increasing the size of this buffer. Applications not using compute shaders at all may set the size to zero to save memory.</p>
<p>The default compute memory size can be queried using the property <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ab35cc3044033489f4f72bc81576a614b" title="Default size for per-queue compute memory. ">NVN_DEVICE_INFO_QUEUE_COMPUTE_MEMORY_DEFAULT_SIZE</a>.</p>
<dl class="section note"><dt>覚え書き</dt><dd>If the queue compute memory size is zero, it is illegal to submit command sets containing compute work, such as nvnCommandBufferDispatchCompute.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the embedded queue command buffer. Must be a multiple of 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a85d83ee88a1d86d44da8f3ccce567553" title="Required granularity for per-queue compute memory. ">NVN_DEVICE_INFO_QUEUE_COMPUTE_MEMORY_GRANULARITY</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a29">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a42">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a42">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a38">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a38">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a30">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a30">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a29">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a29">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a36">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaef123992e515f2eac2af9fecad8634a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueBuilderSetControlMemorySize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the size of the control memory buffer used by a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object. </p>
<p>Each NVN queue has an internal control memory buffer used for gathering command buffer references consumed by the GPU. For example nvnQueueSubmitCommands and nvnCommandBufferCallCommands will add these references. The control buffer needs to be large enough so that NVN doesn't need to stall due to waiting for the buffer to drain. On the other hand, unnecessarily large buffer wastes memory. The default size of 16KB should be enough for most applications, but an application may want to tune this value for its needs. NVN will issue a debug layer performance warning in case the buffer is too small.</p>
<p>The default queue control memory size can be queried using the property <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a6c14564a64b9425808158e3bfc05db1a" title="Default size for queue control memory. ">NVN_DEVICE_INFO_QUEUE_CONTROL_MEMORY_DEFAULT_SIZE</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the queue control memory. Must be greater than or equal to 4096 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a0e27f85a4c45ef97de142618f384b6d3" title="Minimum allowed size for queue control memory. ">NVN_DEVICE_INFO_QUEUE_CONTROL_MEMORY_MIN_SIZE</a>). Must be a multiple of 4096 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a4a7d50535e574f4b8b9fc8a4e2431ed9" title="Required granularity for queue control memory. ">NVN_DEVICE_INFO_QUEUE_CONTROL_MEMORY_GRANULARITY</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2903b2910d9471307595962237d3c578"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnQueueBuilderGetQueueMemorySize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the amount of extra memory needed for a queue initialized using a <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a>. </p>
<p>Each NVN queue requires a separate block of per-queue memory for the GPU to use, which can be provided by nvnQueueBuilderSetQueueMemory. This command allows applications to determine the size of the provided memory, given the current <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> state. For correct operation, the <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> must have a device set via nvnQueueBuilderSetDevice.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a33">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a46">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a46">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a42">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a42">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a34">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a34">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a33">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a33">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a40">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga0403d233aff80ce9cc6548b5dbe24ca2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueBuilderSetQueueMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides memory to be used by queues pools initialized using a <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a>. </p>
<p>Each NVN queue created from a queue builder requires per-queue memory for several uses:</p>
<ul>
<li>Embedded command buffer memory, with a size provided by nvnQueueBuilderSetCommandMemorySize. </li>
<li>Embedded control memory, with a size provided by nvnQueueBuilderSetControlMemorySize. </li>
<li>Compute shader ring buffers, with a size provided by nvnQueueBuilderSetComputeMemorySize. </li>
<li>Scratch memory for fragment shader interlocks, which can be disabled by setting <a class="el" href="group__nvn__c__enum.html#gga23e18ba1a4734288fff6c67afd04df14aa3e0ad816f08301b322ba4d01d1853cd" title="Disable support for fragment shader interlocks. ">NVN_QUEUE_FLAGS_NO_FRAGMENT_INTERLOCK_BIT</a>. </li>
<li>Scratch memory for other internal GPU operations.</li>
</ul>
<p>When a queue is initialized using a queue builder on NX, <em>size</em> bytes of memory pointed to by <em>memory</em> will be owned by the queue until the queue is finalized. Applications must not access <em>memory</em> directly after calling nvnQueueInitialize. <em>size</em> must be sufficiently large to satisfy the requirements described above; the minimum size can be queried using nvnQueueBuilderGetQueueMemorySize. On the Windows reference implementation, per-queue memory is allocated by the driver, and the memory provided by <em>memory</em> (if any) is ignored.</p>
<p>The default queue memory size is zero, indicating that no memory is provided by the application. In that case, the NVN driver will allocate a buffer of sufficient size when the queue is initialized.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object to update.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">memory</td><td>Storage used for the queue memory. Must be aligned to a multiple of 4KB (NVN_MEMORY_POOL_STORAGE_ALIGNMENT).</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>Size (in bytes) of the queue memory. Must be aligned to a multiple of 4KB (NVN_MEMORY_POOL_STORAGE_GRANULARITY). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a36">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a49">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a49">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a45">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a45">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a37">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a37">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a36">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a36">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a43">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga4de1469ce962b138ca454c034f6e649b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueBuilderSetCommandFlushThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a flush threshold for a new <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object. </p>
<p><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> objects include an embedded command buffer that is automatically managed by the NVN driver. This command buffer is used to send commands to the GPU for various <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> methods or for command sets that require additional processing when nvnQueueSubmitCommands is called. Most commands require very little command memory, but certain commands like compute dispatches or shader subroutine uniform updates may require significant amounts of command memory. The NVN driver will automatically flush the queue when the amount of command memory used since the last queue flush approaches a specified flush threshold.</p>
<p>By default, the flush threshold is 1/8 of the total available command memory. Setting a higher threshold may reduce the number of automatic flushes performed, but less frequent flushes may cause the driver to have to wait for the completion of previous flushes before reusing command memory.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">threshold</td><td>Threshold (in bytes) of queue command memory usage triggering automatic flushes. Must be greater than or equal to 4096 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a41746792748f7b142878c4d1654e5c4d" title="Minimum flush threshold size for per-queue command memory provided to NVN. ">NVN_DEVICE_INFO_QUEUE_COMMAND_MEMORY_MIN_FLUSH_THRESHOLD</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a32">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a45">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a45">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a41">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a41">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a33">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a33">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a32">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a32">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a39">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaea2b90419b41e5ece6af3edd45129d32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a>* nvnQueueBuilderGetDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7bbd3d283a12e7b08f06f006dbebee66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnQueueBuilderGetFlags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get queue flags associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga12df64513ce3e52474dc6a091cd3616d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnQueueBuilderGetCommandMemorySize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the command memory size associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object. </p>
<p>The function will return true if the command memory size was explicitly set.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Command memory size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf728cfa48fe1665b195f0bbcb7ece385"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnQueueBuilderGetComputeMemorySize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the compute memory size associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object. </p>
<p>The function will return true if the compute memory size was explicitly set.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Compute memory size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0be1544f07aa9d9c50f0d7a6261df8f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnQueueBuilderGetControlMemorySize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the control memory size associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object. </p>
<p>The function will return true if the control memory size was explicitly set.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Control memory size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga620c9128e6758213a4fecaf7ce6fccea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnQueueBuilderGetCommandFlushThreshold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>flushThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the command flush threshold associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object. </p>
<p>The function will return true if the flush threshold was explicitly set.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flushThreshold</td><td>Flush threshold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf8ddabb30dcd2193f80184a22a395b13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnQueueBuilderGetMemorySize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the memory associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga272f5fc06e59a8c193abb2ad86ad6900"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nvnQueueBuilderGetMemory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the memory associated with this <a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga512027cc783d925feb7261915130e2ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnQueueInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nqueue_builder.html">NVNqueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object from a queue builder. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object to initialize.</td></tr>
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nqueue_builder.html" title="Object specifying state used to construct new queue objects. ">NVNqueueBuilder</a> object holding properties of the new <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a37">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a50">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a50">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a46">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a46">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a38">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a38">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a37">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a37">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a44">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga54ac57de39c708eb9758bae7770d5ccc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object. </p>
<dl class="section note"><dt>覚え書き</dt><dd>Finalizing a queue will wait for the completion of all commands previously submitted to the queue, including those sent by the driver during queue initialization.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a67">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a106">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a115">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a154">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a112">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a83">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a83">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a94">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a60">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a143">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga0c90495a1a43ec403d590ee7603057ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga095fabdb4c81459bbe496ba45528211b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueSubmitCommands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numCommands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> *&#160;</td>
          <td class="paramname"><em>handles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit commands encapsulated in command buffers to a queue for processing. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> receiving the commands stored in the command buffers.</td></tr>
    <tr><td class="paramname">numCommands</td><td>Number of command buffers to send.</td></tr>
    <tr><td class="paramname">handles</td><td>Array of numCommands handles for the command buffers to send. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a72">DebugTextRenderer.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a85">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a108">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a117">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a138">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a118">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a88">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a88">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a99">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a80">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a116">NvnTutorial11.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a29">StatTracker.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga98feac9fc906eb1a9a5eb19ef4381b46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush commands previously submitted to a queue for processing. </p>
<p>Commands submitted to <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> objects may be batched up by the implementation to avoid the overhead that would be involved in flushing each command immediately after it is submitted. Flush can be used to manually flush commands that were previously batched up.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> whose commands should be flushed for further processing. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a57">DebugTextRenderer.cpp</a>, <a class="el" href="_frame_buffer_manager_8cpp-example.html#a8">FrameBufferManager.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a71">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a111">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a120">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a111">NvnTutorial05.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a20">StatTracker.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaab3c15f657cefdff33dab453795ff38f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueFinish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until all commands previously submitted to a queue have completed execution. </p>
<p>This command will not return to the caller until the previously submitted commands have completed. To determine if submitted commands have completed without blocking, applications can use <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> objects and Sync::WaitSync(). Finish will automatically flush the previously submitted commands as part of its operation.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> whose commands should be waited on for completion. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a62">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a101">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a110">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a151">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a108">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a79">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a79">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a91">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a56">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a138">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gad317e78382b7f51a7a6f0504193d90c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueuePresentTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display the contents of a texture into the window. </p>
<p>This command presents the texture specified by <em>textureIndex</em> in the native window associated with <em>window</em>. It also triggers an implicit call to nvnQueueFlush so that the texture is guaranteed to be shown on the screen in finite time.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> used for previous commands rendering to texture.</td></tr>
    <tr><td class="paramname">window</td><td>The window where the texture should be presented.</td></tr>
    <tr><td class="paramname">textureIndex</td><td>The index of the texture to be displayed on-screen. The texture must be previously acquired from <em>window</em> using nvnWindowAcquireTexture. nvnQueuePresentTexture transfers the ownership of the texture back to the platform windowing system, and the application must re-acquire it with nvnWindowAcquireTexture before using it again. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a86">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a116">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a125">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a141">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a119">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a89">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a89">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a100">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a81">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a165">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gae29950b5f011bc5cbc190659c4e335ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVN_PRE_DEPRECATED <a class="el" href="group__nvn__c__enum.html#gad3bc319f6ddc7241c7001442771fcb8f">NVNqueueAcquireTextureResult</a> nvnQueueAcquireTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>textureIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire a texture from the window. </p>
<p>Deprecated in favor of nvnWindowAcquireTexture.</p>
<p>This is semantically equivalent to calling</p>
<div class="fragment"><div class="line">Sync displayReleaseSync;</div>
<div class="line">displayReleaseSync.Initialize(...);</div>
<div class="line">window.AcquireTexture(&amp;displayReleaseSync, textureIndex);</div>
<div class="line">queue.WaitSync(&amp;displayReleaseSync);</div>
<div class="line">displayReleaseSync.Finalize();</div>
</div><!-- fragment --><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object that will be used to render to the texture.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object to acquire a texture from.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">textureIndex</td><td>An index into the texture array that was passed in when <em>window</em> was initialized, which identifies the texture that is now released from the platform windowing system to the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf93ec4cee4147e9cc004b7b16c802621"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowBuilderSetDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> owning <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> objects created by the <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a60">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a98">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a92">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a86">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a84">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a66">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a66">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a77">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a54">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a67">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga3924f2d40fa227e1b405df3755ad46e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowBuilderSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object. </p>
<p>This method does not modify the device associated with the builder, which is programmed by SetDevice.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">WindowBuilder::SetNativeWindow(NULL);</div>
<div class="line">WindowBuilder::SetTextures(0, NULL);</div>
<div class="line">WindowBuilder::SetPresentInterval(1);</div>
</div><!-- fragment --><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a59">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a97">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a91">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a85">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a83">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a65">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a65">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a76">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a53">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a66">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gac518ddbead9eac057d3578c6195166b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowBuilderSetNativeWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a>&#160;</td>
          <td class="paramname"><em>nativeWindow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the native window where the textures of this window will be presented to. </p>
<p>On NX, the native window should be of type <a class="el" href="namespacenn_1_1vi.html#a4d5f9e1b22348c0080755ad26cb980c1" title="Platform-dependent handle to a window. ">nn::vi::NativeWindowHandle</a>.</p>
<p>On Windows, the native window (if provided) should be of type HWND and applications must have set a pixel format using the Windows <code>SetPixelFormat</code> API. The pixel format must be an RGBA format that supports NVIDIA hardware acceleration and has the <code>PFD_DRAW_TO_WINDOW</code>, <code>PFD_SUPPORT_OPENGL</code>, and <code>PFD_DOUBLEBUFFER</code> properties set. The window class that was registered using the Windows <code>RegisterClass</code> function, needs to have the CS_OWNDC flag set. If no native window is provided on Windows, applications must bind a "donor" OpenGL context and drawable using <code>wglMakeCurrent</code> before calling nvnQueuePresentTexture.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">nativeWindow</td><td>NativeWindow where the textures of this window will be presented to. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a61">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a99">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a93">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a87">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a85">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a67">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a67">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a78">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a55">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a68">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga610c7f233b7bb1e02f4926fe554df5db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowBuilderSetTextures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numTextures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *const *&#160;</td>
          <td class="paramname"><em>textures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the textures used for presenting to this window. </p>
<p>The textures must specify <a class="el" href="group__nvn__c__enum.html#gga57ab2536473c8e62f621554a2618121bad47e8f3aafe9ec5eb90d9309d591604f" title="This texture can be displayed on-screen. ">NVN_TEXTURE_FLAGS_DISPLAY_BIT</a>, and must not be finalized before the <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> is finalized.</p>
<p>For additional restrictions such as a list of supported formats, refer to the NVN programming guide.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">numTextures</td><td>Number of color textures to use. Must be greater than or equal to 2 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a7117530c35faff1e4158bc9610ca7892" title="Minimum value supported by nvnWindowBuilderSetTextures. ">NVN_DEVICE_INFO_MIN_TEXTURES_PER_WINDOW</a>). Must be less than or equal to 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a732f31ae4f01b3912cb4742f1c98cbed" title="Maximum value supported by nvnWindowBuilderSetTextures. ">NVN_DEVICE_INFO_MAX_TEXTURES_PER_WINDOW</a>).</td></tr>
    <tr><td class="paramname">textures</td><td>Array of numTextures pointers for color textures. The pointer must remain valid until the window is initialized with nvnWindowInitialize. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a76">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a124">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a133">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a149">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a125">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a92">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a92">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a103">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a84">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a166">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga9c80a6fc0718d28e05c183a8110b9f07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowBuilderSetPresentInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>presentInterval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the present interval used when presenting to this window. </p>
<p>Sets the present interval for the window object. The present interval specifies the minimum number of display refresh between frames when presenting to a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object. Legal values are in the range [0,MAX_PRESENT_INTERVAL]:</p>
<ul>
<li>0: Update the display without waiting for the next refresh. This will display frames as fast as possible but will likely result in visual tearing.</li>
<li>1: Update the display on the next refresh. This limits the frame rate to the display's refresh rate.</li>
<li><em>n</em> (&gt; 1): Update the display on the next refresh, but no sooner than <em>n</em> refreshes since the previous update. This limits the frame rate to 1 / <em>n</em> of the display's refresh rate.</li>
</ul>
<dl class="section note"><dt>覚え書き</dt><dd>The production environment will not support a present interval of 0. In that environment, setting a present interval of 0 will behave as though 1 were specified.</dd>
<dd>
On the Windows reference implementation, calling SetPresentInterval with an interval different than 1 is only supported if the application provides a native window to the <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a>.</dd>
<dd>
On NX, the display refresh rate will always be 60Hz. On the Windows reference implementation, the refresh rate depend on the capabilities of the connected monitor and might be in some cases different than 60Hz.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">presentInterval</td><td>Present interval to use. Must be greater than or equal to zero. Must be less than or equal to 5 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a139273b9da8efa2fd1bba31f9bc93a8f" title="Maximum value supported by nvnWindowBuilderSetPresentInterval. ">NVN_DEVICE_INFO_MAX_PRESENT_INTERVAL</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8a123578bac4b0a41cd7601cc53b84f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a>* nvnWindowBuilderGetDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the device associated with this <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacad10a6368b14ab7ba7d98f2855c800f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnWindowBuilderGetNumTextures </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of textures associated with this <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga02e84bd3df0a6dd2bc27e9775f959da2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a>* nvnWindowBuilderGetTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the texture with index textureId associated with this <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object. </p>
<p>The texture array stored in the <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object is supposed to remain valid until the window is initialized with nvnWindowInitialize. Therefore GetTexture should be called before the window is initialized to make sure it returns a valid pointer.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object to query.</td></tr>
    <tr><td class="paramname">textureId</td><td>Index of the texture to be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga20d7c6255438597f1e6ff33a17bc1028"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a> nvnWindowBuilderGetNativeWindow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the native window for a <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga23b4fc7396418e24deb8286cdb74da8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnWindowBuilderGetPresentInterval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the present interval for a <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac5c388ac1ed70cb34ea4d71d23af9a73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnWindowInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow_builder.html">NVNwindowBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new window object from a window builder. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object to initialize.</td></tr>
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a> object holding properties of the new <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a77">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a125">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a134">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a150">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a126">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a93">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a93">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a104">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a85">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a167">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga53660a4abfffea411f62415c79a65cdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a65">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a104">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a113">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a145">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a110">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a81">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a81">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a92">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a58">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a140">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga4e7fcf2ce10cbe51af72130cacac4840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7fa0b45affa2e04d77e3c1ad11a03c32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga58e9b155d7f2272b95044eed1f40415e">NVNwindowAcquireTextureResult</a> nvnWindowAcquireTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>textureAvailableSync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>textureIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire a texture from the window. </p>
<p>This function will block until the GPU has completed rendering the previous frame to the acquired texture, but may return before the acquired texture is ready for rendering the next frame. The sync object <em>textureAvailableSync</em> can be used to determine when the acquired texture can be rendered to.</p>
<p>The caller is responsible for ensuring that it doesn't render to the acquired texture prematurely. Passing <em>textureAvailableSync</em> to nvnQueueWaitSync ensures that any subsequent commands sent to a queue are not processed by the GPU until the acquired texture is ready for use.</p>
<p>Applications should also use <em>textureAvailableSync</em> to match their rendering rate to the presentation rate. This can be done by calling nvnSyncWait on <em>textureAvailableSync</em> before calling nvnQueuePresentTexture.</p>
<dl class="section note"><dt>覚え書き</dt><dd>Waiting for <em>textureAvailableSync</em> does not provide any guarantees regarding GPU work completion. For example, when double buffering between textures A and B, GPU may still be rendering texture B when A has become available for rendering (i.e. <em>textureAvailableSync</em> associated with acquiring texture A has been signaled).</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object to acquire a texture from.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">textureAvailableSync</td><td><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object that will be signaled when the texture is available for rendering a new frame. If the texture has not been presented before with nvnQueuePresentTexture, <em>textureAvailableSync</em> will be signaled immediately. If nvnWindowAcquireTexture returns an error, <em>textureAvailableSync</em> will not be modified.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">textureIndex</td><td>An index into the texture array that was passed in when <em>window</em> was initialized, which identifies the texture that is now released from the platform windowing system to the application. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a87">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a117">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a126">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a142">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a120">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a70">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a70">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a82">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a65">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a147">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga35e25752c0757803fdb19b8b9584af9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga05b6b3dd5b965bd81efe2d03cee0bbbd">NVNnativeWindow</a> nvnWindowGetNativeWindow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the native window for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga759e5d9a7bd29dda539893cfd23d3ca2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnWindowGetPresentInterval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the present interval for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3b735c095396aabd05d437bd2bda1ded"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowSetPresentInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>presentInterval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the present interval for a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object. </p>
<p>Sets the present interval for the window object. The present interval specifies the minimum number of display refresh between frames when presenting to a <a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object. Legal values are in the range [0,MAX_PRESENT_INTERVAL]:</p>
<ul>
<li>0: Update the display without waiting for the next refresh. This will display frames as fast as possible but will likely result in visual tearing.</li>
<li>1: Update the display on the next refresh. This limits the frame rate to the display's refresh rate.</li>
<li><em>n</em> (&gt; 1): Update the display on the next refresh, but no sooner than <em>n</em> refreshes since the previous update. This limits the frame rate to 1 / <em>n</em> of the display's refresh rate.</li>
</ul>
<dl class="section note"><dt>覚え書き</dt><dd>The production environment will not support a present interval of 0. In that environment, setting a present interval of 0 will behave as though 1 were specified.</dd>
<dd>
On the Windows reference implementation, calling SetPresentInterval with an interval different than 1 is only supported if the application provides a native window to the <a class="el" href="struct_n_v_nwindow_builder.html" title="Object specifying state used to construct new window objects. ">NVNwindowBuilder</a>.</dd>
<dd>
On NX, the display refresh rate will always be 60Hz. On the Windows reference implementation, the refresh rate depend on the capabilities of the connected monitor and might be in some cases different than 60Hz.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object.</td></tr>
    <tr><td class="paramname">presentInterval</td><td>Present interval to use. Must be greater than or equal to zero. Must be less than or equal to 5 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a139273b9da8efa2fd1bba31f9bc93a8f" title="Maximum value supported by nvnWindowBuilderSetPresentInterval. ">NVN_DEVICE_INFO_MAX_PRESENT_INTERVAL</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf961e88cbeee4c0612548c40e7db432d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowSetCrop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the rectangle inside the window texture that gets displayed. </p>
<p>This method sets the rectangle inside a texture that gets displayed. If the rectangle size does not match the window size, the texture rectangle gets scaled to fit the window size. Passing a width or height of zero will reset the crop rectangle to match the dimension of the window texture.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object.</td></tr>
    <tr><td class="paramname">x</td><td>Smallest X coordinate of the display rectangle in window coordinates.</td></tr>
    <tr><td class="paramname">y</td><td>Smallest Y coordinate of the display rectangle in window coordinates.</td></tr>
    <tr><td class="paramname">w</td><td>Width of the display rectangle.</td></tr>
    <tr><td class="paramname">h</td><td>Height of the display rectangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae0857c62a4ddce422c4aed104c607ac4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnWindowGetCrop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nwindow.html">NVNwindow</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nrectangle.html">NVNrectangle</a> *&#160;</td>
          <td class="paramname"><em>crop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the dimensions of the crop rectangle that defines the region inside the window texture which gets displayed. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">window</td><td><a class="el" href="struct_n_v_nwindow.html" title="Object that manages texture presentation to the platform windowing system. ">NVNwindow</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">crop</td><td>The crop rectangle that is used for presenting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga94b5dc5a5043495db9e6c3bc41ed6098"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnProgramInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives. ">NVNprogram</a> object for the specified device. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives. ">NVNprogram</a> object to initialize.</td></tr>
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> owning the program. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a89">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a26">MultiThreadedAssetFileLoadingHelper.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga24bd32154585c557cea6e061aecb6000"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnProgramFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives. ">NVNprogram</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives. ">NVNprogram</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_data_holder_8cpp-example.html#a2">AssetFileDataHolder.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga5cae86887480bb2aac1d98a5a4f94f68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnProgramSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives. ">NVNprogram</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives. ">NVNprogram</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives. ">NVNprogram</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives. ">NVNprogram</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad6a517c8312bcaea2bafddfdf59f426a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnProgramSetShaders </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nshader_data.html">NVNshaderData</a> *&#160;</td>
          <td class="paramname"><em>stageData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a program object to use pre-compiled GPU code from one or multiple shaders. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives. ">NVNprogram</a> object to set up.</td></tr>
    <tr><td class="paramname">count</td><td>Number of GPU programs to load in.</td></tr>
    <tr><td class="paramname">stageData</td><td>GPU control information to help set up </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a90">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a27">MultiThreadedAssetFileLoadingHelper.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gacafb3b85111e530155835f1048360d59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMemoryPoolBuilderSetDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> owning <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> objects created by the <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_memory_pool_8cpp-example.html#a7">MemoryPool.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaaa17de90ba16494d5076a9a0dba9185d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMemoryPoolBuilderSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a> object. </p>
<p>This method does not modify the device associated with the builder, which is programmed by SetDevice.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">MemoryPoolBuilder::SetStorage(NULL, 0);</div>
<div class="line">MemoryPoolBuilder::SetFlags(<a class="code" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654ae90d91fe770d2eb3e1476c404c003369">NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT</a> |</div>
<div class="line">                            <a class="code" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a81b40bf9e82d33f8c546a95fc5ce5f7e">NVN_MEMORY_POOL_FLAGS_GPU_CACHED_BIT</a>);</div>
</div><!-- fragment --><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_memory_pool_8cpp-example.html#a6">MemoryPool.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga86c5f0efe19800f8571930177679853f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMemoryPoolBuilderSetStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides memory to be used by memory pools initialized using a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a>. </p>
<p>When a memory pool is initialized using a memory pool builder, <em>size</em> bytes of memory pointed to by <em>memory</em> will be owned by the memory pool until the memory pool is finalized. Applications must not access <em>memory</em> directly after calling nvnMemoryPoolInitialize. For memory pools created with <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a2fa7e2b859d94d1dc2c7077822b46f83" title="Indicates that the memory pool will be accessed by the CPU with caching. ">NVN_MEMORY_POOL_FLAGS_CPU_CACHED_BIT</a> or <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a93f5342f52f301cfdca9901586b9b8e1" title="Indicates that the memory pool will be accessed by the CPU without caching. ">NVN_MEMORY_POOL_FLAGS_CPU_UNCACHED_BIT</a>, applications can retrieve a CPU pointer to the pool using nvnMemoryPoolMap that can be used until the pool is finalized. The memory provided by <em>memory</em> can be re-used or freed by the application after the pool is finalized using nvnMemoryPoolFinalize.</p>
<p>Virtual memory pools (<a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a651cb5e0623ae5abd441c6c1b48087f5" title="Indicates that the memory pool may be used for sparse operations. ">NVN_MEMORY_POOL_FLAGS_VIRTUAL_BIT</a>) do not own any storage and must be initialized using a NULL <em>memory</em> parameter.</p>
<p>On NX, non-virtual memory pools must be initialized with application-provided memory. Initialization for non-virtual memory pools will fail if a builder with a NULL <em>memory</em> parameter is provided.</p>
<p>On Windows, NVN allocates separate memory for non-virtual memory pools and does not take ownership of the application-provided memory. If <em>memory</em> is NULL, the contents of the allocated pool memory will be uninitialized. If <em>memory</em> is non-NULL, the allocated pool memory will be initialized by copying the <em>size</em> bytes pointed to by <em>memory</em>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a> object to update.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">memory</td><td>Storage used for the memory pool. Must be aligned to a multiple of 4KB (NVN_MEMORY_POOL_STORAGE_ALIGNMENT).</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>Size (in bytes) of the memory pool. Must be aligned to a multiple of 4KB (NVN_MEMORY_POOL_STORAGE_GRANULARITY). Must be greater than zero. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_memory_pool_8cpp-example.html#a9">MemoryPool.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga332d877a6825cf3af6904c9615935daa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMemoryPoolBuilderSetFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set properties of <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> objects created from the builder. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">flags</td><td>Bitfield specifying properties of the memory pool to initialize. See <a class="el" href="group__nvn__c__enum.html#gaa7df4970255609d7a317631bcb37d654" title="Specifies properties of memory pools created from a memory pool builder. ">NVNmemoryPoolFlags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_memory_pool_8cpp-example.html#a8">MemoryPool.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga40a50e5352cccfa1ba2c2569777b85fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a>* nvnMemoryPoolBuilderGetDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the device associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac5dd6a5d6a9164d1bddf18cdef18502a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nvnMemoryPoolBuilderGetMemory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory allocation associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga692de7a3a6d9d318a39ea376a096097e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnMemoryPoolBuilderGetSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the size associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga68a5197066d35e0f2bb74afc79fc0020"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#gaa7df4970255609d7a317631bcb37d654">NVNmemoryPoolFlags</a> nvnMemoryPoolBuilderGetFlags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the flags associated with a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae78de6694c8b1b054050dcc1b82bb20d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnMemoryPoolInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool_builder.html">NVNmemoryPoolBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object using a <a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a> object. </p>
<dl class="section note"><dt>覚え書き</dt><dd>On Windows, nvnMemoryPoolInitialize may return NVN_FALSE if video memory on the discrete GPU is exhausted. Reducing the size of the memory pool and/or shutting down other applications that consume video memory may resolve this error.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object to initialize.</td></tr>
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nmemory_pool_builder.html" title="Object specifying state used to construct new memory pool objects. ">NVNmemoryPoolBuilder</a> object holding properties of the new <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_memory_pool_8cpp-example.html#a10">MemoryPool.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga6d256413a09dc0163d78749b7e8756b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMemoryPoolSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4cc130f7dcc64cd765e0b74a8c10e448"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMemoryPoolFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Memory pool to finalize. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_memory_pool_8cpp-example.html#a13">MemoryPool.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga072ffc85fe3f8ae544f3c788b192be77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nvnMemoryPoolMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a CPU pointer to the memory owned by the <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object. </p>
<p>If the memory pool does not support CPU access (<a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654ae90d91fe770d2eb3e1476c404c003369" title="Indicates that the memory pool will not be accessed by the CPU. ">NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT</a>), NULL is returned.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Memory pool object being accessed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9f76c329bcb4a9420bc4c6bc29f762e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMemoryPoolFlushMappedRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush previous CPU writes to a range of the memory pool to be visible to the GPU. </p>
<dl class="section note"><dt>覚え書き</dt><dd>On NX, calling <a class="el" href="namespacenn_1_1os.html#a0fc3b750c03200539a98c98f7acca022" title="データキャッシュをメモリに書き出したのち破棄します。 ">nn::os::FlushDataCache</a> on an equivalent memory range will have the same effect as calling this function.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object containing the range to flush.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of the memory pool range to flush.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the memory pool range to flush. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabc7ba26caa615b7f4abb81de4ed6205e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMemoryPoolInvalidateMappedRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate CPU caches for a range of the memory pool that may have been written by the GPU. </p>
<dl class="section note"><dt>覚え書き</dt><dd>On NX, calling <a class="el" href="namespacenn_1_1os.html#a0fc3b750c03200539a98c98f7acca022" title="データキャッシュをメモリに書き出したのち破棄します。 ">nn::os::FlushDataCache</a> on an equivalent memory range will have the same effect as calling this function.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object containing the range to invalidate.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of the memory pool range to invalidate.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the memory pool range to invalidate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac1c21d6dc85c6325013b0e782998fbdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> nvnMemoryPoolGetBufferAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the GPU address of the data store of a memory pool object. </p>
<p>All buffer resources stored in a memory pool are accessed using a single GPU address mapping created for the entire pool. This function returns the GPU address of the first byte of this mapping.</p>
<dl class="section note"><dt>覚え書き</dt><dd>The address for a buffer object can be obtained by adding the buffer address of the memory pool owning the buffer object and the offset of the buffer object within its pool.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object used for the address query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae6dac6504ee2c716377f6dce9cede4e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnMemoryPoolMapVirtual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>virtualPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numRequests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmapping_request.html">NVNmappingRequest</a> *&#160;</td>
          <td class="paramname"><em>requests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map memory pages from physical memory pools into a virtual memory pool. </p>
<p>This command can be used to map memory from a physical memory pool (one using <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654af8bf52f665606652b45e14bae4cb7f4f" title="Indicates that the memory pool may only be used as physical storage for memory mappings into virtual ...">NVN_MEMORY_POOL_FLAGS_PHYSICAL_BIT</a>) into a virtual memory pool (one using <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a651cb5e0623ae5abd441c6c1b48087f5" title="Indicates that the memory pool may be used for sparse operations. ">NVN_MEMORY_POOL_FLAGS_VIRTUAL_BIT</a>). Each individual mapping request will map a contiguous set of pages in the physical pool into a contiguous range of the virtual pool, using a specified storage class for the virtual memory mapping. Applications can specify one or multiple mapping requests in a single call; performing multiple mappings in a single call can reduce CPU overhead required to perform the mappings.</p>
<p>Returns NVN_TRUE if all virtual mapping requests were successfully processed. If any mapping request fails, NVN_FALSE will be returned. If NVN_FALSE is returned, some of the virtual mapping requests may have been fully or partially satisfied prior to the failure. There is no guarantee that the mappings in <em>virtualPool</em> are unchanged if this command fails. Virtual mappings may fail if the graphics firmware has insufficient memory to set up the new mapping.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">virtualPool</td><td>Virtual memory pool to update.</td></tr>
    <tr><td class="paramname">numRequests</td><td>Number of mapping requests to perform.</td></tr>
    <tr><td class="paramname">requests</td><td>Array of mapping requests to perform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1ab20a3416a36855861741c3305c2d80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnMemoryPoolGetSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the size associated with a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaae82797756975754c0e3f141c66a524"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#gaa7df4970255609d7a317631bcb37d654">NVNmemoryPoolFlags</a> nvnMemoryPoolGetFlags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the flags associated with a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf3b22a7104a3c1cb6c0ab5c46e753587"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnTexturePoolInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>texturePool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>memoryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numDescriptors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object. </p>
<p>The texture pool is a contiguous block of memory where texture descriptors are written. <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> descriptors hold information about textures and are used by the GPU when using textures in rendering operations. <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> descriptors are written into the pool using RegisterTexture. The pool itself must be set to the queue before rendering with any individual textures. A number of entries at the beginning of the pool are reserved for use by the driver. The number of reserved entries can be found by querying the device property RESERVED_TEXTURE_DESCRIPTORS. The size of each entry can be found by querying TEXTURE_DESCRIPTOR_SIZE.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texturePool</td><td><a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object to initialize.</td></tr>
    <tr><td class="paramname">memoryPool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object providing storage for the texture pool. The memory pool must be CPU-accessible (except on the Windows reference implementation).</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of memory pool storage used by the texture pool. Must be a multiple of 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a72e50333aa53ce4a4d9dbd00c2af3db9" title="Size (in bytes) of a single texture descriptor stored in the pool. ">NVN_DEVICE_INFO_TEXTURE_DESCRIPTOR_SIZE</a>).</td></tr>
    <tr><td class="paramname">numDescriptors</td><td>The number of texture descriptors that can be stored within the texture pool, including texture descriptors reserved to the driver. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a513596e8b2dc04714d6478aed173a891" title="Number of entries reserved at the beginning of the texture pool for internal driver usage...">NVN_DEVICE_INFO_RESERVED_TEXTURE_DESCRIPTORS</a>). Must be less than or equal to 1048576 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3e1b65743283fca466db252241b5dd87" title="Maximum number of entries (including reserved ones) supported in a texture descriptor pool...">NVN_DEVICE_INFO_MAX_TEXTURE_POOL_SIZE</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_texture_i_d_manager_8cpp-example.html#a12">TextureIDManager.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga58691b87b17bce83845582aa218982f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTexturePoolSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaef9948023397e7c1c3294fba08135f68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTexturePoolFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> pool to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae68c38ccc4963fcdefa710b993104364"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTexturePoolRegisterTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>texturePool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a texture descriptor in a texture pool for use via texture handles. </p>
<p>The identifier <em>id</em> specifies an index into <em>texturePool</em> where the descriptor is written. The texture pool index is used together with a sampler pool index to generate a texture handle used for subsequent texture binding operations or bindless texture accesses. </p><dl class="section note"><dt>覚え書き</dt><dd>If a texture needs to be used for both texture and image accesses, it must be registered separately for both use cases unless the device property <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a0932b19f385c068c4a59815c0b719b89" title="1 if the NVN implementation supports using texture handles for image accesses, 0 otherwise. ">NVN_DEVICE_INFO_SUPPORTS_IMAGES_USING_TEXTURE_HANDLES</a> is true.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texturePool</td><td>The texture pool owning the texture descriptor.</td></tr>
    <tr><td class="paramname">id</td><td>Offset (in descriptors) in the texture pool used to store the texture descriptor. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a513596e8b2dc04714d6478aed173a891" title="Number of entries reserved at the beginning of the texture pool for internal driver usage...">NVN_DEVICE_INFO_RESERVED_TEXTURE_DESCRIPTORS</a>). Must be less than or equal to 1048576 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3e1b65743283fca466db252241b5dd87" title="Maximum number of entries (including reserved ones) supported in a texture descriptor pool...">NVN_DEVICE_INFO_MAX_TEXTURE_POOL_SIZE</a>).</td></tr>
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to register.</td></tr>
    <tr><td class="paramname">view</td><td>View of the texture object to register. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_texture_i_d_manager_8cpp-example.html#a14">TextureIDManager.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gab9357d2ef95b193039fab87192187845"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTexturePoolRegisterImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>texturePool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an image descriptor in a texture pool for use via image loads and stores. </p>
<p>The identifier <em>id</em> specifies an index into <em>texturePool</em> where the descriptor is written. The texture pool index is used to generate an image handle used for subsequent image binding operations or bindless image accesses.</p>
<dl class="section note"><dt>覚え書き</dt><dd>If a texture needs to be used for both texture and image accesses, it must be registered separately for both use cases unless the device property <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a0932b19f385c068c4a59815c0b719b89" title="1 if the NVN implementation supports using texture handles for image accesses, 0 otherwise. ">NVN_DEVICE_INFO_SUPPORTS_IMAGES_USING_TEXTURE_HANDLES</a> is true.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texturePool</td><td>The texture pool owning the image descriptor.</td></tr>
    <tr><td class="paramname">id</td><td>Offset (in descriptors) in the texture pool used to store the image descriptor. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a513596e8b2dc04714d6478aed173a891" title="Number of entries reserved at the beginning of the texture pool for internal driver usage...">NVN_DEVICE_INFO_RESERVED_TEXTURE_DESCRIPTORS</a>). Must be less than or equal to 1048576 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3e1b65743283fca466db252241b5dd87" title="Maximum number of entries (including reserved ones) supported in a texture descriptor pool...">NVN_DEVICE_INFO_MAX_TEXTURE_POOL_SIZE</a>).</td></tr>
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to register.</td></tr>
    <tr><td class="paramname">view</td><td>View of the texture object to register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabc56cdaa4e3572684ac54699776459f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnTexturePoolGetMemoryPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool used by a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga235dc3565dd2c666c1162229b58c9d36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnTexturePoolGetMemoryOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool offset used by a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga94185c1c4011d6a6cf9343fa5b923701"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTexturePoolGetSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of descriptors in the memory of a <a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac78aeeebf55a677fa61bdceebc46ef5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnSamplerPoolInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>samplerPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>memoryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numDescriptors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object. </p>
<p>The sampler pool is a contiguous block of memory where sampler descriptors are written. <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> descriptors hold information about textures and are used by the GPU when using samplers in rendering operations. <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> descriptors are written into the pool using the RegisterSampler or RegisterSamplerBuilder methods. The pool itself must be set to the queue before rendering with any individual textures. A number of entries at the beginning of the pool are reserved for use by the driver. The number of reserved entries can be found by querying the device property RESERVED_SAMPLER_DESCRIPTORS. The size of each entry can be found by querying SAMPLER_DESCRIPTOR_SIZE.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">samplerPool</td><td><a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object to initialize.</td></tr>
    <tr><td class="paramname">memoryPool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object providing storage for the sampler pool. The memory pool must be CPU-accessible (except on the Windows reference implementation).</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of memory pool storage used by the sampler pool. Must be a multiple of 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ad6c9e8c2fd664c8ce50eddcf7563dbff" title="Size in bytes of a single sampler descriptor. ">NVN_DEVICE_INFO_SAMPLER_DESCRIPTOR_SIZE</a>).</td></tr>
    <tr><td class="paramname">numDescriptors</td><td>The number of sampler descriptors that can be stored within the sampler pool, including samplers reserved to the driver. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5b9a26a5aadab05c4a9f8a286718fbc7" title="Number of samplers that must be reserved for use by the driver. ">NVN_DEVICE_INFO_RESERVED_SAMPLER_DESCRIPTORS</a>). Must be less than or equal to 4096 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ae2d3753921fc35e9af1b1ae2b0cae57f" title="Maximum number of entries (including reserved ones) supported in a sampler descriptor pool...">NVN_DEVICE_INFO_MAX_SAMPLER_POOL_SIZE</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_texture_i_d_manager_8cpp-example.html#a10">TextureIDManager.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gad5a4a7a3602ace4ed28a8249bdaf249f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerPoolSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0f34faa24cf7902685de6c5c58e3b370"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerPoolFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> pool to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga534898b94679ef42198d21f4a3bd966e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerPoolRegisterSampler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>samplerPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a sampler descriptor in a sampler pool for use via texture handles, using a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object. </p>
<p>The identifier <em>id</em> specifies an index into <em>samplerPool</em> where the descriptor is written. The sampler pool index is used together with a texture pool index to generate a texture handle used for subsequent texture binding operations or bindless texture accesses.</p>
<dl class="section note"><dt>覚え書き</dt><dd>The nvnSamplerPoolRegisterSamplerBuilder method performs identical sampler descriptor registration directly from sampler builder state, without a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">samplerPool</td><td>The sampler pool owning the sampler descriptor.</td></tr>
    <tr><td class="paramname">id</td><td>Offset (in descriptors) in the sampler pool used to store the sampler descriptor. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5b9a26a5aadab05c4a9f8a286718fbc7" title="Number of samplers that must be reserved for use by the driver. ">NVN_DEVICE_INFO_RESERVED_SAMPLER_DESCRIPTORS</a>). Must be less than or equal to 4096 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ae2d3753921fc35e9af1b1ae2b0cae57f" title="Maximum number of entries (including reserved ones) supported in a sampler descriptor pool...">NVN_DEVICE_INFO_MAX_SAMPLER_POOL_SIZE</a>).</td></tr>
    <tr><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object to register. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_texture_i_d_manager_8cpp-example.html#a16">TextureIDManager.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga33025ca24e76ce3cc2df1844cad3bca8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerPoolRegisterSamplerBuilder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>samplerPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a sampler descriptor in a sampler pool for use via texture handles, using <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> state. </p>
<p>The identifier <em>id</em> specifies an index into <em>samplerPool</em> where the descriptor is written. The sampler pool index is used together with a texture pool index to generate a texture handle used for subsequent texture binding operations or bindless texture accesses.</p>
<dl class="section note"><dt>覚え書き</dt><dd>The nvnSamplerPoolRegisterSampler method performs identical sampler descriptor registration using a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">samplerPool</td><td>The sampler pool owning the sampler descriptor.</td></tr>
    <tr><td class="paramname">id</td><td>Offset (in descriptors) in the sampler pool used to store the sampler descriptor. Must be greater than or equal to 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5b9a26a5aadab05c4a9f8a286718fbc7" title="Number of samplers that must be reserved for use by the driver. ">NVN_DEVICE_INFO_RESERVED_SAMPLER_DESCRIPTORS</a>). Must be less than or equal to 4096 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ae2d3753921fc35e9af1b1ae2b0cae57f" title="Maximum number of entries (including reserved ones) supported in a sampler descriptor pool...">NVN_DEVICE_INFO_MAX_SAMPLER_POOL_SIZE</a>).</td></tr>
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> builder state to register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaee878a9e546d6c2b6325cf0be61ae41c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnSamplerPoolGetMemoryPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool used by a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7ab7ea81536b1e2cf80ad042e8f862a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnSamplerPoolGetMemoryOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool offset used by a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadc23370e8330ae3727bb03f26f5d097c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnSamplerPoolGetSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of descriptors in the memory of a <a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7f1e5a40cc9b049892a527b95ac9b9fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBufferBuilderSetDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> owning <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> objects created by the <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a9">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a41">DebugTextRenderer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a7">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a75">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a75">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a63">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a66">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a41">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a41">NvnTutorial08.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a35">StatTracker.cpp</a>, <a class="el" href="_uniform_buffer_8cpp-example.html#a5">UniformBuffer.cpp</a>, <a class="el" href="_uniform_buffer_manager_8cpp-example.html#a6">UniformBufferManager.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga17550ab21d8136e4f5c48c91c21716f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBufferBuilderSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object. </p>
<p>This method does not modify the device associated with the builder, which is programmed by SetDevice.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">BufferBuilder::SetStorage(NULL, 0, 0);</div>
</div><!-- fragment --><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a10">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a42">DebugTextRenderer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a8">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a76">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a76">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a64">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a67">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a42">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a42">NvnTutorial08.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a36">StatTracker.cpp</a>, <a class="el" href="_uniform_buffer_8cpp-example.html#a6">UniformBuffer.cpp</a>, <a class="el" href="_uniform_buffer_manager_8cpp-example.html#a7">UniformBufferManager.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaaaa4fd698902c746debccb3fa967e324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBufferBuilderSetStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the range of a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> used for a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object created from the <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object providing storage for the new <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of pool storage used by the new <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the new buffer object. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a86">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a96">DebugTextRenderer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a23">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a37">StatTracker.cpp</a>, <a class="el" href="_uniform_buffer_8cpp-example.html#a7">UniformBuffer.cpp</a>, <a class="el" href="_uniform_buffer_manager_8cpp-example.html#a8">UniformBufferManager.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaf799ed12f9ff9d00ec9acdc4ba60ba57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a>* nvnBufferBuilderGetDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the device associated with this <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga80ec5e6a2f5d90f738de111cef60c5b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnBufferBuilderGetMemoryPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool used by a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga205e32b963584eaf5e8c78cdba135e68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnBufferBuilderGetMemoryOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool offset used by a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga318db40761633c5e9129be18c1420f9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnBufferBuilderGetSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the size (in bytes) of the storage in a <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga862eafc1a9c42ce08a7c40ba004d7b57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnBufferInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_builder.html">NVNbufferBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new buffer object from a buffer builder. </p>
<p><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> objects are created using the <a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object, with storage provided by a memory pool or a previously existing <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to initialize.</td></tr>
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nbuffer_builder.html" title="Object specifying state used to construct new buffer objects. ">NVNbufferBuilder</a> object holding properties of the new <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a87">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a97">DebugTextRenderer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a24">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a38">StatTracker.cpp</a>, <a class="el" href="_uniform_buffer_8cpp-example.html#a8">UniformBuffer.cpp</a>, <a class="el" href="_uniform_buffer_manager_8cpp-example.html#a9">UniformBufferManager.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga9c0027b477c987c8a8573c7d04d854b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBufferSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3e56941d8153c1e1b2ba861189ea993d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBufferFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_data_holder_8cpp-example.html#a3">AssetFileDataHolder.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a95">DebugTextRenderer.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a39">StatTracker.cpp</a>, <a class="el" href="_uniform_buffer_8cpp-example.html#a13">UniformBuffer.cpp</a>, <a class="el" href="_uniform_buffer_manager_8cpp-example.html#a14">UniformBufferManager.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaa3a80a57023737b594e83a9fa04282c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nvnBufferMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a CPU pointer to the memory of a previously created <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object. </p>
<p>If the memory pool used by the buffer object does not support CPU access (<a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654ae90d91fe770d2eb3e1476c404c003369" title="Indicates that the memory pool will not be accessed by the CPU. ">NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT</a>), NULL is returned.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to map. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a98">DebugTextRenderer.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a40">StatTracker.cpp</a>, <a class="el" href="_uniform_buffer_8cpp-example.html#a10">UniformBuffer.cpp</a>, <a class="el" href="_uniform_buffer_manager_8cpp-example.html#a10">UniformBufferManager.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gac38c964075df642306d6490b8b50ace3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a> nvnBufferGetAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the GPU address of the data store of a buffer object. </p>
<dl class="section note"><dt>覚え書き</dt><dd>The address for a buffer object can also be obtained by adding the buffer address of the memory pool owning the buffer object and the offset of the buffer object within its pool.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object used for the address query. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a88">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a61">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_cube_8cpp-example.html#a20">GraphicsObjectCube.cpp</a>, <a class="el" href="_graphics_object_specialized_cube_8cpp-example.html#a19">GraphicsObjectSpecializedCube.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a25">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a138">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a147">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a127">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a140">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a154">NvnTutorial11.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a41">StatTracker.cpp</a>, <a class="el" href="_uniform_buffer_8cpp-example.html#a11">UniformBuffer.cpp</a>, <a class="el" href="_uniform_buffer_manager_8cpp-example.html#a11">UniformBufferManager.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga77aee9d827392e1bb7d86a02dd5b8e5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBufferFlushMappedRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush previous CPU writes to a range of a buffer to be visible to the GPU. </p>
<dl class="section note"><dt>覚え書き</dt><dd>On NX, calling <a class="el" href="namespacenn_1_1os.html#a0fc3b750c03200539a98c98f7acca022" title="データキャッシュをメモリに書き出したのち破棄します。 ">nn::os::FlushDataCache</a> on an equivalent memory range will have the same effect as calling this function.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object containing the range to flush.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of the buffer range to flush.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the buffer range to flush. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf7087d787b41f8b07b13ed3a7f1edddc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBufferInvalidateMappedRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate CPU caches for a range of a buffer that may have been written by the GPU. </p>
<dl class="section note"><dt>覚え書き</dt><dd>On NX, calling <a class="el" href="namespacenn_1_1os.html#a0fc3b750c03200539a98c98f7acca022" title="データキャッシュをメモリに書き出したのち破棄します。 ">nn::os::FlushDataCache</a> on an equivalent memory range will have the same effect as calling this function.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object containing the range to invalidate.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of the buffer to invalidate.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the buffer to invalidate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5f89923da0518bec56898b2dcddf213d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnBufferGetMemoryPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool used by a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga748c3509a17ea343cbee8675d4185f6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnBufferGetMemoryOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool offset used by a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad9537e164c060a08b95e68caea5c9ba6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnBufferGetSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the size (in bytes) of the storage of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3d63ead7e4386863c9d3e250be49ad47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nvnBufferGetDebugID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer.html">NVNbuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the debug layer unique ID of this buffer. </p>
<p>Returns 0 if debug layer disabled.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3125b10128cdf01e0c489ebf9644cc36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> associated with a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> owning <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created by the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a11">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a43">DebugTextRenderer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a9">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a46">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a77">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a77">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a65">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a68">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a43">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a43">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a40">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a38">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a45">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga6287f82327692478ee9040e4fe73dd36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<p>This method does not modify the device associated with the builder, which is programmed by SetDevice.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">TextureBuilder::SetFlags(0);</div>
<div class="line">TextureBuilder::SetTarget(TextureTarget::TARGET_2D);</div>
<div class="line">TextureBuilder::SetWidth(0);</div>
<div class="line">TextureBuilder::SetHeight(0);</div>
<div class="line">TextureBuilder::SetDepth(0);</div>
<div class="line">TextureBuilder::SetLevels(1);</div>
<div class="line">TextureBuilder::SetFormat(Format::NONE);</div>
<div class="line">TextureBuilder::SetSamples(0);</div>
<div class="line">TextureBuilder::SetSwizzle(TextureSwizzle::R, TextureSwizzle::G,</div>
<div class="line">                           TextureSwizzle::B, TextureSwizzle::A);</div>
<div class="line">TextureBuilder::SetDepthStencilMode(TextureDepthStencilMode::DEPTH);</div>
<div class="line">TextureBuilder::SetStorage(NULL, 0, 0);</div>
<div class="line">TextureBuilder::SetPackagedTextureData(NULL);</div>
<div class="line">TextureBuilder::SetPackagedTextureLayout(NULL);</div>
<div class="line">TextureBuilder::SetStride(0);</div>
<div class="line">TextureBuilder::SetGLTextureName(0);</div>
</div><!-- fragment --><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a12">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a44">DebugTextRenderer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a10">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a47">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a78">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a78">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a66">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a69">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a44">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a44">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a41">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a39">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a46">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga249280b0e8c57ead0fa7a82a8ebc56f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set flags indentifying special properties of <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group__nvn__c__enum.html#ga57ab2536473c8e62f621554a2618121b" title="Identifies special properties of texture allocations. ">NVNtextureFlags</a> value specifying special properties for created <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a48">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a79">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a79">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a67">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a70">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a45">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a45">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a42">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a40">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a47">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaa7e80e3d31c6cffc51d255cbe86694b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the target (texture type) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">target</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> target to use. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a92">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a83">DebugTextRenderer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a29">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a51">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a83">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a83">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a71">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a74">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a49">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a49">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a46">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a44">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a51">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaeb74efcd860292768c1ee95c09c647c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the width (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">width</td><td>Width (in texels) used for new textures. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad6c93fbfa974a07606f5c398adb4a080"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetHeight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the height (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">height</td><td>Height (in texels) used for new textures. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad86f04179d66882fe758554678311e42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the depth (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">depth</td><td>Depth (in texels) used for new textures. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a95">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a89">DebugTextRenderer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a32">MultiThreadedAssetFileLoadingHelper.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaff26847111e7f31129495f9211db22d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetSize1D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the width (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>. </p>
<p>This command also sets the height and depth (in texels) to one.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">width</td><td>Width (in texels) used for new textures. Must be greater than zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1eb945f455f851adf9b738be38cfb0bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetSize2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the width and height (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>. </p>
<p>This command also sets the depth (in texels) to one.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">width</td><td>Width (in texels) used for new textures. Must be greater than zero.</td></tr>
    <tr><td class="paramname">height</td><td>Height (in texels) used for new textures. Must be greater than zero. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a94">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a88">DebugTextRenderer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a31">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a55">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a82">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a82">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a70">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a73">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a48">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a48">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a45">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a43">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a50">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga1295ca18055627e3128e6ec7f0be5439"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetSize3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the width, height, and depth (in texels) for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">width</td><td>Width (in texels) used for new textures. Must be greater than zero.</td></tr>
    <tr><td class="paramname">height</td><td>Height (in texels) used for new textures. Must be greater than zero.</td></tr>
    <tr><td class="paramname">depth</td><td>Depth (in texels) used for new textures. Must be greater than zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7b84b7b97960b702cd6e8438e0bc303b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetLevels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numLevels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of mipmap levels for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">numLevels</td><td>Number of mipmap levels to create for the texture. <ul>
<li>Must be greater than zero. </li>
<li>Must be one for targets TextureTarget::TARGET_RECTANGLE and TextureTarget::TARGET_BUFFER. Must be greater than zero. Must be less than or equal to 15 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50afb8ed8803991c4da6b6b989c8cf955be" title="Maximum number of levels supported for any texture target. ">NVN_DEVICE_INFO_MAX_TEXTURE_LEVELS</a>). </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a96">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a85">DebugTextRenderer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a33">MultiThreadedAssetFileLoadingHelper.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gad83f59e208a24b5843543e1d0c7aec8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded. ">NVNformat</a> for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>. </p>
<p>Note that compressed formats are not supported for 1D or 1D array textures.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">format</td><td><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded. ">NVNformat</a> to use for new textures. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a93">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a86">DebugTextRenderer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a30">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a53">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a85">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a85">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a73">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a76">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a51">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a51">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a48">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a46">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a53">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga0d9a12fdb214af17acac6536d23cd911"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetSamples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sample count for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">samples</td><td>Sample count to use for new textures. <ul>
<li>Must be zero for non-multisample textures (those with targets other than TextureTarget::TEXTURE_MULTISAMPLE and TextureTarget::TARGET_MULTISAMPLE_ARRAY). </li>
<li>Must be 2, 4, 8 or 16 for multisample textures. </li>
<li>May be 16 only for textures with a format of Format::STENCIL8. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a90">DebugTextRenderer.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gabc101b1093b409c29b8db4a6f144d968"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetSwizzle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the texture swizzle for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>. </p>
<p>Lookups from <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects will return a four-component vector with (R,G,B,A) components. The texture <a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded. ">NVNformat</a> specifies the (R,G,B,A) components used for storing texel data. The texture swizzle allows applications to produce a new (R,G,B,A) vector by specifying a source component value (R, G, B, A, or the constants 0 or 1) to use for each component of the new output vector. For example, an application can use the swizzle to remap a texture with a format of <a class="el" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecaba1b8221c2a207f0d16fb49c568040da0b" title="One 8-bit unsigned normalized component. ">NVN_FORMAT_R8</a> into a 'LUMINANCE8' texture by using a swizzle pattern of (R,R,R,1).</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">r</td><td>Input component value used for the first (R) output component.</td></tr>
    <tr><td class="paramname">g</td><td>Input component value used for the second (G) output component.</td></tr>
    <tr><td class="paramname">b</td><td>Input component value used for the third (B) output component.</td></tr>
    <tr><td class="paramname">a</td><td>Input component value used for the fourth (A) output component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad1f0c27399978e0f15954533cc4763bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetDepthStencilMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the values returned for depth/stencil <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>. </p>
<p>If the texture has a format with no depth or stencil components, the depth/stencil mode is ignored. If depth/stencil mode selects the stencil component in a texture with only a depth component or vice versa, the results of texture lookups are undefined.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">mode</td><td>Specifies whether to return depth or stencil values from a texture with depth and/or stencil components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1ba9cfd0600643dbb909eaa9c36abe26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnTextureBuilderGetStorageSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of memory (in bytes) required to hold a texture to be created using the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<p>For correct operation, the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> must have a device set via nvnTextureBuilderSetDevice.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to be used to create a new texture. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a91">DebugTextRenderer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a34">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a56">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a87">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a87">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a75">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a78">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a53">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a53">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a50">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a48">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a55">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga05c4e80a256b37ed63e1478ffd680eab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnTextureBuilderGetStorageAlignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimum alignment in bytes (in bytes) required to hold a texture to be created using the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<p>For correct operation, the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> must have a device set via nvnTextureBuilderSetDevice.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to be used to create a new texture. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf6530c01a016b836ad82434f6a793cd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the location in a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> used for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object created from the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">pool</td><td><a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> object providing storage for the new <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of pool storage used by the new <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. <ul>
<li>The provided offset must be a multiple of the required alignment for the provided TextureBuilder object. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a98">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a92">DebugTextRenderer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a39">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a74">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a122">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a131">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a147">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a123">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a90">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a90">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a101">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a82">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a81">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga6ccd08d4bafb09088fb0c39aea731354"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetPackagedTextureData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify optional packaged texture data used to initialize texture storage. </p>
<p>On the Windows reference implementation, texture data produced by the texture packager is not in a form that can be consumed directly by the GPU. When creating a texture with a non-NULL packaged texture data pointer, the Windows reference implementation will convert the texture data from the packaged form to the native format of the GPU, storing the results in the pool memory specified in the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> used to create the texture. If the packaged texture data pointer is NULL, no conversion or copy will be performed. On the target device, the packaged texture data pointer is not used; packaged texture data may be loaded directly in the underlying pool storage used by the texture.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">data</td><td>CPU pointer to NX-optimized texture data built by the texture packager; ignored on NX. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a97">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a38">MultiThreadedAssetFileLoadingHelper.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gab9c504fb68daac897da16e9161e61eb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetPackagedTextureLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_npackaged_texture_layout.html">NVNpackagedTextureLayout</a> *&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the layout of packaged texture data used for texture storage. </p>
<p>This command specifies the memory layout of packaged texture data produced by the NVN texture packager. By default, the driver and texture packager select an optimal layout for a texture based on its size and format. This command allows applications to provide the driver with a layout descriptor produced by the NVN texture packager so that old packaged texture assets can continue to be used even if the default layout changes in a new driver.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">layout</td><td>Description of the texture layout produced by the NVN texture packager. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabaadb0c9f8190a0f8dbc4e637f593636"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetStride </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the stride for linear textures. </p>
<p>Only used when the TextureFlags::LINEAR_BIT flag is set. The stride is defined as the number of bytes between consecutive rows in the linear image. If the texture is to be used as a render target, then this value must be aligned to at least deviceInfo::LINEAR_RENDER_TARGET_STRIDE_ALIGNMENT. If it is only used as a texture, then it needs to be aligned to deviceInfo::LINEAR_TEXTURE_STRIDE_ALIGNMENT Should be at least (width * bpp).</p>
<p>Specify stride for linear textures.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">stride</td><td>Stride for this linear texture. <ul>
<li>Must be greater than zero for linear textures. </li>
<li>Must be aligned to either deviceInfo::LINEAR_RENDER_TARGET_STRIDE_ALIGNMENT or deviceInfo::LINEAR_TEXTURE_STRIDE_ALIGNMENT. Must be greater than or equal to zero. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial11_8cpp-example.html#a118">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gae8382ee09ab0b9f65b84368aa3aa8fef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderSetGLTextureName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the name of the OpenGL texture to use as an external texture source. </p>
<p>If a texture builder with a non-zero texture name is used to initialize a new NVN texture, the texture will be initialized to use all the properties, including texel storage, of the OpenGL or OpenGL ES texture with the provided name. The texture name will be used to look up OpenGL or OpenGL ES texture object using the OpenGL/OpenGL ES context current on the thread initializing the NVN texture. If no OpenGL/OpenGL ES context is current, or if the name does not identify a valid texture object, the results of NVN texture initialization are undefined. There are a number of restrictions on the GL texture object: </p><ul>
<li><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> storage must be immutable. </li>
<li>The format and target of the texture must have NVN equivalents. </li>
<li>Sparse textures are unsupported. </li>
<li><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> textures are unsupported. Synchronization and lifetime management must be handled by the application. In particular, the application must ensure that all NVN commands accessing the texture have completed (e.g., by calling <a class="el" href="group__nvn__c__functions.html#gaab3c15f657cefdff33dab453795ff38f" title="Wait until all commands previously submitted to a queue have completed execution. ...">nvnQueueFinish()</a>) before calling either glDeleteTextures() or <a class="el" href="group__nvn__c__functions.html#gaa5741253f7ab5c9075a6821a68cfa351" title="Finalize a NVNtexture object. ">nvnTextureFinalize()</a>. By default, the texture name associated with a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> is zero, which indicates that no GL texture should be used for NVN texture initialization.</li>
</ul>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">name</td><td>The name of the OpenGL/OpenGL ES texture to use as a source. <ul>
<li>Must be zero, or the name of a valid OpenGL or OpenGL ES texture. </li>
<li>If non-zero, the texture properties must be compatible with NVN. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial10_8cpp-example.html#a86">NvnTutorial10.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gad4136c92f14cf364c1776814c31d098a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga4e21960c2b9244bbd2753954b23580d3">NVNstorageClass</a> nvnTextureBuilderGetStorageClass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the storage class needed for virtual memory mappings for a texture to be created using the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<p>When memory from a physical memory pool is mapped into a virtual memory pool, the mapping must be established with a storage class appropriate for texture or buffer resources using the virtual memory. The value returned by this command should be used for memory mappings of textures created with this <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to be used to create a new texture. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf602e9d491bac3c2389d3f62e5fc3a82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a>* nvnTextureBuilderGetDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the device associated with this <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5e8501ec354c364fc84ac787a1b29042"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga57ab2536473c8e62f621554a2618121b">NVNtextureFlags</a> nvnTextureBuilderGetFlags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the flags for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf0202b12c55ce5a46f3c023266d8c454"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a> nvnTextureBuilderGetTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the target for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga386847eb4289c7cd7ad45ee0d2b62918"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureBuilderGetWidth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the width for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga33852e99c26e6d9ca7cce5faf24b55ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureBuilderGetHeight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the height for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab08075b4fd422c5586f418ec95432ca8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureBuilderGetDepth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga203060aa64e2655e160e502337c80345"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureBuilderGetLevels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the level count for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8882c4fa3c8f9f232bcc966516005a2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> nvnTextureBuilderGetFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the format for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga838dc1cd980379c39027331f1390169f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureBuilderGetSamples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the sample count for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad00012a5e2ba6e63b8c022fff5d233c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderGetSwizzle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the swizzles for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>Input component value used for the first (R) output component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>Input component value used for the second (G) output component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>Input component value used for the third (B) output component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a</td><td>Input component value used for the fourth (A) output component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae190535d6c7660700220beee28fabb20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a> nvnTextureBuilderGetDepthStencilMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth/stencil mode for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4c64f715837363c1e2920cae77be92da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* nvnTextureBuilderGetPackagedTextureData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the packaged texture data pointer for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8d4eab4f6bf7d1b48e53dfa1ee035058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnTextureBuilderGetPackagedTextureLayout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_npackaged_texture_layout.html">NVNpackagedTextureLayout</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the packaged texture layout associated with this <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<p>Returns true if a layout of packaged texture data is associated with this <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a>. In this case the layout is returned in data.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Packaged texture layout associated with this <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9939e7f8604b5c1c58eade93a8c6f2df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnTextureBuilderGetStride </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the stride for a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gade45e847441bcf19b57835e7b30e3dbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureBuilderGetSparseTileLayout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_sparse_tile_layout.html">NVNtextureSparseTileLayout</a> *&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns properties of the sparse memory layout for a texture to be created using the provided <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<p>For correct operation, the <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> must have a device set via nvnTextureBuilderSetDevice.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to be used to create a new texture.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">layout</td><td>Pointer to a <a class="el" href="struct_n_v_ntexture_sparse_tile_layout.html" title="Data structure used by queries of the memory layout used by sparse textures. ">NVNtextureSparseTileLayout</a> structure to receive layout information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaad49dafe49d8e52a12518c8dc492fe71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nvnTextureBuilderGetGLTextureName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the OpenGL or OpenGL ES texture to use as an external texture source. </p>
<p>If the returned name is zero, no source texture will be used. See SetGLTextureName for details.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa00aaba8acd99e423733589231ac411a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnTextureBuilderGetZCullStorageSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth texture. </p>
<p>The buffer should be aligned to <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a0ed594e80e327869a5f693ae2cdc2835" title="Minimum alignment for ZCull save/restore buffers. ">NVN_DEVICE_INFO_ZCULL_SAVE_RESTORE_ALIGNMENT</a> bytes.</p>
<p>If the texture has a format with no depth or stencil components, this function returns zero.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to be used to create a new texture. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeade4627ca9fc552f5c5b8584a7cd514"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnTextureBuilderGetMemoryPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool used by a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac22e6e0c78a09ad5348b8e6b3e7c5c1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnTextureBuilderGetMemoryOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool offset used by a <a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3c88faa3760e867dc363f64b46ad3487"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureViewSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object. </p>
<p>A <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object programmed with the default state will use all of the properties of the original texture using the texture view object. Only those properties explicitly programmed in the <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object will affect the view of the original texture.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial11_8cpp-example.html#a89">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gae0bf0a7949e2e49f628bbba2358ef86e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureViewSetLevels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numLevels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a texture view to select a subset of the mipmap levels in a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<p>By default, texture objects registered in the texture pool will use all mipmap levels in the original texture. Selecting levels in the texture view when registering a texture will limit the registered texture to a subset of the levels of the original texture object. Other rendering operations using a texture will default to using the base level (numbered zero) of the original texture. Selecting levels in the texture view in these cases will instead use the baseLevel parameter of the texture view.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object to update.</td></tr>
    <tr><td class="paramname">baseLevel</td><td>Specifies the minimum (base) level in a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. A base level of zero selects the highest-resolution mipmap level of the texture; larger values select lower-resolution mipmap levels. Must be less than the number of layers in the original texture object. Must be less than 15 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50afb8ed8803991c4da6b6b989c8cf955be" title="Maximum number of levels supported for any texture target. ">NVN_DEVICE_INFO_MAX_TEXTURE_LEVELS</a>).</td></tr>
    <tr><td class="paramname">numLevels</td><td>Specifies the number of mipmap levels in a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. If non-zero, selects the specified number of mipmap levels. If zero, selects all mipmap levels below baseLevel. The sum of <em>baseLevel</em> and <em>numLevels</em> in the view must be less than or equal to the number of levels in the original texture object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad854d7dac2c34ed9bf7258d5083d12b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureViewSetLayers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numLayers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a texture view to select a subset of the layers in a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<p>By default, texture objects registered in the texture pool or used for rendering will use all layers in the original texture. Selecting layers in the texture view will limit the view to a subset of the layers of the original texture object.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object to update.</td></tr>
    <tr><td class="paramname">minLayer</td><td>Specifies the minimum layer number in a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. Must be less than the total number of layers in the texture. Must be less than 2048 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a0937333540ee2d53634d831a2533c485" title="Maximum number of layers supported for any array texture target. ">NVN_DEVICE_INFO_MAX_TEXTURE_LAYERS</a>).</td></tr>
    <tr><td class="paramname">numLayers</td><td>Specifies the number of layers to use when accessing this texture. If non-zero, selects the specified number of layers. If zero, selects all layers greater than or equal to minLayer. The sum of <em>minLayer</em> and <em>numLayers</em> in the view must be less than or equal to the number of layers in the original texture object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga33693bbcbc48e8dd365fa40627d8fc93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureViewSetFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a texture view to select an alternate texture format. </p>
<p>Using a format in a texture view allows applications to reinterpret the storage belonging to a texture object with an alternate format. For example, a texture with a format of <a class="el" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecaba81514f73c168617e9819e91131e87426" title="Four 8-bit unsigned normalized components. ">NVN_FORMAT_RGBA8</a> can be reinterpreted with a format of <a class="el" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecabaadce15bed959fd4fbdd5e62ad368f17c" title="Four 8-bit unsigned integer components. ">NVN_FORMAT_RGBA8UI</a> to obtain the components of the texture as raw integer values instead of as normalized values in [0,1]. The format selected for the texture view must be compatible with the format of the original texture object. The format specified in a texture view overrides the format specified by nvnTextureBuilderSetFormat.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object to update.</td></tr>
    <tr><td class="paramname">format</td><td><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded. ">NVNformat</a> to use in the texture view. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial11_8cpp-example.html#a90">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga034326c7ada555fedcd5ddb4ed1eeef9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureViewSetSwizzle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a texture view to select an alternate component swizzle. </p>
<p>The swizzles specified in a texture view override those specified by nvnTextureBuilderSetSwizzle.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object to update.</td></tr>
    <tr><td class="paramname">r</td><td>Input component value used for the first (R) output component.</td></tr>
    <tr><td class="paramname">g</td><td>Input component value used for the second (G) output component.</td></tr>
    <tr><td class="paramname">b</td><td>Input component value used for the third (B) output component.</td></tr>
    <tr><td class="paramname">a</td><td>Input component value used for the fourth (A) output component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2f34ef29814d767bb2347759358832db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureViewSetDepthStencilMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a texture view to select an alternate depth/stencil mode. </p>
<p>The swizzles specified in a texture view override those specified by nvnTextureBuilderSetDepthStencilMode.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object to update.</td></tr>
    <tr><td class="paramname">mode</td><td>Specifies whether to return depth or stencil values from a texture with depth and/or stencil components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabb89f522ce35d06d0067032ab0e42b0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureViewSetTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a texture view to select an alternate texture target. </p>
<p>The swizzles specified in a texture view override those specified by nvnTextureBuilderSetTarget.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object to update.</td></tr>
    <tr><td class="paramname">target</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> target to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga367cd40a7a0c3ebfa548291f93bfd4fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnTextureViewGetLevels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>baseLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>numLevels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the set of levels associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object. </p>
<p>Returns NVN_TRUE if a set of levels has been specified in the view. Returns NVN_FALSE if no set of levels has been specified.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">baseLevel</td><td>Minimum (base) level in a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. Zero is returned if no set of levels has been specified.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numLevels</td><td>Number of mipmap levels in a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. Zero is returned if no set of levels has been specified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacf9f4f92177b7a7801a6a6d7c829ec00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnTextureViewGetLayers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>minLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>numLayers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the set of layers associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object. </p>
<p>Returns NVN_TRUE if a set of layers has been specified in the view. Returns NVN_FALSE if no set of layers has been specified.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">minLayer</td><td>The minimum layer number in a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. Zero is returned if no set of layers has been specified.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numLayers</td><td>The number of layers in a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. Zero is returned if no set of layers has been specified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf06b460df83524343f9092f1c50d50ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnTextureViewGetFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> *&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the format associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object. </p>
<p>Returns NVN_TRUE if a format has been specified in the view. Returns NVN_FALSE if no format has been specified.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">format</td><td><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded. ">NVNformat</a> in the texture view. <a class="el" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecaba7c782a722996d27efbfc6f9128f32d73" title="Placeholder enum indicating no defined format; never valid. ">NVN_FORMAT_NONE</a> is returned if no format has been specified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3e112fd45346310739045b94eeef908f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnTextureViewGetSwizzle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the swizzles associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object. </p>
<p>Returns NVN_TRUE if swizzles have been specified in the view. Returns NVN_FALSE if no swizzles have been specified.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>Input component value used for the first (R) output component. <a class="el" href="group__nvn__c__enum.html#gga2655fafafc505f95439b33402186b6beaf9b420bd02d4a13c4c66e97023476d00" title="Output component returned as 0 or 0.0, depending on the texture format. ">NVN_TEXTURE_SWIZZLE_ZERO</a> is returned if no swizzles have been specified.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>Input component value used for the second (G) output component. <a class="el" href="group__nvn__c__enum.html#gga2655fafafc505f95439b33402186b6beaf9b420bd02d4a13c4c66e97023476d00" title="Output component returned as 0 or 0.0, depending on the texture format. ">NVN_TEXTURE_SWIZZLE_ZERO</a> is returned if no swizzles have been specified.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>Input component value used for the third (B) output component. <a class="el" href="group__nvn__c__enum.html#gga2655fafafc505f95439b33402186b6beaf9b420bd02d4a13c4c66e97023476d00" title="Output component returned as 0 or 0.0, depending on the texture format. ">NVN_TEXTURE_SWIZZLE_ZERO</a> is returned if no swizzles have been specified.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a</td><td>Input component value used for the fourth (A) output component. <a class="el" href="group__nvn__c__enum.html#gga2655fafafc505f95439b33402186b6beaf9b420bd02d4a13c4c66e97023476d00" title="Output component returned as 0 or 0.0, depending on the texture format. ">NVN_TEXTURE_SWIZZLE_ZERO</a> is returned if no swizzles have been specified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2176ce574e0478a456a9a87022a25532"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnTextureViewGetDepthStencilMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a> *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth/stencil mode associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object. </p>
<p>Returns NVN_TRUE if a depth/stencil mode has been specified in the view. Returns NVN_FALSE if no depth/stencil mode has been specified.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mode</td><td>Selector to return depth or stencil values from a texture with depth and/or stencil components. <a class="el" href="group__nvn__c__enum.html#gga3fc9be97b8a8e51aacbaf2d93edb9b1ca8ad2671f2dca9db97b1d62d29df0f7f0" title="Return depth data as floating-point values. ">NVN_TEXTURE_DEPTH_STENCIL_MODE_DEPTH</a> is returned if no depth/stencil mode has been specified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5aa74261dd204238deca7932be67bdb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnTextureViewGetTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the target associated with a <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object. </p>
<p>Returns NVN_TRUE if a target has been specified in the view. Returns NVN_FALSE if no target has been specified.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">view</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">target</td><td>Target associated with the texture view. <a class="el" href="group__nvn__c__enum.html#gga7f247010f53480c7dd1f3b2ad638c431abd7d830ea240f95cd050f980ec7c59a4" title="One-dimensional texture. ">NVN_TEXTURE_TARGET_1D</a> is returned if no target has been specified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab95e7a5cd51184f9578614b4ec442b78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnTextureViewCompare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>otherView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> objects are equivalent. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>First <a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object.</td></tr>
    <tr><td class="paramname">otherView</td><td><a class="el" href="struct_n_v_ntexture_view.html" title="Object used to specify an alternate &#39;view&#39; of a full texture object for various rendering operations...">NVNtextureView</a> object to compare against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad8c5cbaa3292721f1de9d521a66aac3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnTextureInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_builder.html">NVNtextureBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a texture object from a texture builder using storage provided by a memory pool. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to initialize.</td></tr>
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_ntexture_builder.html" title="Object specifying state used to construct new texture objects. ">NVNtextureBuilder</a> object holding properties of the new <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a99">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a93">DebugTextRenderer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a40">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a75">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a123">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a132">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a148">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a124">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a91">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a91">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a102">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a83">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a82">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga73cb447f019bda7152e2ab27a5a9156d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnTextureGetZCullStorageSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth texture. </p>
<p>The buffer should be aligned to <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a0ed594e80e327869a5f693ae2cdc2835" title="Minimum alignment for ZCull save/restore buffers. ">NVN_DEVICE_INFO_ZCULL_SAVE_RESTORE_ALIGNMENT</a> bytes.</p>
<p>If the texture has a format with no depth or stencil components, this function returns zero.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa5741253f7ab5c9075a6821a68cfa351"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_data_holder_8cpp-example.html#a14">AssetFileDataHolder.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a82">DebugTextRenderer.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a66">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a105">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a114">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a146">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a111">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a82">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a82">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a93">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a59">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a141">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga38af53eeec445c9775f1b4715c707570"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga290d7f9e06d3eb2618b601f83d3bbbb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__api__typedefs.html#ga4e21960c2b9244bbd2753954b23580d3">NVNstorageClass</a> nvnTextureGetStorageClass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the storage class needed for virtual memory mappings for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<p>When memory from a physical memory pool is mapped into a virtual memory pool, the mapping must be established with a storage class appropriate for texture or buffer resources using the virtual memory. The value returned by this command should be used for memory mappings used by this texture.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4f538a9539abbb991fd0c42089293105"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnTextureGetViewOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the offset (in bytes) of the first byte of storage used by a view of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<p>The offset returned is a value relative to the offset of the first byte of storage used by the full texture. Textures are stored in (virtually) contiguous memory. For array and cube map textures, each layer or face is stored in memory as a unit with offsets increasing by layer number. For mipmapped textures, each mipmap level in the texture (or in each layer for array and cube map textures) is stored as a unit with offsets increasing by mipmap level number.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query.</td></tr>
    <tr><td class="paramname">textureView</td><td>View of the texture used to determine an offset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2b2185123abcb5454ce65f662c34e166"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga57ab2536473c8e62f621554a2618121b">NVNtextureFlags</a> nvnTextureGetFlags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the flags for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga785889a42583d3e442610a7385ec2f3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga7f247010f53480c7dd1f3b2ad638c431">NVNtextureTarget</a> nvnTextureGetTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the target for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga529f99644886d9a725ef2bf7b9108a27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureGetWidth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the width for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga53c4d11d01059c6d3d875ecf85ede8a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureGetHeight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the height for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1949a4d4cb3eaf94f805beae5748209d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureGetDepth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab847c77fff2d7ff0597ba6138da6dae5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureGetLevels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the level count for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa1d6ee5609a77cbcc3d7af85edf1ea76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> nvnTextureGetFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the format for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga05bc2d539e76dd0f5daaf6faccc8d718"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureGetSamples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the sample count for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad8a208369ab9e5f3c15794f023893a5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureGetSwizzle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga2655fafafc505f95439b33402186b6be">NVNtextureSwizzle</a> *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the swizzles for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>Input component value used for the first (R) output component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>Input component value used for the second (G) output component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>Input component value used for the third (B) output component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a</td><td>Input component value used for the fourth (A) output component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga745f91a439a4c7ab71f1e58cd2e2246b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga3fc9be97b8a8e51aacbaf2d93edb9b1c">NVNtextureDepthStencilMode</a> nvnTextureGetDepthStencilMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth/stencil mode for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4813ee9097b828190f3b6098fb3c3ab0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnTextureGetStride </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the stride for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1830936e33236e3808dbf70c8bd076f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__handle.html#ga25907f5565e57af5a1f3f2fef4493887">NVNtextureAddress</a> nvnTextureGetTextureAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the GPU address of the first byte of memory used by a texture. </p>
<dl class="section warning"><dt>警告</dt><dd>Except for buffer and linear textures, a NVNtextureAddress returned by nvnTextureGetTextureAddress corresponds to a special memory mapping that can not be used to view or manipulate memory in commands accepting a buffer address.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga92054c4c5f509f4be2e4b5536f755344"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureGetSparseTileLayout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ntexture_sparse_tile_layout.html">NVNtextureSparseTileLayout</a> *&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns properties of the sparse memory layout for a texture. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">layout</td><td>Pointer to a <a class="el" href="struct_n_v_ntexture_sparse_tile_layout.html" title="Data structure used by queries of the memory layout used by sparse textures. ">NVNtextureSparseTileLayout</a> structure to receive layout information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0e4a235dac08f14ecbaf8e566df8444e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureWriteTexels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy texture data from memory into a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<p>Copies texture data from the memory pointed to by <em>data</em> to the specified region of a texture, using the CPU. This command behaves like nvnCommandBufferCopyBufferToTexture, except that the copy is performed immediately and does not involve the GPU on NX. On the Windows reference implementation, this copy will use the GPU to update GPU-attached video memory. If the texture is stored in a memory pool created with <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a2fa7e2b859d94d1dc2c7077822b46f83" title="Indicates that the memory pool will be accessed by the CPU with caching. ">NVN_MEMORY_POOL_FLAGS_CPU_CACHED_BIT</a>, the caller must use nvnTextureFlushTexels to flush relevant portions of the CPU cache prior to using the updated texture in the GPU.</p>
<dl class="section warning"><dt>警告</dt><dd>Because the CPU does not have access to GPU compression information needed to properly interpret GPU-compressed textures, it is an error to use this command to operate on a texture with the <a class="el" href="group__nvn__c__enum.html#gga57ab2536473c8e62f621554a2618121ba0d4ba29569c01183e9a92cb3359da7d1" title="The contents of this texture can be compressed by the GPU. ">NVN_TEXTURE_FLAGS_COMPRESSIBLE_BIT</a> flag set.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to update. This command may not be used to update textures stored in memory pools created with <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654ae90d91fe770d2eb3e1476c404c003369" title="Indicates that the memory pool will not be accessed by the CPU. ">NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT</a>.</td></tr>
    <tr><td class="paramname">textureView</td><td>View of the texture object used as the destination for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>texture</em>. If NULL is specified, the base level of the texture <em>texture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">region</td><td>Region of the destination texture to update.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to source texel data in system memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacaa6b82b65f0aa146a786e5f08e762ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureWriteTexelsStrided </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>rowStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>imageStride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy texture data from memory into a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object with user-specified stride. </p>
<p>Copies texture data from the memory pointed to by <em>data</em> to the specified region of a texture, using the CPU. This command behaves like the combination of nvnCommandBufferSetCopyRowStride, nvnCommandBufferSetCopyImageStride, and nvnCommandBufferCopyBufferToTexture, except that no stride state is retained, and the copy is performed immediately and does not involve the GPU on NX. Note this means that <em>rowStride</em> must be at least the number of bytes in a row of the image, and <em>imageStride</em> must be at least the number of bytes in one full image. On the Windows reference implementation, this copy will use the GPU to update GPU-attached video memory. If the texture is stored in a memory pool created with <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a2fa7e2b859d94d1dc2c7077822b46f83" title="Indicates that the memory pool will be accessed by the CPU with caching. ">NVN_MEMORY_POOL_FLAGS_CPU_CACHED_BIT</a>, the caller must use nvnTextureFlushTexels to flush relevant portions of the CPU cache prior to using the updated texture in the GPU.</p>
<dl class="section warning"><dt>警告</dt><dd>Because the CPU does not have access to GPU compression information needed to properly interpret GPU-compressed textures, it is an error to use this command to operate on a texture with the <a class="el" href="group__nvn__c__enum.html#gga57ab2536473c8e62f621554a2618121ba0d4ba29569c01183e9a92cb3359da7d1" title="The contents of this texture can be compressed by the GPU. ">NVN_TEXTURE_FLAGS_COMPRESSIBLE_BIT</a> flag set.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to update. This command may not be used to update textures stored in memory pools created with <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654ae90d91fe770d2eb3e1476c404c003369" title="Indicates that the memory pool will not be accessed by the CPU. ">NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT</a>.</td></tr>
    <tr><td class="paramname">textureView</td><td>View of the texture object used as the destination for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>texture</em>. If NULL is specified, the base level of the texture <em>texture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">region</td><td>Region of the destination texture to update.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to source texel data in system memory.</td></tr>
    <tr><td class="paramname">rowStride</td><td>Stride (in bytes) between rows of texels in <em>data</em>. If specified as 0, rows of texels in <em>data</em> will be treated as densely packed, where each new row in memory starts immediately after the end of the previous row. For compressed texture formats, <em>rowStride</em> indicates the stride between rows of blocks.</td></tr>
    <tr><td class="paramname">imageStride</td><td>Stride (in bytes) between 2D arrays of texels in <em>data</em>. If specified as 0, 2D arrays of texels (corresponding to 2d texture layers, cube faces, or slices of a 3D texture) will be treated as densely packed, where each 2D array in memory starts immediately after the end of the previous 2D array. If <em>imageStride</em> is 0 and <em>rowStride</em> is non-zero, each 2D array is treated as an array of rows, each consuming <em>rowStride</em> bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0a3763d942005f48eaa467571ff8ad8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureReadTexels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read texture data from a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object into memory. </p>
<p>Copies texture data from the specified region of a texture to the memory pointed to by <em>data</em>, using the CPU. This command behaves like nvnCommandBufferCopyTextureToBuffer, except that the copy is performed immediately and does not involve the GPU on NX. On the Windows reference implementation, this copy will use the GPU to read GPU-attached video memory. If the texture is stored in a memory pool created with <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a2fa7e2b859d94d1dc2c7077822b46f83" title="Indicates that the memory pool will be accessed by the CPU with caching. ">NVN_MEMORY_POOL_FLAGS_CPU_CACHED_BIT</a> and has been updated using the GPU, the caller must use nvnTextureInvalidateTexels to invalidate relevant portions of the CPU cache prior to using this command to read from the texture.</p>
<dl class="section warning"><dt>警告</dt><dd>Because the CPU does not have access to GPU compression information needed to properly interpret GPU-compressed textures, it is an error to use this command to operate on a texture with the <a class="el" href="group__nvn__c__enum.html#gga57ab2536473c8e62f621554a2618121ba0d4ba29569c01183e9a92cb3359da7d1" title="The contents of this texture can be compressed by the GPU. ">NVN_TEXTURE_FLAGS_COMPRESSIBLE_BIT</a> flag set.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to read. This command may not be used to read from textures stored in memory pools created with <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654ae90d91fe770d2eb3e1476c404c003369" title="Indicates that the memory pool will not be accessed by the CPU. ">NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT</a>.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">textureView</td><td>View of the texture object used as the source for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>texture</em>. If NULL is specified, the base level of the texture <em>texture</em> will be used as-is.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">region</td><td>Region of the source texture to read.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Pointer to destination texel data in system memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3284bbe008a0f733024a6a041579632e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureReadTexelsStrided </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>rowStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>imageStride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read texture data from a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object into memory. </p>
<p>Copies texture data from the specified region of a texture to the memory pointed to by <em>data</em>, using the CPU. This command behaves like the combination of nvnCommandBufferSetCopyRowStride, nvnCommandBufferSetCopyImageStride, and nvnCommandBufferCopyTextureToBuffer, except that no stride state is retained, and the copy is performed immediately and does not involve the GPU on NX. Note this means that <em>rowStride</em> must be at least the number of bytes in a row of the image, and <em>imageStride</em> must be at least the number of bytes in one full image. On the Windows reference implementation, this copy will use the GPU to read GPU-attached video memory. If the texture is stored in a memory pool created with <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a2fa7e2b859d94d1dc2c7077822b46f83" title="Indicates that the memory pool will be accessed by the CPU with caching. ">NVN_MEMORY_POOL_FLAGS_CPU_CACHED_BIT</a> and has been updated using the GPU, the caller must use nvnTextureInvalidateTexels to invalidate relevant portions of the CPU cache prior to using this command to read from the texture.</p>
<dl class="section warning"><dt>警告</dt><dd>Because the CPU does not have access to GPU compression information needed to properly interpret GPU-compressed textures, it is an error to use this command to operate on a texture with the <a class="el" href="group__nvn__c__enum.html#gga57ab2536473c8e62f621554a2618121ba0d4ba29569c01183e9a92cb3359da7d1" title="The contents of this texture can be compressed by the GPU. ">NVN_TEXTURE_FLAGS_COMPRESSIBLE_BIT</a> flag set.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to read. This command may not be used to read from textures stored in memory pools created with <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654ae90d91fe770d2eb3e1476c404c003369" title="Indicates that the memory pool will not be accessed by the CPU. ">NVN_MEMORY_POOL_FLAGS_CPU_NO_ACCESS_BIT</a>.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">textureView</td><td>View of the texture object used as the source for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>texture</em>. If NULL is specified, the base level of the texture <em>texture</em> will be used as-is.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">region</td><td>Region of the source texture to read.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Pointer to destination texel data in system memory.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rowStride</td><td>Stride (in bytes) between rows of texels in <em>data</em>. If specified as 0, rows of texels in <em>data</em> will be treated as densely packed, where each new row in memory starts immediately after the end of the previous row. For compressed texture formats, <em>rowStride</em> indicates the stride between rows of blocks.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">imageStride</td><td>Stride (in bytes) between 2D arrays of texels in <em>data</em>. If specified as 0, 2D arrays of texels (corresponding to 2d texture layers, cube faces, or slices of a 3D texture) will be treated as densely packed, where each 2D array in memory starts immediately after the end of the previous 2D array. If <em>imageStride</em> is 0 and <em>rowStride</em> is non-zero, each 2D array is treated as an array of rows, each consuming <em>rowStride</em> bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga955c791dfe86ae65b7e87903575c0cfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureFlushTexels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush CPU cache lines holding portions of a texture. </p>
<p>When a texture object is stored in a memory pool created using <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a2fa7e2b859d94d1dc2c7077822b46f83" title="Indicates that the memory pool will be accessed by the CPU with caching. ">NVN_MEMORY_POOL_FLAGS_CPU_CACHED_BIT</a>, texel updates using nvnTextureWriteTexels will use the CPU cache and may not be immediately visible to the GPU. Before using the contents of such textures on the GPU, this command should be used to flush relevant portions of the CPU cache to ensure that updated texels are written to main memory and will be visible to the GPU. This operation is not needed for textures stored in memory pools created using <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a93f5342f52f301cfdca9901586b9b8e1" title="Indicates that the memory pool will be accessed by the CPU without caching. ">NVN_MEMORY_POOL_FLAGS_CPU_UNCACHED_BIT</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object used for the flush operation.</td></tr>
    <tr><td class="paramname">textureView</td><td>View of the texture object used for the flush operation. A texture view, if specified, can be used to override properties of the corresponding texture <em>texture</em>. If NULL is specified, the base level of the texture <em>texture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">region</td><td>Region of the texture used by the flush operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaec4e878f1036375ad23ff57ceafe53f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnTextureInvalidateTexels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>textureView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate CPU cache lines holding portions of a texture. </p>
<p>When a texture object is stored in a memory pool created using <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a2fa7e2b859d94d1dc2c7077822b46f83" title="Indicates that the memory pool will be accessed by the CPU with caching. ">NVN_MEMORY_POOL_FLAGS_CPU_CACHED_BIT</a>, texels accessed by the CPU may be stored in CPU caches. If texel values are updated using the GPU, subsequent accesses using nvnTextureReadTexels may read old texel values if any of the old data remains in the CPU cache. Before reading GPU-modified textures using nvnTextureReadTexels, this command should be used to invalidate relevant portions of the CPU cache to ensure that stale texel values do not remain in the CPU caches. This operation is not needed for textures stored in memory pools created using <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a93f5342f52f301cfdca9901586b9b8e1" title="Indicates that the memory pool will be accessed by the CPU without caching. ">NVN_MEMORY_POOL_FLAGS_CPU_UNCACHED_BIT</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object used for the invalidate operation.</td></tr>
    <tr><td class="paramname">textureView</td><td>View of the texture object used for the invalidate operation. A texture view, if specified, can be used to override properties of the corresponding texture <em>texture</em>. If NULL is specified, the base level of the texture <em>texture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">region</td><td>Region of the texture used for the invalidate operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga15b7941491a88ad4abf82bdc145216f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnTextureGetMemoryPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool used by a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaec925c37d4094927b8e9fc1d9808545a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnTextureGetMemoryOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the memory pool offset used by a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga74382bb40eec4fcbd761e8c76e0bbd3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnTextureGetStorageSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the storage size for a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga236976f3597cb6595dc0703c6a8e7dae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnTextureCompare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>otherTexture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if texture objects are equivalent. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>First texture object.</td></tr>
    <tr><td class="paramname">otherTexture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to compare against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga89c5c4383243a7679a4d4d9977ffc365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nvnTextureGetDebugID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the debug layer unique ID of this texture. </p>
<p>Returns 0 if debug layer disabled.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7504233cce44b1f5a7223f322b76a84d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> associated with a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> owning <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created by the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a13">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a39">DebugTextRenderer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a11">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a73">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a73">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a61">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a64">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a39">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a39">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a38">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a85">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga889b306858059648c66e88a226391acc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object. </p>
<p>This method does not modify the device associated with the builder, which is programmed by SetDevice.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">SamplerBuilder::SetMinMagFilter(<a class="code" href="group__nvn__c__enum.html#gga41610125d2ee1e59db15c26f9a1288c5a46491b2e050963aebd1adca628936509">NVN_MIN_FILTER_LINEAR</a>, <a class="code" href="group__nvn__c__enum.html#gga7f4e9b2ce71bbd9c4c2de6b3cfc293dca803ef983fc9050410c23c0362c58e2d0">NVN_MAG_FILTER_LINEAR</a>);</div>
<div class="line">SamplerBuilder::SetWrapMode(<a class="code" href="group__nvn__c__enum.html#ggae1db40da1d4ffe0bc8d43aa853380d5ca6d3c99612a8b57980009aad19ea7d29f">NVN_WRAP_MODE_REPEAT</a>, <a class="code" href="group__nvn__c__enum.html#ggae1db40da1d4ffe0bc8d43aa853380d5ca6d3c99612a8b57980009aad19ea7d29f">NVN_WRAP_MODE_REPEAT</a>,</div>
<div class="line">                            <a class="code" href="group__nvn__c__enum.html#ggae1db40da1d4ffe0bc8d43aa853380d5ca6d3c99612a8b57980009aad19ea7d29f">NVN_WRAP_MODE_REPEAT</a>);</div>
<div class="line">SamplerBuilder::SetLodClamp(0.0, 1000.0);</div>
<div class="line">SamplerBuilder::SetLodBias(0.0);</div>
<div class="line">SamplerBuilder::SetCompare(<a class="code" href="group__nvn__c__enum.html#ggaa5f726f373cd522aa586a0b26a34fb3da921569e4fb61ef832a021841d6a6c9fd">NVN_COMPARE_MODE_NONE</a>, <a class="code" href="group__nvn__c__enum.html#gga83d020997abcffbd763d2ca9e7b1aff6aa71bc29784a35d4c5a0eadc049cea236">NVN_COMPARE_FUNC_LESS</a>);</div>
<div class="line">SamplerBuilder::SetBorderColor({ 0.0, 0.0, 0.0, 0.0 });</div>
<div class="line">SamplerBuilder::SetMaxAnisotropy(1.0);</div>
<div class="line">SamplerBuilder::SetReductionFilter(<a class="code" href="group__nvn__c__enum.html#gga867b21c764db6c0573e9fc68e1b83437afbd37d3bc403996a59b4fbf1b085321e">NVN_SAMPLER_REDUCTION_AVERAGE</a>);</div>
<div class="line">SamplerBuilder::SetLodSnap(0.0);</div>
</div><!-- fragment --><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_loading_helper_8cpp-example.html#a14">AssetFileLoadingHelper.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a40">DebugTextRenderer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a12">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a74">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a74">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a62">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a65">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a40">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a40">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a39">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a86">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga0f634bd122e2b47cbebfeb16cda8352f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetMinMagFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga41610125d2ee1e59db15c26f9a1288c5">NVNminFilter</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga7f4e9b2ce71bbd9c4c2de6b3cfc293dc">NVNmagFilter</a>&#160;</td>
          <td class="paramname"><em>mag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minification and magnification filters for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">min</td><td>Specifies the minification filter.</td></tr>
    <tr><td class="paramname">mag</td><td>Specifies the magnification filter. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a75">DebugTextRenderer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a35">MultiThreadedAssetFileLoadingHelper.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga63aec39a3ab8401a6e287d2024c74e2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetWrapMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the coordinate wrap modes for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">s</td><td>Specifies the wrap mode for the first (S) texture coordinate.</td></tr>
    <tr><td class="paramname">t</td><td>Specifies the wrap mode for the second (T) texture coordinate.</td></tr>
    <tr><td class="paramname">r</td><td>Specifies the wrap mode for the third (R) texture coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a78">DebugTextRenderer.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gacd10e1f2dc492fdf600365ef94945170"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetLodClamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimum and maximum level of detail used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>. </p>
<p>When a sampler builder is used to initialize a sampler object, <em>min</em> will be clamped to [0.0, 15.0], and <em>max</em> will be clamped to [max(0.0, <em>min</em>), 15.0].</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">min</td><td>Specifies the minimum level of detail used with the sampler. <ul>
<li>Must be less than or equal to max.</li>
</ul>
</td></tr>
    <tr><td class="paramname">max</td><td>Specifies the maximum level of detail used with the sampler. <ul>
<li>Must be greater than or equal to min. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga21c8ec90c03a9ba5c53824bfb9c1eee6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetLodBias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the level-of-detail bias used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>. </p>
<p>When a sampler builder is used to initialize a sampler object, <em>bias</em> will be clamped to [-16.0, 15.996].</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">bias</td><td>Specifies the bias to add to the computed level of detail when the sampler is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga61212f6d7e261272b3f3d8a2bedb7fd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetCompare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa5f726f373cd522aa586a0b26a34fb3d">NVNcompareMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga83d020997abcffbd763d2ca9e7b1aff6">NVNcompareFunc</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the depth comparison mode used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>. </p>
<p>When used with textures without depth components, the depth comparison mode is ignored.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">mode</td><td>Specifies whether depth comparisons are performed when using the sampler.</td></tr>
    <tr><td class="paramname">func</td><td>If depth comparisons are enabled, specifies the comparison function used with the sampler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga58d007814dbbe79756a873c62077f8f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetBorderColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>borderColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set floating-point border color values used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">borderColor</td><td>Specifies four floating-point components (R,G,B,A) for the border color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae65d26314f7fcc219ac81cd331037cee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetBorderColori </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>borderColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set signed integer border color values used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">borderColor</td><td>Specifies four signed integer components (R,G,B,A) for the border color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga620e4e3a9f487eaaab3b1ff4e7854bde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetBorderColorui </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>borderColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set unsigned integer border color values used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">borderColor</td><td>Specifies four unsigned integer components (R,G,B,A) for the border color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga211345dfd517cb8458313d2bd00df0a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetMaxAnisotropy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxAniso</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum level of anisotropy used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">maxAniso</td><td>Specifies the maximum level of anisotropy used with the sampler. Must be greater than zero. Must be less than or equal to 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50aeac483b004f722e9e092a4c20e695181" title="Maximum sampler anisotropy. ">NVN_DEVICE_INFO_MAX_TEXTURE_ANISOTROPY</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3c077843893df456f4abff6862b4d467"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetReductionFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga867b21c764db6c0573e9fc68e1b83437">NVNsamplerReduction</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the reduction filter used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">filter</td><td>Specifies the reduction filter used for the sampler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7165b9753b8ce20db7f8658c918fb686"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderSetLodSnap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lodSnap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set LOD snap used for <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects created from the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>. </p>
<p>The texture LOD snap feature is an optimization that reduces texture bandwidth consumption with minification filters that average samples in multiple texture LODs. When performing texture lookups, hardware will round (snap) the computed texture LOD to the nearest integer if the difference between the computed LOD and the integer value is less than the snap value in the sampler. LOD values that are not snapped are adjusted so that the function adjusting the LOD value is continuous. When snapping occurs, hardware will save bandwidth by sampling from only one mipmap level instead of two.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to update.</td></tr>
    <tr><td class="paramname">lodSnap</td><td>Specifies the LOD snap used for the sampler. Specifies the LOD snap used for the sampler. Valid values are in the range [0.0, 0.5], where 0.0 will result in no snapping and 0.5 would round most computed LODs to integer values. Not all values are supported by the hardware; the driver will select a supported snap value close to the value provided in the sampler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8362d8f866fe4e0f19bf075d801f7220"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_ndevice.html">NVNdevice</a>* nvnSamplerBuilderGetDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the device associated with this <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab3a7a2b46cc8ada75360ac6b0bd73257"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderGetMinMagFilter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga41610125d2ee1e59db15c26f9a1288c5">NVNminFilter</a> *&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga7f4e9b2ce71bbd9c4c2de6b3cfc293dc">NVNmagFilter</a> *&#160;</td>
          <td class="paramname"><em>mag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the minification and magnification filters for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min</td><td>Minification filter for the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mag</td><td>Magnification filter for the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga86f90d77048555a8d81b586536752299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderGetWrapMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the coordinate wrap modes for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Wrap mode for the first (S) texture coordinate.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">t</td><td>Wrap mode for the second (T) texture coordinate.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>Wrap mode for the third (R) texture coordinate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabe25c536260b86ccfde63a91d187c6c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderGetLodClamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the minimum and maximum level of detail in a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min</td><td>Minimum level of detail used with the sampler.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max</td><td>Maximum level of detail used with the sampler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae616d8490657704e4afae4dce930f03f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nvnSamplerBuilderGetLodBias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the level-of-detail bias for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga759f6c95513d59fe4239f85eeac0a534"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderGetCompare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa5f726f373cd522aa586a0b26a34fb3d">NVNcompareMode</a> *&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga83d020997abcffbd763d2ca9e7b1aff6">NVNcompareFunc</a> *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth comparison modes for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mode</td><td>Enable for depth comparisons in the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">func</td><td>Comparison function in the <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga83e8344bbc081cb9ba7464b5e3436c47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderGetBorderColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>borderColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query floating-point border color values for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">borderColor</td><td>Four floating-point components (R,G,B,A) for the border color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7fd5ad1183b027c260ec36d73c6ee3bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderGetBorderColori </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>borderColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query signed integer border color values for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">borderColor</td><td>Four signed integer components (R,G,B,A) for the border color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8354e069c30e1e18a0581471daf66409"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerBuilderGetBorderColorui </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>borderColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query unsigned integer border color values for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">borderColor</td><td>Four unsigned integer components (R,G,B,A) for the border color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1ee3fc56d9b39c67402c04802437976f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nvnSamplerBuilderGetMaxAnisotropy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the maximum level of anisotropy for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabefac5ca39cb0fb81d4fc8b53a031515"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga867b21c764db6c0573e9fc68e1b83437">NVNsamplerReduction</a> nvnSamplerBuilderGetReductionFilter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the reduction filter for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4da85e68ee693bfffd871cace32923c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nvnSamplerBuilderGetLodSnap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the LOD snap for a <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5f3728966dc1ce72231c88bd3bca94ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnSamplerInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_builder.html">NVNsamplerBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object using the specified <a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object to initialize.</td></tr>
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nsampler_builder.html" title="Object specifying state used to construct new sampler objects. ">NVNsamplerBuilder</a> object specifying the state of the new sampler object. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_data_holder_8cpp-example.html#a18">AssetFileDataHolder.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a80">DebugTextRenderer.cpp</a>, <a class="el" href="_multi_threaded_asset_file_loading_helper_8cpp-example.html#a42">MultiThreadedAssetFileLoadingHelper.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a87">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga82945a36dea04505dcd29e03442ed5a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_data_holder_8cpp-example.html#a15">AssetFileDataHolder.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a74">DebugTextRenderer.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a142">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaf992a842dafe3db3a3d68c36a7f89b1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2bacdf25415f1169fff22060eae02d85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerGetMinMagFilter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga41610125d2ee1e59db15c26f9a1288c5">NVNminFilter</a> *&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga7f4e9b2ce71bbd9c4c2de6b3cfc293dc">NVNmagFilter</a> *&#160;</td>
          <td class="paramname"><em>mag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the minification and magnification filters for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min</td><td>Minification filter for the <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mag</td><td>Magnification filter for the <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae2f6cd6c8e394fb4357615ae4d6e6590"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerGetWrapMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae1db40da1d4ffe0bc8d43aa853380d5c">NVNwrapMode</a> *&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the coordinate wrap modes for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>Wrap mode for the first (S) texture coordinate.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">t</td><td>Wrap mode for the second (T) texture coordinate.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>Wrap mode for the third (R) texture coordinate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae3ffb490c3ac760043e8fd7539344341"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerGetLodClamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the minimum and maximum level of detail in a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min</td><td>Minimum level of detail used with the sampler.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max</td><td>Maximum level of detail used with the sampler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga94a996072e4bfcf92d86b6866a28d511"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nvnSamplerGetLodBias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the level-of-detail bias for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf974179c68b5aeebac1e821b757235da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerGetCompare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa5f726f373cd522aa586a0b26a34fb3d">NVNcompareMode</a> *&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga83d020997abcffbd763d2ca9e7b1aff6">NVNcompareFunc</a> *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the depth comparison modes for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mode</td><td>Enable for depth comparisons in the <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">func</td><td>Comparison function in the <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga05bf524362b220a01368041d936a5473"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerGetBorderColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>borderColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query floating-point border color values for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">borderColor</td><td>Four floating-point components (R,G,B,A) for the border color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga42f49191e28dd92309cd80f79c71d325"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerGetBorderColori </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>borderColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query signed integer border color values for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">borderColor</td><td>Four signed integer components (R,G,B,A) for the border color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga09cffaeae4405d2a9b3b8b2054002c29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSamplerGetBorderColorui </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>borderColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query unsigned integer border color values for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">borderColor</td><td>Four unsigned integer components (R,G,B,A) for the border color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga25e6287ab1146df61fe42a501d93abaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nvnSamplerGetMaxAnisotropy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the maximum level of anisotropy for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga476d91292dcfa379c72a31f17bb1e1bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga867b21c764db6c0573e9fc68e1b83437">NVNsamplerReduction</a> nvnSamplerGetReductionFilter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the reduction filter for a <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga530d7f40e1ddc78fcb447d1950f2b471"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnSamplerCompare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>otherSampler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if sampler objects are equivalent. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td>First sampler object.</td></tr>
    <tr><td class="paramname">otherSampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object to compare against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7bedba0ca7bda287c734f16e1124d303"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nvnSamplerGetDebugID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler.html">NVNsampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the debug layer unique ID of this sampler. </p>
<p>Returns 0 if debug layer disabled.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td><a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad0c043334f5f7eb94883fc0465f18e4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object. </p>
<dl class="section note"><dt>覚え書き</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">BlendState::SetBlendTarget(0);</div>
<div class="line">BlendState::SetBlendFunc(<a class="code" href="group__nvn__c__enum.html#ggaa7cd27129fc2e2357fda1f14d9ba60aaa81c217f2553e38a696f4b588656109fb">NVN_BLEND_FUNC_ONE</a>, <a class="code" href="group__nvn__c__enum.html#ggaa7cd27129fc2e2357fda1f14d9ba60aaa63623c63a40ea0468a6733815d741fa2">NVN_BLEND_FUNC_ZERO</a>,</div>
<div class="line">                         <a class="code" href="group__nvn__c__enum.html#ggaa7cd27129fc2e2357fda1f14d9ba60aaa81c217f2553e38a696f4b588656109fb">NVN_BLEND_FUNC_ONE</a>, <a class="code" href="group__nvn__c__enum.html#ggaa7cd27129fc2e2357fda1f14d9ba60aaa63623c63a40ea0468a6733815d741fa2">NVN_BLEND_FUNC_ZERO</a>);</div>
<div class="line">BlendState::SetBlendEquation(<a class="code" href="group__nvn__c__enum.html#gga127348ecf50d7e4c7197ed7e989c5e60af7626fb9998de54f77c5dc495b4c3cc3">NVN_BLEND_EQUATION_ADD</a>,</div>
<div class="line">                             <a class="code" href="group__nvn__c__enum.html#gga127348ecf50d7e4c7197ed7e989c5e60af7626fb9998de54f77c5dc495b4c3cc3">NVN_BLEND_EQUATION_ADD</a>);</div>
<div class="line">BlendState::SetAdvancedMode(<a class="code" href="group__nvn__c__enum.html#gga594e8a6aa9642c5542c0a0ee0156c146abebf3d2a655c414e8e8e67003be3f3ba">NVN_BLEND_ADVANCED_MODE_NONE</a>);</div>
<div class="line">BlendState::SetAdvancedOverlap(<a class="code" href="group__nvn__c__enum.html#gga49a9399d8c6cc26a7f4b256fe0951699a34aecc8444db64de9bc72f3979573902">NVN_BLEND_ADVANCED_OVERLAP_UNCORRELATED</a>);</div>
<div class="line">BlendState::SetAdvancedPremultipliedSrc(<a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>);</div>
<div class="line">BlendState::SetAdvancedNormalizedDst(<a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>);</div>
</div><!-- fragment --><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a13">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_8cpp-example.html#a0">GraphicsObject.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a57">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a57">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a55">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a48">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a97">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gafe4427881d956cf1db9fc536bb9586ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateSetBlendTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the number of the color target to update via the <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">target</td><td>Color target number to update when binding the blend state object. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a14">DebugTextRenderer.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga8f1f669fc90892348eb5763a6d173c60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateSetBlendFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a>&#160;</td>
          <td class="paramname"><em>srcFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a>&#160;</td>
          <td class="paramname"><em>dstFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a>&#160;</td>
          <td class="paramname"><em>srcFuncAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a>&#160;</td>
          <td class="paramname"><em>dstFuncAlpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify blend functions for source and destination color and alpha channels. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">srcFunc</td><td>Blend factor used for source RGB color components.</td></tr>
    <tr><td class="paramname">dstFunc</td><td>Blend factor used for destination RGB color components.</td></tr>
    <tr><td class="paramname">srcFuncAlpha</td><td>Blend factor used for source alpha color components.</td></tr>
    <tr><td class="paramname">dstFuncAlpha</td><td>Blend factor used for destination alpha color components. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a17">DebugTextRenderer.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a101">NvnTutorial05.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gad8c227afe934866f7758f9158ebe1f9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateSetBlendEquation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a>&#160;</td>
          <td class="paramname"><em>modeRGB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a>&#160;</td>
          <td class="paramname"><em>modeAlpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify blend equations for color and alpha channels. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">modeRGB</td><td>Blend equation used for RGB color components.</td></tr>
    <tr><td class="paramname">modeAlpha</td><td>Blend equation used for alpha color components. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a15">DebugTextRenderer.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gadda20b441c242fbad2fa87c9c441735a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateSetAdvancedMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga594e8a6aa9642c5542c0a0ee0156c146">NVNblendAdvancedMode</a>&#160;</td>
          <td class="paramname"><em>overlap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a mode for advanced blending equations. </p>
<p>Advanced blending in NVN provides capabilities similar to those provided by the NV_blend_equation_advanced OpenGL extension. These blend modes specify a technique for combining source and destination color components, and use the source and destination alpha components to evaluate how colors are combined with overlapping color components. The advanced blending modes provided here are similar to those supported in various standards, including several OpenGL and OpenGL ES extensions, OpenVG, the SVG compositing standard, the PDF document format, and various other APIs. For more information on the operation of these blend modes, please consult the NV_blend_equation_advanced specification.</p>
<p>When advanced blending is enabled (not set to <a class="el" href="group__nvn__c__enum.html#gga594e8a6aa9642c5542c0a0ee0156c146abebf3d2a655c414e8e8e67003be3f3ba" title="Use normal blending equations specified with nvnBlendStateSetBlendEquation and nvnBlendStateSetBlendF...">NVN_BLEND_ADVANCED_MODE_NONE</a>), only a single render target is supported. Advanced blending wtih multiple color targets has undefined behavior and may result in to GPU errors. Advanced modes other than NONE are supported only for color target zero.</p>
<p>Advanced blending modes are supported on NX but are not supported on the Windows reference implementation for GPUs older than first-generation Maxwell GPUs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">overlap</td><td>Mode to use for advanced blending equations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0e2be1cd8aad18c9d1ba0f9fa4ca7af4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateSetAdvancedOverlap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga49a9399d8c6cc26a7f4b256fe0951699">NVNblendAdvancedOverlap</a>&#160;</td>
          <td class="paramname"><em>overlap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify blend overlap mode for advanced blending equations. </p>
<p>Advanced blending in NVN provides capabilities similar to those provided by the NV_blend_equation_advanced OpenGL extension. The overlap modes specify how coverage for partially covered sources and/or destinations is treated in the blending equations. This state has no effect if the advanced blending mode is <a class="el" href="group__nvn__c__enum.html#gga594e8a6aa9642c5542c0a0ee0156c146abebf3d2a655c414e8e8e67003be3f3ba" title="Use normal blending equations specified with nvnBlendStateSetBlendEquation and nvnBlendStateSetBlendF...">NVN_BLEND_ADVANCED_MODE_NONE</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">overlap</td><td>Overlap mode used for advanced blending equations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac8aae125e2a9006310e3812c99e5f7ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateSetAdvancedPremultipliedSrc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>premultiplied</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether the source color is considered premultiplied for advanced blending equations. </p>
<p>Advanced blending in NVN provides capabilities similar to those provided by the NV_blend_equation_advanced OpenGL extension. By default, blending is performed with pre-multiplied colors, where a white pixel with 50% coverage has an (R,G,B,A) value of (0.5, 0.5, 0.5, 0.5). If NVN_FALSE is specified, the source color is assumed not to be premultiplied and the same white pixel would be passed as (1.0, 1.0, 1.0, 0.5). Destination colors in advanced blending are always considered pre-multiplied. This state has no effect if the advanced blending mode is <a class="el" href="group__nvn__c__enum.html#gga594e8a6aa9642c5542c0a0ee0156c146abebf3d2a655c414e8e8e67003be3f3ba" title="Use normal blending equations specified with nvnBlendStateSetBlendEquation and nvnBlendStateSetBlendF...">NVN_BLEND_ADVANCED_MODE_NONE</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">premultiplied</td><td>TRUE if source color components are considered to be pre-multiplied by the source alpha. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3ae21c2d569e680699ce50ff6d6b3a7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateSetAdvancedNormalizedDst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>normalized</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether the destination color target has unsigned normalized components (values in [0,1]). </p>
<p>Advanced blending in NVN provides capabilities similar to those provided by the NV_blend_equation_advanced OpenGL extension. By default, blending assumes that the destination values are stored with unsigned normalized components (e.g., using formats like <a class="el" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecaba81514f73c168617e9819e91131e87426" title="Four 8-bit unsigned normalized components. ">NVN_FORMAT_RGBA8</a>). If this value is set to NVN_FALSE, advanced blending will not assume that the destination input and the output will be clamped to [0,1] and will clamp values manually when required. This state has no effect if the advanced blending mode is <a class="el" href="group__nvn__c__enum.html#gga594e8a6aa9642c5542c0a0ee0156c146abebf3d2a655c414e8e8e67003be3f3ba" title="Use normal blending equations specified with nvnBlendStateSetBlendEquation and nvnBlendStateSetBlendF...">NVN_BLEND_ADVANCED_MODE_NONE</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object to update.</td></tr>
    <tr><td class="paramname">normalized</td><td>TRUE if destination color components are unsigned normalized ([0,1]) values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga67117050f7018fa4eb4f51b7611b743c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnBlendStateGetBlendTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of the color target to update via the <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafac4c143756021848290b54879da1240"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateGetBlendFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> *&#160;</td>
          <td class="paramname"><em>srcFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> *&#160;</td>
          <td class="paramname"><em>dstFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> *&#160;</td>
          <td class="paramname"><em>srcFuncAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa7cd27129fc2e2357fda1f14d9ba60aa">NVNblendFunc</a> *&#160;</td>
          <td class="paramname"><em>dstFuncAlpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query blend functions for source and destination color and alpha channels. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">srcFunc</td><td>Blend factor used for source RGB color components.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dstFunc</td><td>Blend factor used for destination RGB color components.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">srcFuncAlpha</td><td>Blend factor used for source alpha color components.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dstFuncAlpha</td><td>Blend factor used for destination alpha color components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7473bde2a4b5144923394d2b2b3ebaab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnBlendStateGetBlendEquation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a> *&#160;</td>
          <td class="paramname"><em>modeRGB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga127348ecf50d7e4c7197ed7e989c5e60">NVNblendEquation</a> *&#160;</td>
          <td class="paramname"><em>modeAlpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query blend equations for color and alpha channels. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">modeRGB</td><td>Blend equation used for RGB color components.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">modeAlpha</td><td>Blend equation used for alpha color components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga347fb2b3121de63e9c3a6b9595ccd2c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga594e8a6aa9642c5542c0a0ee0156c146">NVNblendAdvancedMode</a> nvnBlendStateGetAdvancedMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the mode for advanced blending equations. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9a0232ed175b83f4002d237e98eea02c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga49a9399d8c6cc26a7f4b256fe0951699">NVNblendAdvancedOverlap</a> nvnBlendStateGetAdvancedOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the blend overlap mode for advanced blending equations. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8e8df2c0b7c30848c050cf62da45494d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnBlendStateGetAdvancedPremultipliedSrc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether the source color is considered premultiplied for advanced blending equations. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4c2a450326605d61c14c8a888db2fb2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnBlendStateGetAdvancedNormalizedDst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether the destination color target has unsigned normalized components (values in [0,1]). </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1b5549b5bc5384456dda61010d85b5c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnColorStateSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values. ">NVNcolorState</a> object. </p>
<dl class="section note"><dt>覚え書き</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (NVNuint i = 0; i &lt; DeviceInfo::COLOR_BUFFER_BINDINGS; ++i) {</div>
<div class="line">  ColorState::SetBlendEnable(i, <a class="code" href="group__nvn__c__defines.html#gad12fb86930f09043843be6b39c78bb1b">NVN_FALSE</a>);</div>
<div class="line">};</div>
<div class="line">ColorState::SetLogicOp(<a class="code" href="group__nvn__c__enum.html#gga13d92b26dc58a3c92b79e217e1d81786a32b2015eabb649101676f7562fd573cb">NVN_LOGIC_OP_COPY</a>);</div>
<div class="line">ColorState::SetAlphaTest(<a class="code" href="group__nvn__c__enum.html#ggaef30ce5d138fb99aee61e09d89d9952ea5831bb73448f400fbb8034277fbf2452">NVN_ALPHA_FUNC_ALWAYS</a>);</div>
</div><!-- fragment --><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td><a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values. ">NVNcolorState</a> object to update. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a21">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_8cpp-example.html#a2">GraphicsObject.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a59">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a59">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a57">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a50">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a95">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga4c1c99c2ad31d66b2a6c170b8d8b324c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnColorStateSetBlendEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the blending enable for a single color target. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td><a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values. ">NVNcolorState</a> object to update.</td></tr>
    <tr><td class="paramname">index</td><td>Number of the color target to update. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a9f4ab24a0b8c08e3f2b66ce04e379b16" title="Number of color buffer binding points. ">NVN_DEVICE_INFO_COLOR_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">enable</td><td>TRUE if blending should be enabled for the specified target; FALSE, otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a22">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_cube_8cpp-example.html#a10">GraphicsObjectCube.cpp</a>, <a class="el" href="_graphics_object_specialized_cube_8cpp-example.html#a11">GraphicsObjectSpecializedCube.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a99">NvnTutorial05.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga34d488b77453064ee98fd042c5f8f9df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnColorStateSetLogicOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga13d92b26dc58a3c92b79e217e1d81786">NVNlogicOp</a>&#160;</td>
          <td class="paramname"><em>logicOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the logical operation to perform for all color targets. </p>
<p>If programmed to anything but COPY, arithmetic blending has no effect. Unlike blending, there is no support for separate logical operations for each color target.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td><a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values. ">NVNcolorState</a> object to update.</td></tr>
    <tr><td class="paramname">logicOp</td><td>Logical operation to perform on all color targets. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a24">DebugTextRenderer.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga1cd9f1df52f41fef96e17bbd42facaa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnColorStateSetAlphaTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaef30ce5d138fb99aee61e09d89d9952e">NVNalphaFunc</a>&#160;</td>
          <td class="paramname"><em>alphaTest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a comparison function to use for alpha testing. </p>
<p>Using <a class="el" href="group__nvn__c__enum.html#ggaef30ce5d138fb99aee61e09d89d9952ea5831bb73448f400fbb8034277fbf2452" title="Comparison always passes. ">NVN_ALPHA_FUNC_ALWAYS</a> disables the alpha test entirely.</p>
<dl class="section note"><dt>覚え書き</dt><dd>Applications may get better performance from performing an alpha test in the fragment shader and discarding fragments that fail. Doing so allows the fragment shader to skip other color calculations for failing fragments.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td><a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values. ">NVNcolorState</a> object to update.</td></tr>
    <tr><td class="paramname">alphaTest</td><td>Comparison function used by the alpha test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3503d68a40da5ab574a594125f8cef2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnColorStateGetBlendEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the blending enable for a single color target. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td><a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values. ">NVNcolorState</a> object to query.</td></tr>
    <tr><td class="paramname">index</td><td>Number of the color target to query. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a9f4ab24a0b8c08e3f2b66ce04e379b16" title="Number of color buffer binding points. ">NVN_DEVICE_INFO_COLOR_BUFFER_BINDINGS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf55951ccbd93d23d1753d4de03d81119"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga13d92b26dc58a3c92b79e217e1d81786">NVNlogicOp</a> nvnColorStateGetLogicOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the logical operation to perform for all color targets. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td><a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values. ">NVNcolorState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9dd303cf6348a6e860f26da1f9219e46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#gaef30ce5d138fb99aee61e09d89d9952e">NVNalphaFunc</a> nvnColorStateGetAlphaTest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the comparison function to use for alpha testing. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td><a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values. ">NVNcolorState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafc110d97cce3482f715d26e83413adfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnChannelMaskStateSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nchannel_mask_state.html">NVNchannelMaskState</a> *&#160;</td>
          <td class="paramname"><em>channelMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nchannel_mask_state.html" title="API state object holding per-channel write masks for all color buffers. ">NVNchannelMaskState</a> object. </p>
<dl class="section note"><dt>覚え書き</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (NVNuint i = 0; i &lt; DeviceInfo::COLOR_BUFFER_BINDINGS; ++i) {</div>
<div class="line">  ChannelMaskState::SetChannelMask(i, <a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>, <a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>,</div>
<div class="line">                                      <a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>, <a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>);</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelMask</td><td><a class="el" href="struct_n_v_nchannel_mask_state.html" title="API state object holding per-channel write masks for all color buffers. ">NVNchannelMaskState</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a20">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_8cpp-example.html#a1">GraphicsObject.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a58">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a58">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a56">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a49">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a96">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga2493330ef54d576b537e2f0b1aadbf24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnChannelMaskStateSetChannelMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nchannel_mask_state.html">NVNchannelMaskState</a> *&#160;</td>
          <td class="paramname"><em>channelMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives. ">NVNprogram</a> RGBA channel masks for a single color target. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelMask</td><td><a class="el" href="struct_n_v_nchannel_mask_state.html" title="API state object holding per-channel write masks for all color buffers. ">NVNchannelMaskState</a> object to update.</td></tr>
    <tr><td class="paramname">index</td><td>Number of the color target to update. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a9f4ab24a0b8c08e3f2b66ce04e379b16" title="Number of color buffer binding points. ">NVN_DEVICE_INFO_COLOR_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">r</td><td>Enable (TRUE) or disable (FALSE) writes to the first (R) component.</td></tr>
    <tr><td class="paramname">g</td><td>Enable (TRUE) or disable (FALSE) writes to the second (G) component.</td></tr>
    <tr><td class="paramname">b</td><td>Enable (TRUE) or disable (FALSE) writes to the third (B) component.</td></tr>
    <tr><td class="paramname">a</td><td>Enable (TRUE) or disable (FALSE) writes to the fourth (A) component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacc2b78b04c91b5deabcfaf93cdb0e36c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnChannelMaskStateGetChannelMask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nchannel_mask_state.html">NVNchannelMaskState</a> *&#160;</td>
          <td class="paramname"><em>channelMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query RGBA channel masks for a single color target. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">channelMask</td><td><a class="el" href="struct_n_v_nchannel_mask_state.html" title="API state object holding per-channel write masks for all color buffers. ">NVNchannelMaskState</a> object to query.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index</td><td>Number of the color target to query. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a9f4ab24a0b8c08e3f2b66ce04e379b16" title="Number of color buffer binding points. ">NVN_DEVICE_INFO_COLOR_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>Enable (TRUE) or disable (FALSE) writes to the first (R) component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>Enable (TRUE) or disable (FALSE) writes to the second (G) component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>Enable (TRUE) or disable (FALSE) writes to the third (B) component.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a</td><td>Enable (TRUE) or disable (FALSE) writes to the fourth (A) component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0d649ca21de18dd8b544c8006d6612d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object. </p>
<dl class="section note"><dt>覚え書き</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">MultisampleState::SetMultisampleEnable(<a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>);</div>
<div class="line">MultisampleState::SetAlphaToCoverageEnable(<a class="code" href="group__nvn__c__defines.html#gad12fb86930f09043843be6b39c78bb1b">NVN_FALSE</a>);</div>
<div class="line">MultisampleState::SetAlphaToCoverageDither(<a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>);</div>
<div class="line">MultisampleState::SetSamples(0);</div>
<div class="line">MultisampleState::SetRasterSamples(0);</div>
<div class="line">MultisampleState::SetCoverageModulationMode(CoverageModulationMode::NONE);</div>
<div class="line">MultisampleState::SetCoverageToColorEnable(<a class="code" href="group__nvn__c__defines.html#gad12fb86930f09043843be6b39c78bb1b">NVN_FALSE</a>);</div>
<div class="line">MultisampleState::SetCoverageToColorOutput(0);</div>
<div class="line">MultisampleState::SetSampleLocationsEnable(<a class="code" href="group__nvn__c__defines.html#gad12fb86930f09043843be6b39c78bb1b">NVN_FALSE</a>);</div>
<div class="line">MultisampleState::SetSampleLocationsGridEnable(<a class="code" href="group__nvn__c__defines.html#gad12fb86930f09043843be6b39c78bb1b">NVN_FALSE</a>);</div>
</div><!-- fragment --><p> All sample locations in the <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object are initialized to pixel centers (0.5).</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a31">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_8cpp-example.html#a4">GraphicsObject.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a65">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a65">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a59">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a56">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a94">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga7f1d552844cb1b2388d012cb80d094ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetMultisampleEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable multisample rasterization. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) multisample rasterization. When multisample rasterization is enabled, separate coverage information is computed for every sample in a pixel. When multisample rasterization is disabled, a single coverage value is used for all samples in a pixel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafc59ccbfdafe205cd8ba04f1795ada6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetSamples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the number of samples in the framebuffer. </p>
<dl class="section warning"><dt>警告</dt><dd>If the sample count in the <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object and the textures in the framebuffer don't match, the results of rendering are undefined.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">samples</td><td>Specifies the number of samples in the framebuffer. If non-multisample framebuffers are used, the value should be specified as 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3837dd1e28700073cfd34479a6a2e677"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetAlphaToCoverageEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable alpha-to-coverage operation. </p>
<p>When alpha-to-coverage operations are enabled, the fourth (A) component of fragment color zero is used to produce a sample mask that is combined with raster coverage to produce an updated sample mask. An alpha value of 0.0 disables all samples; an alpha value of 1.0 enables all samples.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) the alpha-to-coverage operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabc12eb75e49cd73800ac71eac99e4008"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetAlphaToCoverageDither </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>dither</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable dithering in the alpha-to-coverage operation. </p>
<p>When alpha-to-coverage operations are enabled via MultisampleState::SetAlphaToCoverage, the fourth (A) component of fragment color zero is used to produce a sample mask that is combined with raster coverage to produce an updated sample mask. An alpha value of 0.0 disables all samples; an alpha value of 1.0 enables all samples. If alpha-to-coverage dithering is enabled by this command, the same alpha value will produce different sample masks for different pixels. If dithering is disabled, the same alpha value will produce the same sample mask in all pixels. Dithering will allow for more effective levels of transparency, but may result in more visible noise. Dithering has no effect if alpha-to-coverage is disabled.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">dither</td><td>Enable (TRUE) or disable (FALSE) the alpha-to-coverage dithering operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab7f67824bc1e151868f8d1cd2a1ce1c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnMultisampleStateGetMultisampleEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the multisample rasterization enable. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8aa20b9525683eeca5f07d1c40db4078"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnMultisampleStateGetSamples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of samples in a <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga709089315b48eb90eb3cf781957c9dc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnMultisampleStateGetAlphaToCoverageEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the alpha-to-coverage enable. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga172c7ccc42da8dbc211c9d8f8dc383dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnMultisampleStateGetAlphaToCoverageDither </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the alpha-to-coverage dithering enable. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae00fe1081ea4ab7c88803a66283990d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetRasterSamples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rasterSamples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the raster sample count for target-independent rasterization. </p>
<p>When using a non-zero value (supported: 2, 4, 8, and 16), this command enables target-independent rasterization, where the rasterizer evaluates sample coverage using the specified number of sample locations. This raster sample count may differ from the number of stored samples in the framebuffer. When using a zero value (default), the command disables target-independent rasterization and has the rasterizer evaluate sample coverage based on the stored samples in the framebuffer.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">rasterSamples</td><td>Raster sample count. If depth or stencil tests are performed with target-independent rasterization, the raster sample count must be equal to the number of samples in the depth/stencil render target. If non-zero, the raster sample count must be greater than or equal to the color sample count set by nvnMultisampleStateSetSamples. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga313e2131ca507a3133a1aa1d85e68cdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnMultisampleStateGetRasterSamples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the raster sample count for target-independent rasterization. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab15dd40cc4d6671ec613598a489f99ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetCoverageModulationMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga26f01c2daca8e41b2961de31a9079501">NVNcoverageModulationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the coverage modulation mode for target-independent rasterization. </p>
<p>When target-independent rasterization is enabled, pixel or sample color values in the framebuffer are updated whenever any of the associated raster samples are covered by a primitive. Applications can enable coverage modulation to account for partial coverage, where color (RGB) or alpha components are multiplied by a factor that reflects the fraction of raster samples that are covered. This modulation mode allows applications to specify that some, all, or none of the color components are multiplied by this factor.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">mode</td><td>Specifies the set of color channels to multiply by the coverage modulation factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabfac452c21527aeb1043008e5924564d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga26f01c2daca8e41b2961de31a9079501">NVNcoverageModulationMode</a> nvnMultisampleStateGetCoverageModulationMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the coverage modulation mode for target-independent rasterization. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabbf2410e5a0f923e692f3223cf49935c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetCoverageToColorEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the fragment coverage-to-color feature. </p>
<p>When enabled using nvnMultisampleStateSetCoverageToColorEnable, the fragment coverage-to-color feature writes a coverage mask for each fragment into the red component of the fragment color for one color output. The color output number recieving the coverage mask is specified by nvnMultisampleStateSetCoverageToColorOutput.</p>
<p>The coverage mask used for coverage-to-color reflects not only raster sample coverage, but also the results of per-fragment operations including other sample masks, alpha to coverage, alpha test, and the depth bounds, depth, and stencil tests.</p>
<dl class="section warning"><dt>警告</dt><dd>When coverage-to-color is enabled, the color target receiving the coverage mask must have a one-component format with signed or unsigned integer components (e.g., R8I, R32UI). Coverage-to-color has no effect if other color target formats are used.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to set.</td></tr>
    <tr><td class="paramname">enable</td><td>Fragment coverage-to-color enable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0713e246ce816f781da8e21ab070194a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnMultisampleStateGetCoverageToColorEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the enable for the fragment coverage-to-color feature. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga09d3ac530fffb5efaac50748ff4873f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetCoverageToColorOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the color output updated by the fragment coverage-to-color feature. </p>
<p>When enabled using nvnMultisampleStateSetCoverageToColorEnable, the fragment coverage-to-color feature writes a coverage mask for each fragment into the red component of the fragment color for one color output. The color output number recieving the coverage mask is specified by nvnMultisampleStateSetCoverageToColorOutput.</p>
<p>The coverage mask used for coverage-to-color reflects not only raster sample coverage, but also the results of per-fragment operations including other sample masks, alpha to coverage, alpha test, and the depth bounds, depth, and stencil tests.</p>
<dl class="section warning"><dt>警告</dt><dd>When coverage-to-color is enabled, the color target receiving the coverage mask must have a one-component format with signed or unsigned integer components (e.g., R8I, R32UI). Coverage-to-color has no effect if other color target formats are used.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">color</td><td>Color output number updated by the fragment coverage-to-color feature. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9e1d59807858c15163a9b4be1959b8e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnMultisampleStateGetCoverageToColorOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the color output updated by the fragment coverage-to-color feature. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga882228d131ff8d2ca6f0ba72d4a9182c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetSampleLocationsEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable programmable sample locations. </p>
<p>By default, rasterization in NVN uses a set of fixed sample locations based on the total number of raster samples. When programmable sample locations are enabled, rasterization instead uses a set of locations from the <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object programmed using nvnMultisampleStateSetSampleLocations.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable/disable programmble sample locations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf91e203d2f30a7a960993c14826b3a2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnMultisampleStateGetSampleLocationsEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the programmable sample locations enable. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga41a34fd884435c3a3de1089633068740"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateGetSampleLocationsGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the size of a pixel grid used for programmable sample locations. </p>
<p>When programmable sample locations are enabled, the rasterizer can use the same set of locations for each pixel, or use a different set of locations for each pixel in a small fixed-size grid, based on the enable set by nvnMultisampleStateSetSampleLocationsGridEnable. This function returns the width and height of the fixed-size grid used when enabled. The grid will have a total of 16/N pixels, where N is the total number of raster samples in the multisample state object. Please refer to the documentation of nvnMultisampleStateSetSampleLocations for more details.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">width</td><td>Returns the width (in pixels) of the sample location pixel grid.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">height</td><td>Returns the height (in pixels) of the sample location pixel grid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga705b9946424e5f6e727adae9eae7ace5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetSampleLocationsGridEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the programmable sample locations grid enable. </p>
<p>When programmable sample locations are enabled, the rasterizer can use the same set of locations for each pixel (disabled), or use a different set of locations for each pixel in a small fixed-size grid.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable or disable the programmble sample locations grid. If set to NVN_TRUE, different sample locations are used for each pixel in a fixed-size grid. If set to NVN_FALSE, the same locations are used for all pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga87e1af29088e21596f0e4d5744777498"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnMultisampleStateGetSampleLocationsGridEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the programmable sample locations grid enable. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab91f126da720035da293ef8bd7f527b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnMultisampleStateSetSampleLocations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies programmable sample locations for rasterization. </p>
<p>When programmable sample locations are enabled using nvnMultisampleStateSetSampleLocationsEnable, rasterization uses a set of sample locations programmed in the multisample state object using this command. Each sample location is a pair of (x,y) values identifying the location of a sample within its pixel.</p>
<p>The rasterizer may use the same sample locations for each pixel or varying sample locations within a repeating pixel grid, depending on state set using nvnMultisampleStateSetSampleLocationsGridEnable. If the pixel grid is disabled, a sample with index <em>s</em> in the pixel with coordinates (x,y) always uses entry <em>s</em> in the array of sample locations. If the pixel grid is enabled and the grid has a width and height of <em>gw</em> and <em>gh</em>, respectively, sample <em>s</em> in pixel (x,y) uses entry <em>s</em> + (<em>y</em> % <em>gh</em>) * <em>gw</em> + (<em>x</em> % <em>gw</em>).</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to update.</td></tr>
    <tr><td class="paramname">start</td><td>Index of the first sample location to update.</td></tr>
    <tr><td class="paramname">count</td><td>Number of sample locations to update.</td></tr>
    <tr><td class="paramname">values</td><td>Array of sample location value pairs. <em>values</em> is an array of 2 * <em>count</em> floating-point values, where each sample (x,y) location is specified using two values in the range [0.0, 1.0). The pair (0.5, 0.5) identifies the center of a pixel. Sample locations are converted to fixed-point values when the multisample state object is updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga47c2200da77cbb2c0d7279ecb9311525"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnPolygonStateSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons. ">NVNpolygonState</a> object. </p>
<dl class="section note"><dt>覚え書き</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">PolygonState::SetCullFace(<a class="code" href="group__nvn__c__enum.html#gga258b4f915ce6b9b20d57763d617278dfa31eec9eec788ac370a4a89491376e43e">NVN_FACE_NONE</a>);</div>
<div class="line">PolygonState::SetFrontFace(<a class="code" href="group__nvn__c__enum.html#gga77dcac47ffba6330842afbc0c57db3c3a171a73f1463236c1cc74be65247e2eb1">NVN_FRONT_FACE_CCW</a>);</div>
<div class="line">PolygonState::SetPolygonMode(<a class="code" href="group__nvn__c__enum.html#ggae34b6e4f02d0dae7198337f940340ec6afa5ffe77479c77c1d43668353cf58e91">NVN_POLYGON_MODE_FILL</a>);</div>
<div class="line">PolygonState::SetPolygonOffsetEnables(0);</div>
</div><!-- fragment --><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons. ">NVNpolygonState</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a32">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_8cpp-example.html#a5">GraphicsObject.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a66">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a66">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a60">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a57">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a93">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga3520bbbee9b5089521912dacdbdbb4b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnPolygonStateSetCullFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a>&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify controls for culling of front- and back-facing polygons. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons. ">NVNpolygonState</a> object to update.</td></tr>
    <tr><td class="paramname">face</td><td>Specifies the set of faces (if any) that should be cullled. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a33">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_cube_8cpp-example.html#a6">GraphicsObjectCube.cpp</a>, <a class="el" href="_graphics_object_specialized_cube_8cpp-example.html#a7">GraphicsObjectSpecializedCube.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a69">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a69">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a95">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a60">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a76">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga0de647048323e5c7b6fe8d93a0875cca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnPolygonStateSetFrontFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga77dcac47ffba6330842afbc0c57db3c3">NVNfrontFace</a>&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether clockwise or counter-clockwise polygons are considered front-facing. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons. ">NVNpolygonState</a> object to update.</td></tr>
    <tr><td class="paramname">face</td><td>Treat clockwise (CW) or counter-clockwise (CCW) polygons as front-facing. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a35">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_cube_8cpp-example.html#a11">GraphicsObjectCube.cpp</a>, <a class="el" href="_graphics_object_specialized_cube_8cpp-example.html#a5">GraphicsObjectSpecializedCube.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a67">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a67">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a93">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a58">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a74">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gae5d89993b3e9b7adcee98d5846052cb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnPolygonStateSetPolygonMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae34b6e4f02d0dae7198337f940340ec6">NVNpolygonMode</a>&#160;</td>
          <td class="paramname"><em>polygonMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether polygons are rendered as points, lines, or triangles. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons. ">NVNpolygonState</a> object to update.</td></tr>
    <tr><td class="paramname">polygonMode</td><td>Render polygons as points (POINT), lines (LINE), or triangles (FILL). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a37">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_cube_8cpp-example.html#a8">GraphicsObjectCube.cpp</a>, <a class="el" href="_graphics_object_specialized_cube_8cpp-example.html#a9">GraphicsObjectSpecializedCube.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a71">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a71">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a97">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a62">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a78">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga5351a8bc94ba8da9a23a17d5e01ff2d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnPolygonStateSetPolygonOffsetEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether polygon offset is applied for point-mode, line-mode, and filled polygons. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons. ">NVNpolygonState</a> object to update.</td></tr>
    <tr><td class="paramname">enables</td><td>Bitfield indicating whether polygon offset is applied for point-mode, line-mode, and filled polygons. See <a class="el" href="group__nvn__c__enum.html#ga04590c619164a552f5c23b8f096b3d73" title="Specifies whether the depth values of rasterized polygon primitives should be offset. ">NVNpolygonOffsetEnable</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8bbd7972e1b1ed778eddbf09ff967b32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a> nvnPolygonStateGetCullFace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the control for culling of front- and back-facing polygons. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons. ">NVNpolygonState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga462e3ea6a04c604d1fd83a7ef7c4508c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga77dcac47ffba6330842afbc0c57db3c3">NVNfrontFace</a> nvnPolygonStateGetFrontFace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether clockwise or counter-clockwise polygons are considered front-facing. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons. ">NVNpolygonState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac6b72dd688c4c3e432aacb9af6305520"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#gae34b6e4f02d0dae7198337f940340ec6">NVNpolygonMode</a> nvnPolygonStateGetPolygonMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether polygons are rendered as points, lines, or triangles. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons. ">NVNpolygonState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga27a048c2d766c7f3f46f828eb9d963de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga04590c619164a552f5c23b8f096b3d73">NVNpolygonOffsetEnable</a> nvnPolygonStateGetPolygonOffsetEnables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether polygon offset is applied for point-mode, line-mode, and filled polygons. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons. ">NVNpolygonState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2f659011ea2a0c713e64022959b865e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDepthStencilStateSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object. </p>
<dl class="section note"><dt>覚え書き</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">DepthStencilState::SetDepthFunc(<a class="code" href="group__nvn__c__enum.html#gga14f57c18bdbcc7517a24b723743e61e6a3381414ebe69b3db3da052248ba47bda">NVN_DEPTH_FUNC_LESS</a>);</div>
<div class="line">DepthStencilState::SetDepthTestEnable(<a class="code" href="group__nvn__c__defines.html#gad12fb86930f09043843be6b39c78bb1b">NVN_FALSE</a>);</div>
<div class="line">DepthStencilState::SetDepthWriteEnable(<a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>);</div>
<div class="line">DepthStencilState::SetStencilFunc(<a class="code" href="group__nvn__c__enum.html#gga258b4f915ce6b9b20d57763d617278dfac96908105a8675de01cc0eecf1114b85">NVN_FACE_FRONT_AND_BACK</a>,</div>
<div class="line">                                  <a class="code" href="group__nvn__c__enum.html#ggab50861ff9b46503782bb66c4edb734aea0d379e3cc5b5a944bb32e60b1a9693f1">NVN_STENCIL_FUNC_ALWAYS</a>);</div>
<div class="line">DepthStencilState::SetStencilOp(<a class="code" href="group__nvn__c__enum.html#gga258b4f915ce6b9b20d57763d617278dfac96908105a8675de01cc0eecf1114b85">NVN_FACE_FRONT_AND_BACK</a>,</div>
<div class="line">  <a class="code" href="group__nvn__c__enum.html#ggad3757d551ee48be48890aa243050e6caabd2cfdc64ee1f1e22f3f5c6c27f7f83f">NVN_STENCIL_OP_KEEP</a>, <a class="code" href="group__nvn__c__enum.html#ggad3757d551ee48be48890aa243050e6caabd2cfdc64ee1f1e22f3f5c6c27f7f83f">NVN_STENCIL_OP_KEEP</a>, <a class="code" href="group__nvn__c__enum.html#ggad3757d551ee48be48890aa243050e6caabd2cfdc64ee1f1e22f3f5c6c27f7f83f">NVN_STENCIL_OP_KEEP</a>);</div>
<div class="line">DepthStencilState::SetStencilTestEnable(<a class="code" href="group__nvn__c__defines.html#gad12fb86930f09043843be6b39c78bb1b">NVN_FALSE</a>);</div>
</div><!-- fragment --><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a26">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_8cpp-example.html#a3">GraphicsObject.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a60">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a60">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a58">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a51">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a92">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga8a0a2454a1b00a8889d1d34fd8a7da69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDepthStencilStateSetDepthTestEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether depth testing is enabled or disabled. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) depth testing. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a27">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_cube_8cpp-example.html#a1">GraphicsObjectCube.cpp</a>, <a class="el" href="_graphics_object_specialized_cube_8cpp-example.html#a0">GraphicsObjectSpecializedCube.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a61">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a61">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a89">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a52">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a70">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga363282d1d17b72e5553651d7b2c367cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDepthStencilStateSetDepthWriteEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether the depth buffer should be updated by the depth test. </p>
<p>If depth testing is disabled, the depth buffer is not updated, regardless of the depth write enable.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) writes to the depth buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a29">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_cube_8cpp-example.html#a3">GraphicsObjectCube.cpp</a>, <a class="el" href="_graphics_object_specialized_cube_8cpp-example.html#a2">GraphicsObjectSpecializedCube.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a62">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a62">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a90">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a53">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a71">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gafdbe8e6bc4bfb62a304d831a919d9890"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDepthStencilStateSetDepthFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga14f57c18bdbcc7517a24b723743e61e6">NVNdepthFunc</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the comparison function used when depth testing is enabled. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object to update.</td></tr>
    <tr><td class="paramname">func</td><td>Comparison function used when depth testing is enabled. If depth testing is disabled, the depth function has no effect. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_graphics_object_cube_8cpp-example.html#a4">GraphicsObjectCube.cpp</a>, <a class="el" href="_graphics_object_specialized_cube_8cpp-example.html#a3">GraphicsObjectSpecializedCube.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a63">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a63">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a91">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a54">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a72">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga0127f672494691efb62b594091eeddee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDepthStencilStateSetStencilTestEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether the stencil testing is enabled or disabled. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object to update.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) stencil testing. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a30">DebugTextRenderer.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaa6c290c610aa9daf1a2ece3e18065e32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDepthStencilStateSetStencilFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a>&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab50861ff9b46503782bb66c4edb734ae">NVNstencilFunc</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the comparison function used when stencil testing is enabled. </p>
<p>There are separate stencil functions for front- and back-facing primitives. This function can update the value of either or both functions in the <a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object. If stencil testing is disabled, the stencil function has no effect.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object to update.</td></tr>
    <tr><td class="paramname">faces</td><td>Specifies the face(s) (front and/or back) using the new stencil function.</td></tr>
    <tr><td class="paramname">func</td><td>Comparison function used when stencil testing is enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga36095f921d11664dbe4b3139b8bf7793"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDepthStencilStateSetStencilOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a>&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a>&#160;</td>
          <td class="paramname"><em>fail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a>&#160;</td>
          <td class="paramname"><em>depthFail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a>&#160;</td>
          <td class="paramname"><em>depthPass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies operations performed on stored stencil values by the stencil test. </p>
<p>There are separate sets of stencil operations for front- and back-facing primitives. This function can update the value of either or both sets of operations in the <a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object. If stencil testing is disabled, the stencil operations have no effect.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object to update.</td></tr>
    <tr><td class="paramname">faces</td><td>Specifies the face(s) (front and/or back) using the new stencil operations.</td></tr>
    <tr><td class="paramname">fail</td><td>Operation performed on the stencil value when the stencil test fails.</td></tr>
    <tr><td class="paramname">depthFail</td><td>Operation performed on the stencil value when the stencil test passes and the depth test fails.</td></tr>
    <tr><td class="paramname">depthPass</td><td>Operation performed on the stencil value when the stencil and depth tests pass. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0e0c9f60146ff3dce4ae5377e5dea5df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnDepthStencilStateGetDepthTestEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether depth testing is enabled or disabled. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2dbfe16804066f2acf2127e1b36fadb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnDepthStencilStateGetDepthWriteEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether the depth buffer should be updated by the depth test. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga988a86f1527afdfb7cd08e79b5ac600a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga14f57c18bdbcc7517a24b723743e61e6">NVNdepthFunc</a> nvnDepthStencilStateGetDepthFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the comparison function used when depth testing is enabled. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga22358a58ee07fdefd11993f6929ac9d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnDepthStencilStateGetStencilTestEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether the stencil testing is enabled or disabled. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga11ef77b998e4d4ca6bff2e8721a18ae7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#gab50861ff9b46503782bb66c4edb734ae">NVNstencilFunc</a> nvnDepthStencilStateGetStencilFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a>&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the comparison function used when stencil testing is enabled. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object to query.</td></tr>
    <tr><td class="paramname">face</td><td>Specifies the face (front or back) to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf1f44de3d7815edec84bc5773e4bf6b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnDepthStencilStateGetStencilOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a> *&#160;</td>
          <td class="paramname"><em>fail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a> *&#160;</td>
          <td class="paramname"><em>depthFail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gad3757d551ee48be48890aa243050e6ca">NVNstencilOp</a> *&#160;</td>
          <td class="paramname"><em>depthPass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query operations performed on stored stencil values by the stencil test. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object to query.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">face</td><td>Specifies the face (front or back) to query the stencil operations.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fail</td><td>Operation performed on the stencil value when the stencil test fails.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">depthFail</td><td>Operation performed on the stencil value when the stencil test passes and the depth test fails.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">depthPass</td><td>Operation performed on the stencil value when the stencil and depth tests pass. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8e71254f0f8cd7eb8fa2aa8e8909779f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnVertexAttribStateSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *&#160;</td>
          <td class="paramname"><em>attrib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nvertex_attrib_state.html" title="API state object controlling vertex attrib state. ">NVNvertexAttribState</a> object. </p>
<dl class="section note"><dt>覚え書き</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">VertexAttribState::SetFormat(<a class="code" href="group__nvn__c__enum.html#gga99463f5b9af6151e604b01dfdd5fecaba7c782a722996d27efbfc6f9128f32d73">NVN_FORMAT_NONE</a>, 0);</div>
<div class="line">VertexAttribState::SetStreamIndex(0);</div>
</div><!-- fragment --><p>except that the object will be disabled until the first valid call to <a class="el" href="group__nvn__c__functions.html#ga447b6bbe81e21c3bff3dbf10bc15d80e" title="Specifies the format (in memory) for values for a single vertex attribute. ">nvnVertexAttribStateSetFormat()</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrib</td><td><a class="el" href="struct_n_v_nvertex_attrib_state.html" title="API state object controlling vertex attrib state. ">NVNvertexAttribState</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_data_holder_8cpp-example.html#a6">AssetFileDataHolder.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a46">DebugTextRenderer.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga447b6bbe81e21c3bff3dbf10bc15d80e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnVertexAttribStateSetFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *&#160;</td>
          <td class="paramname"><em>attrib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>relativeOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the format (in memory) for values for a single vertex attribute. </p>
<p>Specifying format is mandatory, and doing so also enables the vertex attribute for fetching.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrib</td><td><a class="el" href="struct_n_v_nvertex_attrib_state.html" title="API state object controlling vertex attrib state. ">NVNvertexAttribState</a> object to update.</td></tr>
    <tr><td class="paramname">format</td><td><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded. ">NVNformat</a> of the specified vertex attribute.</td></tr>
    <tr><td class="paramname">relativeOffset</td><td>Offset (in bytes) of the values for the vertex attribute relative to the base address from the vertex buffer binding. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_data_holder_8cpp-example.html#a8">AssetFileDataHolder.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a47">DebugTextRenderer.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gab96f74226c1d22d01c186d908eff14ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnVertexAttribStateSetStreamIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *&#160;</td>
          <td class="paramname"><em>attrib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>streamIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the vertex attribute stream binding index. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrib</td><td><a class="el" href="struct_n_v_nvertex_attrib_state.html" title="API state object controlling vertex attrib state. ">NVNvertexAttribState</a> object to update.</td></tr>
    <tr><td class="paramname">streamIndex</td><td>Index of the stream to use for the attribute. Must be less than 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a571496d1d44d5215d5023b1c8603c84f" title="Number of vertex buffer binding points. ">NVN_DEVICE_INFO_VERTEX_BUFFER_BINDINGS</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_data_holder_8cpp-example.html#a7">AssetFileDataHolder.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a49">DebugTextRenderer.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga9ff90c3673688217dba1c0cb18084031"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnVertexAttribStateGetFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *&#160;</td>
          <td class="paramname"><em>attrib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab">NVNformat</a> *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>relativeOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the format (in memory) for values for a single vertex attribute. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">attrib</td><td><a class="el" href="struct_n_v_nvertex_attrib_state.html" title="API state object controlling vertex attrib state. ">NVNvertexAttribState</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">format</td><td><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded. ">NVNformat</a> of the specified vertex attribute.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">relativeOffset</td><td>Offset (in bytes) of the values for the vertex attribute relative to the base address from the vertex buffer binding. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6633a58ae913e3de782d0d2af524e2f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnVertexAttribStateGetStreamIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *&#160;</td>
          <td class="paramname"><em>attrib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the vertex attribute stream binding index. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrib</td><td><a class="el" href="struct_n_v_nvertex_attrib_state.html" title="API state object controlling vertex attrib state. ">NVNvertexAttribState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9dca0133939bd660957dd5de2a56d240"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnVertexStreamStateSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state. ">NVNvertexStreamState</a> object. </p>
<dl class="section note"><dt>覚え書き</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line">VertexStreamState::SetDivisor(0);</div>
<div class="line">VertexStreamState::SetStride(0);</div>
</div><!-- fragment --><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state. ">NVNvertexStreamState</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_data_holder_8cpp-example.html#a10">AssetFileDataHolder.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga9a72c7499ec4a36d8cc38d0b5d575c90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnVertexStreamStateSetStride </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the stride (in bytes) for vertex attribute records fetched from a single vertex binding point. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state. ">NVNvertexStreamState</a> object to update.</td></tr>
    <tr><td class="paramname">stride</td><td>Stride (in bytes) between vertex attribute records for the specified binding point. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_asset_file_data_holder_8cpp-example.html#a11">AssetFileDataHolder.cpp</a>, <a class="el" href="_debug_text_renderer_8cpp-example.html#a51">DebugTextRenderer.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gac6f8d41933935967cde1cadcc328c8da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnVertexStreamStateSetDivisor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the frequency divisor for vertices in vertex binding N. </p>
<p>If zero, specifies that the vertex binding holds a separate set of values for each vertex in a rendered primitive. If set to a non-zero value X, a separate set of values will be used for each group of X instances, with the same set of values used for each vertex in a single instance.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state. ">NVNvertexStreamState</a> object to update.</td></tr>
    <tr><td class="paramname">divisor</td><td>Frequency divisor for vertex attributes using the specified binding point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaebbf25d7f5c74f49b0b3635d3f8d78bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnVertexStreamStateGetStride </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the stride (in bytes) for a <a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state. ">NVNvertexStreamState</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state. ">NVNvertexStreamState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3a99fed1a389e1a231314215842674e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvnVertexStreamStateGetDivisor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the frequency divisor in a <a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state. ">NVNvertexStreamState</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state. ">NVNvertexStreamState</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab146b70a699dfee69d0724e430d5694e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnCommandBufferInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object for the specified device. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Commandbuffer object to initialize.</td></tr>
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> owning the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a5">DebugTextRenderer.cpp</a>, <a class="el" href="_managed_command_buffer_8cpp-example.html#a6">ManagedCommandBuffer.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a38">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a51">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a51">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a47">NvnTutorial05.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a8">StatTracker.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga014c41d2335d4d9ff6c776c99bc70bfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a100">DebugTextRenderer.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a64">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a103">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a112">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a153">NvnTutorial05.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a32">StatTracker.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga3ecae66d8ac5f623d7a1abae492fc243"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga69eb92c349d648988d02b9b7a7a94a75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetMemoryCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__funcptrs.html#gab918942b035dac79abd29dfb506823d9">PFNNVNCOMMANDBUFFERMEMORYCALLBACKPROC</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a callback function for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object that will be called if it runs out of memory. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to update.</td></tr>
    <tr><td class="paramname">callback</td><td>Callback function to use on out-of-memory events. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_managed_command_buffer_8cpp-example.html#a11">ManagedCommandBuffer.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga8656f3468c263124963216458569ec07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetMemoryCallbackData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a generic pointer that will be passed to a callback function if the command buffer runs out of memory. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to update.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">callbackData</td><td>Callback data to be passed in an out-of-memory event callback. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_managed_command_buffer_8cpp-example.html#a12">ManagedCommandBuffer.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga2c0d758cfa73c25f2a34486353f46d92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferAddCommandMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add command data memory for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object. </p>
<p>This can be called at any time, even outside an out-of-memory callback or while recording or not recording. Any leftover space in the previous command memory will remain unused. Only the last provided block is consumed.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to update.</td></tr>
    <tr><td class="paramname">pool</td><td>Memory pool used to store commands.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) relative to pool of the memory used to store commands. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ada72f2b5ef4df11606b61aaa86f6f22c" title="Minimum alignment for command data in a command builder. ">NVN_DEVICE_INFO_COMMAND_BUFFER_COMMAND_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of memory used to store commands. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ada72f2b5ef4df11606b61aaa86f6f22c" title="Minimum alignment for command data in a command builder. ">NVN_DEVICE_INFO_COMMAND_BUFFER_COMMAND_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a10">DebugTextRenderer.cpp</a>, <a class="el" href="_managed_command_buffer_8cpp-example.html#a9">ManagedCommandBuffer.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a43">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a54">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a54">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a52">NvnTutorial05.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a9">StatTracker.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga8de6ce290ee0180d9bcd700c1d08d0bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferAddControlMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add control memory for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object. </p>
<p>This can be called at any time, even outside an out-of-memory callback or while recording or not recording. Any leftover space in the previous control memory will remain unused. Only the last provided block is consumed.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to update.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">memory</td><td>Storage used for the command buffer control information. Must be a multiple of 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a743ea42e337a76b9d8ed34181a0d802e" title="Minimum alignment for control data in a command builder. ">NVN_DEVICE_INFO_COMMAND_BUFFER_CONTROL_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>Size (in bytes) of memory used to store control information. Must be a multiple of 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a743ea42e337a76b9d8ed34181a0d802e" title="Minimum alignment for control data in a command builder. ">NVN_DEVICE_INFO_COMMAND_BUFFER_CONTROL_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a11">DebugTextRenderer.cpp</a>, <a class="el" href="_managed_command_buffer_8cpp-example.html#a10">ManagedCommandBuffer.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a44">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a55">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a55">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a53">NvnTutorial05.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a10">StatTracker.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga7c33bb9cd401c44be336bdcb915d9e70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnCommandBufferGetCommandMemorySize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total amount of command memory programmed in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7976af012dd82485da7127beca93e2ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnCommandBufferGetCommandMemoryUsed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the amount of command memory used in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a83">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a147">NvnTutorial03.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga211e559b84b562b34d26b809a9316ff2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnCommandBufferGetCommandMemoryFree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the amount of free command memory in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga93c82ac4fededbf48d55179b57248de7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnCommandBufferGetControlMemorySize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total amount of control memory programmed in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaef36338c2d889d846bf1fbbe3efd25df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnCommandBufferGetControlMemoryUsed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the amount of control memory used in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a84">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a148">NvnTutorial03.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga3fe9b2e839389d1a7396b54edb86ca77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvnCommandBufferGetControlMemoryFree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the amount of free control memory in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeb763d2bdad2c058c75802190fef4748"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBeginRecording </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin recording a new set of commands in this <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object used for command buffer construction. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a60">DebugTextRenderer.cpp</a>, <a class="el" href="_managed_command_buffer_8cpp-example.html#a13">ManagedCommandBuffer.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a78">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a119">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a128">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a114">NvnTutorial05.cpp</a>, <a class="el" href="_render_thread_pool_8cpp-example.html#a20">RenderThreadPool.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a11">StatTracker.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga7d97d4cbf72259b6e867f3080f223b95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> nvnCommandBufferEndRecording </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete recording a new set of commands in this <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object used for command buffer construction. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a71">DebugTextRenderer.cpp</a>, <a class="el" href="_managed_command_buffer_8cpp-example.html#a14">ManagedCommandBuffer.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a82">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a121">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a130">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a136">NvnTutorial05.cpp</a>, <a class="el" href="_render_thread_pool_8cpp-example.html#a21">RenderThreadPool.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a14">StatTracker.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaa47b42c6deb95e59c6eae4c49645d4bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferCallCommands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numCommands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> *&#160;</td>
          <td class="paramname"><em>handles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert calls to previously recorded command sets into the command set under construction. </p>
<p>CallCommands will copy control data from the previously recorded command sets into the new command set. Command data from these command sets are called directly. The command buffer under construction must hold sufficient memory to hold the control data. The command data from called command sets must not be freed until all command sets referencing the data are no longer in use. The command data in the called command sets should be recorded in a memory pool using <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a93f5342f52f301cfdca9901586b9b8e1" title="Indicates that the memory pool will be accessed by the CPU without caching. ">NVN_MEMORY_POOL_FLAGS_CPU_UNCACHED_BIT</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer recording the command set that should call the previously recorded command sets.</td></tr>
    <tr><td class="paramname">numCommands</td><td>Number of command sets to call.</td></tr>
    <tr><td class="paramname">handles</td><td>Array of numCommands command set handles to call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafe98746c7c6c6d0a0fef2e1b8d9381d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferCopyCommands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numCommands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__c__handle.html#gab7f10945ffe1f6161c87238c75ae411d">NVNcommandHandle</a> *&#160;</td>
          <td class="paramname"><em>handles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert copies of previously recorded command sets into the command set under construction. </p>
<p>CopyCommands will copy command and control data from the previously recorded command sets into the new command set. The command buffer must hold sufficient memory to hold the copied data. The command data in the called command sets should be recorded in a memory pool using <a class="el" href="group__nvn__c__enum.html#ggaa7df4970255609d7a317631bcb37d654a2fa7e2b859d94d1dc2c7077822b46f83" title="Indicates that the memory pool will be accessed by the CPU with caching. ">NVN_MEMORY_POOL_FLAGS_CPU_CACHED_BIT</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer recording the command set that should copy the previously recorded command sets.</td></tr>
    <tr><td class="paramname">numCommands</td><td>Number of command sets to copy.</td></tr>
    <tr><td class="paramname">handles</td><td>Array of numCommands command set handles to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7c3895b442dc5055a3ba72b149389a90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindBlendState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nblend_state.html">NVNblendState</a> *&#160;</td>
          <td class="paramname"><em>blend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new <a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object to bind for subsequent commands. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the bind operation.</td></tr>
    <tr><td class="paramname">blend</td><td><a class="el" href="struct_n_v_nblend_state.html" title="API state object controlling blending for one color target. ">NVNblendState</a> object to be bound. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a106">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_8cpp-example.html#a7">GraphicsObject.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a131">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a140">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a120">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a133">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a105">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gac468cb3593c0a9653515830e19800536"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindChannelMaskState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nchannel_mask_state.html">NVNchannelMaskState</a> *&#160;</td>
          <td class="paramname"><em>channelMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new <a class="el" href="struct_n_v_nchannel_mask_state.html" title="API state object holding per-channel write masks for all color buffers. ">NVNchannelMaskState</a> object to bind for subsequent commands. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the bind operation.</td></tr>
    <tr><td class="paramname">channelMask</td><td><a class="el" href="struct_n_v_nchannel_mask_state.html" title="API state object holding per-channel write masks for all color buffers. ">NVNchannelMaskState</a> object to be bound. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a107">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_8cpp-example.html#a8">GraphicsObject.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a132">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a141">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a121">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a134">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a106">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga6b957807821fbeac2c91ddfc34e9e941"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindColorState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncolor_state.html">NVNcolorState</a> *&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new <a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values. ">NVNcolorState</a> object to bind for subsequent commands. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">color</td><td><a class="el" href="struct_n_v_ncolor_state.html" title="API state object controlling processing of color values. ">NVNcolorState</a> object to be bound. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a108">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_8cpp-example.html#a9">GraphicsObject.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a133">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a142">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a122">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a135">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a107">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga463e501c3151aab9e9cb737e6cbaba5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindMultisampleState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmultisample_state.html">NVNmultisampleState</a> *&#160;</td>
          <td class="paramname"><em>multisample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new <a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to bind for subsequent commands. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">multisample</td><td><a class="el" href="struct_n_v_nmultisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">NVNmultisampleState</a> object to be bound. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a110">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_8cpp-example.html#a11">GraphicsObject.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a135">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a144">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a124">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a137">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a109">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gab5bee99214e32842654cbc22dd5f17bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindPolygonState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_npolygon_state.html">NVNpolygonState</a> *&#160;</td>
          <td class="paramname"><em>polygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new <a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons. ">NVNpolygonState</a> object to bind for subsequent commands. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">polygon</td><td><a class="el" href="struct_n_v_npolygon_state.html" title="API state object controlling rasterization of polygons. ">NVNpolygonState</a> object to be bound. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a111">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_8cpp-example.html#a12">GraphicsObject.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a136">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a145">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a125">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a138">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a110">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gae829ea8fc2209e876f64e9eaa7b21992"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindDepthStencilState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndepth_stencil_state.html">NVNdepthStencilState</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new <a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object to bind for subsequent commands. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">depthStencil</td><td><a class="el" href="struct_n_v_ndepth_stencil_state.html" title="API state object controlling depth and stencil testing operations. ">NVNdepthStencilState</a> object to be bound. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a109">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_8cpp-example.html#a10">GraphicsObject.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a134">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a143">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a123">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a136">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a108">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga4f0e28ea8b574b0b7d3ee6bd2e94dcac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindVertexAttribState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numAttribs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nvertex_attrib_state.html">NVNvertexAttribState</a> *&#160;</td>
          <td class="paramname"><em>attribs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a vertex attribute layout for subsequent commands. </p>
<p>All attributes beyond <em>numAttribs</em> are disabled, and fetching from them in the shader will return zero.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">numAttribs</td><td>Number of vertex attributes to bind. Must be less than or equal to 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a09de36a611cb7c5512ec623eb29684a7" title="Number of vertex attributes. ">NVN_DEVICE_INFO_VERTEX_ATTRIBUTES</a>).</td></tr>
    <tr><td class="paramname">attribs</td><td><a class="el" href="struct_n_v_nvertex_attrib_state.html" title="API state object controlling vertex attrib state. ">NVNvertexAttribState</a> objects to be bound. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a113">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_cube_8cpp-example.html#a24">GraphicsObjectCube.cpp</a>, <a class="el" href="_graphics_object_specialized_cube_8cpp-example.html#a24">GraphicsObjectSpecializedCube.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a143">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a149">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a129">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a145">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a158">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga8540a860937580eaa607cfa549667083"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindVertexStreamState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numStreams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nvertex_stream_state.html">NVNvertexStreamState</a> *&#160;</td>
          <td class="paramname"><em>streams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a vertex stream layout for subsequent commands. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">numStreams</td><td>Number of vertex streams to bind. Must be less than or equal to 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a571496d1d44d5215d5023b1c8603c84f" title="Number of vertex buffer binding points. ">NVN_DEVICE_INFO_VERTEX_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">streams</td><td><a class="el" href="struct_n_v_nvertex_stream_state.html" title="API state object controlling vertex stream state. ">NVNvertexStreamState</a> objects to be bound. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a114">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_cube_8cpp-example.html#a25">GraphicsObjectCube.cpp</a>, <a class="el" href="_graphics_object_specialized_cube_8cpp-example.html#a25">GraphicsObjectSpecializedCube.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a144">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a150">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a130">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a146">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a159">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga1f4b9d505338994b172c814ed32565c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindProgram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind or unbind shaders in a <a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives. ">NVNprogram</a> object for subsequent rendering commands. </p>
<p>This command binds all shaders present in <em>program</em>, and optionally disables additional shader stages based on the bitfield <em>stages</em>. If <em>program</em> is NULL, all shader stages specified in the bitfield <em>stages</em> are disabled. If <em>program</em> is non-NULL, all shaders present in <em>program</em> will be bound and any stages in <em>stages</em> that don't have shaders in <em>program</em> are disabled. For example, using <a class="el" href="group__nvn__c__enum.html#ggab5a02ce3ef6a80ad09e574e4e6791afaa9134531cb00eb495c3c2866a4bc216a5" title="Specifies all shader stages used to process graphics primitives. ">NVN_SHADER_STAGE_ALL_GRAPHICS_BITS</a> with a program with only a vertex and fragment shader will bind the vertex and fragment shaders in the program and disable the optional tessellation control, tessellation evaluation, and geometry shader stages.</p>
<dl class="section warning"><dt>警告</dt><dd>When <em>program</em> is non-NULL, all stages present in <em>program</em> must be enabled in the bitfield <em>stages</em>.</dd>
<dd>
In the C interface, it is possible to pass enums of the type NVNshaderStage (NVN_VERTEX_SHADER) in <em>stages</em>. This is not legal; <em>stages</em> requires a bitfield built from values of type NVNshaderStageBits (NVN_VERTEX_SHADER_BIT).</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">program</td><td><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives. ">NVNprogram</a> object to be bound.</td></tr>
    <tr><td class="paramname">stages</td><td>Bitfield identifying the set of shader stages to be updated. See <a class="el" href="group__nvn__c__enum.html#gab5a02ce3ef6a80ad09e574e4e6791afa" title="Specifies a set of programmable shader stages. ">NVNshaderStageBits</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a115">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_cube_8cpp-example.html#a26">GraphicsObjectCube.cpp</a>, <a class="el" href="_graphics_object_specialized_cube_8cpp-example.html#a26">GraphicsObjectSpecializedCube.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a145">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a154">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a134">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a147">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a102">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga328bba22810a4467865b444d17bec8e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to use for fetching vertex attributes. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">index</td><td>Vertex buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a571496d1d44d5215d5023b1c8603c84f" title="Number of vertex buffer binding points. ">NVN_DEVICE_INFO_VERTEX_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of vertex buffer memory to bind.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the range of the <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to bind. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a116">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_cube_8cpp-example.html#a21">GraphicsObjectCube.cpp</a>, <a class="el" href="_graphics_object_specialized_cube_8cpp-example.html#a20">GraphicsObjectSpecializedCube.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a139">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a148">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a128">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a141">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a155">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gae37fd304d3aa02d4773a74d2ce843b8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindVertexBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object ranges to use for fetching vertex attributes. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">first</td><td>First vertex buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a571496d1d44d5215d5023b1c8603c84f" title="Number of vertex buffer binding points. ">NVN_DEVICE_INFO_VERTEX_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous vertex buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a571496d1d44d5215d5023b1c8603c84f" title="Number of vertex buffer binding points. ">NVN_DEVICE_INFO_VERTEX_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of vertex buffer ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga50631d9a85aca68db2ede52b0d13521e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindUniformBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to use for fetching shader uniform values. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Uniform buffer binding point number to update. Must be greater than or equal to zero. Must be less than 14 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a56301a29a39a7a7e6cce351b1483bcc6" title="Number of uniform buffer bindings supported for each shader stage. ">NVN_DEVICE_INFO_UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer object memory to bind. Must be a multiple of 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ac5b90148e47e9a26cd38b367123ff374" title="Minimum alignment of uniform buffer bindings. ">NVN_DEVICE_INFO_UNIFORM_BUFFER_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the range of the <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to bind. Must be less than or equal to 65536 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3f3db4bfcb9457a4ca25046221f97409" title="Maximum size (in bytes) of a bound uniform buffer. ">NVN_DEVICE_INFO_MAX_UNIFORM_BUFFER_SIZE</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a117">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_cube_8cpp-example.html#a22">GraphicsObjectCube.cpp</a>, <a class="el" href="_graphics_object_specialized_cube_8cpp-example.html#a21">GraphicsObjectSpecializedCube.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a141">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a152">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a132">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a142">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a156">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga970a3c1387ee642760b7db22b848a46b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindUniformBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object ranges to use for fetching shader uniform values. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">first</td><td>First uniform buffer binding point number to update. Must be less than 14 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a56301a29a39a7a7e6cce351b1483bcc6" title="Number of uniform buffer bindings supported for each shader stage. ">NVN_DEVICE_INFO_UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous uniform buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 14 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a56301a29a39a7a7e6cce351b1483bcc6" title="Number of uniform buffer bindings supported for each shader stage. ">NVN_DEVICE_INFO_UNIFORM_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of buffer object ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadacbd5a1b83b888949d3374015019a39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindTransformFeedbackBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to use for capturing transformed vertex data. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">index</td><td>Transform feedback buffer binding point number to update. Must be less than 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50aed491c3dd4f146cdd6a3da9b18650836" title="Number of transform feedback buffer binding points. ">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of transform feedback buffer memory to bind. If specified as zero, no data should be captured for the updated binding point. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5b01bf12e41d77eb9bf6321e62b2ec6b" title="Minimum alignment of transform feedback buffer bindings. ">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_BUFFER_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the range of the <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to bind. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5b01bf12e41d77eb9bf6321e62b2ec6b" title="Minimum alignment of transform feedback buffer bindings. ">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_BUFFER_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8d491ae584fb9cb1bbb9c53976d20c26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindTransformFeedbackBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object ranges to use for capturing transformed vertex data. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">first</td><td>First transform feedback buffer binding point number to update. Must be less than 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50aed491c3dd4f146cdd6a3da9b18650836" title="Number of transform feedback buffer binding points. ">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous transform feedback buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50aed491c3dd4f146cdd6a3da9b18650836" title="Number of transform feedback buffer binding points. ">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of buffer object ranges to bind. If specified as zero, no data should be captured for the updated binding point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga18f58558537f39f4d427bd09c99de607"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindStorageBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a range of a <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to use for random-access reads and writes in shaders. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Shader storage buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ad3ff4123a22f799bd1e1712471e1e254" title="Number of shader storage buffer bindings supported for each shader stage. ">NVN_DEVICE_INFO_SHADER_STORAGE_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer object memory to bind.</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the range of the <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4717fd2c3476689066d49079e21ed781"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindStorageBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nbuffer_range.html">NVNbufferRange</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object ranges to use for random-access reads and writes in shaders. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">first</td><td>First shader storage buffer binding point number to update. Must be less than 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ad3ff4123a22f799bd1e1712471e1e254" title="Number of shader storage buffer bindings supported for each shader stage. ">NVN_DEVICE_INFO_SHADER_STORAGE_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous shader storage buffer binding points to update. Must be greater than or equal to zero. Must be less than or equal to 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ad3ff4123a22f799bd1e1712471e1e254" title="Number of shader storage buffer bindings supported for each shader stage. ">NVN_DEVICE_INFO_SHADER_STORAGE_BUFFER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">buffers</td><td>Array of buffer object ranges to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad89eb87dde4d1dba6444ea4f8f79e66b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a>&#160;</td>
          <td class="paramname"><em>texture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a NVNtexture/NVNsampler pair to use for texture mapping in shaders. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>NVNtexture/sampler binding point number to update. Must be less than 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5584c5a71f1b9cb98626dcc190156a91" title="Number of texture and sampler bindings supported for each shader stage. ">NVN_DEVICE_INFO_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">texture</td><td>Handle for the pair of <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> and <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial11_8cpp-example.html#a103">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga11e4a4a182413079203513c4cdaa3a83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindTextures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a> *&#160;</td>
          <td class="paramname"><em>textures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more NVNtexture/NVNsampler pairs to use for texture mapping in shaders. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First texture/sampler binding point number to update. Must be less than 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5584c5a71f1b9cb98626dcc190156a91" title="Number of texture and sampler bindings supported for each shader stage. ">NVN_DEVICE_INFO_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous texture/sampler binding points to update. Must be less than or equal to 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5584c5a71f1b9cb98626dcc190156a91" title="Number of texture and sampler bindings supported for each shader stage. ">NVN_DEVICE_INFO_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">textures</td><td>Array of handles for pairs of <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> and <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga26915307b6b313db6e592c0b2c9a9aa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#gacba3c44a43c05f11bc1b88c49b118606">NVNimageHandle</a>&#160;</td>
          <td class="paramname"><em>image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> to use for image loads and stores in shaders. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Image binding point number to update. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a361bd4e100b213cf339f09e9e233cc89" title="Number of image bindings supported for each shader stage. ">NVN_DEVICE_INFO_IMAGE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">image</td><td>Image handle for the <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0451e037db54d61e07c7af605ea6a1c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindImages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__c__handle.html#gacba3c44a43c05f11bc1b88c49b118606">NVNimageHandle</a> *&#160;</td>
          <td class="paramname"><em>images</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more Textures to use for image loads and stores in shaders. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First image binding point number to update. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a361bd4e100b213cf339f09e9e233cc89" title="Number of image bindings supported for each shader stage. ">NVN_DEVICE_INFO_IMAGE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous image binding points to update. Must be less than or equal to 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a361bd4e100b213cf339f09e9e233cc89" title="Number of image bindings supported for each shader stage. ">NVN_DEVICE_INFO_IMAGE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">images</td><td>Array of handles for <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0030496de8749dee42285b464f59f066"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetPatchSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the number of vertices in each patch when rendering patch primitives. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update operation.</td></tr>
    <tr><td class="paramname">size</td><td>Number of vertices present in each patch. Must be greater than zero. Must be less than or equal to 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a28bfcb18df0b156944353878b0c29321" title="Maximum number of vertices in each patch primitive. ">NVN_DEVICE_INFO_MAX_PATCH_SIZE</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga69c2614e24b04c147e05abf5e4bf6757"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetInnerTessellationLevels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>levels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify default inner tessellation levels when rendering patch primitives. </p>
<p>The default inner and outer tessellation levels are used when a tessellation evaluation shader is bound without a tessellation control shader. When a tessellation control shader is bound, default levels are ignored.</p>
<dl class="section note"><dt>覚え書き</dt><dd>Tessellation levels are clamped to the range [1.0, 64.0], and may be further clamped according to the tessellation spacing.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update operation.</td></tr>
    <tr><td class="paramname">levels</td><td>Two floating-point inner tessellation levels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga48be9a09e423781b7c466c3b1516daef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetOuterTessellationLevels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>levels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify default outer tessellation levels when rendering patch primitives. </p>
<p>The default inner and outer tessellation levels are used when a tessellation evaluation shader is bound without a tessellation control shader. When a tessellation control shader is bound, default levels are ignored.</p>
<dl class="section note"><dt>覚え書き</dt><dd>If any outer tessellation level is less than or equal to zero, a patch will be discarded, except for the fourth level when processing triangular patches.</dd>
<dd>
Tessellation levels greater than zero are clamped to the range [1.0, 64.0] and may be further clamped according to the tessellation spacing.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update operation.</td></tr>
    <tr><td class="paramname">levels</td><td>Four floating-point outer tessellation levels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9fe0e7f03b40e90dc870c706d6432d8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetPrimitiveRestart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable and disable primitive restart and specify a primitive restart index. </p>
<p>When enabled, a primitive is restarted (with the same primitive type) whenever an index value matching the restart index value is found.</p>
<dl class="section note"><dt>覚え書き</dt><dd>The vertex index value must match the restart index exactly. For example, primitives rendered using the index type <a class="el" href="group__nvn__c__enum.html#ggaaf90e0c2dbdc1e42db8192f0c0cb1522a9d49b4695541469d3ecbadeac29c98b8" title="Index values are specified as (8-bit) unsigned bytes. ">NVN_INDEX_TYPE_UNSIGNED_BYTE</a> wil not be restarted if the restart index is outside the range [0,255].</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update operation.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) primitive restart operations.</td></tr>
    <tr><td class="paramname">index</td><td>Index value used to indicate that a primitive should be restarted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8a5d40804e1ae718dfb71928afc6963e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBeginTransformFeedback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a transform feedback (stream output) operation. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used for the transform feedback commands.</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory holding 32 bytes of control information used by the transform feedback operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>警告</dt><dd>Must point to valid buffer storage. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a263810a39849679dad70888a328d84a3" title="Minimum alignment of transform feedback control data. ">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_CONTROL_ALIGNMENT</a>). </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1f8deb2cc863867218ce25789684809"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferEndTransformFeedback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete a transform feedback (stream output) operation. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used for the transform feedback commands.</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory holding 32 bytes of control information used by the transform feedback operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>警告</dt><dd>Must point to valid buffer storage. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a263810a39849679dad70888a328d84a3" title="Minimum alignment of transform feedback control data. ">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_CONTROL_ALIGNMENT</a>). </dd></dl>

</div>
</div>
<a class="anchor" id="ga36606b1759b3b79a8844de9ff4072b49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferPauseTransformFeedback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause a transform feedback (stream output) operation. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used for the transform feedback commands.</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory holding 32 bytes of control information used by the transform feedback operation. The provided address may be zero, in which case, no control information will be written to memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>If an address of zero is used, the current state of the transform feedback operation is not saved to memory. If any other transform feedback operation is performed before resuming, or if transform feedback is resumed using a non-zero address, this state is lost. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a263810a39849679dad70888a328d84a3" title="Minimum alignment of transform feedback control data. ">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_CONTROL_ALIGNMENT</a>). </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ad2246e89cf77b1a4cf41c38ff43527"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferResumeTransformFeedback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume a transform feedback (stream output) operation. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used for the transform feedback commands.</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory holding 32 bytes of control information used by the transform feedback operation. The provided address may be zero, in which case, no control information will be read from memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>If an address of zero is used, the state of the previously paused transform feedback operation is not restored from memory. If any other transform feedback operation is performed before resuming with a zero address, this state is lost. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a263810a39849679dad70888a328d84a3" title="Minimum alignment of transform feedback control data. ">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_CONTROL_ALIGNMENT</a>). </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c7d4cceeb20e66d10503c868a05a99d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDrawTransformFeedback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw primitives captured in a previous transform feedback (stream output) operation. </p>
<dl class="section warning"><dt>警告</dt><dd>Applications must call nvnCommandBufferBarrier with the <a class="el" href="group__nvn__c__enum.html#ggaab4eabfc248236cc6b42d9de9d735621ad90225b2b4d5e8e3b710573a967ac67e" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">NVN_BARRIER_ORDER_INDIRECT_DATA_BIT</a> bit set to ensure that the GPU doesn't fetch the indirect data before previous commands are finished writing the data. Waiting via nvnQueueFinish, nvnQueueWaitSync, or nvnCommandBufferWaitSync is not sufficient to ensure that GPU-produced indirect data are not fetched prematurely.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used for the transform feedback commands.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of primitive to render. When rendering primitives captured by transform feedback, this parameter should typically be POINTS, LINES, or TRIANGLES, since transform feedback captures only independent primitives (even if the original geometry were provided as strips).</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory holding 32 bytes of control information used by the transform feedback operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>警告</dt><dd>Must point to valid buffer storage. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a263810a39849679dad70888a328d84a3" title="Minimum alignment of transform feedback control data. ">NVN_DEVICE_INFO_TRANSFORM_FEEDBACK_CONTROL_ALIGNMENT</a>). </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a1a1002239aa2f5f61e79308c99a84a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDrawArrays </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render a primitive with consecutive vertex indices. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the draw operation.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">first</td><td>Index of the first vertex in the primitive.</td></tr>
    <tr><td class="paramname">count</td><td>Number of vertices in the primitive. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial11_8cpp-example.html#a111">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga06f4d4765bf74d01809661766ac7df80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDrawElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indexBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render a primitive with vertex indices fetched from an index buffer. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the draw operation.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">type</td><td>Type of index values stored in the index buffer.</td></tr>
    <tr><td class="paramname">count</td><td>Number of vertices in the primitive.</td></tr>
    <tr><td class="paramname">indexBuffer</td><td>GPU address of buffer object memory used as the index buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a120">DebugTextRenderer.cpp</a>, <a class="el" href="_graphics_object_cube_8cpp-example.html#a28">GraphicsObjectCube.cpp</a>, <a class="el" href="_graphics_object_specialized_cube_8cpp-example.html#a28">GraphicsObjectSpecializedCube.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a146">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a155">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a135">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a149">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a161">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga24c189bbc5765d6e8e7c862156417baf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDrawElementsBaseVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseVertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render a primitive with vertex indices fetched from an index buffer, with a base vertex value added to each fetched index. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the draw operation.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">type</td><td>Type of index values stored in the index buffer.</td></tr>
    <tr><td class="paramname">count</td><td>Number of vertices in the primitive.</td></tr>
    <tr><td class="paramname">indexBuffer</td><td>GPU address of buffer object memory used as the index buffer.</td></tr>
    <tr><td class="paramname">baseVertex</td><td>Base vertex value, added to each index fetched from the index buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga990fb401259b83e26716733dd581d5d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDrawArraysInstanced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instanceCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render multiple copies (instances) of a primitive with consecutive vertex indices. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the draw operation.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">first</td><td>Index of the first vertex in the primitive.</td></tr>
    <tr><td class="paramname">count</td><td>Number of vertices in the primitive.</td></tr>
    <tr><td class="paramname">baseInstance</td><td>Instance number of the first primitive instance.</td></tr>
    <tr><td class="paramname">instanceCount</td><td>Number of primitive instances to render. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabe27aeb078f485947d4c4454182c8fde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDrawElementsInstanced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instanceCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render multiple copies (instances) of a primitive with vertex indices fetched from an index buffer. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the draw operation.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">type</td><td>Type of index values stored in the index buffer.</td></tr>
    <tr><td class="paramname">count</td><td>Number of vertices in the primitive.</td></tr>
    <tr><td class="paramname">indexBuffer</td><td>GPU address of buffer object memory used as the index buffer.</td></tr>
    <tr><td class="paramname">baseVertex</td><td>Base vertex value, added to each index fetched from the index buffer.</td></tr>
    <tr><td class="paramname">baseInstance</td><td>Instance number of the first primitive instance.</td></tr>
    <tr><td class="paramname">instanceCount</td><td>Number of primitive instances to render. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7266e9a35bb52a07df08a09333b1e2e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDrawArraysIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indirectBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render primitives with consecutive vertex indices, using draw parameters fetched from an indirect data buffer. </p>
<p>The parameters of the draw are stored in <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object memory using the <a class="el" href="struct_n_v_ndraw_arrays_indirect_data.html" title="Data structure representing values used by indirect DrawArrays commands. ">NVNdrawArraysIndirectData</a> structure.</p>
<dl class="section warning"><dt>警告</dt><dd>If the indirect data are produced by previous commands executed on the GPU, applications must call nvnCommandBufferBarrier with the <a class="el" href="group__nvn__c__enum.html#ggaab4eabfc248236cc6b42d9de9d735621ad90225b2b4d5e8e3b710573a967ac67e" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">NVN_BARRIER_ORDER_INDIRECT_DATA_BIT</a> bit set to ensure that the GPU doesn't fetch the indirect data before previous commands are finished writing the data. Waiting via nvnQueueFinish, nvnQueueWaitSync, or nvnCommandBufferWaitSync is not sufficient to ensure that GPU-produced indirect data are not fetched prematurely.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the draw operation.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">indirectBuffer</td><td>GPU address of buffer object memory holding the indirect draw data. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a27ead5808358b8c8d7bc9a058e246751" title="Minimum alignment of indirect draw data. ">NVN_DEVICE_INFO_INDIRECT_DRAW_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0ea4fb762b38faa6bce7d27c075011e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDrawElementsIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indirectBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render primitives with vertex indices fetched from an index buffer, using draw parameters fetched from an indirect data buffer. </p>
<p>The parameters of the draw are stored in <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object memory using the <a class="el" href="struct_n_v_ndraw_elements_indirect_data.html" title="Data structure representing values used by indirect DrawElements commands. ">NVNdrawElementsIndirectData</a> structure.</p>
<dl class="section warning"><dt>警告</dt><dd>If the indirect data are produced by previous commands executed on the GPU, applications must call nvnCommandBufferBarrier with the <a class="el" href="group__nvn__c__enum.html#ggaab4eabfc248236cc6b42d9de9d735621ad90225b2b4d5e8e3b710573a967ac67e" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">NVN_BARRIER_ORDER_INDIRECT_DATA_BIT</a> bit set to ensure that the GPU doesn't fetch the indirect data before previous commands are finished writing the data. Waiting via nvnQueueFinish, nvnQueueWaitSync, or nvnCommandBufferWaitSync is not sufficient to ensure that GPU-produced indirect data are not fetched prematurely.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the draw operation.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">type</td><td>Type of index values stored in the index buffer.</td></tr>
    <tr><td class="paramname">indexBuffer</td><td>GPU address of buffer object memory used as the index buffer.</td></tr>
    <tr><td class="paramname">indirectBuffer</td><td>GPU address of buffer object memory holding the indirect draw data. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a27ead5808358b8c8d7bc9a058e246751" title="Minimum alignment of indirect draw data. ">NVN_DEVICE_INFO_INDIRECT_DRAW_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga06413e93f9e3d29a45fa878540947a8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferMultiDrawArraysIndirectCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indirectBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>parameterBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxDrawCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render multiple primitives with vertices fetched from a vertex buffer, using draw parameters fetched from an indirect data buffer and the number of primitives fetched from a parameter buffer. </p>
<p>The parameters of the draw are stored in <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object memory using the <a class="el" href="struct_n_v_ndraw_arrays_indirect_data.html" title="Data structure representing values used by indirect DrawArrays commands. ">NVNdrawArraysIndirectData</a> structure.</p>
<dl class="section warning"><dt>警告</dt><dd>If the indirect data or the draw count data are produced by previous commands executed on the GPU, applications must call nvnCommandBufferBarrier with the <a class="el" href="group__nvn__c__enum.html#ggaab4eabfc248236cc6b42d9de9d735621ad90225b2b4d5e8e3b710573a967ac67e" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">NVN_BARRIER_ORDER_INDIRECT_DATA_BIT</a> bit set to ensure that the GPU doesn't fetch the indirect data before previous commands are finished writing the data. Waiting via nvnQueueFinish, nvnQueueWaitSync, or nvnCommandBufferWaitSync is not sufficient to ensure that GPU-produced indirect data are not fetched prematurely.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the draw operation.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">indirectBuffer</td><td>GPU address of buffer object memory holding the indirect draw data. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a27ead5808358b8c8d7bc9a058e246751" title="Minimum alignment of indirect draw data. ">NVN_DEVICE_INFO_INDIRECT_DRAW_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">parameterBuffer</td><td>GPU address of buffer object memory holding the draw count. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a27ead5808358b8c8d7bc9a058e246751" title="Minimum alignment of indirect draw data. ">NVN_DEVICE_INFO_INDIRECT_DRAW_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">maxDrawCount</td><td>Specifies the maximum number of draws that are allowed. If the draw count in GPU memory pointed to by <em>parameterBuffer</em> is greater than <em>maxDrawCount</em>, only the first <em>maxDrawCount</em> primitives will be drawn.</td></tr>
    <tr><td class="paramname">stride</td><td>Stride (in bytes) between elements in <em>indirectBuffer</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga181160adcfe4ed4870196d02ff457a72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferMultiDrawElementsIndirectCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab22437710b6816a67a1263d0087ded72">NVNdrawPrimitive</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaaf90e0c2dbdc1e42db8192f0c0cb1522">NVNindexType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indirectBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>parameterBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxDrawCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render multiple primitives with vertex indices fetched from an index buffer, using draw parameters fetched from an indirect data buffer and the number of primitives fetched from a parameter buffer. </p>
<p>The parameters of the draw are stored in buffer object memory using the <a class="el" href="struct_n_v_ndraw_elements_indirect_data.html" title="Data structure representing values used by indirect DrawElements commands. ">NVNdrawElementsIndirectData</a> structure.</p>
<dl class="section warning"><dt>警告</dt><dd>If the indirect data or the draw count data are produced by previous commands executed on the GPU, applications must call nvnCommandBufferBarrier with the <a class="el" href="group__nvn__c__enum.html#ggaab4eabfc248236cc6b42d9de9d735621ad90225b2b4d5e8e3b710573a967ac67e" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">NVN_BARRIER_ORDER_INDIRECT_DATA_BIT</a> bit set to ensure that the GPU doesn't fetch the indirect data before previous commands are finished writing the data. Waiting via nvnQueueFinish, nvnQueueWaitSync, or nvnCommandBufferWaitSync is not sufficient to ensure that GPU-produced indirect data are not fetched prematurely.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the draw operation.</td></tr>
    <tr><td class="paramname">mode</td><td>Type of the primitive to render.</td></tr>
    <tr><td class="paramname">type</td><td>Type of index values stored in the index buffer.</td></tr>
    <tr><td class="paramname">indexBuffer</td><td>GPU address of buffer object memory used as the index buffer.</td></tr>
    <tr><td class="paramname">indirectBuffer</td><td>GPU address of buffer object memory holding the indirect draw data. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a27ead5808358b8c8d7bc9a058e246751" title="Minimum alignment of indirect draw data. ">NVN_DEVICE_INFO_INDIRECT_DRAW_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">parameterBuffer</td><td>GPU address of buffer object memory holding the draw count. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a27ead5808358b8c8d7bc9a058e246751" title="Minimum alignment of indirect draw data. ">NVN_DEVICE_INFO_INDIRECT_DRAW_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">maxDrawCount</td><td>Specifies the maximum number of draws that are allowed. If the draw count in GPU memory pointed to by <em>parameterBuffer</em> is greater than <em>maxDrawCount</em>, only the first <em>maxDrawCount</em> primitives will be drawn.</td></tr>
    <tr><td class="paramname">stride</td><td>Stride (in bytes) between elements in <em>indirectBuffer</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab857894818dcd7f7a58d0358a9e44100"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferClearColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a color buffer using floating-point clear color values. </p>
<p>This command should be used only to clear color buffers with floating-point or <em>normalized</em> signed or unsigned integer components. When clearing color buffers with unnormalized integer components (with formats ending in "I" or "UI"), the values in <code>color</code> will be re-interpreted as integers. For example, clearing an integer color buffer to the value 1.0 will instead clear to 0x3F800000, the IEEE-754 encoding of 1.0.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the clear.</td></tr>
    <tr><td class="paramname">index</td><td>Index of the color target to clear. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a9f4ab24a0b8c08e3f2b66ce04e379b16" title="Number of color buffer binding points. ">NVN_DEVICE_INFO_COLOR_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">color</td><td>Array of four floating-point (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">mask</td><td>Bitfield indicating which color channels should be cleared. See <a class="el" href="group__nvn__c__enum.html#gac703c5549157a2c6efb057f8047bde0f" title="Specifies the set of color buffer channels enabled for writing. ">NVNclearColorMask</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial01_8cpp-example.html#a80">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a128">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a137">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a117">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a130">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a76">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a76">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a88">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a71">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a149">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gae7b84424af2bf2f2eb00730c8fb2f1dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferClearColori </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a color buffer using signed integer clear color values. </p>
<p>This command should be used only to clear color buffers with <em>unnormalized</em> signed integer components (with formats ending in "I"). When clearing color buffers with floating-point or normalized integer components, the values in <code>color</code> will be re-interpreted as floating-point values. For example, clearing a floating-point color buffer to the value 0x3F800000 will instead clear to 1.0 (the IEEE-754 floating-point equivalent). When clearing color buffers with unsigned integer components, the signed clear color will be re-interpreted as unsigned.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the clear.</td></tr>
    <tr><td class="paramname">index</td><td>Index of the color target to clear. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a9f4ab24a0b8c08e3f2b66ce04e379b16" title="Number of color buffer binding points. ">NVN_DEVICE_INFO_COLOR_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">color</td><td>Array of four signed integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">mask</td><td>Bitfield indicating which color channels should be cleared. See <a class="el" href="group__nvn__c__enum.html#gac703c5549157a2c6efb057f8047bde0f" title="Specifies the set of color buffer channels enabled for writing. ">NVNclearColorMask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad4e558a6f5a75f2ca927361818c65d1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferClearColorui </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a color buffer using unsigned integer clear color values. </p>
<p>This command should be used only to clear color buffers with <em>unnormalized</em> unsigned integer components (with formats ending in "UI"). When clearing color buffers with floating-point or normalized integer components, the values in <code>color</code> will be re-interpreted as floating-point values. For example, clearing a floating-point color buffer to the value 0x3F800000 will instead clear to 1.0 (the IEEE-754 floating-point equivalent). When clearing color buffers with signed integer components, the unsigned clear color will be re-interpreted as signed.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the clear.</td></tr>
    <tr><td class="paramname">index</td><td>Index of the color target to clear. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a9f4ab24a0b8c08e3f2b66ce04e379b16" title="Number of color buffer binding points. ">NVN_DEVICE_INFO_COLOR_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">color</td><td>Array of four unsigned integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">mask</td><td>Bitfield indicating which color channels should be cleared. See <a class="el" href="group__nvn__c__enum.html#gac703c5549157a2c6efb057f8047bde0f" title="Specifies the set of color buffer channels enabled for writing. ">NVNclearColorMask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae5f7adad6751d801a89cd1101253fa85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferClearDepthStencil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depthValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>depthMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stencilValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stencilMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a depth/stencil buffer. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the clear.</td></tr>
    <tr><td class="paramname">depthValue</td><td>Floating-point depth clear value (in the range [0.0, 1.0]).</td></tr>
    <tr><td class="paramname">depthMask</td><td>Enable (TRUE) or disable (FALSE) clearing of the depth channel.</td></tr>
    <tr><td class="paramname">stencilValue</td><td>Stencil clear value.</td></tr>
    <tr><td class="paramname">stencilMask</td><td>Mask indicating the bits of the stencil buffer to clear. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial03_8cpp-example.html#a130">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a139">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a119">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a132">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a78">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a78">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a90">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a151">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga32b1e19b7700460afce5817b7c9d7bee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDispatchCompute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>groupsX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>groupsY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>groupsZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch a new grid of compute shader work groups for processing. </p>
<p>Each compute shader dispatch spawns a three-dimensional array of work groups for processing. Each work group is processed independently, with a three-dimensional array of threads whose size is specified in the compute shader.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to dispatch the compute work.</td></tr>
    <tr><td class="paramname">groupsX</td><td>The number of compute work groups in the X dimension. Must be less than or equal to 65535 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a69a6d14c905f7669aebe64db6d5bc0c6" title="Maximum number of work groups in the X dimension supported in a compute dispatch. ...">NVN_DEVICE_INFO_MAX_COMPUTE_DISPATCH_WORK_GROUPS_X</a>).</td></tr>
    <tr><td class="paramname">groupsY</td><td>The number of compute work groups in the Y dimension. Must be less than or equal to 65535 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5f2caf0b93f02718c5db35ccf3bd02ba" title="Maximum number of work groups in the Y dimension supported in a compute dispatch. ...">NVN_DEVICE_INFO_MAX_COMPUTE_DISPATCH_WORK_GROUPS_Y</a>).</td></tr>
    <tr><td class="paramname">groupsZ</td><td>The number of compute work groups in the Z dimension. Must be less than or equal to 65535 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50adca24846860ee2ba71a911b9811fd676" title="Maximum number of work groups in the Z dimension supported in a compute dispatch. ...">NVN_DEVICE_INFO_MAX_COMPUTE_DISPATCH_WORK_GROUPS_Z</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafa16fbe913a0dc193ff71d835abcf404"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDispatchComputeIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>indirectBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch a new grid of compute shader work groups for processing. </p>
<p>Each compute shader dispatch spawns a three-dimensional array of work groups for processing. Each work group is processed independently, with a three-dimensional array of threads whose size is specified in the compute shader. The number of compute workgroups in each dimension is read from buffer memory.</p>
<dl class="section warning"><dt>警告</dt><dd>If the indirect data are produced by previous commands executed on the GPU, applications must call nvnCommandBufferBarrier with the <a class="el" href="group__nvn__c__enum.html#ggaab4eabfc248236cc6b42d9de9d735621ad90225b2b4d5e8e3b710573a967ac67e" title="Ensure that all work before the barrier completes before fetching per-draw data for indirect draws an...">NVN_BARRIER_ORDER_INDIRECT_DATA_BIT</a> bit set to ensure that the GPU doesn't fetch the indirect data before previous commands are finished writing the data. Waiting via nvnQueueFinish, nvnQueueWaitSync, or nvnCommandBufferWaitSync is not sufficient to ensure that GPU-produced indirect data are not fetched prematurely.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to dispatch the compute work.</td></tr>
    <tr><td class="paramname">indirectBuffer</td><td>GPU address of buffer object memory holding the indirect dispatch data. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a8b0a281dbb6991d93e30ecbe4d2f63e2" title="Minimum alignment of indirect dispatch data. ">NVN_DEVICE_INFO_INDIRECT_DISPATCH_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac4cadef7ff012bc4d218bfd9e510a888"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetViewport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the rectangle for viewport 0. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">x</td><td>Smallest X coordinate of the viewport rectangle.</td></tr>
    <tr><td class="paramname">y</td><td>Smallest Y coordinate of the viewport rectangle.</td></tr>
    <tr><td class="paramname">w</td><td>Width of the viewport rectangle.</td></tr>
    <tr><td class="paramname">h</td><td>Height of the viewport rectangle. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a105">DebugTextRenderer.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a127">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a136">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a116">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a129">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a75">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a75">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a87">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a70">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a100">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga28fd845211c4219f176ee89e8a3d948d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetViewports </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify one or more viewport rectangles. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">first</td><td>Index of the first viewport to modify.</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous viewports to set.</td></tr>
    <tr><td class="paramname">ranges</td><td>An array of values to use for the viewports. The array must contain 4 * <em>count</em> values corresponding to the range of viewports specified by <em>first</em> and <em>count</em>. Each quartet of values corresponds to, in order: the smallest X coordinate of the viewport, the smallest Y coordinate of the viewport, the width of the viewport, and the height of the viewport. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6ffac06ea80ba1df6d07234615c0ae66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetViewportSwizzles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__c__enum.html#ga00e92e1d7e5fff49496f813b6288ec0f">NVNviewportSwizzle</a> *&#160;</td>
          <td class="paramname"><em>swizzles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a set of viewport swizzle selectors for one or more viewport rectangles. </p>
<p>As part of the viewport transformation, each vertex is transformed by the viewport swizzle operation before the vertex is transformed to screen space. The viewport swizzle produces a four-component swizzled position, where each component is produced by selecting and optionally negating one of the four compenents of the original vertex position. This command specifies sets of four swizzle selectors used to produce the transformed position. The default swizzles for each viewport are POSITIVE_X, POSITIVE_Y, POSITIVE_Z, and POSITIVE_W, which specify no change to the incoming position.</p>
<dl class="section note"><dt>覚え書き</dt><dd>There is a separate set of four viewport swizzle values for each viewport. A primitive broadcast to multiple viewports will have a separate swizzle applied for each viewport.</dd>
<dd>
Viewport swizzles rasterization is only supported on NX and second-generation Maxwell and later GPUs. Query the SUPPORTS_VIEWPORT_SWIZZLE device property to determine if this command is supported.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">first</td><td>Index of the first viewport to modify.</td></tr>
    <tr><td class="paramname">count</td><td>Number of consecutive viewports to update.</td></tr>
    <tr><td class="paramname">swizzles</td><td>An array of swizzle values to use for the viewports. This array must contain 4 * <em>count</em> values corresponding to the range of viewports specified by <em>first</em> and <em>count</em>. Each set of four values identifies the input position component used for the X, Y, Z, and W components, respectively, of the position vector produced by the viewport swizzle operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac6c38cac9330ae402f2f911d1e1aa757"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetScissor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the scissor rectangle used for clipping primitives and clears. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">x</td><td>Smallest X coordinate of the scissor rectangle.</td></tr>
    <tr><td class="paramname">y</td><td>Smallest Y coordinate of the scissor rectangle.</td></tr>
    <tr><td class="paramname">w</td><td>Width of the scissor rectangle.</td></tr>
    <tr><td class="paramname">h</td><td>Height of the scissor rectangle. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a104">DebugTextRenderer.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a79">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a126">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a135">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a115">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a128">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a74">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a74">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a86">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a69">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a101">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga51fff8146007887cfd821c3e82dc11f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetScissors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>rects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify one or more scissor rectangles. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">first</td><td>Index of the first scissor rectangle to modify.</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous scissor rectangles to set.</td></tr>
    <tr><td class="paramname">rects</td><td>An array of values to use for the scissor rectangles. The array must contain 4 * <em>count</em> values corresponding to the range of scissor rectangles specified by <em>first</em> and <em>count</em>. Each quartet of values corresponds to, in order: the smallest X coordinate of the rectangle, the smallest Y coordinate of the rectangle, the width of the rectangle, and the height of the rectangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga82e8dc14164ab8018898a76e07e6e86a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetDepthRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the range of depth values for rendered primitives. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to change the depth range.</td></tr>
    <tr><td class="paramname">n</td><td>Depth value corresponding to the near clip plane.</td></tr>
    <tr><td class="paramname">f</td><td>Depth value corresponding to the far clip plane. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4b174a2678de189471d5466ca2bfd4d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetDepthBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control the operation of the depth bounds test. </p>
<p>This command lets applications enable or disable the depth bounds test. When enabled, the depth bounds test will discard any fragments where the stored Z value in the depth buffer is outside the range [<em>n</em>, <em>f</em>]. By default, the depth bounds test is disabled.</p>
<dl class="section warning"><dt>警告</dt><dd>When the depth bounds test is enabled, <em>n</em> must be less than or equal to <em>f</em>.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to change the depth bounds test.</td></tr>
    <tr><td class="paramname">enable</td><td>Enable or disable the depth bounds test.</td></tr>
    <tr><td class="paramname">n</td><td>Minimum value of the depth bounds test range.</td></tr>
    <tr><td class="paramname">f</td><td>Maximum value of the depth bounds test range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga72d653ea55400bfbb48101628878f782"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetDepthRanges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets multiple ranges of depth values for rendered primitives. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">first</td><td>Index of the first depth range to modify.</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous depth ranges to set.</td></tr>
    <tr><td class="paramname">ranges</td><td>An array of values to use for the depth ranges. It must contain <em>count</em> pairs of values corresponding to the depth ranges specified by <em>first</em> and <em>count</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae2e294bc785c1a41a874f71fe5b277d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetTiledCacheAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gaa34a73b0ed878a1ee610efb60d5bbb9c">NVNtiledCacheAction</a>&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a specified operation related to tiled caching. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">action</td><td>Tiled caching operation to perform. Actions include enabling, disabling, or flushing the tiled cache binner. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga682b6f01fe95daff5aa16c5b044fca32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetTiledCacheTileSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tileWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tileHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the tile size used for tiled caching. </p>
<p>If the tile size has changed, the hardware will automatically flush the tiled cache binner. The tile size is clamped to [16, 16384] in either dimension.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">tileWidth</td><td>Sets the tile width, in pixels.</td></tr>
    <tr><td class="paramname">tileHeight</td><td>Sets the tile height, in pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9b5b85ce0b512e73c9d3b5ad067c3bbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindSeparateTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nseparate_texture_handle.html">NVNseparateTextureHandle</a>&#160;</td>
          <td class="paramname"><em>textureHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> to use for texture mapping in shaders. </p>
<p>This command binds a separate texture handle (without sampler information) for use with shaders using separate texture types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders).</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> binding point number to update. Must be less than 128 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a908ba4406dc9e894d8a13f8e2b8c4bbf" title="Number of separate texture bindings supported for each shader stage. ">NVN_DEVICE_INFO_SEPARATE_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">textureHandle</td><td>Separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> handle for the separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaee3d37a925075c3b7309519710eba21c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindSeparateSampler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nseparate_sampler_handle.html">NVNseparateSamplerHandle</a>&#160;</td>
          <td class="paramname"><em>samplerHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> to use for texture mapping in shaders. </p>
<p>This command binds a separate sampler handle (without texture information) for use with shaders using separate sampler types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders).</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> binding point to update.</td></tr>
    <tr><td class="paramname">index</td><td>Separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> binding point number to update. Must be less than 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a238ded224f2bed89b13843fb328771cc" title="Number of separate sampler bindings supported for each shader stage. ">NVN_DEVICE_INFO_SEPARATE_SAMPLER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">samplerHandle</td><td>Separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> handle for the separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> object to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafa9403fe47ad6ca243c10cbd12562464"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindSeparateTextures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nseparate_texture_handle.html">NVNseparateTextureHandle</a> *&#160;</td>
          <td class="paramname"><em>textureHandles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more separate textures to use for texture mapping in shaders. </p>
<p>This command binds one or more separate texture handles (without sampler information) for use with shaders using separate texture types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders). This command is equivalent to making multiple calls to BindSeparateTexture.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First separate texture binding point number to update. Must be less than 128 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a908ba4406dc9e894d8a13f8e2b8c4bbf" title="Number of separate texture bindings supported for each shader stage. ">NVN_DEVICE_INFO_SEPARATE_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous separate texture binding points to update. Must be less than or equal to 128 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a908ba4406dc9e894d8a13f8e2b8c4bbf" title="Number of separate texture bindings supported for each shader stage. ">NVN_DEVICE_INFO_SEPARATE_TEXTURE_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">textureHandles</td><td>Array of handles of separate <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabf3893f22e69cca544a365b85e9295d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindSeparateSamplers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nseparate_sampler_handle.html">NVNseparateSamplerHandle</a> *&#160;</td>
          <td class="paramname"><em>samplerHandles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind one or more Samplers to use for texture mapping in shaders. </p>
<p>This command binds one or more separate sampler handles (without texture information) for use with shaders using separate sampler types. These bindings are not used for variables with combined sampler types (such as "sampler2D" in GLSL shaders). This command is equivalent to making multiple calls to BindSeparateSampler.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the bind operation.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage owning the binding points to update.</td></tr>
    <tr><td class="paramname">first</td><td>First separate sampler binding point number to update. Must be less than 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a238ded224f2bed89b13843fb328771cc" title="Number of separate sampler bindings supported for each shader stage. ">NVN_DEVICE_INFO_SEPARATE_SAMPLER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">count</td><td>Number of contiguous separate sampler binding points to update. Must be less than or equal to 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a238ded224f2bed89b13843fb328771cc" title="Number of separate sampler bindings supported for each shader stage. ">NVN_DEVICE_INFO_SEPARATE_SAMPLER_BINDINGS_PER_STAGE</a>).</td></tr>
    <tr><td class="paramname">samplerHandles</td><td>Array of handles of separate <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab057345ad441b37deda70d0434d0cb5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetStencilValueMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a>&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a mask that will be applied to the stencil index and reference values prior to performing the stencil test. </p>
<p>There are separate stencil value masks for front- and back-facing primitives. This function can update the value of either or both masks. If stencil testing is disabled, the stencil value mask has no effect. The default value for both front and back masks is 0xFF (all bits set).</p>
<dl class="section note"><dt>覚え書き</dt><dd>In API versions prior to 53.8, the default mask was unintentionally set to zero.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">faces</td><td>Specifies the face(s) (front and/or back) using the new stencil value mask.</td></tr>
    <tr><td class="paramname">mask</td><td>Mask to be applied to stencil index and reference values prior to the stencil test </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5f084072b85bde09e40e4920fce1be65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetStencilMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a>&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a mask to apply to stencil values written by the stencil test. </p>
<p>Bits in the existing stencil index corresponding to zero bits in the stencil mask will not be updated by the stencil test. There are separate stencil masks for front- and back-facing primitives. This function can update the value of either or both masks. If stencil testing is disabled, the stencil mask has no effect. The default value for both front and back masks is 0xFF (all bits set).</p>
<dl class="section note"><dt>覚え書き</dt><dd>In API versions prior to 53.8, the default mask was unintentionally set to zero.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">faces</td><td>Specifies the face(s) (front and/or back) using the new stencil mask.</td></tr>
    <tr><td class="paramname">mask</td><td>Mask to apply to stencil values written by the stencil test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3670a8f6d5e0a5267dfb69919d46d8d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetStencilRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga258b4f915ce6b9b20d57763d617278df">NVNface</a>&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a stencil reference value used by the stencil test. </p>
<p>There are separate reference values for front- and back-facing primitives. This function can update the value of either or both values. If stencil testing is disabled, the stencil reference value has no effect. The default reference value for both front and back is zero.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">faces</td><td>Specifies the face(s) (front and/or back) using the new stencil reference value.</td></tr>
    <tr><td class="paramname">ref</td><td>Stencil reference value used by the stencil test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae80cb65cbc04a34f6892023d529526f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetBlendColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>blendColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a constant color that may be used by blending functions. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">blendColor</td><td>Array of four floating-point (RGBA) blend color values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf3a20e6577e2780cf1de7487730a2086"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetPointSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pointSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the size (in pixels) of point primitives to render. </p>
<p>If the last enabled vertex, tessellation control, tessellation evaluation, or geometry shader writes to gl_PointSize, this value is ignored and point size written in that shader will be used.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">pointSize</td><td>Size (in pixels) of point primitives to render. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafb4bb0bdb2ac78ee60e2e3e5138ce22e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetLineWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the width (in pixels) of line primitives to render. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">lineWidth</td><td>Width (in pixels) of line primitives to render. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga81867da9e1301f27904dae46435c931b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetPolygonOffsetClamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies values used to compute a depth offset value when polygon offset is enabled. </p>
<p>The offset is computed by multiplying the maximum depth slope of the primitive [sqrt((dz/dx)^2 + (dz/dy)^2)] by <em>factor</em>, adding in the minimum resolvable difference in depth values multiplied by <em>units</em>, and clamping the result as described in the documentation for <em>clamp</em>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">factor</td><td>Value multiplied by the maximum depth slope when computing offset.</td></tr>
    <tr><td class="paramname">units</td><td>Value multiplied by the minimum resolvable depth difference when computing offset.</td></tr>
    <tr><td class="paramname">clamp</td><td>Value used to clamp the computed offset. If <code>clamp</code> is positive, the computed depth offset will be clamped to a value less than or equal to <code>clamp</code>. If <code>clamp</code> is negative, the computed depth offset will be clamped to a value greater than or equal to <code>clamp</code>. If <code>clamp</code> is zero, the computed depth offset will not be clamped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab298722737de06614902b5e15ffadea6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetAlphaRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a reference value to use for alpha testing. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">ref</td><td>Reference value for the alpha test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadcba5a3b987a3f421ca0566a48dbf62e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetSampleMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a mask of samples that may be covered by rendered primitives. </p>
<p>If bit N is zero in the provided mask, sample N will never be considered to be covered when rasterizing primitives.</p>
<p>The default sample mask is ~0 (all bits enabled).</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the update.</td></tr>
    <tr><td class="paramname">mask</td><td>Mask of samples that may be covered by rendered primitives. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a112">DebugTextRenderer.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a137">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a146">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a126">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a139">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a153">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gacff1db19e51d3dec85a952263345dcff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetRasterizerDiscard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>discard</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable rasterizer discard. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to change the rasterizer discard state. When enabled, rasterizer discard instructs the GPU to discard all primitives produced by Draw* commands prior to rasterization and fragment processing. Such primitives are still processed by vertex, tessellation, and geometry shaders and will be captured by transform feedback, if enabled. Additionally, when enabled, clears of color, depth, and stencil buffers will be discarded.</td></tr>
    <tr><td class="paramname">discard</td><td>True if primitives should be discarded; false (default) otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5ddab005c7a86e3b0b29a62932893cb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetDepthClamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>clamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable depth clamping of rendered primitives. </p>
<p>When enabled, primitives are not clipped to the near and far clip planes. Instead, primitives are rasterized without clipping in Z, and interpolated Z values are clamped to the extents of the depth range.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to change the depth range.</td></tr>
    <tr><td class="paramname">clamp</td><td>TRUE if depth clamping should be enabled; FALSE otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1e231e88d224fc168ca94e22252be6e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetConservativeRasterEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable conservative rasterization of rendered primitives. </p>
<p>Conservative rasterization is only supported on second-generation Maxwell and later GPUs. Query the SUPPORTS_CONSERVATIVE_RASTER device property to determine support.</p>
<p>By default, conservative rasterization is disabled.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to toggle conservative rasterization.</td></tr>
    <tr><td class="paramname">enable</td><td>TRUE if conservative rasterization should be enabled; FALSE, otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaced655069ef6e505fddd493fb0d33606"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetConservativeRasterDilate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dilate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the degree of primitive dilation when conservative rasterization is enabled. </p>
<p>This provides a mechanism for "over-conservative" rasterization by dilating (expanding) primitives prior to rasterization. <em>dilate</em> is automatically clamped to the range [0.0, 0.75] and rounded up to a multiple of 0.25. When <em>dilate</em> is 0.0, ordinary conservative rasterization is performed. When dilate is greater than 0.0, rasterized primitives are dilated by <em>dilate</em> pixels. If conservative rasterization is disabled, dilation has no effect on rasterization. This function is only supported on second-generation Maxwell and later GPUs. Query the SUPPORTS_CONSERVATIVE_RASTER device property to determine support.</p>
<p>By default, conservative rasterization is disabled.</p>
<dl class="section warning"><dt>警告</dt><dd>Changing the dilation setting requires idling the GPU and results in reduced performance. Applications should avoid changing the dilation factor frequently.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to update conservative raster dilation.</td></tr>
    <tr><td class="paramname">dilate</td><td>The fraction of a pixel by which to dilate rasterized primitives. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6c5fe84c110d0a48de87c2f6f83eb6e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetSubpixelPrecisionBias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the number of additional bits of subpixel precision to be used for primitive rasterization when conservative rasterization is enabled. </p>
<p>When vertices are transformed to window coordinates, they are snapped to fixed-point positions. By default, the number of bits of fractional precision within a pixel is given by the device property SUBPIXEL_BITS. This function enables applications to increase the subpixel precision for snapped vertex positions. If conservative rasterization is disabled, additional bias bits have no effect on rasterization.</p>
<p>Additional subpixel precision allows for consistent conservative rasterization when rendering the same geometry at different resolutions. Rasterizing a scene at 64x64 with 3 extra subpixel bits in X and Y will have the same snapping behavior as rasterizing the same scene at 512x512 with no extra subpixel bits.</p>
<p>By default, the subpixel precision bias is 0.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to update conservative raster bias bits.</td></tr>
    <tr><td class="paramname">xBits</td><td>The number of additional bits of subpixel precision in the horizontal direction. Must be less than or equal to 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5f9b4fb232267d68961d17111ed70752" title="The maximum number of additional bits of subpixel precision that can be used to represent vertex wind...">NVN_DEVICE_INFO_MAX_SUBPIXEL_BIAS_BITS</a>).</td></tr>
    <tr><td class="paramname">yBits</td><td>The number of additional bits of subpixel precision in the vertical direction. Must be less than or equal to 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a5f9b4fb232267d68961d17111ed70752" title="The maximum number of additional bits of subpixel precision that can be used to represent vertex wind...">NVN_DEVICE_INFO_MAX_SUBPIXEL_BIAS_BITS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaa8c77d09aa827fbbced85deecec671e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferCopyBufferToTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>dstTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>dstRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy texture data from buffer memory into a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the copy.</td></tr>
    <tr><td class="paramname">src</td><td>Address of the buffer holding the source data for the copy.</td></tr>
    <tr><td class="paramname">dstTexture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object used as the destination for the copy.</td></tr>
    <tr><td class="paramname">dstView</td><td>View of the texture object used as the destination for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>dstTexture</em>. If NULL is specified, the base level of the texture <em>dstTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">dstRegion</td><td>Region of the destination texture to update for the copy.</td></tr>
    <tr><td class="paramname">flags</td><td>Specifies options used when performing the copy. See <a class="el" href="group__nvn__c__enum.html#ga264a21eefa322cd0ad9acf4c2ab949ad" title="Flags controlling the operation of copy commands. ">NVNcopyFlags</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a70">DebugTextRenderer.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga769cb5c27cfad2fd8bbe61b5277122af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferCopyTextureToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>srcTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>srcView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>srcRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy texture data from a region of a <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object into buffer memory. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the copy.</td></tr>
    <tr><td class="paramname">srcTexture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object used as the source for the copy.</td></tr>
    <tr><td class="paramname">srcView</td><td>View of the texture object used as the source for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>srcTexture</em>. If NULL is specified, the base level of the texture <em>srcTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">srcRegion</td><td>Region of the source texture to copy from.</td></tr>
    <tr><td class="paramname">dst</td><td>Address of the buffer holding the destination data for the copy.</td></tr>
    <tr><td class="paramname">flags</td><td>Specifies options used when performing the copy. See <a class="el" href="group__nvn__c__enum.html#ga264a21eefa322cd0ad9acf4c2ab949ad" title="Flags controlling the operation of copy commands. ">NVNcopyFlags</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf7137adca4ad85a28917d01374c09219"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferCopyTextureToTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>srcTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>srcView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>srcRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>dstTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>dstRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy texture data from a region of one <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object into a region of another <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object. </p>
<p>Copies texture data from the region <em>srcRegion</em> of a view of the source texture to the region <em>dstRegion</em> of a view of the destination texture. If <em>srcRegion</em> and <em>dstRegion</em> are of different sizes, the source region will be scaled when copying. If <a class="el" href="group__nvn__c__enum.html#gga264a21eefa322cd0ad9acf4c2ab949ada538f93eef3f762d31d30bef43ba898e0" title="Enable linear filtering for texture-to-texture copies. ">NVN_COPY_FLAGS_LINEAR_FILTER_BIT</a> is set in <em>flags</em> when scaling, the copy will average texels from the source. Otherwise, the copy will select the nearest source texel for each destination texel.</p>
<dl class="section note"><dt>覚え書き</dt><dd>If the source and destination regions overlap in memory, the results of the copy will be undefined.</dd>
<dd>
Filtering across layers of a source texture is not supported; the number of layers in <em>srcRegion</em> and <em>dstRegion</em> must match.</dd>
<dd>
Linear filtering is supported for a limited subset of source and destination formats, as documented in the Programming Guide.</dd>
<dd>
Copies involving multisample textures are not supported.</dd>
<dd>
Copies of compressed formats must be aligned on compression block boundaries and do not support scaling.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the copy.</td></tr>
    <tr><td class="paramname">srcTexture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object holding the source data for the copy.</td></tr>
    <tr><td class="paramname">srcView</td><td>View of the texture object used as the source for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>srcTexture</em>. If NULL is specified, the base level of the texture <em>srcTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">srcRegion</td><td>Region of the source texture to read from.</td></tr>
    <tr><td class="paramname">dstTexture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object used as the destination for the copy.</td></tr>
    <tr><td class="paramname">dstView</td><td>View of the texture object used as the destination for the copy. A texture view, if specified, can be used to override properties of the corresponding texture <em>dstTexture</em>. If NULL is specified, the base level of the texture <em>dstTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">dstRegion</td><td>Region of the destination texture to write to.</td></tr>
    <tr><td class="paramname">flags</td><td>Specifies options used when performing the copy. See <a class="el" href="group__nvn__c__enum.html#ga264a21eefa322cd0ad9acf4c2ab949ad" title="Flags controlling the operation of copy commands. ">NVNcopyFlags</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial10_8cpp-example.html#a77">NvnTutorial10.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gafd877eff408eaf5795b2e6affa58d2c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferCopyBufferToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule a copy of data from one <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object into another <a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the copy.</td></tr>
    <tr><td class="paramname">src</td><td>Address of the buffer holding the source data for the copy.</td></tr>
    <tr><td class="paramname">dst</td><td>Address of the buffer holding the destination data for the copy.</td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to copy between source and destination buffers.</td></tr>
    <tr><td class="paramname">flags</td><td>Specifies options used when performing the copy. See of <a class="el" href="group__nvn__c__enum.html#ga264a21eefa322cd0ad9acf4c2ab949ad" title="Flags controlling the operation of copy commands. ">NVNcopyFlags</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab0d38dd93f857f1242072e0fc1d3aa05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferClearBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a buffer to a 32-bit integer value. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the clear.</td></tr>
    <tr><td class="paramname">dst</td><td>Address of the buffer holding the destination data for the clear. This address should be aligned to 4 bytes.</td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to clear. Size must be a multiple of four. Clears with zero size are treated as no-ops.</td></tr>
    <tr><td class="paramname">value</td><td>32-bit integer value to clear with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad95f1a98899a4036008ac16e011bd2e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferClearTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>dstTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>dstRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a color buffer using floating point clear color values. </p>
<p>Clears texture data from the region <em>region</em> of a view of the destination texture.</p>
<p>This command supports only texture formats that can be bound as a render target. Please refer to the 'Render' column in the programming guide's <a class="el" href="nvn_index.html#nvn_guide_formats_table">formats table</a> for supported formats.</p>
<dl class="section warning"><dt>警告</dt><dd>Unlike Copy commands, ClearTexure renders to the texture using the 3D Engine. Before accessing the cleared texture, applications must ensure that the GPU commands producing the new data have completed with <a class="el" href="group__nvn__c__enum.html#gaab4eabfc248236cc6b42d9de9d735621" title="Controls the ordering of commands and invalidation of caches for nvnCommandBufferBarrier. ">NVNbarrierBits</a> of ORDER_FRAGMENTS and INVALIDATE_TEXTURE or by waiting on a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the clear.</td></tr>
    <tr><td class="paramname">dstTexture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object used as the destination for the clear.</td></tr>
    <tr><td class="paramname">dstView</td><td>View of the texture object used as the destination for the clear. A texture view, if specified, can be used to override properties of the corresponding texture <em>dstTexture</em>. If NULL is specified, the base level of the texture <em>dstTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">dstRegion</td><td>Region of the destination texture to write to.</td></tr>
    <tr><td class="paramname">color</td><td>Array of four floating-point (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">mask</td><td>Bitfield indicating which color channels should be cleared. See of <a class="el" href="group__nvn__c__enum.html#gac703c5549157a2c6efb057f8047bde0f" title="Specifies the set of color buffer channels enabled for writing. ">NVNclearColorMask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga713cc9cb373ffda6953aa73511de626f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferClearTexturei </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>dstTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>dstRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a color buffer using signed integer clear color values. </p>
<p>Clears texture data from the region <em>region</em> of a view of the destination texture.</p>
<p>This command supports only texture formats that can be bound as a render target. Please refer to the 'Render' column in the programming guide's <a class="el" href="nvn_index.html#nvn_guide_formats_table">formats table</a> for supported formats.</p>
<dl class="section warning"><dt>警告</dt><dd>Unlike Copy commands, ClearTexure renders to the texture using the 3D Engine. Before accessing the cleared texture, applications must ensure that the GPU commands producing the new data have completed with <a class="el" href="group__nvn__c__enum.html#gaab4eabfc248236cc6b42d9de9d735621" title="Controls the ordering of commands and invalidation of caches for nvnCommandBufferBarrier. ">NVNbarrierBits</a> of ORDER_FRAGMENTS and INVALIDATE_TEXTURE or by waiting on a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the clear.</td></tr>
    <tr><td class="paramname">dstTexture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object used as the destination for the clear.</td></tr>
    <tr><td class="paramname">dstView</td><td>View of the texture object used as the destination for the clear. A texture view, if specified, can be used to override properties of the corresponding texture <em>dstTexture</em>. If NULL is specified, the base level of the texture <em>dstTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">dstRegion</td><td>Region of the destination texture to write to.</td></tr>
    <tr><td class="paramname">color</td><td>Array of four signed integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">mask</td><td>Bitfield indicating which color channels should be cleared. See <a class="el" href="group__nvn__c__enum.html#gac703c5549157a2c6efb057f8047bde0f" title="Specifies the set of color buffer channels enabled for writing. ">NVNclearColorMask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga608d429e488f09ead4879c28995767d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferClearTextureui </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>dstTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncopy_region.html">NVNcopyRegion</a> *&#160;</td>
          <td class="paramname"><em>dstRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a color buffer using unsigned integer clear color values. </p>
<p>Clears texture data from the region <em>region</em> of a view of the destination texture.</p>
<p>This command supports only texture formats that can be bound as a render target. Please refer to the 'Render' column in the programming guide's <a class="el" href="nvn_index.html#nvn_guide_formats_table">formats table</a> for supported formats.</p>
<dl class="section warning"><dt>警告</dt><dd>Unlike Copy commands, ClearTexure renders to the texture using the 3D Engine. Before accessing the cleared texture, applications must ensure that the GPU commands producing the new data have completed with <a class="el" href="group__nvn__c__enum.html#gaab4eabfc248236cc6b42d9de9d735621" title="Controls the ordering of commands and invalidation of caches for nvnCommandBufferBarrier. ">NVNbarrierBits</a> of ORDER_FRAGMENTS and INVALIDATE_TEXTURE or by waiting on a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the clear.</td></tr>
    <tr><td class="paramname">dstTexture</td><td><a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> object used as the destination for the clear.</td></tr>
    <tr><td class="paramname">dstView</td><td>View of the texture object used as the destination for the clear. A texture view, if specified, can be used to override properties of the corresponding texture <em>dstTexture</em>. If NULL is specified, the base level of the texture <em>dstTexture</em> will be used as-is.</td></tr>
    <tr><td class="paramname">dstRegion</td><td>Region of the destination texture to write to.</td></tr>
    <tr><td class="paramname">color</td><td>Array of four unsigned integer (RGBA) clear color values.</td></tr>
    <tr><td class="paramname">mask</td><td>Bitfield indicating which color channels should be cleared. See of <a class="el" href="group__nvn__c__enum.html#gac703c5549157a2c6efb057f8047bde0f" title="Specifies the set of color buffer channels enabled for writing. ">NVNclearColorMask</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2d1a1fe5fa1806e89138de41ee9c601f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferUpdateUniformBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>updateOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>updateSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the contents of a uniform buffer. </p>
<p>This command schedules an update of the contents of a uniform buffer, which will execute without waiting for previous draw calls prior to the update. The update will wait on the completion of previous compute dispatches. Draw calls and compute dispatches issued after the update will use the new uniform buffer values. Calls before the update will use the old values.</p>
<p>To get correct ordering of updates, the range of buffer memory identified by <em>buffer</em> and <em>bufferSize</em> must exactly match the memory range bound via nvnCommandBufferBindUniformBuffer. If any other uniform buffer binding (using a different base address or size) overlaps the range of memory updated by this command, shader accesses using that binding (from commands before or after the update) will return undefined values.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the uniform buffer update.</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of the full uniform buffer to update. Must be a multiple of 256 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ac5b90148e47e9a26cd38b367123ff374" title="Minimum alignment of uniform buffer bindings. ">NVN_DEVICE_INFO_UNIFORM_BUFFER_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">bufferSize</td><td>Size (in bytes) of the full uniform buffer to update. Must be less than or equal to 65536 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3f3db4bfcb9457a4ca25046221f97409" title="Maximum size (in bytes) of a bound uniform buffer. ">NVN_DEVICE_INFO_MAX_UNIFORM_BUFFER_SIZE</a>).</td></tr>
    <tr><td class="paramname">updateOffset</td><td>Offset (in bytes) of the first byte to update inside the uniform buffer. Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3a3153b5b8aa5509e8b13aed2c8042f3" title="Alignment required (in bytes) for the offset and size of uniform buffer updates via nvnCommandBufferU...">NVN_DEVICE_INFO_UNIFORM_BUFFER_UPDATE_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">updateSize</td><td>Number of bytes to update inside the uniform buffer. Must be less than or equal to 65536 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3f3db4bfcb9457a4ca25046221f97409" title="Maximum size (in bytes) of a bound uniform buffer. ">NVN_DEVICE_INFO_MAX_UNIFORM_BUFFER_SIZE</a>). Must be a multiple of 4 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a3a3153b5b8aa5509e8b13aed2c8042f3" title="Alignment required (in bytes) for the offset and size of uniform buffer updates via nvnCommandBufferU...">NVN_DEVICE_INFO_UNIFORM_BUFFER_UPDATE_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">data</td><td>New data to write into the uniform buffer. The data is consumed before the call returns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gade6b81268dfab6d9e22de06bbd170951"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferReportCounter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga280033bdac9f8e19de62817c8d200773">NVNcounterType</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a GPU counter and timestamp into buffer object memory. </p>
<p>The GPU maintains a set of counters for each queue that will be incremented on certain events. This function requests that the current value of the counter be written to a specified offset in the specified buffer object. 16 bytes will be written to the buffer object.</p>
<p>Except for the <a class="el" href="group__nvn__c__enum.html#gga280033bdac9f8e19de62817c8d200773a70f06f4dc0079b53603c5c2632a0d470" title="Report zcull counters. ">NVN_COUNTER_TYPE_ZCULL_STATS</a> counter, the first 8 bytes hold the 64-bit counter value and the second 8 bytes hold a timestamp when the counter value was reported. <a class="el" href="group__nvn__c__enum.html#gga280033bdac9f8e19de62817c8d200773a70f06f4dc0079b53603c5c2632a0d470" title="Report zcull counters. ">NVN_COUNTER_TYPE_ZCULL_STATS</a> reports four 32-bit counter values.</p>
<dl class="section note"><dt>覚え書き</dt><dd>If tiled caching is enabled, this command will trigger an implicit tiled cache flush.</dd>
<dd>
On the NX device, timestamps are reported in units of approximately 1.625 ns. The Windows reference platform uses 1.0 ns units.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the counter report operation.</td></tr>
    <tr><td class="paramname">counter</td><td>Type of counter that will be written.</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory where the counter will be written. Must be a multiple of 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a17852f8ea9a95fc08cce83cbd2886bb1" title="Minimum alignment for counter reports. ">NVN_DEVICE_INFO_COUNTER_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_stat_tracker_8cpp-example.html#a27">StatTracker.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga49ee8eb6d0cecd901d9de38d983ceb1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferResetCounter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga280033bdac9f8e19de62817c8d200773">NVNcounterType</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a GPU counter to zero. </p>
<p>The GPU maintains a set of counters for each queue that will be incremented on certain events. This function resets the current value of the counter to zero.</p>
<dl class="section note"><dt>覚え書き</dt><dd>If tiled caching is enabled, this command will trigger an implicit tiled cache flush.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the counter reset operation.</td></tr>
    <tr><td class="paramname">counter</td><td>Type of counter that will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_stat_tracker_8cpp-example.html#a13">StatTracker.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga9642c6dc30a8a0f71464a7de155c0f2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferReportValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a GPU counter report and timestamp into buffer object memory using an application-provided value. </p>
<p>This command will cause the GPU to write a counter report (of type <a class="el" href="struct_n_v_ncounter_data.html" title="Data structure describing how counter values are written to buffer memory. ">NVNcounterData</a>) to buffer object memory, with the counter value replaced by an unsigned 32-bit value provided in the command. In the report, the first 8 bytes hold a 64-bit integer set to the provided report value and the second 8 bytes hold a timestamp when the report was performed.</p>
<dl class="section note"><dt>覚え書き</dt><dd>If tiled caching is enabled, this command will trigger an implicit tiled cache flush.</dd>
<dd>
On the NX device, timestamps are reported in units of approximately 1.625 ns. The Windows reference platform uses 1.0 ns units.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the counter report operation.</td></tr>
    <tr><td class="paramname">value</td><td>Value that be written in the counter report.</td></tr>
    <tr><td class="paramname">buffer</td><td>GPU address of buffer memory where the counter will be written. Must be a multiple of 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a17852f8ea9a95fc08cce83cbd2886bb1" title="Minimum alignment for counter reports. ">NVN_DEVICE_INFO_COUNTER_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gada2e0273010f55fc9c3a44e57320a0d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetRenderEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the render enable for a queue. </p>
<p>The render enable allows applications to disable all rendering to a queue unconditionally. If rendering is disabled for a queue, all rendering commands (framebuffer clears, Draw commands) will be discarded without any processing. Commands changing queue state will be executed even if rendering is disabled and will affect subsequent rendering commands if/when rendering is re-enabled. SetRenderEnable and SetRenderEnableConditional affect the same state in the queue.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to enable or disable rendering.</td></tr>
    <tr><td class="paramname">enable</td><td>NVN_TRUE if rendering should be enabled; NVN_FALSE if rendering should be disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa29e43ea6dbe7c77ea050ae7ae95758c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetRenderEnableConditional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae555b5b8ce83bd8c76b77f40481adc8b">NVNconditionalRenderMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>counters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables rendering for a queue, depending on the equality of counters. </p>
<p>Enable or disable rendering based on whether two 64-bit values in buffer memory are equal. If the values are written using the SAMPLES_PASSED counter, this function can be used in an implementation of occlusion culling. SetRenderEnable and SetRenderEnableConditional affect the same state in the queue.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> for which rendering should be enabled or disabled.</td></tr>
    <tr><td class="paramname">mode</td><td>NVN_CONDITIONAL_RENDER_MODE_RENDER_IF_EQUAL if rendering should be enabled if the buffer values are equal, NVN_CONDITIONAL_RENDER_MODE_RENDER_IF_NOT_EQUAL otherwise.</td></tr>
    <tr><td class="paramname">counters</td><td><a class="el" href="struct_n_v_nbuffer.html" title="Block of GPU-accessible memory used to hold data used for various purposes. ">NVNbuffer</a> address of the two values to be compared. There must be at least 32 bytes of buffer memory starting at this address. The first value is contained in the first eight bytes starting at this address, and the second value is contained in the eight bytes starting at <em>bufferAddress</em> + 16. Note that this layout is consistent with two counter query results stored consecutively in memory. Must be a multiple of 16 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a17852f8ea9a95fc08cce83cbd2886bb1" title="Minimum alignment for counter reports. ">NVN_DEVICE_INFO_COUNTER_ALIGNMENT</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae3e9cdfa2eaad5ed0f5363598fa0ce7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetRenderTargets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numColors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *const *&#160;</td>
          <td class="paramname"><em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *const *&#160;</td>
          <td class="paramname"><em>colorViews</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>depthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>depthStencilView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets color and depth/stencil textures in the framebuffer. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to program the new render targets.</td></tr>
    <tr><td class="paramname">numColors</td><td>Number of color textures in the framebuffer. If zero is specified, the framebuffer will be programmed with no color textures. Any color binding point numbered <em>numColors</em> or higher will be programmed with no color texture. Must be less than or equal to 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a9f4ab24a0b8c08e3f2b66ce04e379b16" title="Number of color buffer binding points. ">NVN_DEVICE_INFO_COLOR_BUFFER_BINDINGS</a>).</td></tr>
    <tr><td class="paramname">colors</td><td>Array of <em>numColors</em> color textures to program in the framebuffer. If any element in the array is set to NULL, the corresponding color target in the framebuffer will be programmed with no texture.</td></tr>
    <tr><td class="paramname">colorViews</td><td>Array of <em>numColors</em> color texture views to program in the framebuffer. The texture views, if specified, can be used to override properties of the corresponding texture in the array <em>colors</em>. If NULL is specified, all textures in <em>colors</em> will be used as-is. If a non-NULL array of views is specified but one or more entries in that array is NULL, the corresponding textures in <em>colors</em> will be used as-is.</td></tr>
    <tr><td class="paramname">depthStencil</td><td>Depth/stencil texture to program in the framebuffer. If NULL is specified, the framebuffer will be programmed with no depth/stencil buffer.</td></tr>
    <tr><td class="paramname">depthStencilView</td><td>Depth/stencil texture view to program in the framebuffer. A texture view, if specified, can be used to override properties of the corresponding texture <em>depthStencil</em>. If NULL is specified, the texture <em>depthStencil</em> will be used as-is. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a103">DebugTextRenderer.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a89">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a120">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a129">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a144">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a122">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a73">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a73">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a85">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a68">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a99">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gae319235f09374fb2e5968d09cfbba7f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDiscardColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discard the contents of the specified bound color render target. </p>
<p>After discarding the contents of a color render target, its values will become undefined. This command can be useful for saving memory bandwidth for 'transient' rendering operations such as rendering to a multisample texture. After rendering to a multisample texture, the contents are often filtered to produce single-sample texels using nvnCommandBufferDownsample. Discarding the contents of a multisample texture after the downsample allows the GPU to throw away its contents before writing values to memory.</p>
<p>Only the portion of the render target contained inside the current scissor rectangle will be discarded.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the discard operation.</td></tr>
    <tr><td class="paramname">index</td><td>Number of the color target whose contents should be discarded. Must be less than 8 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a9f4ab24a0b8c08e3f2b66ce04e379b16" title="Number of color buffer binding points. ">NVN_DEVICE_INFO_COLOR_BUFFER_BINDINGS</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga883170655ee34cb170ebe9475679c946"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDiscardDepthStencil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discard the contents of the currently bound depth/stencil render target. </p>
<p>After discarding the contents of a depth/stencil render target, its values will become undefined. This command can be useful for saving memory bandwidth for 'transient' rendering operations such as rendering to a depth/stencil buffer that is only used to generate a color buffer image in the same frame. Discarding the contents of a texture allows the GPU to throw away its contents before writing values to main memory.</p>
<p>Only the portion of the render target contained inside the current scissor rectangle will be discarded.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the discard operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadd85afea943735121bd9ce1755d65623"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDownsample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a filtered version of a multisample source texture to produce a single-sample destination texture. </p>
<p>This command completes the execution of all previous rendering commands before performing the downsample operation. In particular, it will flush all primitives accumulated by tiled caching logic. When using tiled caching, nvnCommandBufferTiledDownsample will perform better. This command is performed by the RSTR2D unit.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the downsample operation. When performing the downsample operation, any commands previously submitted to the queue are completed prior to the downsample. The downsample does not synchronize with commands submitted to any other queue.</td></tr>
    <tr><td class="paramname">src</td><td>Source texture for the downsample operation.</td></tr>
    <tr><td class="paramname">dst</td><td>Destination texture for the downsample operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga09ac3a51249e04fe24e778d62fa0717b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferTiledDownsample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a filtered version of a multisample source texture to produce a single-sample destination texture. </p>
<p>When tiled caching is enabled, the downsample operation performed by this command will be accumulated along with other rendered primitives. The actual downsample will be performed on a tile-by-tile basis, and may complete on one tile before regular rendering for another tile begins. When tiled caching is disabled, this command will behave similarly to nvnCommandBufferDownsample, which fully flushes previous work before starting the downsample operation. This command is performed by the 3D pipeline.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the downsample operation. When performing the downsample operation, any commands previously submitted to the queue are completed prior to the downsample. The downsample does not synchronize with commands submitted to any other queue.</td></tr>
    <tr><td class="paramname">src</td><td>Source texture for the downsample operation.</td></tr>
    <tr><td class="paramname">dst</td><td>Destination texture for the downsample operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga94e7b8993c4327a89c561af942a22388"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDownsampleTextureView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>srcView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a filtered version of a multisample source texture and texture view to produce a single-sample destination texture through a texture view. </p>
<p>This command completes the execution of all previous rendering commands before performing the downsample operation. In particular, it will flush all primitives accumulated by tiled caching logic. When using tiled caching, nvnCommandBufferTiledDownsample will perform better. This command is performed by the RSTR2D unit. The texture views may only describe one single level/layer of a texture.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the downsample operation. When performing the downsample operation, any commands previously submitted to the queue are completed prior to the downsample. The downsample does not synchronize with commands submitted to any other queue.</td></tr>
    <tr><td class="paramname">src</td><td>Source texture for the downsample operation.</td></tr>
    <tr><td class="paramname">srcView</td><td>Source texture view for the downsample operation. Selects one level/layer.</td></tr>
    <tr><td class="paramname">dst</td><td>Destination texture for the downsample operation.</td></tr>
    <tr><td class="paramname">dstView</td><td>Destination texture view for the downsample operation. Selects one level/layer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga04940df32b22af5553e256021e876f26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferTiledDownsampleTextureView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>srcView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture.html">NVNtexture</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_view.html">NVNtextureView</a> *&#160;</td>
          <td class="paramname"><em>dstView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a filtered version of a multisample source texture texture view to produce a single-sample destination texture view. </p>
<p>When tiled caching is enabled, the downsample operation performed by this command will be accumulated along with other rendered primitives. The actual downsample will be performed on a tile-by-tile basis, and may complete on one tile before regular rendering for another tile begins. When tiled caching is disabled, this command will behave similarly to nvnCommandBufferDownsample, which fully flushes previous work before starting the downsample operation. This command is performed by the 3D pipeline. The texture views must each describe only a single level/layer of a texture.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the downsample operation. When performing the downsample operation, any commands previously submitted to the queue are completed prior to the downsample. The downsample does not synchronize with commands submitted to any other queue.</td></tr>
    <tr><td class="paramname">src</td><td>Source texture for the downsample operation.</td></tr>
    <tr><td class="paramname">srcView</td><td>Source texture view for the downsample operation. Selects one level/layer.</td></tr>
    <tr><td class="paramname">dst</td><td>Destination texture for the downsample operation.</td></tr>
    <tr><td class="paramname">dstView</td><td>Destination texture view for the downsample operation. Selects one level/layer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8004a74da7c68a5424ac4466653dce34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBarrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>barrier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a barrier ordering execution of GPU commands and invalidating internal GPU caches. </p>
<p>Rendering and compute dispatch commands sent to NVN queues are executed on the GPU using a hardware pipeline, with no guarantee that work for one draw call or dispatch completes before work on the next draw call or dispatch starts. Additionally, some units of the GPU maintain caches that are not automatically invalidated when cached data are overwritten by the CPU or other units of the GPU. This command allows applications to order the processing of commands sent before and after the barrier and to invalidate GPU caches before processing commands sent after the barrier.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to insert the barrier.</td></tr>
    <tr><td class="paramname">barrier</td><td>Bitfield controlling the order of commands before and after the barrier and the invalidation of GPU caches for commands after the barrier. See <a class="el" href="group__nvn__c__enum.html#gaab4eabfc248236cc6b42d9de9d735621" title="Controls the ordering of commands and invalidation of caches for nvnCommandBufferBarrier. ">NVNbarrierBits</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_nvn_tutorial11_8cpp-example.html#a113">NvnTutorial11.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga7e5ab25595c79c070fc8dd7442a69d6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferWaitSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object to be signaled on the GPU before processing any further commands in the specified <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object whose subsequent commands wait on the <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object.</td></tr>
    <tr><td class="paramname">sync</td><td><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object to wait on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7649fa38fde42a6fc9ec32b1133d5528"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferFenceSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga6ab26a343b68da722799167ea97ec69d">NVNsyncCondition</a>&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object as signaled when all previous commands have completed in the <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object. </p>
<dl class="section warning"><dt>警告</dt><dd>FenceSync commands are not automatically flushed for processing by the GPU. Before waiting on a FenceSync call with the CPU using nvnSyncWait or from another <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> using nvnQueueWaitSync, applications must ensure that the previous FenceSync call was flushed using nvnQueueFlush. Waiting on a FenceSync call using nvnQueueWaitSync in the same queue requires no manual flush.</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>If tiled caching is enabled, this command will trigger an implicit tiled cache flush.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object with commands to wait on before signaling completion.</td></tr>
    <tr><td class="paramname">sync</td><td><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object to mark as signaled when commands complete.</td></tr>
    <tr><td class="paramname">condition</td><td>Type of command completion to wait for.</td></tr>
    <tr><td class="paramname">flags</td><td>Bitfield of additional operations to perform before signaling. See <a class="el" href="group__nvn__c__enum.html#ga5aa7e7ddcb3ce72c5b38ab55edc9f199" title="Specifies additional operations performed when a FenceSync command is processed. ">NVNsyncFlagBits</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga43781240fe1741acfa122ad4fd63b802"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetTexturePool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ntexture_pool.html">NVNtexturePool</a> *&#160;</td>
          <td class="paramname"><em>texturePool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new texture pool used for subsequent rendering operations. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used for programming new texture pool.</td></tr>
    <tr><td class="paramname">texturePool</td><td><a class="el" href="struct_n_v_ntexture_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for texture objects. ">NVNtexturePool</a> object to be programmed. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_texture_i_d_manager_8cpp-example.html#a19">TextureIDManager.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga71cd4e0a83ae73c92c76333d3adc6212"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetSamplerPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsampler_pool.html">NVNsamplerPool</a> *&#160;</td>
          <td class="paramname"><em>samplerPool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a new sampler pool used for subsequent rendering operations. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used for programming new sampler pool.</td></tr>
    <tr><td class="paramname">samplerPool</td><td><a class="el" href="struct_n_v_nsampler_pool.html" title="Block of GPU-accessible memory that can be used to store descriptors for sampler objects. ">NVNsamplerPool</a> object to be programmed. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_texture_i_d_manager_8cpp-example.html#a18">TextureIDManager.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gafccbb352a6e0b28138c1a1e727fc1f83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetShaderScratchMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify scratch memory required for shader execution. </p>
<p>The scratch memory provided by this function allows shaders to require temporary (scratch) memory during execution to save the results of intermediate computations or flow control state. Each queue has its own block of scratch memory, programmed via command buffers. Scratch memory will be shared by all active shaders running on the queue. Multiple queues can share the same block of scratch memory.</p>
<p>Each compiled shader will report a minimum and recommended amount of scratch memory required. We recommend that applications provide the largest recommended amount of scratch memory for optimal performance. Providing less memory may resolve in lower shader performance, and providing less than the minimum amount of memory will result in crashes. For more information, consult the programming guide.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used for programming new scratch memory.</td></tr>
    <tr><td class="paramname">pool</td><td>Memory pool providing storage for the shader scratch memory.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) of the first byte of shader scratch memory. Must be a multiple of 4096 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50ad7057e277907059442d45e1a1af16b70" title="Alignment required (in bytes) for the shader scratch memory. ">NVN_DEVICE_INFO_SHADER_SCRATCH_MEMORY_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the scratch memory. Must be a multiple of 131072 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50af0acd8cf2a4d4b92edcd57fc887e5526" title="Required granularity for shader scratch memory provided to NVN. ">NVN_DEVICE_INFO_SHADER_SCRATCH_MEMORY_GRANULARITY</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_gfx_simple_8cpp-example.html#a222">GfxSimple.cpp</a>, <a class="el" href="_mii_compressed_texture_8cpp-example.html#a440">MiiCompressedTexture.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaaf22d0bc677beea73eac74721ddfb325"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSaveZCullData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the current ZCull state for the current depth render target. </p>
<p>The ZCull unit of the GPU tracks the contents of the currently bound depth render target and uses this information to perform high-speed depth and stencil testing. When applications switch between depth render targets, ZCull discards tracking information for the old render target. This command allows applications to instead save the ZCull state to buffer memory so that it can be later restored when switching back to the old target. When saving information for a depth render target, SaveZCullData should be called immediately before switching render targets.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the operation.</td></tr>
    <tr><td class="paramname">dst</td><td>GPU address of buffer object memory where the ZCull contents will be stored. Must be a multiple of 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a0ed594e80e327869a5f693ae2cdc2835" title="Minimum alignment for ZCull save/restore buffers. ">NVN_DEVICE_INFO_ZCULL_SAVE_RESTORE_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the destination buffer. To determine the amount of memory required to save and restore ZCull data, call <a class="el" href="group__nvn__c__functions.html#ga73cb447f019bda7152e2ab27a5a9156d" title="Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth text...">nvnTextureGetZCullStorageSize()</a> or <a class="el" href="group__nvn__c__functions.html#gaa00aaba8acd99e423733589231ac411a" title="Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth text...">nvnTextureBuilderGetZCullStorageSize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad6f7056d3e1f5a0c04ebfb301bf26a22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferRestoreZCullData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#ga067da3a838f115226c89fad655278f80">NVNbufferAddress</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the current ZCull state to use saved state from a previous render target. </p>
<p>The ZCull unit of the GPU tracks the contents of the currently bound depth render target and uses this information to perform high-speed depth and stencil testing. When applications switch between depth render targets, ZCull discards tracking information for the old render target. This command allows applications restore previously saved ZCull state from buffer memory so that it can be used when continuing to render to the new target. When restoring information for a depth render target, RestoreZCullData should be called immediately after switching render targets.</p>
<dl class="section warning"><dt>警告</dt><dd>The data restored by this command must have been previously saved by nvnCommandBufferSaveZCullData. Additionally, the same depth/stencil texture and texture view must be bound as a render target at the time of the restore and the previous save. In case of a mismatch, the results of the restore are undefined and may result in GPU exceptions.</dd>
<dd>
If the current contents of the depth render target are inconsistent with the contents of the render target when SaveZCullData was called, the state written by RestoreZCullData is invalid and the results of depth and stencil testing are undefined.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the operation.</td></tr>
    <tr><td class="paramname">src</td><td>GPU address of buffer object memory where the ZCull contents will be loaded from. Must be a multiple of 32 (the value of <a class="el" href="group__nvn__c__enum.html#ggac887e20e2474bb76b87943b0f0be7a50a0ed594e80e327869a5f693ae2cdc2835" title="Minimum alignment for ZCull save/restore buffers. ">NVN_DEVICE_INFO_ZCULL_SAVE_RESTORE_ALIGNMENT</a>).</td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the source buffer. To determine the amount of memory required to save and restore ZCull data, call <a class="el" href="group__nvn__c__functions.html#ga73cb447f019bda7152e2ab27a5a9156d" title="Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth text...">nvnTextureGetZCullStorageSize()</a> or <a class="el" href="group__nvn__c__functions.html#gaa00aaba8acd99e423733589231ac411a" title="Returns the amount of memory (in bytes) required to hold a ZCull save/restore buffer for a depth text...">nvnTextureBuilderGetZCullStorageSize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6face2746fa0f109f61ba3d3b349fb9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetCopyRowStride </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the row stride used for copies between buffer and texture memory. </p>
<p>This command sets the stride (in bytes) between rows of texels in buffer memory when copying texels between buffer and texture memory. With the default stride of zero (default), texel data in buffer memory will be treated as densely packed, where each new row in memory starts immediately after the end of the previous row.</p>
<dl class="section note"><dt>覚え書き</dt><dd>Setting a stride affects any subsequent calls to nvnCommandBufferCopyBufferToTexture and nvnCommandBufferCopyTextureToBuffer using this command buffer. Unlike most <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> calls, this command does not store the stride in command or control memory and does not affect future submissions of previously recorded copy commands or copy commands recorded using other command buffers.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object used to store row stride.</td></tr>
    <tr><td class="paramname">stride</td><td>Stride (in bytes) between rows of texels in buffer memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga58fb857e055afc2512209f671e3d89ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetCopyImageStride </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the image stride used for copies between buffer and texture memory. </p>
<p>This command sets the stride (in bytes) between layers of texels in buffer memory when copying texels between buffer and texture memory. With the default stride of zero (default), texel data in buffer memory will be treated as densely packed, where each new layer in memory starts immediately after the end of the previous layer.</p>
<dl class="section note"><dt>覚え書き</dt><dd>Setting a stride affects any subsequent calls to nvnCommandBufferCopyBufferToTexture and nvnCommandBufferCopyTextureToBuffer using this command buffer. Unlike most <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> calls, this command does not store the stride in command or control memory and does not affect future submissions of previously recorded copy commands or copy commands recorded using other command buffers.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object used to store image stride.</td></tr>
    <tr><td class="paramname">stride</td><td>Stride (in bytes) between 2D arrays of texels in buffer memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaca29ca51ef0664b03280efdcc1e36323"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnCommandBufferGetCopyRowStride </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current copy row stride stored in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga72e2b27a9a418f0eb48b0675c47809b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nvnCommandBufferGetCopyImageStride </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current copy image stride stored in a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga95fc32406d14d9b4674ffc3dba52e465"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferDrawTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__handle.html#gaa1a1fc7a9e690ce93870bcd71ea6b446">NVNtextureHandle</a>&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndraw_texture_region.html">NVNdrawTextureRegion</a> *&#160;</td>
          <td class="paramname"><em>dstRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ndraw_texture_region.html">NVNdrawTextureRegion</a> *&#160;</td>
          <td class="paramname"><em>srcRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws an on-screen rectangle displaying the contents of a provided texture. </p>
<p>This command renders an axis-aligned rectangle into color target zero of the framebuffer, displaying some or all of the contents of a two-dimensional texture or rectangle texture. The caller specifies a texture handle identifying the source texture, a destination region in window coordinates, and a source region in non-normalized texture coordinates. For each fragment produced by the rectangle, DrawTexture computes coordinates in the source region, performs a texture lookup, and uses the texture result as the fragment color. Most per-fragment operations (including blending) are performed, and the results are written into color target zero.</p>
<p>DrawTexture has a number of limitations. Using illegal state may result in undefined behavior or GPU errors:</p><ul>
<li>The source texture must be two-dimensional (or rectangle).</li>
<li>Level of detail selection is not supported; level zero of the original texture is used.</li>
<li>Calling DrawTexture with multiple color targets is illegal.</li>
<li>Calling DrawTexture with blend modes selecting a second source color is illegal.</li>
<li>Conservative rasterization is treated as disabled.</li>
<li>Depth, depth bounds, and stencil tests are treated as disabled.</li>
<li>Anisotropic filtering and wrap modes that mirror or repeat are unsupported.</li>
</ul>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the operation.</td></tr>
    <tr><td class="paramname">texture</td><td>Handle for the pair of <a class="el" href="struct_n_v_ntexture.html" title="Block of GPU-accessible memory and related state used to hold image data. ">NVNtexture</a> and <a class="el" href="struct_n_v_nsampler.html" title="GPU-accessible object controlling how texture data are fetched and filtered. ">NVNsampler</a> objects to use.</td></tr>
    <tr><td class="paramname">dstRegion</td><td>Region identifying the portion of the color target to update. Coordinates (x0,y0) and (x1,y1) identify opposite corners of the region, in screen coordinates. All coordinates must be in the range [-65536, +65535], and x1-x0 and y1-y0 must be in the range [0, 65535].</td></tr>
    <tr><td class="paramname">srcRegion</td><td>Region identifying the portion of <em>texture</em> to access. Coordinates (x0,y0) and (x1,y1) identify opposite corners of the region, in non-normalized texel coordinates. All coordinates must be in the range [-65536, +65535]. The texture region will be mirrored horizontally and/or vertically if x0 &gt; x1 or y0 &gt; y1, respectively. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafe101d51f91200d5c59c756b8f754961"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnProgramSetSubroutineLinkage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__c__api__typedefs.html#gab66e1162e92eb9ed7611be8e01118116">NVNsubroutineLinkageMapPtr</a> *&#160;</td>
          <td class="paramname"><em>linkageMapPtrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the program's subroutine linkage maps for future use with nvnCommandBufferSetProgramSubroutines. </p>
<p>When using shader subroutines, applications update the values of subroutine uniforms using nvnCommandBufferSetProgramSubroutines. Such updates require the driver to adjust function pointers and related data to reflect the new uniform values. This linkage mapping must be set before submitting any commands from a nvnCommandBufferSetProgramSubroutines call. For each shader stage with subroutines, the compiler provides a <em>linkage map</em> that applications must provide to the driver to support subroutine updates. The linkage maps for a program must be set before binding the program or attempting to update subroutine uniforms. The linkage maps must be exactly what the compiler outputs for the input program in order for correctness. If the driver detects any inconsistencies between the input linkage maps and what the program requires, such as not providing linkage maps for all the stages of the program that use subroutines, NVN_FALSE is returned. Additionally, the data may be modified internally by the driver, so the data backed by this pointer must remain live for the lifetime of the program after calling SetSubroutineLinkage, and must not be modified by the application. The driver might also write to the contents of the linkage map during run-time.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives. ">NVNprogram</a> object to set up.</td></tr>
    <tr><td class="paramname">count</td><td>Number of linkage maps to use, one for each shader stage that uses subroutines.</td></tr>
    <tr><td class="paramname">linkageMapPtrs</td><td>An array of subroutine linkage map pointers where each subroutine linkage map was produced by the offline compiler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8b099e33e61c1f1f74d4b827c1751f00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetProgramSubroutines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nprogram.html">NVNprogram</a> *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac99deb2b11df8b0358f73a92e2a2abdd">NVNshaderStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the subroutine uniform parameters. </p>
<p>Sets subroutine uniform parameters for program subroutine, similar to the ARB_shader_subroutine functionality in OpenGL. Subroutines allow a application to dynamically switch between using different sets of functions instead without having to recompile the program, similar to setting function pointers in C-based languages. In order to use this feature, some linkage information from the offline compiler needs to be set in the program first via a call to SetSubroutineLinkage. This function allows a program to set a range of uniform locations to point to the input subroutines denoted by the index values in the array <em>values</em>. See the offline compiler documentation and the NVN documentation for more information on how to use this feature.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the operation.</td></tr>
    <tr><td class="paramname">program</td><td><a class="el" href="struct_n_v_nprogram.html" title="Collection of programmable shaders used to process primitives. ">NVNprogram</a> object to perform the operation on.</td></tr>
    <tr><td class="paramname">stage</td><td>Shader stage to update.</td></tr>
    <tr><td class="paramname">first</td><td>First subroutine uniform location in the program to update, and corresponds to the first array entry in the <em>values</em> input.</td></tr>
    <tr><td class="paramname">count</td><td>Number of subroutine uniform locations to update, starting with uniform with location <em>first</em>, and corresponds to the number of entries in the input array <em>values</em>.</td></tr>
    <tr><td class="paramname">values</td><td>An array of <em>count</em> subroutine index values to be assigned to successive subroutine uniform locations, where the first entry in the array corresponds to subroutine uniform location <em>first</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga904b069b58abb45362b69d4373a501fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferBindCoverageModulationTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>entries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds or unbinds a coverage modulation table used for target-independent rasterization. </p>
<p>By default, the color modulation feature of target-independent rasterization scales color using a factor based on the fraction of covered samples. For example, if three out of four samples for a fragment are covered, the default modulation factor will be 0.75. This function allows applications to override this behavior by specifying a 16-element table of modulation factors. If the modulation table is used with a render target with N raster samples per color sample and M samples are covered in a fragment, the modulation factor will be <em>entries</em>[(M-1) * 16 / N]. If no modulation table is bound (i.e., <em>entries</em> is NULL), the modulation factor will be M / N.</p>
<p>By default, no modulation table is bound.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the operation.</td></tr>
    <tr><td class="paramname">entries</td><td>Table of color modulation factors. If NULL, color modulation will use the fraction of covered raster samples as the color modulation factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2f474458657c1fea18b88dd48777b581"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferResolveDepthBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve depth values in a compressible depth render target. </p>
<p>Compressible depth render targets may store depth values in a compressed form, where individual values are reconstructed using compressed depth data and the current set of sample locations. This command decompresses the depth buffer, resolving individual depth values based on the current sample locations. This command should be used in the unlikely event that an application needs to change sample locations for a render target but use depth values that reflect the old locations. It is not necessary to decompress depth render targets for any other reason, including to use them for texture mapping. If there is no current depth render target, this command will have no effect.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to perform the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga41c02cd9b5c931fd6b233b48ca245daa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetColorReductionEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable color reduction. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the enable or disable operation.</td></tr>
    <tr><td class="paramname">enable</td><td>If NVN_TRUE, enable color reduction. Otherwise disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga75a746908aa8a2688d6269f5441bf758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetColorReductionThresholds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gac983c7ec7de25e7b97dacc14b163b5a5">NVNformatClass</a>&#160;</td>
          <td class="paramname"><em>formatClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thresholdConservative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thresholdAggressive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify new color reduction thresholds for a format class. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td>Command buffer used to perform the Set operation.</td></tr>
    <tr><td class="paramname">formatClass</td><td><a class="el" href="group__nvn__c__enum.html#ga99463f5b9af6151e604b01dfdd5fecab" title="Identifies how data elements stored in texture or buffer objects are encoded. ">NVNformat</a> class for which to set thresholds</td></tr>
    <tr><td class="paramname">thresholdConservative</td><td>Color reduction threshold for possible primitive edges. This threshold is used if a tile is used for more than one rasterization operation before flushing to L2 cache.</td></tr>
    <tr><td class="paramname">thresholdAggressive</td><td>Color reduction threshold for interior pixels. This threshold is used if a tile is used for exactly once in a rasterization operation before flushing to L2 cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga54bb644ef7005a664579254b47587c93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferPushDebugGroupStatic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes a debug group into the command stream. </p>
<p>Debug groups provide a method for annotating a command stream with discrete groups of commands using a descriptive name. New debug groups are pushed to the top of the debug group stack. Debug groups are strictly hierarchical and their sequences may be nested within other debug groups but can not overlap. These groups may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<p>This entry point is for use with debug groups whose description is comprised of a static string.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to push the new debug group.</td></tr>
    <tr><td class="paramname">domainId</td><td>Debug domain ID.</td></tr>
    <tr><td class="paramname">description</td><td>Text string used to annotate the debug group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf4877bd1b7b58d555d274260de7bae4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferPushDebugGroupDynamic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes a debug group into the command stream. </p>
<p>Debug groups provide a method for annotating a command stream with discrete groups of commands using a descriptive name. New debug groups are pushed to the top of the debug group stack. Debug groups are strictly hierarchical and their sequences may be nested within other debug groups but can not overlap. These groups may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<p>This entry point is for use with debug groups whose description is comprised of a dynamic string.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to push the new debug group.</td></tr>
    <tr><td class="paramname">domainId</td><td>Debug domain ID.</td></tr>
    <tr><td class="paramname">description</td><td>Text string used to annotate the debug group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac328ee49a5aecdaf097da8d156837955"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferPushDebugGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes a debug group into the command stream. </p>
<p>Debug groups provide a method for annotating a command stream with discrete groups of commands using a descriptive name. New debug groups are pushed to the top of the debug group stack. Debug groups are strictly hierarchical and their sequences may be nested within other debug groups but can not overlap. These groups may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<p>This entry point is equivalent to calling nvnCommandBufferPushDebugGroupStatic with a debug domain ID of 0.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to push the new debug group.</td></tr>
    <tr><td class="paramname">description</td><td>Text string used to annotate the debug group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9e093d931066afbd07f7dc62f728a1d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferPopDebugGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops the active debug group off the command stream. </p>
<p>This entry point is equivalent to calling nvnCommandBufferPopDebugGroupId with a debug domain ID of 0.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to pop the debug group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab9a3654de302a8d7725d78a793f47571"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferPopDebugGroupId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domainId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops the active debug group off the command stream. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to pop the debug group.</td></tr>
    <tr><td class="paramname">domainId</td><td>Debug domain ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga68f148606bec51c995b3b86f851c5b09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferInsertDebugMarkerStatic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a debug event marker to the command stream. </p>
<p>Inserts a debug marker to annotate a command stream with a descriptive text marker. These event markers may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<p>This entry point is for use with debug markers whose description is comprised of a static string.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to add the event marker.</td></tr>
    <tr><td class="paramname">domainId</td><td>Debug domain ID.</td></tr>
    <tr><td class="paramname">description</td><td>Text string used to annotate the event marker. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5c7249b1f6594352ac6ab0acb35703a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferInsertDebugMarkerDynamic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domainId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a debug event marker to the command stream. </p>
<p>Inserts a debug marker to annotate a command stream with a descriptive text marker. These event markers may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<p>This entry point can be used with dynamically allocated strings, as it copies the data onto the command buffer itself.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to add the event marker.</td></tr>
    <tr><td class="paramname">domainId</td><td>Debug domain ID.</td></tr>
    <tr><td class="paramname">description</td><td>Text string used to annotate the event marker. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4d91848e0c99bad0ca343ba3710278e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferInsertDebugMarker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a debug event marker to the command stream. </p>
<p>Inserts a debug marker to annotate a command stream with a descriptive text marker. These event markers may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<p>This entry point is identical to nvnCommandBufferInsertDebugMarkerStatic with a domainId of 0.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> used to add the event marker.</td></tr>
    <tr><td class="paramname">description</td><td>Text string used to annotate the event marker. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1b241dbc3db41646a27cf4fe10ef3538"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__funcptrs.html#gab918942b035dac79abd29dfb506823d9">PFNNVNCOMMANDBUFFERMEMORYCALLBACKPROC</a> nvnCommandBufferGetMemoryCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query a callback function for a <a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object that will be called if it runs out of memory. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaf726c18072c4b8ece85794276cfd991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nvnCommandBufferGetMemoryCallbackData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query a generic pointer that will be passed to a callback function if the command buffer runs out of memory. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf0790bc37a5893867aa5258dfbfe7923"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnCommandBufferIsRecording </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether the command buffer is currently recording. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad8eeff0f19eaa7bb9b57ea8134411baa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnSyncInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_ndevice.html">NVNdevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object for the specified device. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object to initialize.</td></tr>
    <tr><td class="paramname">device</td><td><a class="el" href="struct_n_v_ndevice.html" title="API class used to represent a specific GPU/device. ">NVNdevice</a> owning the <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a12">DebugTextRenderer.cpp</a>, <a class="el" href="_frame_buffer_manager_8cpp-example.html#a4">FrameBufferManager.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a45">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a56">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a56">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a54">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a47">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a64">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a64">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a61">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a52">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a65">NvnTutorial11.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a7">StatTracker.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga918f1f02b17ba89d048372ead736a929"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSyncFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>sync</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a101">DebugTextRenderer.cpp</a>, <a class="el" href="_frame_buffer_manager_8cpp-example.html#a13">FrameBufferManager.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a63">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a102">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a111">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a152">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a109">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a80">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a80">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a57">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a139">NvnTutorial11.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a31">StatTracker.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga052a5bc70782ffe27301d0e317e6382b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnSyncSetDebugLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object. </p>
<p>Annotates a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object to set debug label.</td></tr>
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae646129720b27503c239a22db9653fa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnQueueFenceSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga6ab26a343b68da722799167ea97ec69d">NVNsyncCondition</a>&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object as signaled when all previous commands have completed in the <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object. </p>
<dl class="section warning"><dt>警告</dt><dd>FenceSync commands are not automatically flushed for processing by the GPU. Before waiting on a FenceSync call with the CPU using nvnSyncWait or from another <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> using nvnQueueWaitSync, applications must ensure that the previous FenceSync call was flushed using nvnQueueFlush. Waiting on a FenceSync call using nvnQueueWaitSync in the same queue requires no manual flush.</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>If tiled caching is enabled, this command will trigger an implicit tiled cache flush.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object with commands to wait on before signaling completion.</td></tr>
    <tr><td class="paramname">sync</td><td><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object to mark as signaled when commands complete.</td></tr>
    <tr><td class="paramname">condition</td><td>Type of command completion to wait for.</td></tr>
    <tr><td class="paramname">flags</td><td>Bitfield of additional operations to perform before signaling. See <a class="el" href="group__nvn__c__enum.html#ga5aa7e7ddcb3ce72c5b38ab55edc9f199" title="Specifies additional operations performed when a FenceSync command is processed. ">NVNsyncFlagBits</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a55">DebugTextRenderer.cpp</a>, <a class="el" href="_frame_buffer_manager_8cpp-example.html#a5">FrameBufferManager.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a69">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a109">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a118">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a109">NvnTutorial05.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a17">StatTracker.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga2e9deb5d068866fe0c32929a3f82baf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nvn__c__enum.html#ga52ff133a79fc03ef1f60a3e7946332a1">NVNsyncWaitResult</a> nvnSyncWait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeoutNs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object to be signaled on the CPU before returning. </p>
<p>The value returned indicates the status of the <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object when the command returns.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object to wait on.</td></tr>
    <tr><td class="paramname">timeoutNs</td><td>Minimum time (in nanoseconds) to wait for the <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object to be signaled. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_debug_text_renderer_8cpp-example.html#a58">DebugTextRenderer.cpp</a>, <a class="el" href="_frame_buffer_manager_8cpp-example.html#a9">FrameBufferManager.cpp</a>, <a class="el" href="_nvn_tutorial01_8cpp-example.html#a72">NvnTutorial01.cpp</a>, <a class="el" href="_nvn_tutorial03_8cpp-example.html#a112">NvnTutorial03.cpp</a>, <a class="el" href="_nvn_tutorial04_8cpp-example.html#a121">NvnTutorial04.cpp</a>, <a class="el" href="_nvn_tutorial05_8cpp-example.html#a112">NvnTutorial05.cpp</a>, <a class="el" href="_nvn_tutorial06_8cpp-example.html#a116">NvnTutorial06.cpp</a>, <a class="el" href="_nvn_tutorial07_8cpp-example.html#a86">NvnTutorial07.cpp</a>, <a class="el" href="_nvn_tutorial08_8cpp-example.html#a86">NvnTutorial08.cpp</a>, <a class="el" href="_nvn_tutorial09_8cpp-example.html#a97">NvnTutorial09.cpp</a>, <a class="el" href="_nvn_tutorial10_8cpp-example.html#a78">NvnTutorial10.cpp</a>, <a class="el" href="_nvn_tutorial11_8cpp-example.html#a163">NvnTutorial11.cpp</a>, <a class="el" href="_stat_tracker_8cpp-example.html#a21">StatTracker.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaad28b8279c1f539d143c1902212df11f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnQueueWaitSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nqueue.html">NVNqueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nsync.html">NVNsync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object to be signaled on the GPU before processing any further commands in the specified <a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td><a class="el" href="struct_n_v_nqueue.html" title="API class used to send commands to the GPU. ">NVNqueue</a> whose subsequent commands wait on the <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object.</td></tr>
    <tr><td class="paramname">sync</td><td><a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> object to wait on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf9cbb0430ea71279858b791e61bbddae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnEventBuilderSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects. ">NVNeventBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects. ">NVNeventBuilder</a> object to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga220c8fbd5686a7d0bb8629205ad0ce7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnEventBuilderSetStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the location in a <a class="el" href="struct_n_v_nmemory_pool.html" title="Block of GPU-accessible memory that can be used for storage of buffer and texture objects...">NVNmemoryPool</a> used to hold the state of an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> created from the <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects. ">NVNeventBuilder</a>. </p>
<p>Each <a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object created by an event builder has a 32-bit unsigned integer value stored in GPU-accessible memory in a memory pool. API commands are provided to read and write to this value and to wait for it to reach a specified value. When an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object is initialized, its initial value comes from the current contents of the associated storage.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects. ">NVNeventBuilder</a> object to modify.</td></tr>
    <tr><td class="paramname">pool</td><td>Memory pool used to hold the state of the event. If the event is signaled or queried by the CPU, a CPU_UNCACHED memory pool is recommended. If a CPU_CACHED memory pool is used, the event object's memory must be flushed from the CPU data cache using nvnMemoryPoolFlushMappedRange after calling nvnEventSignal and must be invalidated from the CPU data cache using nvnMemoryPoolInvalidateMappedRange before calling nvnEventGetValue. Memory pools created with the VIRTUAL, PHYSICAL, and GPU_NO_ACCESS flags are not supported. Memory pools created with GPU_CACHED are only supported if the pool also uses CPU_NO_ACCESS. Memory pools created with CPU_CACHED are not supported on the Windows reference implementation.</td></tr>
    <tr><td class="paramname">offset</td><td>offset in <em>pool</em> for event write back location. <em>offset</em> must be aligned to the size of an event which is a 32-bit unsigned integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga798a91d0cfa6b69b33678a78631f6d38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_nmemory_pool.html">NVNmemoryPool</a>* nvnEventBuilderGetStorage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the memory pool and the offset associated with this <a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects. ">NVNeventBuilder</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects. ">NVNeventBuilder</a> object to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">offset</td><td>Offset into the memory pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga969cdf368faed960c33d23f25d72e16b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvnEventInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nevent.html">NVNevent</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nevent_builder.html">NVNeventBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object to initialize.</td></tr>
    <tr><td class="paramname">builder</td><td><a class="el" href="struct_n_v_nevent_builder.html" title="Object specifying state used to construct new event objects. ">NVNeventBuilder</a> object to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3396c994019a4149ee5cf81d6fdf368c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnEventFinalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nevent.html">NVNevent</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object to finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga95d214178cd0d00385e74cba7b2c2b76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nvnEventGetValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value associated with an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8ea5599a30f15446978d9b535e3aabf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnEventSignal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_nevent.html">NVNevent</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae0c7c9637d4f93ea56fc315c97f17a7e">NVNeventSignalMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the CPU to signal an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object to initialize.</td></tr>
    <tr><td class="paramname">mode</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> signal mode.</td></tr>
    <tr><td class="paramname">value</td><td>Signal value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga81d0bfe6252b8f44e1b0a3607856d71c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferWaitEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga6062c139aaf05b84d9c59913ff914cad">NVNeventWaitMode</a>&#160;</td>
          <td class="paramname"><em>waitMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause work on the GPU until an event is signaled. </p>
<p>When applications use this command, they are required to ensure that the memory associated with the event will eventually contain a value that passes the test specified by <em>waitMode</em>. If not, a GPU timeout error will occur.</p>
<dl class="section warning"><dt>警告</dt><dd>On the Windows reference implementation, <a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> objects do not support synchronization between queues. Submitting a command set containing a WaitEvent command on one queue to wait on an event signaled by a nvnCommandBufferSignalEvent command submitted to another queue may result in GPU timeout errors. Applications can use <a class="el" href="struct_n_v_nsync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">NVNsync</a> objects to reliably synchronize between queues on all platforms.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to use.</td></tr>
    <tr><td class="paramname">event</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object to wait on.</td></tr>
    <tr><td class="paramname">waitMode</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> wait mode. The wait mode specifies a test use to compare the value in memory associated with the <a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object and the <em>value</em> provided in this command. The event is considered to be signaled when this test passes.</td></tr>
    <tr><td class="paramname">value</td><td>Value to compare to the value in the <a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object's memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae26f02577d10f5b39bb432d34d4b8649"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSignalEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_n_v_nevent.html">NVNevent</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gae0c7c9637d4f93ea56fc315c97f17a7e">NVNeventSignalMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#ga46d20cb478c11853f23d27890c28f4ee">NVNeventSignalLocation</a>&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the GPU to signal an <a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to use.</td></tr>
    <tr><td class="paramname">event</td><td><a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object to signal.</td></tr>
    <tr><td class="paramname">mode</td><td>Method used to update the memory associated with the <a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object.</td></tr>
    <tr><td class="paramname">location</td><td>Location in the GPU pipeline that the command must reach before the signal operation is performed.</td></tr>
    <tr><td class="paramname">flags</td><td>Flags used to control the signal operation. See <a class="el" href="group__nvn__c__enum.html#ga3a070a6e8b4c2fe6b7dfaa5caffab64f" title="Flags controlling the behavior of CommnadBuffer::SignalEvent. ">NVNeventSignalFlags</a>.</td></tr>
    <tr><td class="paramname">value</td><td>Value used to update the memory associated with the <a class="el" href="struct_n_v_nevent.html" title="NVNevent object. ">NVNevent</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3fdbe92539c8703c2e92cec46a3ce654"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvnCommandBufferSetStencilCullCriteria </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_v_ncommand_buffer.html">NVNcommandBuffer</a> *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvn__c__enum.html#gab50861ff9b46503782bb66c4edb734ae">NVNstencilFunc</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the criteria that is used by the ZCull HW for stencil culling. </p>
<p>This function sets the criteria that is used by the ZCull HW for stencil culling. ZCull will only try to discard pixels/fragments if the cull criteria matches the current stencil state and if the depth texture of the current render target was created using the ZCULL_SUPPORT_STENCIL flag. Note that calling this function will make the current ZCull region invalid until the next clear. This might have a negative impact on the depth culling performance.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuf</td><td><a class="el" href="struct_n_v_ncommand_buffer.html" title="Collection of commands to send to the GPU via queues. ">NVNcommandBuffer</a> object to use.</td></tr>
    <tr><td class="paramname">func</td><td>Stencil function to be used for stencil culling.</td></tr>
    <tr><td class="paramname">ref</td><td>Specify a stencil reference value used for stencil culling.</td></tr>
    <tr><td class="paramname">mask</td><td>Mask used for stencil culling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
