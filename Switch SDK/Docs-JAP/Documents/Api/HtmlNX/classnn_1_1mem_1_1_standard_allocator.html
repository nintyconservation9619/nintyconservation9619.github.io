<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>NintendoSDK API Reference: nn::mem::StandardAllocator クラス</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>総合概要</span></a></li>
      <li><a href="pages.html"><span>諸情報</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>名前空間</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>クラス一覧</span></a></li>
      <li><a href="classes.html"><span>クラス索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>クラスメンバ</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1mem.html">mem</a></li><li class="navelem"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html">StandardAllocator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">クラス</a> &#124;
<a href="#pub-types">公開型</a> &#124;
<a href="classnn_1_1mem_1_1_standard_allocator-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">nn::mem::StandardAllocator クラス</div>  </div>
</div><!--header-->
<div class="contents">

<p>メモリ管理のためのクラスです  
 <a href="classnn_1_1mem_1_1_standard_allocator.html#details">[詳解]</a></p>

<p><code>#include &lt;nn/mem/mem_StandardAllocator.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
クラス</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1mem_1_1_standard_allocator_1_1_allocator_hash.html">AllocatorHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">アロケータの内部状態を取得するための型です。  <a href="structnn_1_1mem_1_1_standard_allocator_1_1_allocator_hash.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
公開型</h2></td></tr>
<tr class="memitem:a95dd2800aef14ef0508282fd508fedcb"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a95dd2800aef14ef0508282fd508fedcb">WalkCallback</a>) (void *addr, size_t size, void *userPtr)</td></tr>
<tr class="memdesc:a95dd2800aef14ef0508282fd508fedcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">確保されたメモリ領域を巡るときに呼び出されるコールバック関数の型です。  <a href="#a95dd2800aef14ef0508282fd508fedcb">[詳解]</a><br /></td></tr>
<tr class="separator:a95dd2800aef14ef0508282fd508fedcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">コンストラクタ・デストラクタ</div></td></tr>
<tr class="memitem:a0e7e99aededf6ded0c7bdf01fbef21e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a0e7e99aededf6ded0c7bdf01fbef21e1">StandardAllocator</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0e7e99aededf6ded0c7bdf01fbef21e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンストラクタです。  <a href="#a0e7e99aededf6ded0c7bdf01fbef21e1">[詳解]</a><br /></td></tr>
<tr class="separator:a0e7e99aededf6ded0c7bdf01fbef21e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3efc1b684befdaa9d3ea4c08fc8c23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a1e3efc1b684befdaa9d3ea4c08fc8c23">StandardAllocator</a> (void *addr, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1e3efc1b684befdaa9d3ea4c08fc8c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンストラクタです。  <a href="#a1e3efc1b684befdaa9d3ea4c08fc8c23">[詳解]</a><br /></td></tr>
<tr class="separator:a1e3efc1b684befdaa9d3ea4c08fc8c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdb91a0ab9c236c97866b385659d35e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#affdb91a0ab9c236c97866b385659d35e">StandardAllocator</a> (void *addr, size_t size, bool isCacheEnable) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:affdb91a0ab9c236c97866b385659d35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンストラクタです。スレッド毎のキャッシュ機能の有効・無効が選択できます。  <a href="#affdb91a0ab9c236c97866b385659d35e">[詳解]</a><br /></td></tr>
<tr class="separator:affdb91a0ab9c236c97866b385659d35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254da7aa9f98eb4947ce540c28727644"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a254da7aa9f98eb4947ce540c28727644">~StandardAllocator</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a254da7aa9f98eb4947ce540c28727644"><td class="mdescLeft">&#160;</td><td class="mdescRight">デストラクタです。  <a href="#a254da7aa9f98eb4947ce540c28727644">[詳解]</a><br /></td></tr>
<tr class="separator:a254da7aa9f98eb4947ce540c28727644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">初期化・終了処理</div></td></tr>
<tr class="memitem:acdb0dd01602811a4f469c87c348d3ed1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#acdb0dd01602811a4f469c87c348d3ed1">Initialize</a> (void *addr, size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acdb0dd01602811a4f469c87c348d3ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたメモリ領域を <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="メモリ管理のためのクラスです ">StandardAllocator</a> で管理するために初期化します。  <a href="#acdb0dd01602811a4f469c87c348d3ed1">[詳解]</a><br /></td></tr>
<tr class="separator:acdb0dd01602811a4f469c87c348d3ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb339622a4d7801fd791afe25a8ed81a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#aeb339622a4d7801fd791afe25a8ed81a">Initialize</a> (void *addr, size_t size, bool isCacheEnable) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aeb339622a4d7801fd791afe25a8ed81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定されたメモリ領域を <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="メモリ管理のためのクラスです ">StandardAllocator</a> で管理するために初期化します。スレッド毎のキャッシュ機能の有効・無効が選択できます。  <a href="#aeb339622a4d7801fd791afe25a8ed81a">[詳解]</a><br /></td></tr>
<tr class="separator:aeb339622a4d7801fd791afe25a8ed81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6027bb6b016064edb1b007651d4af419"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a6027bb6b016064edb1b007651d4af419">Finalize</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6027bb6b016064edb1b007651d4af419"><td class="mdescLeft">&#160;</td><td class="mdescRight">アロケータを破棄します。  <a href="#a6027bb6b016064edb1b007651d4af419">[詳解]</a><br /></td></tr>
<tr class="separator:a6027bb6b016064edb1b007651d4af419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">メモリ領域操作 API</div></td></tr>
<tr class="memitem:a53438b7a6199e4f100c59312d2f123cf"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a53438b7a6199e4f100c59312d2f123cf">Allocate</a> (size_t size) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a53438b7a6199e4f100c59312d2f123cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ領域を確保します。  <a href="#a53438b7a6199e4f100c59312d2f123cf">[詳解]</a><br /></td></tr>
<tr class="separator:a53438b7a6199e4f100c59312d2f123cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fc331f7bbcac7221fd7416366ef87a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#ac7fc331f7bbcac7221fd7416366ef87a">Allocate</a> (size_t size, size_t alignment) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac7fc331f7bbcac7221fd7416366ef87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">アライメントを指定してメモリ領域を確保します。  <a href="#ac7fc331f7bbcac7221fd7416366ef87a">[詳解]</a><br /></td></tr>
<tr class="separator:ac7fc331f7bbcac7221fd7416366ef87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81377b59c5e1532869b003cd9b5f318"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#ad81377b59c5e1532869b003cd9b5f318">Free</a> (void *addr) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad81377b59c5e1532869b003cd9b5f318"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ領域を解放します。  <a href="#ad81377b59c5e1532869b003cd9b5f318">[詳解]</a><br /></td></tr>
<tr class="separator:ad81377b59c5e1532869b003cd9b5f318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b6984b5dac190453d450e819041633"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a83b6984b5dac190453d450e819041633">Reallocate</a> (void *addr, size_t newSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a83b6984b5dac190453d450e819041633"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリ領域を指定したサイズで再確保します。  <a href="#a83b6984b5dac190453d450e819041633">[詳解]</a><br /></td></tr>
<tr class="separator:a83b6984b5dac190453d450e819041633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b942ec23f715b66f82c02150727fa08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a2b942ec23f715b66f82c02150727fa08">ClearThreadCache</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2b942ec23f715b66f82c02150727fa08"><td class="mdescLeft">&#160;</td><td class="mdescRight">特定スレッド用にキャッシュしている空き領域を全てのスレッドが利用可能になるよう解放します。  <a href="#a2b942ec23f715b66f82c02150727fa08">[詳解]</a><br /></td></tr>
<tr class="separator:a2b942ec23f715b66f82c02150727fa08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">デバッグ用 API</div></td></tr>
<tr class="memitem:a45744a752336aa336842674bdccb4210"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a45744a752336aa336842674bdccb4210">GetSizeOf</a> (const void *addr) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a45744a752336aa336842674bdccb4210"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定した確保済みメモリ領域のサイズを取得します。  <a href="#a45744a752336aa336842674bdccb4210">[詳解]</a><br /></td></tr>
<tr class="separator:a45744a752336aa336842674bdccb4210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad236cc9a53ffcaa18e94ec1432fa5c68"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#ad236cc9a53ffcaa18e94ec1432fa5c68">GetTotalFreeSize</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad236cc9a53ffcaa18e94ec1432fa5c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">アロケータに存在する空き領域の合計を取得します。  <a href="#ad236cc9a53ffcaa18e94ec1432fa5c68">[詳解]</a><br /></td></tr>
<tr class="separator:ad236cc9a53ffcaa18e94ec1432fa5c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8b81f5b47c9ade27986951bea02d45"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a5d8b81f5b47c9ade27986951bea02d45">GetAllocatableSize</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5d8b81f5b47c9ade27986951bea02d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">アロケータから確保可能な最大サイズを取得します。  <a href="#a5d8b81f5b47c9ade27986951bea02d45">[詳解]</a><br /></td></tr>
<tr class="separator:a5d8b81f5b47c9ade27986951bea02d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1196844b494e896ea391df672050776b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a1196844b494e896ea391df672050776b">WalkAllocatedBlocks</a> (<a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a95dd2800aef14ef0508282fd508fedcb">WalkCallback</a> callback, void *userPtr) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1196844b494e896ea391df672050776b"><td class="mdescLeft">&#160;</td><td class="mdescRight">確保されたメモリ領域に対して順にコールバック関数を呼び出します。  <a href="#a1196844b494e896ea391df672050776b">[詳解]</a><br /></td></tr>
<tr class="separator:a1196844b494e896ea391df672050776b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644b9a162b9b8bf22a3e429966e53c9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a644b9a162b9b8bf22a3e429966e53c9f">Dump</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a644b9a162b9b8bf22a3e429966e53c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">アロケータ内部の情報を表示します。  <a href="#a644b9a162b9b8bf22a3e429966e53c9f">[詳解]</a><br /></td></tr>
<tr class="separator:a644b9a162b9b8bf22a3e429966e53c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6de9d17a7aaa6f54e95a3125a96dbda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1mem_1_1_standard_allocator_1_1_allocator_hash.html">AllocatorHash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#af6de9d17a7aaa6f54e95a3125a96dbda">Hash</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af6de9d17a7aaa6f54e95a3125a96dbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">アロケータの内部の情報を基にハッシュを生成します。  <a href="#af6de9d17a7aaa6f54e95a3125a96dbda">[詳解]</a><br /></td></tr>
<tr class="separator:af6de9d17a7aaa6f54e95a3125a96dbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p>メモリ管理のためのクラスです </p>
<p><b>詳細</b> <br />
 <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="メモリ管理のためのクラスです ">nn::mem::StandardAllocator</a> はメモリの確保・解放などを行うためのクラスです。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_aligned_allocator_8h-example.html#_a1">AlignedAllocator.h</a>, <a class="el" href="_audio_cpu_renderer_8cpp-example.html#_a1">AudioCpuRenderer.cpp</a>, <a class="el" href="_audio_device_8cpp-example.html#_a1">AudioDevice.cpp</a>, <a class="el" href="_audio_echoback_8cpp-example.html#_a42">AudioEchoback.cpp</a>, <a class="el" href="_audio_effect_8cpp-example.html#_a1">AudioEffect.cpp</a>, <a class="el" href="_audio_effect_aux_utility_8cpp-example.html#_a1">AudioEffectAuxUtility.cpp</a>, <a class="el" href="_audio_memory_pool_8cpp-example.html#_a1">AudioMemoryPool.cpp</a>, <a class="el" href="_audio_multiple_renderer_8cpp-example.html#_a1">AudioMultipleRenderer.cpp</a>, <a class="el" href="_audio_out_8cpp-example.html#_a35">AudioOut.cpp</a>, <a class="el" href="_audio_out_with_resampler_8cpp-example.html#_a35">AudioOutWithResampler.cpp</a>, <a class="el" href="_audio_performance_metrics_8cpp-example.html#_a1">AudioPerformanceMetrics.cpp</a>, <a class="el" href="_audio_renderer_8cpp-example.html#_a1">AudioRenderer.cpp</a>, <a class="el" href="_audio_sink_8cpp-example.html#_a1">AudioSink.cpp</a>, <a class="el" href="_audio_splitter_8cpp-example.html#_a1">AudioSplitter.cpp</a>, <a class="el" href="_codec_aac_decoder_8cpp-example.html#_a6">CodecAacDecoder.cpp</a>, <a class="el" href="_codec_opus_codec_processing_time_8cpp-example.html#_a19">CodecOpusCodecProcessingTime.cpp</a>, <a class="el" href="_codec_opus_decoder_8cpp-example.html#_a7">CodecOpusDecoder.cpp</a>, <a class="el" href="_codec_opus_encoder_8cpp-example.html#_a6">CodecOpusEncoder.cpp</a>, <a class="el" href="_codec_opus_multi_stream_decoder_8cpp-example.html#_a7">CodecOpusMultiStreamDecoder.cpp</a>, <a class="el" href="_demo1_2_demo1_8cpp-example.html#_a3">Demo1/Demo1.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#_a3">FontDemo/Main.cpp</a>, <a class="el" href="_gfx_primitive_renderer_8cpp-example.html#_a228">GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_hid_controller_sequence__main_8cpp-example.html#_a22">HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_npad_six_axis_sensor__main_8cpp-example.html#_a77">HidNpadSixAxisSensor_Main.cpp</a>, <a class="el" href="_hid_vibration_basic_8cpp-example.html#_a1">HidVibrationBasic.cpp</a>, <a class="el" href="_hid_vibration_generator_8cpp-example.html#_a0">HidVibrationGenerator.cpp</a>, <a class="el" href="_hid_vibration_player_8cpp-example.html#_a1">HidVibrationPlayer.cpp</a>, <a class="el" href="_hid_vibration_rolling_ball_8cpp-example.html#_a0">HidVibrationRollingBall.cpp</a>, <a class="el" href="_init_startup_with_malloc_8cpp-example.html#_a4">InitStartupWithMalloc.cpp</a>, <a class="el" href="_irsensor_viewer_8cpp-example.html#_a3">IrsensorViewer.cpp</a>, <a class="el" href="_movie_decoder_player_8cpp-example.html#_a5">MovieDecoderPlayer.cpp</a>, <a class="el" href="_spy_audio_8cpp-example.html#_a0">SpyAudio.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#_a10">Ui2dDemo/Main.cpp</a> (計33項目).</dd>
</dl></div><h2 class="groupheader">型定義メンバ詳解</h2>
<a class="anchor" id="a95dd2800aef14ef0508282fd508fedcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* nn::mem::StandardAllocator::WalkCallback) (void *addr, size_t size, void *userPtr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>確保されたメモリ領域を巡るときに呼び出されるコールバック関数の型です。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>確保されているメモリの先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>確保されているメモリのサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userPtr</td><td>ユーザから渡されるポインタ</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 </p><dl class="retval"><dt><b><a class="el" href="retval.html#_retval000090">戻り値一覧:</a></b></dt><dd><p class="startdd"><b>0</b> <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a1196844b494e896ea391df672050776b" title="確保されたメモリ領域に対して順にコールバック関数を呼び出します。 ">WalkAllocatedBlocks()</a> の実行を終了します。 <br />
 </p>
<p class="enddd"><b>1</b> <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a1196844b494e896ea391df672050776b" title="確保されたメモリ領域に対して順にコールバック関数を呼び出します。 ">WalkAllocatedBlocks()</a> の実行を継続します。</p>
</dd></dl>
<p><b>詳細</b> <br />
 <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a1196844b494e896ea391df672050776b" title="確保されたメモリ領域に対して順にコールバック関数を呼び出します。 ">WalkAllocatedBlocks()</a> で利用されるコールバック関数の型です。 <br />
 コールバック内でメモリの確保や解放を行う場合は、0 を返すようにしてください。 </p>

</div>
</div>
<h2 class="groupheader">構築子と解体子</h2>
<a class="anchor" id="a0e7e99aededf6ded0c7bdf01fbef21e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nn::mem::StandardAllocator::StandardAllocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンストラクタです。 </p>
<p><b>詳細</b> <br />
 このコンストラクタではメモリ領域の初期化を行いません。 後ほど <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#acdb0dd01602811a4f469c87c348d3ed1" title="指定されたメモリ領域を StandardAllocator で管理するために初期化します。 ">Initialize()</a> を呼んで <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="メモリ管理のためのクラスです ">StandardAllocator</a> で管理するメモリ領域を初期化してください。<br />
 <br />
 本 API はスレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a1e3efc1b684befdaa9d3ea4c08fc8c23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nn::mem::StandardAllocator::StandardAllocator </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンストラクタです。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>アロケータが使用する領域の先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>アロケータが使用する領域のサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>メモリ領域がアロケータの管理領域よりも大きい必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>アロケータは初期化済みとなります。</dd></dl>
<p><b>詳細</b> <br />
 指定されたメモリ領域を <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="メモリ管理のためのクラスです ">StandardAllocator</a> で管理するために初期化します。<br />
 <br />
 本アロケータでは、渡されたメモリ領域を 4KB にアラインした上で使用します。<br />
 そのため、addr, size は 4KB 単位である方が効率的です。<br />
 また、アロケータの管理領域に最低 16KB 必要となりますので、 4KB アラインを取った上で 16KB 以上の領域を指定する必要があります。<br />
 <br />
 addr に nullptr を渡した場合、size で指定したサイズの仮想アドレス空間を予約し、 予約された仮想アドレス空間内で適宜必要な物理メモリを割り当てて動作します。 物理メモリが必要になった時点で割り当てを行い、不要になった物理メモリは解放します。 この機能は <a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> が true を返す場合にのみ使用可能です。 詳細は <a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> を参照してください。<br />
 <br />
 本 API はスレッドセーフではありません。<br />
 本 API の動作中にアロケータに対する操作は行わないでください。 </p>

</div>
</div>
<a class="anchor" id="affdb91a0ab9c236c97866b385659d35e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nn::mem::StandardAllocator::StandardAllocator </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isCacheEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンストラクタです。スレッド毎のキャッシュ機能の有効・無効が選択できます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>アロケータが使用する領域の先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>アロケータが使用する領域のサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isCacheEnable</td><td>スレッド毎のメモリキャッシュ機能を有効にするか</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>メモリ領域がアロケータの管理領域よりも大きい必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>アロケータは初期化済みとなります。</dd></dl>
<p><b>詳細</b> <br />
 指定されたメモリ領域を <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="メモリ管理のためのクラスです ">StandardAllocator</a> で管理するために初期化します。<br />
 <br />
 本アロケータでは、渡されたメモリ領域を 4KB にアラインした上で使用します。<br />
 そのため、addr, size は 4KB 単位である方が効率的です。<br />
 また、アロケータの管理領域に最低 16KB 必要となりますので、 4KB アラインを取った上で 16KB 以上の領域を指定する必要があります。<br />
 <br />
 isCacheEnable に true を渡すことでマルチスレッド時の確保・解放速度を向上させる機能を有効にします。<br />
 この機能では TLS スロットを 1 つ消費します。<br />
 isCacheEnable を true にした場合の確保・解放のより詳細な仕様については NintendoSDK ドキュメントの <a href="../../Package/contents/Pages/Page_89102552.html">StandardAllocator</a> の説明を参照してください。<br />
 <br />
 addr に nullptr を渡した場合、size で指定したサイズの仮想アドレス空間を予約し、 予約された仮想アドレス空間内で適宜必要な物理メモリを割り当てて動作します。 物理メモリが必要になった時点で割り当てを行い、不要になった物理メモリは解放します。 この機能は <a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> が true を返す場合にのみ使用可能です。 詳細は <a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> を参照してください。<br />
 <br />
 本 API はスレッドセーフではありません。<br />
 本 API の動作中にアロケータに対する操作は行わないでください。 </p>

</div>
</div>
<a class="anchor" id="a254da7aa9f98eb4947ce540c28727644"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nn::mem::StandardAllocator::~StandardAllocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>デストラクタです。 </p>
<p><b>詳細</b> <br />
 アロケータが初期化済みであれば <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a6027bb6b016064edb1b007651d4af419" title="アロケータを破棄します。 ">Finalize()</a> を呼び、アロケータを破棄します。<br />
 <br />
 本 API はスレッドセーフではありません。 </p>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a class="anchor" id="acdb0dd01602811a4f469c87c348d3ed1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::mem::StandardAllocator::Initialize </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定されたメモリ領域を <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="メモリ管理のためのクラスです ">StandardAllocator</a> で管理するために初期化します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>アロケータが使用する領域の先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>アロケータが使用する領域のサイズ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>アロケータが未初期化である必要があります。 </dd>
<dd>
メモリ領域がアロケータの管理領域よりも大きい必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>アロケータは初期化済みとなります。</dd></dl>
<p><b>詳細</b> <br />
 指定されたメモリ領域を <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="メモリ管理のためのクラスです ">StandardAllocator</a> で管理するために初期化します。<br />
 <br />
 本アロケータでは、渡されたメモリ領域を 4KB にアラインした上で使用します。<br />
 そのため、addr, size は 4KB 単位である方が効率的です。<br />
 また、アロケータの管理領域に最低 16KB 必要となりますので、 4KB アラインを取った上で 16KB 以上の領域を指定する必要があります。<br />
 <br />
 addr に nullptr を渡した場合、size で指定したサイズの仮想アドレス空間を予約し、 予約された仮想アドレス空間内で適宜必要な物理メモリを割り当てて動作します。 物理メモリが必要になった時点で割り当てを行い、不要になった物理メモリは解放します。 この機能は <a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> が true を返す場合にのみ使用可能です。 詳細は <a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> を参照してください。<br />
 <br />
 本 API はスレッドセーフではありません。<br />
 本 API の動作中にアロケータに対する操作は行わないでください。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_multiple_renderer_8cpp-example.html#a64">AudioMultipleRenderer.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a96">FontDemo/Main.cpp</a>, <a class="el" href="_gfx_primitive_renderer_8cpp-example.html#a232">GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_hid_controller_sequence__main_8cpp-example.html#a23">HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_npad_six_axis_sensor__main_8cpp-example.html#a78">HidNpadSixAxisSensor_Main.cpp</a>, <a class="el" href="_hid_vibration_basic_8cpp-example.html#a4">HidVibrationBasic.cpp</a>, <a class="el" href="_hid_vibration_generator_8cpp-example.html#a3">HidVibrationGenerator.cpp</a>, <a class="el" href="_hid_vibration_player_8cpp-example.html#a25">HidVibrationPlayer.cpp</a>, <a class="el" href="_hid_vibration_rolling_ball_8cpp-example.html#a4">HidVibrationRollingBall.cpp</a>, <a class="el" href="_irsensor_viewer_8cpp-example.html#a5">IrsensorViewer.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a132">Ui2dDemo/Main.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aeb339622a4d7801fd791afe25a8ed81a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::mem::StandardAllocator::Initialize </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isCacheEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定されたメモリ領域を <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="メモリ管理のためのクラスです ">StandardAllocator</a> で管理するために初期化します。スレッド毎のキャッシュ機能の有効・無効が選択できます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>アロケータが使用する領域の先頭アドレス </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>アロケータが使用する領域のサイズ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isCacheEnable</td><td>スレッド毎のメモリキャッシュ機能を有効にするか</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>アロケータが未初期化である必要があります。 </dd>
<dd>
メモリ領域がアロケータの管理領域よりも大きい必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>アロケータは初期化済みとなります。</dd></dl>
<p><b>詳細</b> <br />
 指定されたメモリ領域を <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="メモリ管理のためのクラスです ">StandardAllocator</a> で管理するために初期化します。<br />
 <br />
 本アロケータでは、渡されたメモリ領域を 4KB にアラインした上で使用します。<br />
 そのため、addr, size は 4KB 単位である方が効率的です。<br />
 また、アロケータの管理領域に最低 16KB 必要となりますので、 4KB アラインを取った上で 16KB 以上の領域を指定する必要があります。<br />
 <br />
 isCacheEnable に true を渡すことでマルチスレッド時の確保・解放速度を向上させる機能を有効にします。<br />
 この機能では TLS スロットを 1 つ消費します。<br />
 isCacheEnable を true にした場合の確保・解放のより詳細な仕様については NintendoSDK ドキュメントの <a href="../../Package/contents/Pages/Page_89102552.html">StandardAllocator</a> の説明を参照してください。<br />
 <br />
 addr に nullptr を渡した場合、size で指定したサイズの仮想アドレス空間を予約し、 予約された仮想アドレス空間内で適宜必要な物理メモリを割り当てて動作します。 物理メモリが必要になった時点で割り当てを行い、不要になった物理メモリは解放します。 この機能は <a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> が true を返す場合にのみ使用可能です。 詳細は <a class="el" href="namespacenn_1_1os.html#ab9e6556970df605db16e5548b9fd188c" title="仮想アドレスメモリ管理が使用可能になっているかを判定します。 ">nn::os::IsVirtualAddressMemoryEnabled()</a> を参照してください。<br />
 <br />
 本 API はスレッドセーフではありません。<br />
 本 API の動作中にアロケータに対する操作は行わないでください。 </p>

</div>
</div>
<a class="anchor" id="a6027bb6b016064edb1b007651d4af419"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::mem::StandardAllocator::Finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>アロケータを破棄します。 </p>
<dl class="section pre"><dt>事前条件</dt><dd>アロケータが初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>アロケータは未初期化となります。</dd></dl>
<p><b>詳細</b> <br />
 アロケータを破棄します。<br />
 本 API はスレッドセーフではありません。<br />
 本 API の動作中にアロケータに対する操作は行わないでください。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_multiple_renderer_8cpp-example.html#a71">AudioMultipleRenderer.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a110">FontDemo/Main.cpp</a>, <a class="el" href="_gfx_primitive_renderer_8cpp-example.html#a241">GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_hid_controller_sequence__main_8cpp-example.html#a38">HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_vibration_basic_8cpp-example.html#a20">HidVibrationBasic.cpp</a>, <a class="el" href="_hid_vibration_generator_8cpp-example.html#a11">HidVibrationGenerator.cpp</a>, <a class="el" href="_hid_vibration_player_8cpp-example.html#a41">HidVibrationPlayer.cpp</a>, <a class="el" href="_hid_vibration_rolling_ball_8cpp-example.html#a12">HidVibrationRollingBall.cpp</a>, <a class="el" href="_irsensor_viewer_8cpp-example.html#a20">IrsensorViewer.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a155">Ui2dDemo/Main.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a53438b7a6199e4f100c59312d2f123cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::mem::StandardAllocator::Allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリ領域を確保します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>確保するメモリのサイズ（バイト）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>確保したメモリの先頭へのポインタが返ります。失敗すると NULL が返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>アロケータが初期化されている必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>アロケータから確保されたメモリ領域の先頭アドレスが返ります。</dd></dl>
<p><b>詳細</b> <br />
 アロケータから、指定されたサイズのメモリを確保します。<br />
 確保されたメモリ領域の初期値は不定です。<br />
 確保されるメモリ領域は、先頭アドレスが <a class="el" href="nn___macro_8h.html#ac6f80ca2ebf15f619391e35806e9635f" title="アライメントのバイトサイズを取得します。 ">NN_ALIGNOF(std::max_align_t)</a> バイトアライメントされます。<br />
 サイズが 0 の場合、メモリは確保されず、NULL が返ります。<br />
 割り当てられたメモリブロックのサイズは要求サイズより大きい場合があります。sizeof(std::max_align_t)の倍数にパディングされます。<br />
 <br />
 本 API はスレッドセーフです。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_multiple_renderer_8cpp-example.html#a4">AudioMultipleRenderer.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a9">FontDemo/Main.cpp</a>, <a class="el" href="_gfx_primitive_renderer_8cpp-example.html#a230">GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_hid_controller_sequence__main_8cpp-example.html#a50">HidControllerSequence_Main.cpp</a>, <a class="el" href="_hid_npad_six_axis_sensor__main_8cpp-example.html#a81">HidNpadSixAxisSensor_Main.cpp</a>, <a class="el" href="_irsensor_viewer_8cpp-example.html#a15">IrsensorViewer.cpp</a>, <a class="el" href="_spy_audio_8cpp-example.html#a8">SpyAudio.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a12">Ui2dDemo/Main.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac7fc331f7bbcac7221fd7416366ef87a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::mem::StandardAllocator::Allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>アライメントを指定してメモリ領域を確保します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>確保するメモリのサイズ（バイト） </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>確保するメモリのアライメント</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>確保したメモリの先頭へのポインタが返ります。失敗すると NULL が返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>アロケータが初期化されている必要があります。 </dd>
<dd>
size &gt; 0 である必要があります。 </dd>
<dd>
アライメントには正の 2 のべき乗を指定する必要があります。 </dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>アロケータから確保されたメモリ領域の先頭アドレスが返ります。</dd></dl>
<p><b>詳細</b> <br />
 アロケータから、指定されたサイズ、及びアライメントでメモリを確保します。<br />
 確保されたメモリ領域の初期値は不定です。<br />
 アライメントには正の 2 のべき乗を指定してください。<br />
 サイズが 0 の場合、メモリは確保されず、NULL が返ります。<br />
 割り当てられたメモリブロックのサイズは要求サイズより大きい場合があります。sizeof(std::max_align_t)の倍数にパディングされます。<br />
 <br />
 本 API はスレッドセーフです。 </p>

</div>
</div>
<a class="anchor" id="ad81377b59c5e1532869b003cd9b5f318"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::mem::StandardAllocator::Free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリ領域を解放します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>開放するメモリ領域の先頭アドレス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>アロケータが初期化されている必要があります。 </dd>
<dd>
addr はアロケータから確保されたメモリ領域の先頭アドレスである必要があります。</dd></dl>
<p><b>詳細</b> <br />
 メモリ領域を解放します。<br />
 <br />
 本 API はスレッドセーフです。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_audio_multiple_renderer_8cpp-example.html#a61">AudioMultipleRenderer.cpp</a>, <a class="el" href="_font_demo_2_main_8cpp-example.html#a11">FontDemo/Main.cpp</a>, <a class="el" href="_gfx_primitive_renderer_8cpp-example.html#a231">GfxPrimitiveRenderer.cpp</a>, <a class="el" href="_irsensor_viewer_8cpp-example.html#a19">IrsensorViewer.cpp</a>, <a class="el" href="_spy_audio_8cpp-example.html#a10">SpyAudio.cpp</a>, <a class="el" href="_ui2d_demo_2_main_8cpp-example.html#a13">Ui2dDemo/Main.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a83b6984b5dac190453d450e819041633"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::mem::StandardAllocator::Reallocate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリ領域を指定したサイズで再確保します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>確保済みメモリ領域の先頭アドレス<br />
 NULL を指定した場合 <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a53438b7a6199e4f100c59312d2f123cf" title="メモリ領域を確保します。 ">Allocate()</a> と同様の動作になります。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newSize</td><td>新しく割り当てるサイズ<br />
 0 を指定した場合 <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#ad81377b59c5e1532869b003cd9b5f318" title="メモリ領域を解放します。 ">Free()</a> と同様の動作になります。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>再確保したメモリ領域の先頭アドレスが返ります。失敗した場合 NULL が返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>アロケータが初期化されている必要があります。 </dd>
<dd>
addr は <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="メモリ管理のためのクラスです ">StandardAllocator</a> から <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a53438b7a6199e4f100c59312d2f123cf" title="メモリ領域を確保します。 ">Allocate()</a> によって確保されたアドレスでなくてはなりません。</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>アロケータから再確保されたメモリ領域の先頭アドレスが返ります。</dd></dl>
<p><b>詳細</b> <br />
 確保済みのメモリ領域を、指定したサイズに変更して割り当てなおします。<br />
 新しいサイズが前よりも大きい場合、古いメモリ領域のデータは全てコピーされます。<br />
 増えた分のメモリ領域の初期値は不定です。<br />
 新しいサイズが前よりも小さい場合、古いメモリ領域のデータを newSize 分だけコピーします。<br />
 サイズが大きくなる場合でも小さくなる場合でも、メモリ領域のアドレスは変更される可能性があります。<br />
 新たに割り当てられたメモリ領域は、 addr のアライメントを保持しません。先頭アドレスが <a class="el" href="nn___macro_8h.html#ac6f80ca2ebf15f619391e35806e9635f" title="アライメントのバイトサイズを取得します。 ">NN_ALIGNOF(std::max_align_t)</a> バイトアライメントされます。<br />
 <br />
 本 API はスレッドセーフです。 </p>

</div>
</div>
<a class="anchor" id="a2b942ec23f715b66f82c02150727fa08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::mem::StandardAllocator::ClearThreadCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>特定スレッド用にキャッシュしている空き領域を全てのスレッドが利用可能になるよう解放します。 </p>
<dl class="section pre"><dt>事前条件</dt><dd>アロケータが初期化されている必要があります。</dd></dl>
<p><b>詳細</b> <br />
 スレッド毎のメモリキャッシュ機能でキャッシュしている空き領域を解放し、全てのスレッドから確保可能な状態にします。<br />
 本 API はコンストラクタ呼び出し時、もしくは <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#acdb0dd01602811a4f469c87c348d3ed1" title="指定されたメモリ領域を StandardAllocator で管理するために初期化します。 ">Initialize()</a> 時に isCacheEnable に true を与えた場合にのみ有効です。<br />
 解放されるキャッシュは本 API を呼び出したスレッドのキャッシュのみで、他のスレッドがキャッシュを持っている場合、そちらは解放されません。<br />
 全てのスレッドが持つキャッシュを解放したい場合、全てのスレッドで本 API を呼び出す必要があります。<br />
 それ以外の場合は何も処理せず return します。<br />
 <br />
 本 API はスレッドセーフです。 </p>

</div>
</div>
<a class="anchor" id="a45744a752336aa336842674bdccb4210"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::mem::StandardAllocator::GetSizeOf </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定した確保済みメモリ領域のサイズを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>サイズを取得するメモリ領域の先頭アドレス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>アロケータが初期化されている必要があります。 </dd>
<dd>
addr は <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="メモリ管理のためのクラスです ">StandardAllocator</a> から <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a53438b7a6199e4f100c59312d2f123cf" title="メモリ領域を確保します。 ">Allocate()</a> によって確保されたアドレスでなくてはなりません。</dd></dl>
<p><b>詳細</b> <br />
 指定した確保済みメモリ領域のサイズを取得します。<br />
 本 API で取得できるサイズは実際に確保されたメモリ領域のサイズで、 <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a53438b7a6199e4f100c59312d2f123cf" title="メモリ領域を確保します。 ">Allocate()</a> 時に指定したサイズではありません。<br />
 <br />
 本 API はスレッドセーフです。 </p>

</div>
</div>
<a class="anchor" id="ad236cc9a53ffcaa18e94ec1432fa5c68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::mem::StandardAllocator::GetTotalFreeSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>アロケータに存在する空き領域の合計を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>空き領域の合計サイズが返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>アロケータが初期化されている必要があります。</dd></dl>
<p><b>詳細</b> <br />
 アロケータで管理している空き領域の合計を取得します。<br />
 空き領域が複数存在する場合、実際に確保可能なサイズは合計サイズよりも小さくなります。<br />
 実際に確保可能なサイズを取得するには <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a5d8b81f5b47c9ade27986951bea02d45" title="アロケータから確保可能な最大サイズを取得します。 ">GetAllocatableSize()</a> を使用してください。<br />
 <br />
 本 API はアロケータ内の確保・解放状況により時間がかかる場合があります。<br />
 <br />
 仮想アドレスメモリ管理機能が有効で <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="メモリ管理のためのクラスです ">StandardAllocator</a> で指定した仮想アドレス空間が物理アドレス空間よりも大きい場合、物理メモリが割り当て可能な空き領域のサイズを返します。<br />
 <br />
 本 API は <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="メモリ管理のためのクラスです ">StandardAllocator</a> の仮想アドレスメモリ管理機能が無効である場合はスレッドセーフで、有効である場合はスレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a5d8b81f5b47c9ade27986951bea02d45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::mem::StandardAllocator::GetAllocatableSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>アロケータから確保可能な最大サイズを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>確保可能なサイズが返ります。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>アロケータが初期化されている必要があります。</dd></dl>
<p><b>詳細</b> <br />
 アロケータから確保可能な最大サイズを取得します。<br />
 空き領域が複数存在する場合、その中で最大の領域のサイズを取得します。<br />
 <br />
 本 API で返却されたサイズは必ず確保可能であることを保証しますが、アルゴリズム上、本 API で返却されたサイズ以上の領域が確保可能な場合があります。<br />
 <br />
 本 API はアロケータ内の確保・解放状況により時間がかかる場合があります。<br />
 <br />
 仮想アドレスメモリ管理機能が有効で <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="メモリ管理のためのクラスです ">StandardAllocator</a> で指定した仮想アドレス空間が物理アドレス空間よりも大きい場合、物理メモリが割り当て可能な空き領域のサイズを返します。<br />
 <br />
 本 API は <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html" title="メモリ管理のためのクラスです ">StandardAllocator</a> の仮想アドレスメモリ管理機能が無効である場合はスレッドセーフで、有効である場合はスレッドセーフではありません。 </p>

</div>
</div>
<a class="anchor" id="a1196844b494e896ea391df672050776b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::mem::StandardAllocator::WalkAllocatedBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a95dd2800aef14ef0508282fd508fedcb">WalkCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>確保されたメモリ領域に対して順にコールバック関数を呼び出します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>メモリ領域ごとに呼び出されるコールバック関数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userPtr</td><td>コールバック関数に渡されるポインタ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd>アロケータが初期化されている必要があります。 </dd>
<dd>
<a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#acdb0dd01602811a4f469c87c348d3ed1" title="指定されたメモリ領域を StandardAllocator で管理するために初期化します。 ">Initialize()</a> 時に isCacheEnable に true を指定しており、かつコールバック関数内で確保されたメモリ領域に書き込みを行う場合、全てのスレッドで <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a2b942ec23f715b66f82c02150727fa08" title="特定スレッド用にキャッシュしている空き領域を全てのスレッドが利用可能になるよう解放します。 ...">ClearThreadCache()</a> を呼び出した直後に本 API が呼ばれる必要があります。</dd></dl>
<p><b>詳細</b> <br />
 確保済みのメモリ領域全てに対し、順にコールバック関数を呼び出します。<br />
 <br />
 <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#acdb0dd01602811a4f469c87c348d3ed1" title="指定されたメモリ領域を StandardAllocator で管理するために初期化します。 ">Initialize()</a> 時に isCacheEnable に true を指定し、スレッド毎のメモリキャッシュ機能を有効にしている場合、本 API ではそのキャッシュ領域に対してもコールバック関数を呼び出します。<br />
 そのため、本 API を用いて確保されたメモリ領域に書き込みを行う場合は必ず全てのスレッドで <a class="el" href="classnn_1_1mem_1_1_standard_allocator.html#a2b942ec23f715b66f82c02150727fa08" title="特定スレッド用にキャッシュしている空き領域を全てのスレッドが利用可能になるよう解放します。 ...">ClearThreadCache()</a> を呼び出した直後に本 API を呼び出してください。<br />
 <br />
 本 API はスレッドセーフです。 </p>

</div>
</div>
<a class="anchor" id="a644b9a162b9b8bf22a3e429966e53c9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::mem::StandardAllocator::Dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>アロケータ内部の情報を表示します。 </p>
<p><b>詳細</b> <br />
 アロケータの内部状態を出力します。<br />
 <br />
 出力されるフォーマットの詳細については NintendoSDK ドキュメントの <a href="../../Package/contents/Pages/Page_89102552.html">StandardAllocator</a> の説明を参照してください。 </p>

</div>
</div>
<a class="anchor" id="af6de9d17a7aaa6f54e95a3125a96dbda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1mem_1_1_standard_allocator_1_1_allocator_hash.html">AllocatorHash</a> nn::mem::StandardAllocator::Hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>アロケータの内部の情報を基にハッシュを生成します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>アロケータの内部状態が返ります。</dd></dl>
<p><b>詳細</b> <br />
 アロケータの内部状態を取得します。 </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
