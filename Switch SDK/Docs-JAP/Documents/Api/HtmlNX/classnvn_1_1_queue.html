<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>NintendoSDK API Reference: nvn::Queue クラス</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>総合概要</span></a></li>
      <li><a href="pages.html"><span>諸情報</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>名前空間</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>クラス一覧</span></a></li>
      <li><a href="classes.html"><span>クラス索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>クラスメンバ</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenvn.html">nvn</a></li><li class="navelem"><a class="el" href="classnvn_1_1_queue.html">Queue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="classnvn_1_1_queue-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">nvn::Queue クラス<div class="ingroups"><a class="el" href="group__nvn__cpp__interface.html">NVN C++ API Bindings</a> &raquo; <a class="el" href="group__nvn__cpp__apiclasses.html">API Classes</a> &#124; <a class="el" href="group__nvn__cpp__interface.html">NVN C++ API Bindings</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>API class used to send commands to the GPU.  
 <a href="classnvn_1_1_queue.html#details">[詳解]</a></p>

<p><code>#include &lt;nvn/nvn_Cpp.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:ab86977e78d8a6e7e171f439c5ed2b211"><td class="memItemLeft" align="right" valign="top">NVN_PRE_DEPRECATED <a class="el" href="structnvn_1_1_queue_acquire_texture_result.html">QueueAcquireTextureResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#ab86977e78d8a6e7e171f439c5ed2b211">AcquireTexture</a> (<a class="el" href="classnvn_1_1_window.html">Window</a> *window, int *textureIndex) NVN_POST_DEPRECATED</td></tr>
<tr class="memdesc:ab86977e78d8a6e7e171f439c5ed2b211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire a texture from the window.  <a href="#ab86977e78d8a6e7e171f439c5ed2b211">[詳解]</a><br /></td></tr>
<tr class="separator:ab86977e78d8a6e7e171f439c5ed2b211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f5ed18214950f9d34a55cc61ab9ef6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#ae1f5ed18214950f9d34a55cc61ab9ef6">FenceSync</a> (<a class="el" href="classnvn_1_1_sync.html">Sync</a> *sync, <a class="el" href="structnvn_1_1_sync_condition.html">SyncCondition</a> condition, <a class="el" href="structnvn_1_1_sync_flag_bits.html">SyncFlagBits</a> flags)</td></tr>
<tr class="memdesc:ae1f5ed18214950f9d34a55cc61ab9ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">Sync</a> object as signaled when all previous commands have completed in the <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU. ">Queue</a> object.  <a href="#ae1f5ed18214950f9d34a55cc61ab9ef6">[詳解]</a><br /></td></tr>
<tr class="separator:ae1f5ed18214950f9d34a55cc61ab9ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f835fbb1c61e33764e40456ab0a95a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#a73f835fbb1c61e33764e40456ab0a95a">Finalize</a> ()</td></tr>
<tr class="memdesc:a73f835fbb1c61e33764e40456ab0a95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU. ">Queue</a> object.  <a href="#a73f835fbb1c61e33764e40456ab0a95a">[詳解]</a><br /></td></tr>
<tr class="separator:a73f835fbb1c61e33764e40456ab0a95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca51bcfefab8f580172fb0fd43a0431f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#aca51bcfefab8f580172fb0fd43a0431f">Finish</a> ()</td></tr>
<tr class="memdesc:aca51bcfefab8f580172fb0fd43a0431f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until all commands previously submitted to a queue have completed execution.  <a href="#aca51bcfefab8f580172fb0fd43a0431f">[詳解]</a><br /></td></tr>
<tr class="separator:aca51bcfefab8f580172fb0fd43a0431f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf561605d8b58cc923342539f90466f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#abf561605d8b58cc923342539f90466f1">Flush</a> ()</td></tr>
<tr class="memdesc:abf561605d8b58cc923342539f90466f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush commands previously submitted to a queue for processing.  <a href="#abf561605d8b58cc923342539f90466f1">[詳解]</a><br /></td></tr>
<tr class="separator:abf561605d8b58cc923342539f90466f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbf84856df0276128ffef1c6c4cd05c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnvn_1_1_queue_get_error_result.html">QueueGetErrorResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#acdbf84856df0276128ffef1c6c4cd05c">GetError</a> (<a class="el" href="unionnvn_1_1_queue_error_info.html">QueueErrorInfo</a> *errorInfo)</td></tr>
<tr class="memdesc:acdbf84856df0276128ffef1c6c4cd05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get GPU error status of the queue.  <a href="#acdbf84856df0276128ffef1c6c4cd05c">[詳解]</a><br /></td></tr>
<tr class="separator:acdbf84856df0276128ffef1c6c4cd05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139c7e7a7e280f1a87e0a56436009142"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#a139c7e7a7e280f1a87e0a56436009142">GetTotalCommandMemoryUsed</a> ()</td></tr>
<tr class="memdesc:a139c7e7a7e280f1a87e0a56436009142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query total queue command memory usage.  <a href="#a139c7e7a7e280f1a87e0a56436009142">[詳解]</a><br /></td></tr>
<tr class="separator:a139c7e7a7e280f1a87e0a56436009142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d7fd9337d254e9a81bc7e2fb3e0756"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#a95d7fd9337d254e9a81bc7e2fb3e0756">GetTotalComputeMemoryUsed</a> ()</td></tr>
<tr class="memdesc:a95d7fd9337d254e9a81bc7e2fb3e0756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query total queue compute memory usage.  <a href="#a95d7fd9337d254e9a81bc7e2fb3e0756">[詳解]</a><br /></td></tr>
<tr class="separator:a95d7fd9337d254e9a81bc7e2fb3e0756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32700aee92f014ff277f5a27f1665b5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#ad32700aee92f014ff277f5a27f1665b5">GetTotalControlMemoryUsed</a> ()</td></tr>
<tr class="memdesc:ad32700aee92f014ff277f5a27f1665b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query total queue control memory usage.  <a href="#ad32700aee92f014ff277f5a27f1665b5">[詳解]</a><br /></td></tr>
<tr class="separator:ad32700aee92f014ff277f5a27f1665b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6962c3ca8109ba904a8bff54a5b1d2be"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#a6962c3ca8109ba904a8bff54a5b1d2be">Initialize</a> (const <a class="el" href="classnvn_1_1_queue_builder.html">QueueBuilder</a> *builder)</td></tr>
<tr class="memdesc:a6962c3ca8109ba904a8bff54a5b1d2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU. ">Queue</a> object from a queue builder.  <a href="#a6962c3ca8109ba904a8bff54a5b1d2be">[詳解]</a><br /></td></tr>
<tr class="separator:a6962c3ca8109ba904a8bff54a5b1d2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e0218cebe6125389832d447d4b0e54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#a62e0218cebe6125389832d447d4b0e54">PresentTexture</a> (<a class="el" href="classnvn_1_1_window.html">Window</a> *window, int textureIndex)</td></tr>
<tr class="memdesc:a62e0218cebe6125389832d447d4b0e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display the contents of a texture into the window.  <a href="#a62e0218cebe6125389832d447d4b0e54">[詳解]</a><br /></td></tr>
<tr class="separator:a62e0218cebe6125389832d447d4b0e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e41fc089298232cd421f614def75cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#aa6e41fc089298232cd421f614def75cb">ResetMemoryUsageCounts</a> ()</td></tr>
<tr class="memdesc:aa6e41fc089298232cd421f614def75cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset usage counters for command, control and compute memory.  <a href="#aa6e41fc089298232cd421f614def75cb">[詳解]</a><br /></td></tr>
<tr class="separator:aa6e41fc089298232cd421f614def75cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd642a1c65a354234270815e5359340"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#a6dd642a1c65a354234270815e5359340">SetDebugLabel</a> (const char *label)</td></tr>
<tr class="memdesc:a6dd642a1c65a354234270815e5359340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug label string for a <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU. ">Queue</a> object.  <a href="#a6dd642a1c65a354234270815e5359340">[詳解]</a><br /></td></tr>
<tr class="separator:a6dd642a1c65a354234270815e5359340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3211beb342c3d0c4752ac00019a4aca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#ab3211beb342c3d0c4752ac00019a4aca">SubmitCommands</a> (int numCommands, const <a class="el" href="group__nvn__cpp__handle.html#ga48a6926aea0b934109f96ae32027b7fb">CommandHandle</a> *handles)</td></tr>
<tr class="memdesc:ab3211beb342c3d0c4752ac00019a4aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit commands encapsulated in command buffers to a queue for processing.  <a href="#ab3211beb342c3d0c4752ac00019a4aca">[詳解]</a><br /></td></tr>
<tr class="separator:ab3211beb342c3d0c4752ac00019a4aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339d246e329a173e81d8e1cf2a550113"><td class="memItemLeft" align="right" valign="top">NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113">WaitSync</a> (const <a class="el" href="classnvn_1_1_sync.html">Sync</a> *sync)</td></tr>
<tr class="memdesc:a339d246e329a173e81d8e1cf2a550113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">Sync</a> object to be signaled on the GPU before processing any further commands in the specified <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU. ">Queue</a> object.  <a href="#a339d246e329a173e81d8e1cf2a550113">[詳解]</a><br /></td></tr>
<tr class="separator:a339d246e329a173e81d8e1cf2a550113"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p>API class used to send commands to the GPU. </p>
</div><h2 class="groupheader">関数詳解</h2>
<a class="anchor" id="acdbf84856df0276128ffef1c6c4cd05c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvn_1_1_queue_get_error_result.html">QueueGetErrorResult</a> nvn::Queue::GetError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionnvn_1_1_queue_error_info.html">QueueErrorInfo</a> *&#160;</td>
          <td class="paramname"><em>errorInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get GPU error status of the queue. </p>
<p>Applications can use this function to check if queue encountered unrecoverable GPU error such as invalid GPU memory accesses, invalid command, timeout or other errors. After GPU error queue is in faulted state and following behavior is expected:</p><ol type="1">
<li><a class="el" href="group__nvn__c__functions.html#gaab3c15f657cefdff33dab453795ff38f" title="Wait until all commands previously submitted to a queue have completed execution. ...">nvnQueueFinish()</a> returns immediately.</li>
<li><a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">Sync</a> objects placed into faulted queue signal completion.</li>
<li>Faulted queue can be finalized to free resources.</li>
<li>Remaining nvnQueue API calls for faulted queue are ignored or return error.</li>
<li>Other device queues are not affected or blocked by faulted queue.</li>
</ol>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">errorInfo</td><td>Pointer to structure to save information about error. If set to NULL, information will not be retrieved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a139c7e7a7e280f1a87e0a56436009142"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvn::Queue::GetTotalCommandMemoryUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query total queue command memory usage. </p>
<p>This command returns the total amount of queue command memory (in bytes) used by queue commands since the queue was initialized or since usage counts were last reset by <a class="el" href="classnvn_1_1_queue.html#aa6e41fc089298232cd421f614def75cb" title="Reset usage counters for command, control and compute memory. ">Queue::ResetMemoryUsageCounts</a>. The total memory usage count can be used by application developers to determine the amount of memory to provide when initializing a queue. Note that memory usage counts may exceed the total amount of memory provided to the queue since the NVN driver will automatically reuse queue memory when required. </p>

</div>
</div>
<a class="anchor" id="ad32700aee92f014ff277f5a27f1665b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvn::Queue::GetTotalControlMemoryUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query total queue control memory usage. </p>
<p>This command returns the total amount of queue control memory (in bytes) used by queue commands since the queue was initialized or since usage counts were last reset by <a class="el" href="classnvn_1_1_queue.html#aa6e41fc089298232cd421f614def75cb" title="Reset usage counters for command, control and compute memory. ">Queue::ResetMemoryUsageCounts</a>. The total memory usage count can be used by application developers to determine the amount of memory to provide when initializing a queue. Note that memory usage counts may exceed the total amount of memory provided to the queue since the NVN driver will automatically reuse queue memory when required. </p>

</div>
</div>
<a class="anchor" id="a95d7fd9337d254e9a81bc7e2fb3e0756"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nvn::Queue::GetTotalComputeMemoryUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query total queue compute memory usage. </p>
<p>This command returns the total amount of queue compute memory (in bytes) used by queue commands since the queue was initialized or since usage counts were last reset by <a class="el" href="classnvn_1_1_queue.html#aa6e41fc089298232cd421f614def75cb" title="Reset usage counters for command, control and compute memory. ">Queue::ResetMemoryUsageCounts</a>. The total memory usage count can be used by application developers to determine the amount of memory to provide when initializing a queue. Note that memory usage counts may exceed the total amount of memory provided to the queue since the NVN driver will automatically reuse queue memory when required. </p>

</div>
</div>
<a class="anchor" id="aa6e41fc089298232cd421f614def75cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Queue::ResetMemoryUsageCounts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset usage counters for command, control and compute memory. </p>
<p>This command resets the accumulated usage counters for queue command, control, and compute memory.</p>
<dl class="section note"><dt>覚え書き</dt><dd><a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU. ">Queue</a> memory consumed by GPU commands may not be added to the usage counters reset by this command until the queue is next flushed. When total queue memory usage is queried, any memory used by unflushed commands will be added to the total usage counters. As a result, querying memory usage immediately after resetting counters may return non-zero values if the queue has unflushed commands. </dd></dl>

</div>
</div>
<a class="anchor" id="a6962c3ca8109ba904a8bff54a5b1d2be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvn::Queue::Initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_queue_builder.html">QueueBuilder</a> *&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU. ">Queue</a> object from a queue builder. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td><a class="el" href="classnvn_1_1_queue_builder.html" title="Object specifying state used to construct new queue objects. ">QueueBuilder</a> object holding properties of the new <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU. ">Queue</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73f835fbb1c61e33764e40456ab0a95a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Queue::Finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU. ">Queue</a> object. </p>
<dl class="section note"><dt>覚え書き</dt><dd>Finalizing a queue will wait for the completion of all commands previously submitted to the queue, including those sent by the driver during queue initialization. </dd></dl>

</div>
</div>
<a class="anchor" id="a6dd642a1c65a354234270815e5359340"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Queue::SetDebugLabel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the debug label string for a <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU. ">Queue</a> object. </p>
<p>Annotates a <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU. ">Queue</a> object with a descriptive text label. This label may then be used by the debug layer, an external debugger, or a profiler tool.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Text string used to annotate the <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU. ">Queue</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3211beb342c3d0c4752ac00019a4aca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Queue::SubmitCommands </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numCommands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__nvn__cpp__handle.html#ga48a6926aea0b934109f96ae32027b7fb">CommandHandle</a> *&#160;</td>
          <td class="paramname"><em>handles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit commands encapsulated in command buffers to a queue for processing. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">numCommands</td><td>Number of command buffers to send.</td></tr>
    <tr><td class="paramname">handles</td><td>Array of numCommands handles for the command buffers to send. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf561605d8b58cc923342539f90466f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Queue::Flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush commands previously submitted to a queue for processing. </p>
<p>Commands submitted to <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU. ">Queue</a> objects may be batched up by the implementation to avoid the overhead that would be involved in flushing each command immediately after it is submitted. Flush can be used to manually flush commands that were previously batched up. </p>

</div>
</div>
<a class="anchor" id="aca51bcfefab8f580172fb0fd43a0431f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Queue::Finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until all commands previously submitted to a queue have completed execution. </p>
<p>This command will not return to the caller until the previously submitted commands have completed. To determine if submitted commands have completed without blocking, applications can use <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">Sync</a> objects and Sync::WaitSync(). Finish will automatically flush the previously submitted commands as part of its operation. </p>

</div>
</div>
<a class="anchor" id="a62e0218cebe6125389832d447d4b0e54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Queue::PresentTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnvn_1_1_window.html">Window</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textureIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display the contents of a texture into the window. </p>
<p>This command presents the texture specified by <em>textureIndex</em> in the native window associated with <em>window</em>. It also triggers an implicit call to <a class="el" href="classnvn_1_1_queue.html#abf561605d8b58cc923342539f90466f1" title="Flush commands previously submitted to a queue for processing. ">Queue::Flush</a> so that the texture is guaranteed to be shown on the screen in finite time.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>The window where the texture should be presented.</td></tr>
    <tr><td class="paramname">textureIndex</td><td>The index of the texture to be displayed on-screen. The texture must be previously acquired from <em>window</em> using <a class="el" href="classnvn_1_1_window.html#a2be5d9eb053d407b738dd18bf86801e8" title="Acquire a texture from the window. ">Window::AcquireTexture</a>. <a class="el" href="classnvn_1_1_queue.html#a62e0218cebe6125389832d447d4b0e54" title="Display the contents of a texture into the window. ">Queue::PresentTexture</a> transfers the ownership of the texture back to the platform windowing system, and the application must re-acquire it with <a class="el" href="classnvn_1_1_window.html#a2be5d9eb053d407b738dd18bf86801e8" title="Acquire a texture from the window. ">Window::AcquireTexture</a> before using it again. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab86977e78d8a6e7e171f439c5ed2b211"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvn_1_1_queue_acquire_texture_result.html">QueueAcquireTextureResult</a> nvn::Queue::AcquireTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnvn_1_1_window.html">Window</a> *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>textureIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire a texture from the window. </p>
<p>Deprecated in favor of <a class="el" href="classnvn_1_1_window.html#a2be5d9eb053d407b738dd18bf86801e8" title="Acquire a texture from the window. ">Window::AcquireTexture</a>.</p>
<p>This is semantically equivalent to calling</p>
<div class="fragment"><div class="line">Sync displayReleaseSync;</div>
<div class="line">displayReleaseSync.Initialize(...);</div>
<div class="line">window.AcquireTexture(&amp;displayReleaseSync, textureIndex);</div>
<div class="line">queue.WaitSync(&amp;displayReleaseSync);</div>
<div class="line">displayReleaseSync.Finalize();</div>
</div><!-- fragment --><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">window</td><td><a class="el" href="classnvn_1_1_window.html" title="Object that manages texture presentation to the platform windowing system. ">Window</a> object to acquire a texture from.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">textureIndex</td><td>An index into the texture array that was passed in when <em>window</em> was initialized, which identifies the texture that is now released from the platform windowing system to the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1f5ed18214950f9d34a55cc61ab9ef6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::Queue::FenceSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnvn_1_1_sync.html">Sync</a> *&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_sync_condition.html">SyncCondition</a>&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_sync_flag_bits.html">SyncFlagBits</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">Sync</a> object as signaled when all previous commands have completed in the <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU. ">Queue</a> object. </p>
<dl class="section warning"><dt>警告</dt><dd>FenceSync commands are not automatically flushed for processing by the GPU. Before waiting on a FenceSync call with the CPU using <a class="el" href="classnvn_1_1_sync.html#a3ca699554fb2f2a736fb89831f85a0dc" title="Wait for a Sync object to be signaled on the CPU before returning. ">Sync::Wait</a> or from another <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU. ">Queue</a> using <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">Queue::WaitSync</a>, applications must ensure that the previous FenceSync call was flushed using <a class="el" href="classnvn_1_1_queue.html#abf561605d8b58cc923342539f90466f1" title="Flush commands previously submitted to a queue for processing. ">Queue::Flush</a>. Waiting on a FenceSync call using <a class="el" href="classnvn_1_1_queue.html#a339d246e329a173e81d8e1cf2a550113" title="Wait for a Sync object to be signaled on the GPU before processing any further commands in the specif...">Queue::WaitSync</a> in the same queue requires no manual flush.</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>If tiled caching is enabled, this command will trigger an implicit tiled cache flush.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td><a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">Sync</a> object to mark as signaled when commands complete.</td></tr>
    <tr><td class="paramname">condition</td><td>Type of command completion to wait for.</td></tr>
    <tr><td class="paramname">flags</td><td>Bitfield of additional operations to perform before signaling. See <a class="el" href="structnvn_1_1_sync_flag_bits.html" title="Specifies additional operations performed when a FenceSync command is processed. ">nvn::SyncFlagBits</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a339d246e329a173e81d8e1cf2a550113"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVNboolean nvn::Queue::WaitSync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvn_1_1_sync.html">Sync</a> *&#160;</td>
          <td class="paramname"><em>sync</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a <a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">Sync</a> object to be signaled on the GPU before processing any further commands in the specified <a class="el" href="classnvn_1_1_queue.html" title="API class used to send commands to the GPU. ">Queue</a> object. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td><a class="el" href="classnvn_1_1_sync.html" title="Synchronization primitive object used to order execution of commands and track progress. ">Sync</a> object to wait on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
