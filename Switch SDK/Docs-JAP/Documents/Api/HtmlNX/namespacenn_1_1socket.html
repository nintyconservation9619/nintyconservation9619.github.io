<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>NintendoSDK API Reference: nn::socket 名前空間</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>総合概要</span></a></li>
      <li><a href="pages.html"><span>諸情報</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li class="current"><a href="namespaces.html"><span>名前空間</span></a></li>
      <li><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>名前空間一覧</span></a></li>
      <li><a href="namespacemembers.html"><span>名前空間メンバ</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1socket.html">socket</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">クラス</a> &#124;
<a href="#typedef-members">型定義</a> &#124;
<a href="#enum-members">列挙型</a> &#124;
<a href="#func-members">関数</a> &#124;
<a href="#var-members">変数</a>  </div>
  <div class="headertitle">
<div class="title">nn::socket 名前空間</div>  </div>
</div><!--header-->
<div class="contents">

<p>ソケットライブラリの名前空間です。  
<a href="#details">[詳解]</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
クラス</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1socket_1_1_addr_info.html">AddrInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used by <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60">nn::socket::GetAddrInfo()</a> to hold host address information.  <a href="structnn_1_1socket_1_1_addr_info.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1socket_1_1_config.html">Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for supplying configuration to the socket library.  <a href="classnn_1_1socket_1_1_config.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1socket_1_1_config_default.html">ConfigDefault</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class specifying a default configuration.  <a href="classnn_1_1socket_1_1_config_default.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1socket_1_1_config_default_with_constrained_memory.html">ConfigDefaultWithConstrainedMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class specifying a default configuration.  <a href="classnn_1_1socket_1_1_config_default_with_constrained_memory.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1socket_1_1_config_default_with_memory.html">ConfigDefaultWithMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class specifying a default configuration.  <a href="classnn_1_1socket_1_1_config_default_with_memory.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1socket_1_1_config_with_memory.html">ConfigWithMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class allowing for full manual configuration of the socket library.  <a href="classnn_1_1socket_1_1_config_with_memory.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1socket_1_1_fd_set.html">FdSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used for <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2">Select()</a>.  <a href="structnn_1_1socket_1_1_fd_set.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1socket_1_1_host_ent.html">HostEnt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structures returned by network data base library.  <a href="structnn_1_1socket_1_1_host_ent.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1socket_1_1_in_addr.html">InAddr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for storing Internet address in network format.  <a href="structnn_1_1socket_1_1_in_addr.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1socket_1_1_linger.html">Linger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used for manipulating linger option.  <a href="structnn_1_1socket_1_1_linger.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1socket_1_1_poll_fd.html">PollFd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used for <a class="el" href="namespacenn_1_1socket.html#ad9e109d18fb43f275742d74d74d06cde">Poll()</a>.  <a href="structnn_1_1socket_1_1_poll_fd.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used to store most addresses.  <a href="structnn_1_1socket_1_1_sock_addr.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1socket_1_1_sock_addr_in.html">SockAddrIn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used to specify a local or remote endpoint address to which to connect a socket.  <a href="structnn_1_1socket_1_1_sock_addr_in.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1socket_1_1_sock_addr_storage.html">SockAddrStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for storing socket address information.  <a href="structnn_1_1socket_1_1_sock_addr_storage.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1socket_1_1_tcp_info.html">TcpInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to be passed to <a class="el" href="namespacenn_1_1socket.html#afaa7ccade3133a9884ab0b8e44ac18fc">nn::socket::SetSockOpt()</a> when setting the <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca702daca3186e133db09b35f6f08dd7a0">Option::Tcp_Info</a> option.  <a href="structnn_1_1socket_1_1_tcp_info.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1socket_1_1_time_val.html">TimeVal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used by <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2">nn::socket::Select()</a> and for setting timeout options with <a class="el" href="namespacenn_1_1socket.html#afaa7ccade3133a9884ab0b8e44ac18fc">nn::socket::SetSockOpt()</a>.  <a href="structnn_1_1socket_1_1_time_val.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
型定義</h2></td></tr>
<tr class="memitem:afe10cc9b27914073d027bfef195cb192"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe10cc9b27914073d027bfef195cb192"></a>
typedef unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#afe10cc9b27914073d027bfef195cb192">FdMask</a></td></tr>
<tr class="memdesc:afe10cc9b27914073d027bfef195cb192"><td class="mdescLeft">&#160;</td><td class="mdescRight">File descriptor mask. <br /></td></tr>
<tr class="separator:afe10cc9b27914073d027bfef195cb192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08c7d39c115b363db7819d38172127d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac08c7d39c115b363db7819d38172127d"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ac08c7d39c115b363db7819d38172127d">InAddrT</a></td></tr>
<tr class="memdesc:ac08c7d39c115b363db7819d38172127d"><td class="mdescLeft">&#160;</td><td class="mdescRight">IP address. <br /></td></tr>
<tr class="separator:ac08c7d39c115b363db7819d38172127d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6bc7823b6d97bfe254bb8e7a74822d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f6bc7823b6d97bfe254bb8e7a74822d"></a>
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a3f6bc7823b6d97bfe254bb8e7a74822d">InPortT</a></td></tr>
<tr class="memdesc:a3f6bc7823b6d97bfe254bb8e7a74822d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Port number. <br /></td></tr>
<tr class="separator:a3f6bc7823b6d97bfe254bb8e7a74822d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb8a1b63cc61bb57fe8c8c58ef26591"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cb8a1b63cc61bb57fe8c8c58ef26591"></a>
typedef unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a8cb8a1b63cc61bb57fe8c8c58ef26591">NfdsT</a></td></tr>
<tr class="memdesc:a8cb8a1b63cc61bb57fe8c8c58ef26591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for the number of file descriptors. <br /></td></tr>
<tr class="separator:a8cb8a1b63cc61bb57fe8c8c58ef26591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da164bafc83a64e6a51068805e5df52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0da164bafc83a64e6a51068805e5df52"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a></td></tr>
<tr class="memdesc:a0da164bafc83a64e6a51068805e5df52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for length and size values for socket-related parameters. <br /></td></tr>
<tr class="separator:a0da164bafc83a64e6a51068805e5df52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
列挙型</h2></td></tr>
<tr class="memitem:a2c63ce69dddbb1c78d89626f2c43e736"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736">AddrInfoFlag</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736af5758c7e9b74944ef16fe00171db2626">AddrInfoFlag::Ai_None</a> = 0x00000000, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736a07f3aa8bca15327f9ff738676c87a17b">AddrInfoFlag::Ai_Passive</a> = 0x00000001, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736a1a2e6d6759bb114a41af8185090c58e3">AddrInfoFlag::Ai_CanonName</a> = 0x00000002, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736a4e9c7347da15e21e33637e92a8c5357a">AddrInfoFlag::Ai_NumericHost</a> = 0x00000004, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736a25bb67f3036a24405c49021582b87048">AddrInfoFlag::Ai_NumericServ</a> = 0x00000008, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736adc37ac841acdd2d44f66639c607345d2">AddrInfoFlag::Ai_AddrConfig</a> = 0x00000400
<br />
 }<tr class="memdesc:a2c63ce69dddbb1c78d89626f2c43e736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag values for <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60">nn::socket::GetAddrInfo()</a>.  <a href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736">[詳解]</a><br /></td></tr>
<tr class="separator:a2c63ce69dddbb1c78d89626f2c43e736"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:af622578590c2fb499d0c41023de4952a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952a">AiErrno</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952aa063e46c2edc044d4eb15ff1881c61617">AiErrno::EAi_Success</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952aa7dedf0718f97c8239662b8eb48051ec3">AiErrno::EAi_AddrFamily</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952aa39c09b23fe2d1d3727cabe8374db3f32">AiErrno::EAi_Again</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952aa2d629ab06248d8373abced5a838e16e1">AiErrno::EAi_BadFlags</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952aa0af973135fb5e1f7e6b4928735cab38b">AiErrno::EAi_Fail</a> = 4, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952aa249e58b45b4f5d5d3c7d829fd0838007">AiErrno::EAi_Family</a> = 5, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952aa4eb196554f2312d8e76fe54ec43f9732">AiErrno::EAi_Memory</a> = 6, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952aad39f7a0b221378921dbabe9ddb42e91c">AiErrno::EAi_NoData</a> = 7, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952aa49ba37cc879f6a8bd0ed14ca7dd7b900">AiErrno::EAi_NoName</a> = 8, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952aa6d4318baa1c030e5a7bd4bf5847895b8">AiErrno::EAi_Service</a> = 9, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952aa862515285580e8bbd7cdd9197eb610fc">AiErrno::EAi_SockType</a> = 10, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952aa3a66c0aef3e90e7853328eaba9c70a24">AiErrno::EAi_System</a> = 11, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952aa3cd3fdba16234bd5004596f5bd1eff8a">AiErrno::EAi_BadHints</a> = 12, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952aaf760c4b7855651610ab6e6d0262b3250">AiErrno::EAi_Protocol</a> = 13, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952aab42b238abde7f85eb903e64a0cdd51a6">AiErrno::EAi_Overflow</a> = 14, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952aa21cbeb8fe93b42d2e15c7d9719efa52d">AiErrno::EAi_Max</a> = 15
<br />
 }<tr class="memdesc:af622578590c2fb499d0c41023de4952a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error return codes from <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60">nn::socket::GetAddrInfo()</a> and <a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3">nn::socket::GetNameInfo()</a>  <a href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952a">[詳解]</a><br /></td></tr>
<tr class="separator:af622578590c2fb499d0c41023de4952a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ad1ade4838b158c7aaf9c9a78338e06ae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06ae">Errno</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aead87a63798e8be82fcb6b21bf1389ebb3">Errno::ESuccess</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea8cb8036f66c3dfbaaf7c62a5e0a92ce9">Errno::EPerm</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeae9dfa78f47aa1a9ae898a456edeb3fdf">Errno::ENoEnt</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea94262e2ab3d109b69027b3976ec8585c">Errno::ESrch</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaa9b197bd177776afbc2d1a323bf3b929">Errno::EIntr</a> = 4, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea9aa6aea17a595d5edf68646fa2d15383">Errno::EIo</a> = 5, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeac238316b78246eeed4b7786dc622be53">Errno::ENxIo</a> = 6, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea481b5ef7382eb2ea7906e96b83018691">Errno::E2Big</a> = 7, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea032bc39a8be16a062b0663cfff115c00">Errno::ENoExec</a> = 8, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327">Errno::EBadf</a> = 9, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeab03f18641ecf1c34a97116a65f901c1f">Errno::EChild</a> = 10, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> = 11, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaeef22a2860814281d48b1e798808eb01">Errno::ENoMem</a> = 12, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeac382e6a51872c6a43d968c2462a2d3be">Errno::EAcces</a> = 13, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea3fdc41982aa0e73be04ddc708c157a7b">Errno::EFault</a> = 14, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea7ddba288471ecbe5a3a03ffb2c5ef2de">Errno::ENotBlk</a> = 15, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea99d02c0b2c99135d3bb7d041a119609c">Errno::EBusy</a> = 16, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea3d8c5ab131894728bc3324147d27683e">Errno::EExist</a> = 17, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaede9c068704964dc47ebad0a85de9bcc">Errno::EXDev</a> = 18, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea353dd408073cecdf73344f6ee37d3577">Errno::ENoDev</a> = 19, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaa036977d257701b74035e7b27639cb6d">Errno::ENotDir</a> = 20, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeae3f3602dbfee7cfd783ca5dd8cc27b29">Errno::EIsDir</a> = 21, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> = 22, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeae2a9ccfa0eb433b4573729569317d7de">Errno::ENFile</a> = 23, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeab3f5564877c20a778d6e7b4e80c080bd">Errno::EMFile</a> = 24, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea7259324ba5d862aaba5087583e8404a3">Errno::ENotTy</a> = 25, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea2155c3e8f97b702b092a897a2a0d8f9d">Errno::ETxtBsy</a> = 26, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea7594267c68c9883209f58150b19a6ec4">Errno::EFBig</a> = 27, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea5a15b5dc74aea8072e75da3f41cc08c8">Errno::ENoSpc</a> = 28, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea76d2318325d33c3a63e04e369785457c">Errno::ESPipe</a> = 29, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea2b2a5ace1385019b28a6192572243703">Errno::ERofs</a> = 30, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaf9af2489821fd5296454151f1d61a9b8">Errno::EMLink</a> = 31, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaf09952a7a43905596163dee3291e06f2">Errno::EPipe</a> = 32, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea8e85d2487bfcde46c46ad44c85fecca4">Errno::EDom</a> = 33, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaa7ed7ab95d3141a0a84b06d889e00b1d">Errno::ERange</a> = 34, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea99bc84d1fee6f5e097b3bdd372bc914f">Errno::EDeadLk</a> = 35, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea0a8835335a60c7bf038a6c42ae669745">Errno::ENameTooLong</a> = 36, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea0b65c5e43ec5a9ba372624270883ae53">Errno::ENoLck</a> = 37, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeab65b727f3eafd0629c5986511656875c">Errno::ENoSys</a> = 38, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea36fa6025bf27ade7aaf59811f28cdbe3">Errno::ENotEmpty</a> = 39, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaaee63432c3362be93935e1855de31281">Errno::ELoop</a> = 40, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea5d63aa85f4278c762a695b787e5e20b4">Errno::EWouldBlock</a> = EAgain, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaeb4f7d7103ecf7106a8a34e335db604d">Errno::ENoMsg</a> = 42, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea86fcf9e8f1df22cb57bd9cc46abe29a1">Errno::EIdrm</a> = 43, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaa1806e60358990b585e9ebbf3bd4cb45">Errno::EChrng</a> = 44, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaa96c7ac811f484535930e716937d0e51">Errno::EL2NSync</a> = 45, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea267c68029d67983fa737bad281e73c65">Errno::EL3Hlt</a> = 46, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea5a7f23fcd4f8f7e3024165be95eddffb">Errno::EL3Rst</a> = 47, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeac085198eab87c32a83f2302e54bd63f3">Errno::ELnrng</a> = 48, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea49f3ca511be782138dc36e300b3ec77d">Errno::EUnatch</a> = 49, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeac6fbf79d425cac6aa3a7647c648db7a9">Errno::ENoCsi</a> = 50, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea754e4a149c2bef94f597fd18aad1942e">Errno::EL2Hlt</a> = 51, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea98a2c035dc14ffe381438c5a01a71e5b">Errno::EBade</a> = 52, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea6dc080b07103aec2872a56b5a95f87f2">Errno::EBadr</a> = 53, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaf543b8d05f23df49fd94345d665142ad">Errno::EXFull</a> = 54, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeab6a3ca11021fd08f6ca9612b6756b47d">Errno::ENoAno</a> = 55, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaf0af4df7f25af6e90e9925677d631a91">Errno::EBadRqc</a> = 56, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea22cd0d41773f55130d34199b602a7e3f">Errno::EBadSsl</a> = 57, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaa51209c0ef37d581997c721138fbde41">Errno::EDeadLock</a> = EDeadLk, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaaf1977c1079d808c8223e903ee066394">Errno::EBFont</a> = 59, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeab8aeae1f148aeb1b00a8ccef3e8332d1">Errno::ENoStr</a> = 60, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeae5b187b5ed40557fb744d0cf69b73351">Errno::ENoData</a> = 61, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaedf113fb19efb25f3b46f1b99d11d69d">Errno::ETime</a> = 62, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aead41a1d27c02d53137652889638aa4138">Errno::ENoSr</a> = 63, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea08c9024db7b48774ef44b0c8a103d388">Errno::ENoNet</a> = 64, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaec81a97edcf4772d610f708f49d16e45">Errno::ENoPkg</a> = 65, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaa01032c7629608efdfd7253fe0c5dbb1">Errno::ERemote</a> = 66, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeafa0104095220ecf07759933ab1e10b33">Errno::ENoLink</a> = 67, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea282bfaddb76098fec2111c26b82ce85d">Errno::EAdv</a> = 68, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaf8b86149f324f791fab7ecfb12916595">Errno::ESrmnt</a> = 69, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea77872136029e815a5a3756c9a6f4279d">Errno::EComm</a> = 70, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea93e6b9fa5def179ed993b29254ff95e7">Errno::EProto</a> = 71, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea0be074eb8d9371b337b057b6ad2a2207">Errno::EMultiHop</a> = 72, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea05093bab5e645d217995d00c511dcd1e">Errno::EDotDot</a> = 73, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea2012ba78cb82480bbc7a499e105e68e2">Errno::EBadMsg</a> = 74, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea4cbbf7e70525cecf368c4fcf90457d4a">Errno::EOverflow</a> = 75, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea1975215dabd3b158590d70dc7c7bd3d6">Errno::ENotUnuq</a> = 76, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea768786ee873b0d516097ba570626e0ef">Errno::EBadFd</a> = 77, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea709157bbce9f8d21813d3e4aa9c3da71">Errno::ERemChg</a> = 78, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaea49a6d33feb1d380c3ca35bec00a2a2">Errno::ELibAcc</a> = 79, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaf24a082c490b0a274088c14392880d28">Errno::ELibBad</a> = 80, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeac44b613805edd820f39406847276eb28">Errno::ELibScn</a> = 81, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeab04713ab44ec88a625f518886623300d">Errno::ELibMax</a> = 82, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea7cb0887230f830194a839ad259de4dc5">Errno::ELibExec</a> = 83, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeae2f22fccaae58fb6a1511791ec2ab48a">Errno::EIlSeq</a> = 84, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeac888d9b9c48639ba474f73d7fae8a1fa">Errno::ERestart</a> = 85, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea85f3fa8f2af7fa459898318ff03403c9">Errno::EStrPipe</a> = 86, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeae92fcfd186d87a32e655aa7d30728ddd">Errno::EUsers</a> = 87, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea2ee283d2ea4a7035cf02f4401ad6e8c4">Errno::ENotSock</a> = 88, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeab6f06c9908647268602ee06dfe4de82e">Errno::EDestAddrReq</a> = 89, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aead50e4ce04c6d8fa3bcedc355c71e6908">Errno::EMsgSize</a> = 90, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea42dc875635f09bfea546420510ac0ab1">Errno::EPrototype</a> = 91, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaaceea24a2e74e865ad49c5235aa80390">Errno::ENoProtoOpt</a> = 92, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea0b862e14b0970b149efcc374d17116e9">Errno::EProtoNoSupport</a> = 93, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea75f70195d7962cf82c8222f4cce70f39">Errno::ESocktNoSupport</a> = 94, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeac2dd8a9d9020d692236fe36e327a0790">Errno::EOpNotSupp</a> = 95, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea55d425f0db40e77288d34ab4ed070f18">Errno::ENotSup</a> = EOpNotSupp, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea1720dfd2feee6b1db8936ab2ab34eb97">Errno::EPfNoSupport</a> = 96, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea8aa5fd58e6123e002dd6794a9dd41d19">Errno::EAfNoSupport</a> = 97, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea5d70ce827609b95db47cb2801a9a3f02">Errno::EAddrInUse</a> = 98, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea80a6ebced38fdfd7e5fe5a2263b0fdfd">Errno::EAddrNotAvail</a> = 99, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeae57b86c74a54b9dfc0a43f20885d531b">Errno::ENetDown</a> = 100, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeae9e5813d133d21c50d5b9d2821b5c7d5">Errno::ENetUnreach</a> = 101, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeab57c2bd2da5b8a225fd2ed15216279b5">Errno::ENetReset</a> = 102, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeafe202ba38fe5506795fa6f3ac18b1d7e">Errno::EConnAborted</a> = 103, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea35b0f4b6f7c078dbf75d488c08d644d7">Errno::EConnReset</a> = 104, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea8c84e92e411b15ee2a52955b1a4c7f59">Errno::ENoBufs</a> = 105, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea7e42ca49cd604842cf40a55a6fb1da37">Errno::EIsConn</a> = 106, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea49ef25c2845d57c542b75ebf74c22d32">Errno::ENotConn</a> = 107, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea729df151046a4792119264f623eb80e1">Errno::EShutDown</a> = 108, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea092cb05e83ae8bf3fbf945987f17ff16">Errno::ETooManyRefs</a> = 109, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeab8b3b473d7a87bc0787d270847504b62">Errno::ETimedOut</a> = 110, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea06cb83b76f73aee6a739e690d8a615e0">Errno::EConnRefused</a> = 111, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea03738213bb11b2d3c3d4296514be9544">Errno::EHostDown</a> = 112, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea4d13a4e176134b1b99e47bc557803186">Errno::EHostUnreach</a> = 113, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea01a1169f10a84bd5ca327117f7357ffc">Errno::EAlready</a> = 114, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaa912f0d27a490f37dd216b352c5bafc4">Errno::EInProgress</a> = 115, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea1c3b5910a911d1f3e41edba2f06594b5">Errno::EStale</a> = 116, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea9d732f137d84e7da1b32b9cb736d1ddc">Errno::EUClean</a> = 117, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea6282a4dccf34458154ae15890b37d659">Errno::ENotNam</a> = 118, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea23e17817410df3175208154a51b25a55">Errno::ENAvail</a> = 119, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeae9e3ed355fc29e0dad6d05c848e451c8">Errno::EIsNam</a> = 120, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea25f7ffafd2d0599fc5cbee65c14684af">Errno::ERemoteIo</a> = 121, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea82395bcac4c12e9c7c114484e7d75adc">Errno::EDQuot</a> = 122, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea3875301196f736df1fc0723290bce35a">Errno::ENoMedium</a> = 123, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea7c28e4df0019f6dd00c2cfb26ce6b99d">Errno::EMediumType</a> = 124, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaa1e822d71d55e23ef9fdd62d3f00186f">Errno::ECanceled</a> = 125, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea1d533f04c62e336634a34c5d2682d2b4">Errno::ENoKey</a> = 126, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea36e49b905c1ebbea57e42090b42f6d36">Errno::EKeyExpired</a> = 127, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea270c5f22a81c83e17ae57842341b31c6">Errno::EKeyRevoked</a> = 128, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea399cb55edc8e96b594f10358c8ebbdca">Errno::EKeyRejected</a> = 129, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea06bc3b94addadc4c4f6415bd684823bb">Errno::EOwnerDead</a> = 130, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea0bffc159cd62dee50d8f41c1eb13cac8">Errno::ENotRecoverable</a> = 131, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea1997f833be90d1e8062107d8cb1217ea">Errno::ERfKill</a> = 132, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea67b3313d2dc7e38962494c534e3e0235">Errno::EHwPoison</a> = 133, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea99205299258cb573335d080cb4f7c2de">Errno::EProcLim</a> = 156
<br />
 }<tr class="memdesc:ad1ade4838b158c7aaf9c9a78338e06ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global variable <em>errno</em> values, also returned by <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890">nn::socket::GetLastError()</a>.  <a href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06ae">[詳解]</a><br /></td></tr>
<tr class="separator:ad1ade4838b158c7aaf9c9a78338e06ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a057d985148e23267303e6d00d7ed205d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205d">Family</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205daf71f2e4ba3e999c5a27fdd7ad7044628">Family::Af_Unspec</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205da3e60ee00982f3876225add01b048d51c">Family::Pf_Unspec</a> = Af_Unspec, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205daa4d833d8c15a76105639ddd11bcb614e">Family::Af_Inet</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205dab67c056bcb9139a61ab2022bf23270c4">Family::Pf_Inet</a> = Af_Inet, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205da53d19d3503b80a25464b42ea2b842570">Family::Af_Route</a> = 17, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205daf382a0598ba805d89710d4aa2b572371">Family::Pf_Route</a> = Af_Route, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205da286989897035d6bfc1481a71643368de">Family::Af_Link</a> = 18, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205dad55e05ade1d509f24b1e731722f38490">Family::Pf_Link</a> = Af_Link, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205daf734c28714ec9e1040af4f8f4c30b824">Family::Af_Inet6</a> = 28, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205da27e24d2ad16f16c9ee6d44c72fbfa310">Family::Pf_Inet6</a> = Af_Inet6
<br />
 }<tr class="memdesc:a057d985148e23267303e6d00d7ed205d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address and protocol families.  <a href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205d">[詳解]</a><br /></td></tr>
<tr class="separator:a057d985148e23267303e6d00d7ed205d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ae03bdb6384cac8b1ba7617743144d09f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ae03bdb6384cac8b1ba7617743144d09f">FcntlCommand</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ae03bdb6384cac8b1ba7617743144d09fa02772fa35d3b587e7642cbf50c753d08">FcntlCommand::F_GetFl</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ae03bdb6384cac8b1ba7617743144d09fada2f7613aac1b87c8679a7b8c03ac9ca">FcntlCommand::F_SetFl</a> = 4
<br />
 }<tr class="memdesc:ae03bdb6384cac8b1ba7617743144d09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commands used for <a class="el" href="namespacenn_1_1socket.html#a92cb62635aca20860e3ab848f347ec6f">nn::socket::Fcntl()</a>.  <a href="namespacenn_1_1socket.html#ae03bdb6384cac8b1ba7617743144d09f">[詳解]</a><br /></td></tr>
<tr class="separator:ae03bdb6384cac8b1ba7617743144d09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:aa04c2b32bf6fe54bdbb1a3f5febdc477"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#aa04c2b32bf6fe54bdbb1a3f5febdc477">FcntlFlag</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#aa04c2b32bf6fe54bdbb1a3f5febdc477a6adf97f83acf6453d4a6a4b1070f3754">FcntlFlag::None</a> = 0x0000, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#aa04c2b32bf6fe54bdbb1a3f5febdc477a5693df4e99113d8216f084412a7a3849">FcntlFlag::O_NonBlock</a> = 0x0800
<br />
 }<tr class="memdesc:aa04c2b32bf6fe54bdbb1a3f5febdc477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commands used for <a class="el" href="namespacenn_1_1socket.html#a92cb62635aca20860e3ab848f347ec6f">nn::socket::Fcntl()</a>.  <a href="namespacenn_1_1socket.html#aa04c2b32bf6fe54bdbb1a3f5febdc477">[詳解]</a><br /></td></tr>
<tr class="separator:aa04c2b32bf6fe54bdbb1a3f5febdc477"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a7d8c1d2e11d6bdbdd12c05bc4505e96e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a7d8c1d2e11d6bdbdd12c05bc4505e96e">HErrno</a> : int32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a7d8c1d2e11d6bdbdd12c05bc4505e96ea12a4c4b6f764342d7774ec0b61507035">HErrno::Netdb_Internal</a> = -1, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a7d8c1d2e11d6bdbdd12c05bc4505e96ea974fb47430ce74d9c031981a1ba70449">HErrno::Netdb_Success</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a7d8c1d2e11d6bdbdd12c05bc4505e96ea8815b22a3d45c4582c575a4ddf301f27">HErrno::Host_Not_Found</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a7d8c1d2e11d6bdbdd12c05bc4505e96ea75a5b439512277f31d1165a59f32c21b">HErrno::Try_Again</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a7d8c1d2e11d6bdbdd12c05bc4505e96ea1b315dd1ed4bffa191e3c42162cd86e3">HErrno::No_Recovery</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a7d8c1d2e11d6bdbdd12c05bc4505e96eaf0a483b6ea00b43c8e211e4d5bf2e630">HErrno::No_Data</a> = 4, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a7d8c1d2e11d6bdbdd12c05bc4505e96ea6643bf2c5cc3c9c98495983e431cddad">HErrno::No_Address</a> = No_Data
<br />
 }<tr class="memdesc:a7d8c1d2e11d6bdbdd12c05bc4505e96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error return codes from <a class="el" href="namespacenn_1_1socket.html#a358030926e9e63c2e322de2bd3d26719">nn::socket::GetHostEntByName()</a> and <a class="el" href="namespacenn_1_1socket.html#aaace32e2780295ca03bc72efa4b49406">nn::socket::GetHostEntByAddr()</a>  <a href="namespacenn_1_1socket.html#a7d8c1d2e11d6bdbdd12c05bc4505e96e">[詳解]</a><br /></td></tr>
<tr class="separator:a7d8c1d2e11d6bdbdd12c05bc4505e96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a047cb0e8a33ab75269a940a59ac7f62a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a047cb0e8a33ab75269a940a59ac7f62a">IoctlCommand</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a047cb0e8a33ab75269a940a59ac7f62aa84615c987f017ddb39fcd935e4745258">IoctlCommand::FionRead</a> = 0x4004667f, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a047cb0e8a33ab75269a940a59ac7f62aa316efa79f1d14b40adaa703d8483610b">IoctlCommand::FionWrite</a> = 0x40046677, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a047cb0e8a33ab75269a940a59ac7f62aad4c0438bde575cc3318c3ca43dee2192">IoctlCommand::FionSpace</a> = 0x40046676
<br />
 }<tr class="memdesc:a047cb0e8a33ab75269a940a59ac7f62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commands used for <a class="el" href="namespacenn_1_1socket.html#a558dc819d133326891523fcaf32303f8">nn::socket::Ioctl()</a>.  <a href="namespacenn_1_1socket.html#a047cb0e8a33ab75269a940a59ac7f62a">[詳解]</a><br /></td></tr>
<tr class="separator:a047cb0e8a33ab75269a940a59ac7f62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a8f9b7859b60d1ee546e472a7e2a9beaa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a8f9b7859b60d1ee546e472a7e2a9beaa">Level</a> : int32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a8f9b7859b60d1ee546e472a7e2a9beaaa4418133767fb2aecc740f56abdda0a07">Level::Sol_Socket</a> = 0xffff, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a8f9b7859b60d1ee546e472a7e2a9beaaaa6c6737dec8d29d339301143d6d0ed79">Level::Sol_Ip</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a8f9b7859b60d1ee546e472a7e2a9beaaa064e9643ad5bd7963ac529d40422c41e">Level::Sol_Icmp</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a8f9b7859b60d1ee546e472a7e2a9beaaa07877ef6eba5cd50e7fd156ab490e25e">Level::Sol_Tcp</a> = 6, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a8f9b7859b60d1ee546e472a7e2a9beaaa28ce2e827de6e03222cb031dd7262005">Level::Sol_Udp</a> = 17, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a8f9b7859b60d1ee546e472a7e2a9beaaa20031d70d0159b1e9216a32ed067d4ba">Level::Sol_UdpLite</a> = 136
<br />
 }<tr class="memdesc:a8f9b7859b60d1ee546e472a7e2a9beaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket option level.  <a href="namespacenn_1_1socket.html#a8f9b7859b60d1ee546e472a7e2a9beaa">[詳解]</a><br /></td></tr>
<tr class="separator:a8f9b7859b60d1ee546e472a7e2a9beaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a821ac1738bb13dce9aa9d83fe5950e52"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52">MsgFlag</a> : int32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a7a99ac706c1462eb6f473b328821257e">MsgFlag::Msg_None</a> = 0x00000, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a14e4712b9ac705dd2c8cbb473bede526">MsgFlag::Msg_Oob</a> = 0x00001, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a1aa484a90bed28ad47fd226459e15faa">MsgFlag::Msg_Peek</a> = 0x00002, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52ac9a7ddcbf8db795e5c91d656a22b732a">MsgFlag::Msg_DontRoute</a> = 0x00004, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a5d31324825e019d3755c5b5eea5cddf6">MsgFlag::Msg_Eor</a> = 0x00008, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52aaf8c9241ace744a91fdac5bb1af8edb9">MsgFlag::Msg_Trunc</a> = 0x00010, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52ae891367d63615cef0b025c484c813bba">MsgFlag::Msg_CTrunc</a> = 0x00020, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52aa7788a6088ac1aa8889be821288b9c27">MsgFlag::Msg_WaitAll</a> = 0x00040, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a7fba2ade674c746aff1d987a7c23498d">MsgFlag::Msg_DontWait</a> = 0x00080, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a7f014516b662a223d74679cc3eb2808f">MsgFlag::Msg_Eof</a> = 0x00100, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a453a9db8f1ba520722d49137ad4a0785">MsgFlag::Msg_Notification</a> = 0x02000, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52aa812cfecd484f40a7d10b32686bc6442">MsgFlag::Msg_Nbio</a> = 0x04000, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a2ca7dca75281c108b1fcc487a7eefe86">MsgFlag::Msg_Compat</a> = 0x08000, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a1b6e6ae71d15f3af3a41cd07db319f28">MsgFlag::Msg_SoCallbck</a> = 0x10000, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a7122062c2353a3f567ef0ea82727da75">MsgFlag::Msg_NoSignal</a> = 0x20000, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52ac65aa2182e54666b95d4ffa9693d105d">MsgFlag::Msg_CMsg_CloExec</a> = 0x40000
<br />
 }<tr class="memdesc:a821ac1738bb13dce9aa9d83fe5950e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message flags.  <a href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52">[詳解]</a><br /></td></tr>
<tr class="separator:a821ac1738bb13dce9aa9d83fe5950e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ab65d6a3635e193943fa4f95edfbebeae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ab65d6a3635e193943fa4f95edfbebeae">NameInfoFlag</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ab65d6a3635e193943fa4f95edfbebeaea71fedd318bedd821cec9abb5af3505ed">NameInfoFlag::Ni_None</a> = 0x00000000, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ab65d6a3635e193943fa4f95edfbebeaea2b7218595524993b8a5e6f28be48a06e">NameInfoFlag::Ni_NoFqdn</a> = 0x00000001, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ab65d6a3635e193943fa4f95edfbebeaeabce932039fed36ee2d7f93f65888d7cd">NameInfoFlag::Ni_NumericHost</a> = 0x00000002, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ab65d6a3635e193943fa4f95edfbebeaead52a0caf970660226eabd510f35a6d4b">NameInfoFlag::Ni_NameReqd</a> = 0x00000004, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ab65d6a3635e193943fa4f95edfbebeaea1424d526e3e5f2ce5e6e62387181fa3c">NameInfoFlag::Ni_NumericServ</a> = 0x00000008, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#ab65d6a3635e193943fa4f95edfbebeaea2a229d7a05bf4eafb5480f2b0e67b84e">NameInfoFlag::Ni_Dgram</a> = 0x00000010
<br />
 }<tr class="memdesc:ab65d6a3635e193943fa4f95edfbebeae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag values for <a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3">nn::socket::GetNameInfo()</a>.  <a href="namespacenn_1_1socket.html#ab65d6a3635e193943fa4f95edfbebeae">[詳解]</a><br /></td></tr>
<tr class="separator:ab65d6a3635e193943fa4f95edfbebeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a9706518d71ec37371e9aa3ae9a2fa92c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92c">Option</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca2f86c3240686e886bf04673b6dfa1774">Option::So_Debug</a> = 0x0001, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca56f0c4e92af8ae866a97313e10f27825">Option::So_AcceptConn</a> = 0x0002, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca4ff047a311170a7b1b91fbf572b27827">Option::So_ReuseAddr</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca7c793a7e8f86558ba08b3ef3c45cb65a">Option::So_KeepAlive</a> = 0x0008, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca593d609439615cf3bb8fcb4e033212f6">Option::So_DontRoute</a> = 0x0010, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca71f2d3c1f2b815034748923c95b3c7c2">Option::So_Broadcast</a> = 0x0020, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca063d4fa19cacacc94e1eb4ab53c69583">Option::So_UseLoopback</a> = 0x0040, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca77f52d4d2b4cb0a18003473b82fe62fa">Option::So_Linger</a> = 0x0080, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca83cd727bfab799ab2c3282993bc4890e">Option::So_OobInline</a> = 0x0100, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca98f34f2098b46d53adb82302fd9fd3cc">Option::So_ReusePort</a> = 0x0200, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca4078c1b605c4c29f21a0bf25944c0cd4">Option::So_SndBuf</a> = 0x1001, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca1600030ecdfa4988343a0182c2716781">Option::So_RcvBuf</a> = 0x1002, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cacae1d771853d17e6345e649b6f5268c3">Option::So_SndLoWat</a> = 0x1003, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cac06b98b070f9197dd3cae7e9426beb8f">Option::So_RcvLoWat</a> = 0x1004, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca9b65d34203dd13d8c6477fb765edd60a">Option::So_SndTimeo</a> = 0x1005, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cab5605811c9cdb8e46fa16b737d6473b8">Option::So_RcvTimeo</a> = 0x1006, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92caa09b2054c97d538ca128022bdb5d70ff">Option::So_Error</a> = 0x1007, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca290eb4182e53294ce5d51f5ddb9faaf4">Option::So_Type</a> = 0x1008, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca13b81ea29143e0f425217f0cc1e1d947">Option::So_Label</a> = 0x1009, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca0ad5d7204fe937a474e3bee89a8911c5">Option::So_PeerLabel</a> = 0x1010, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cadcf2eab57ae78219999a1f3c0220606f">Option::So_ListenQLimit</a> = 0x1011, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca1ccb3b4f5df5d298d6634435264cf552">Option::So_ListenQLen</a> = 0x1012, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca1ab76ba3c3c726d472d8b67a408c6e2f">Option::So_ListenIncQLen</a> = 0x1013, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca5a873168505d4f5805a0f479afefbd7a">Option::So_SetFib</a> = 0x1014, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca0a0e7b92f66b475e7f263a1f47517ab4">Option::So_User_Cookie</a> = 0x1015, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cad6a9f6dc315317276189f9dbda9e2142">Option::So_Protocol</a> = 0x1016
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92caab7d92ab038534d93c3a247917928cb7">Option::So_Nn_Linger</a> = 0x80000001
, <br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cacfc84cbe560a8aad1c718a7861e33d71">Option::Ip_Options</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca2ea192d20c0bb4351564aca953d62e87">Option::Ip_HdrIncl</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92caa981510ed4830206d7a6c3d118dc9392">Option::Ip_Tos</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca1f884d211d51f87827c58fa2a8b53e76">Option::Ip_Ttl</a> = 4, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca7d421a52a6a6930d432e4a6b7c8e8fe5">Option::Ip_RecvOpts</a> = 5, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cafe12b995ba510bc29c236f12bce3b972">Option::Ip_Multicast_If</a> = 9, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca32ee18abf563ea6ee9912737d312655c">Option::Ip_Multicast_Ttl</a> = 10, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca02f8ec2a469d61c090f3472089a4ab36">Option::Ip_Multicast_Loop</a> = 11, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cac8ec2fe65eaf9fdbc23297dfd36a9e1c">Option::Ip_Add_Membership</a> = 12, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca091584d2877be7911a41c16f2acf0814">Option::Ip_Drop_Membership</a> = 13, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cac7ec079d666c2ffea2fc0d8759b72d7f">Option::Ip_Multicast_Vif</a> = 14, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cab3e067b0aba5e72268f07dcd455f6ded">Option::Ip_Rsvp_On</a> = 15, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca5cdbe7531950912a74f908d990c26295">Option::Ip_Rsvp_Off</a> = 16, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca301f39b550212b09d1e173bb96d8ac15">Option::Ip_Rsvp_Vif_On</a> = 17, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca4e184874353ac4f02d70fe94a67a344f">Option::Ip_Rsvp_Vif_Off</a> = 18, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca12ca196d5fb48531054942f9ba700d15">Option::Ip_PortRange</a> = 19, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cacebde55581618620bacce1c92d246328">Option::Ip_Faith</a> = 22, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca009cfa491615a4710953fa9c3c0c7afd">Option::Ip_OnesBcast</a> = 23, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92caad3f23ed3b1fad7b0ba236a40734e381">Option::Ip_BindAny</a> = 24, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca726abe575b22d7c088bff64f17b6b44b">Option::Ip_RecvTtl</a> = 65, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cad126866d462a421818799f793e87ebcf">Option::Ip_MinTtl</a> = 66, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca1307d6c88fcc4ef7d6a541488f70e777">Option::Ip_DontFrag</a> = 67, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca42706217d313156a41db74a1cc7c96f0">Option::Ip_RecvTos</a> = 68, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca7f5b507de957ab754cfbcae70ee9d8d8">Option::Ip_Add_Source_Membership</a> = 70, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca34b4c9a8fbbef3ccc7a610f45df33133">Option::Ip_Drop_Source_Membership</a> = 71, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca42fccf017ac8a271f88ec603b2862164">Option::Ip_Block_Source</a> = 72, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca4f2e75d3a2af1d30ae44ebfccbee668c">Option::Ip_Unblock_Source</a> = 73, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca2d22a30cb3647dfc45e9cf81c9d7c92e">Option::Tcp_NoDelay</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca3803ae0a82bbc2976fb7d037c66f1e9d">Option::Tcp_MaxSeg</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cab15153f4944a9fddf656bc872f1e4177">Option::Tcp_NoPush</a> = 4, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca79acf2a72d56c802833bca601b678969">Option::Tcp_NoOpt</a> = 8, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca74b6412fc6ea85cbe84a85d1d20f4bce">Option::Tcp_Md5Sig</a> = 16, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca702daca3186e133db09b35f6f08dd7a0">Option::Tcp_Info</a> = 32, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca2e75bc9c4246e5aa93361746bfd8d053">Option::Tcp_Congestion</a> = 64, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cadb6dbfbe2b1f7554bc0c74e3b79b2256">Option::Tcp_KeepInit</a> = 128, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca3b7b30a418f99590551e9c817ff6eda1">Option::Tcp_KeepIdle</a> = 256, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca31d953fbd5cadf801a1bb6ee9d2037f0">Option::Tcp_KeepIntvl</a> = 512, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca6ced1ae2c7ebbc4173ac523590632bc5">Option::Tcp_KeepCnt</a> = 1024
<br />
 }<tr class="memdesc:a9706518d71ec37371e9aa3ae9a2fa92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation flags, OR'ed into <a class="el" href="namespacenn_1_1htcs.html#ae94161d3d49b7af2a87d701a1a87282e" title="新しいソケットを作成します。 ">Socket()</a> type argument.  <a href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92c">[詳解]</a><br /></td></tr>
<tr class="separator:a9706518d71ec37371e9aa3ae9a2fa92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a2b8c53cba8a2be170c93a76742b092c9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9">PollEvent</a> : int16_t { , <br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9a1b0bed7d85ba6b2cbe91629776e3ee6d">PollEvent::PollIn</a> = 0x0001, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9a1034fc649394d42b19fead1ab1828e54">PollEvent::PollPri</a> = 0x0002, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9aca8de23660319dc20822f6e6059a727b">PollEvent::PollOut</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9a6aee635278505dd8cc1da7f50c4a651d">PollEvent::PollErr</a> = 0x0008, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9a2421093408548ab23a7a93500e8cccd3">PollEvent::PollHup</a> = 0x0010, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9aecf0948bef1a1db017a0d4e714f05c04">PollEvent::PollNVal</a> = 0x0020, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9aaf909a6e6a64bebd393ae9fbc33f200a">PollEvent::PollRdNorm</a> = 0x0040, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9a9b8ce4bb4c25d8b2abc5e5648c9cd54a">PollEvent::PollRdBand</a> = 0x0080, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9af5abb7d0050a44e425556082ae71b547">PollEvent::PollWrNorm</a> = 0x0100, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9a70417b0dc75887023e5fa42ca645d4c9">PollEvent::PollWrBand</a> = 0x0200
<br />
 }<tr class="memdesc:a2b8c53cba8a2be170c93a76742b092c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll events.  <a href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9">[詳解]</a><br /></td></tr>
<tr class="separator:a2b8c53cba8a2be170c93a76742b092c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a46347de69614965469ac8f3c8056468e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a46347de69614965469ac8f3c8056468e">Protocol</a> : int32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a46347de69614965469ac8f3c8056468eae6688e7ecb2b86a2bdedd14a8f5794b2">Protocol::IpProto_Ip</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a46347de69614965469ac8f3c8056468eacfaf0973ac4989b34204076e08018320">Protocol::IpProto_Icmp</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a46347de69614965469ac8f3c8056468eaf07a075529789e7d91eefbce84c55d90">Protocol::IpProto_Tcp</a> = 6, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a46347de69614965469ac8f3c8056468ea48e0b0b8eaaf71a2c2c0ebfa0e802b1a">Protocol::IpProto_Udp</a> = 17, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a46347de69614965469ac8f3c8056468ea747b4da735a7d4f75f94d49bac3668c6">Protocol::IpProto_None</a> = 59, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a46347de69614965469ac8f3c8056468eace84ba4f81c9b91654d34b5e5ffff266">Protocol::IpProto_UdpLite</a> = 136, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a46347de69614965469ac8f3c8056468ea5f2672872a021cf5f726af1e84f26960">Protocol::IpProto_Raw</a> = 255
<br />
 }<tr class="memdesc:a46347de69614965469ac8f3c8056468e"><td class="mdescLeft">&#160;</td><td class="mdescRight">IP protocols.  <a href="namespacenn_1_1socket.html#a46347de69614965469ac8f3c8056468e">[詳解]</a><br /></td></tr>
<tr class="separator:a46347de69614965469ac8f3c8056468e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:aef8523201363cec26def667e89cbfeae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#aef8523201363cec26def667e89cbfeae">ShutdownMethod</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#aef8523201363cec26def667e89cbfeaea4c491712eb09285fbca6d544778ce617">ShutdownMethod::Shut_Rd</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#aef8523201363cec26def667e89cbfeaea92c4cf816a81e278824998e27103d833">ShutdownMethod::Shut_Wr</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#aef8523201363cec26def667e89cbfeaea026146e0cdfc1f3e09c9f6a838eb42ef">ShutdownMethod::Shut_RdWr</a> = 2
<br />
 }<tr class="memdesc:aef8523201363cec26def667e89cbfeae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown method used for <a class="el" href="namespacenn_1_1socket.html#a895595468f09d14293edd099a8ff7dc5">nn::socket::Shutdown()</a>.  <a href="namespacenn_1_1socket.html#aef8523201363cec26def667e89cbfeae">[詳解]</a><br /></td></tr>
<tr class="separator:aef8523201363cec26def667e89cbfeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a96fd860616eebd9a4ca188a750539572"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a96fd860616eebd9a4ca188a750539572">TcpInfoOption</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a96fd860616eebd9a4ca188a750539572ad57cdccdc23f4ba4c8fe5d272155b49e">TcpInfoOption::Tcpi_Opt_None</a> = 0x00, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a96fd860616eebd9a4ca188a750539572adf980a96851be8fe7039b3c2b0c2f7f6">TcpInfoOption::Tcpi_Opt_Timestamps</a> = 0x01, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a96fd860616eebd9a4ca188a750539572adeb8b2e5cc324d8502070ab9c7dcc9c1">TcpInfoOption::Tcpi_Opt_Sack</a> = 0x02, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a96fd860616eebd9a4ca188a750539572a7c7b64d43d00289a2ae237a0f052337c">TcpInfoOption::Tcpi_Opt_WScale</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a96fd860616eebd9a4ca188a750539572ae7114f77789abb146f37c238e28e6819">TcpInfoOption::Tcpi_Opt_Ecn</a> = 0x08, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a96fd860616eebd9a4ca188a750539572a3aca115b57cc3e563e1f7ae548e790b2">TcpInfoOption::Tcpi_Opt_Toe</a> = 0x10
<br />
 }<tr class="memdesc:a96fd860616eebd9a4ca188a750539572"><td class="mdescLeft">&#160;</td><td class="mdescRight">TcpInfo options.  <a href="namespacenn_1_1socket.html#a96fd860616eebd9a4ca188a750539572">[詳解]</a><br /></td></tr>
<tr class="separator:a96fd860616eebd9a4ca188a750539572"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a1db675083dcccec6500d1435c5dfeaea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaea">Type</a> : uint32_t { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaa221076d68c5f73ca9d81b6dd6c2e18d4">Type::Sock_Default</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaae703319723c99d2d3a7ba1ad0dc8f572">Type::Sock_Stream</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaa4cc079142a1be58955eb22bed651ebba">Type::Sock_Dgram</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaadbce0ab5f7ffb036b16d28b8e258f720">Type::Sock_Raw</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaa3ee64579e9e60354dc99756954340e99">Type::Sock_SeqPacket</a> = 5, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaa6aa760fecb3b3f81a3c5ed0425f99762">Type::Sock_NonBlock</a> = 0x20000000
<br />
 }<tr class="memdesc:a1db675083dcccec6500d1435c5dfeaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket type, which specifies the semantics of communication.  <a href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaea">[詳解]</a><br /></td></tr>
<tr class="separator:a1db675083dcccec6500d1435c5dfeaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
関数</h2></td></tr>
<tr class="memitem:a56b1fbede96c61d4c94ba51a3cc563b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept</a> (int socket, <a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> *pOutAddress, <a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a> *pOutAddressLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a56b1fbede96c61d4c94ba51a3cc563b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept connection on a socket.  <a href="#a56b1fbede96c61d4c94ba51a3cc563b3">[詳解]</a><br /></td></tr>
<tr class="separator:a56b1fbede96c61d4c94ba51a3cc563b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9950d093e134087776f1b96b8d9af7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a8d9950d093e134087776f1b96b8d9af7">Accept</a> (int socket, sockaddr *pOutAddress, socklen_t *pOutAddressLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8d9950d093e134087776f1b96b8d9af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept connection on a socket - This API will be deprecated in an upcoming SDK release.  <a href="#a8d9950d093e134087776f1b96b8d9af7">[詳解]</a><br /></td></tr>
<tr class="separator:a8d9950d093e134087776f1b96b8d9af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09255737b952ba3ad3a647607fc2af0a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a09255737b952ba3ad3a647607fc2af0a">Bind</a> (int socket, const <a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> *pAddress, <a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a> addressLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a09255737b952ba3ad3a647607fc2af0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a local protocol address to a socket.  <a href="#a09255737b952ba3ad3a647607fc2af0a">[詳解]</a><br /></td></tr>
<tr class="separator:a09255737b952ba3ad3a647607fc2af0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8632820906d88c202c0940ff227059"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ade8632820906d88c202c0940ff227059">Bind</a> (int socket, const sockaddr *pAddress, socklen_t addressLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ade8632820906d88c202c0940ff227059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a local protocol address to a socket - This API will be deprecated in an upcoming SDK release.  <a href="#ade8632820906d88c202c0940ff227059">[詳解]</a><br /></td></tr>
<tr class="separator:ade8632820906d88c202c0940ff227059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01110d228e2148d830b1ecfb9aaa425"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ae01110d228e2148d830b1ecfb9aaa425">Close</a> (int socket) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae01110d228e2148d830b1ecfb9aaa425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a descriptor.  <a href="#ae01110d228e2148d830b1ecfb9aaa425">[詳解]</a><br /></td></tr>
<tr class="separator:ae01110d228e2148d830b1ecfb9aaa425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aded7f0c8c072c7beb68a670d03d36f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f">Connect</a> (int socket, const <a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> *pAddress, <a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a> addressLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3aded7f0c8c072c7beb68a670d03d36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a connection on a socket.  <a href="#a3aded7f0c8c072c7beb68a670d03d36f">[詳解]</a><br /></td></tr>
<tr class="separator:a3aded7f0c8c072c7beb68a670d03d36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b827725f713f2618b9a7b68bb7dd744"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a6b827725f713f2618b9a7b68bb7dd744">Connect</a> (int socket, const sockaddr *pAddress, socklen_t addressLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6b827725f713f2618b9a7b68bb7dd744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a connection on a socket - This API will be deprecated in an upcoming SDK release.  <a href="#a6b827725f713f2618b9a7b68bb7dd744">[詳解]</a><br /></td></tr>
<tr class="separator:a6b827725f713f2618b9a7b68bb7dd744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad646fa3b59d55042faa555f9fbd4d501"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ad646fa3b59d55042faa555f9fbd4d501">Fcntl</a> (int socket, int command,...) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad646fa3b59d55042faa555f9fbd4d501"><td class="mdescLeft">&#160;</td><td class="mdescRight">File control - This API will be deprecated in an upcoming SDK release.  <a href="#ad646fa3b59d55042faa555f9fbd4d501">[詳解]</a><br /></td></tr>
<tr class="separator:ad646fa3b59d55042faa555f9fbd4d501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cb62635aca20860e3ab848f347ec6f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a92cb62635aca20860e3ab848f347ec6f">Fcntl</a> (int socket, <a class="el" href="namespacenn_1_1socket.html#ae03bdb6384cac8b1ba7617743144d09f">FcntlCommand</a> command,...) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a92cb62635aca20860e3ab848f347ec6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">File control.  <a href="#a92cb62635aca20860e3ab848f347ec6f">[詳解]</a><br /></td></tr>
<tr class="separator:a92cb62635aca20860e3ab848f347ec6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea3461fc5a67e39a6f8b6bb71a163b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a6ea3461fc5a67e39a6f8b6bb71a163b9">FdSetClr</a> (int fd, <a class="el" href="structnn_1_1socket_1_1_fd_set.html">FdSet</a> *pFdset) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6ea3461fc5a67e39a6f8b6bb71a163b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <em>fd</em> from <em>fdset</em>.  <a href="#a6ea3461fc5a67e39a6f8b6bb71a163b9">[詳解]</a><br /></td></tr>
<tr class="separator:a6ea3461fc5a67e39a6f8b6bb71a163b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f66b219c3bb6d59b09f26ee75348f82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a8f66b219c3bb6d59b09f26ee75348f82">FdSetIsSet</a> (int fd, const <a class="el" href="structnn_1_1socket_1_1_fd_set.html">FdSet</a> *pFdset) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8f66b219c3bb6d59b09f26ee75348f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if <em>fd</em> is a member of <em>pFdset</em>, zero otherwise.  <a href="#a8f66b219c3bb6d59b09f26ee75348f82">[詳解]</a><br /></td></tr>
<tr class="separator:a8f66b219c3bb6d59b09f26ee75348f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea80c65c3a931a374bf2f0aab5153d1"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a1ea80c65c3a931a374bf2f0aab5153d1">FdSetSet</a> (int fd, <a class="el" href="structnn_1_1socket_1_1_fd_set.html">FdSet</a> *pFdset) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1ea80c65c3a931a374bf2f0aab5153d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Includes a particular descriptor <em>fd</em> in <em>fdset</em>.  <a href="#a1ea80c65c3a931a374bf2f0aab5153d1">[詳解]</a><br /></td></tr>
<tr class="separator:a1ea80c65c3a931a374bf2f0aab5153d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62380fb58406f3d7e83ea25c6deab35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#aa62380fb58406f3d7e83ea25c6deab35">FdSetZero</a> (<a class="el" href="structnn_1_1socket_1_1_fd_set.html">FdSet</a> *pFdset) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa62380fb58406f3d7e83ea25c6deab35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a descriptor set <em>s</em> to the null set.  <a href="#aa62380fb58406f3d7e83ea25c6deab35">[詳解]</a><br /></td></tr>
<tr class="separator:aa62380fb58406f3d7e83ea25c6deab35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a801f086aadf0b731a721567f3e4b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a28a801f086aadf0b731a721567f3e4b2">Finalize</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a28a801f086aadf0b731a721567f3e4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize socket library.  <a href="#a28a801f086aadf0b731a721567f3e4b2">[詳解]</a><br /></td></tr>
<tr class="separator:a28a801f086aadf0b731a721567f3e4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b36451977a644918fa15c7197175280"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a0b36451977a644918fa15c7197175280">FreeAddrInfo</a> (addrinfo *addrInfoStorage) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0b36451977a644918fa15c7197175280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the address info structure - This API will be deprecated in an upcoming SDK release.  <a href="#a0b36451977a644918fa15c7197175280">[詳解]</a><br /></td></tr>
<tr class="separator:a0b36451977a644918fa15c7197175280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243828270d581fb029a86292031a30cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a243828270d581fb029a86292031a30cf">FreeAddrInfo</a> (<a class="el" href="structnn_1_1socket_1_1_addr_info.html">AddrInfo</a> *addrInfoStorage) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a243828270d581fb029a86292031a30cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the address info structure.  <a href="#a243828270d581fb029a86292031a30cf">[詳解]</a><br /></td></tr>
<tr class="separator:a243828270d581fb029a86292031a30cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7205d9966bbcd59d74851c6a49c8af9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ab7205d9966bbcd59d74851c6a49c8af9">GAIStrError</a> (int errorCode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab7205d9966bbcd59d74851c6a49c8af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a human-readable version of the return value from <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60" title="Get a list of IP addresses and port numbers. ">GetAddrInfo()</a> / <a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3" title="Convert a SockAddr structure to a pair of host name and service strings. ">GetNameInfo()</a> - This API will be deprecated in an upcoming SDK release.  <a href="#ab7205d9966bbcd59d74851c6a49c8af9">[詳解]</a><br /></td></tr>
<tr class="separator:ab7205d9966bbcd59d74851c6a49c8af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790112f00a11cf992ba2e04795c9590f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a790112f00a11cf992ba2e04795c9590f">GAIStrError</a> (<a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952a">AiErrno</a> errorCode) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a790112f00a11cf992ba2e04795c9590f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a human-readable version of the return value from <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60">GetAddrInfo()</a> or <a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3">GetNameInfo()</a>.  <a href="#a790112f00a11cf992ba2e04795c9590f">[詳解]</a><br /></td></tr>
<tr class="separator:a790112f00a11cf992ba2e04795c9590f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa323d8a7f14fd5b1e10c35a552f1c877"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#aa323d8a7f14fd5b1e10c35a552f1c877">GetAddrInfo</a> (const char *pNodeName, const char *pServername, const addrinfo *pHints, addrinfo **pResult) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa323d8a7f14fd5b1e10c35a552f1c877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of IP addresses and port numbers - This API will be deprecated in an upcoming SDK release.  <a href="#aa323d8a7f14fd5b1e10c35a552f1c877">[詳解]</a><br /></td></tr>
<tr class="separator:aa323d8a7f14fd5b1e10c35a552f1c877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7c9ca6a33baa3c3216c2de2c320f60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952a">AiErrno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60">GetAddrInfo</a> (const char *pNodeName, const char *pServername, const <a class="el" href="structnn_1_1socket_1_1_addr_info.html">AddrInfo</a> *pHints, <a class="el" href="structnn_1_1socket_1_1_addr_info.html">AddrInfo</a> **pResult) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aba7c9ca6a33baa3c3216c2de2c320f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of IP addresses and port numbers.  <a href="#aba7c9ca6a33baa3c3216c2de2c320f60">[詳解]</a><br /></td></tr>
<tr class="separator:aba7c9ca6a33baa3c3216c2de2c320f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d8cbd2ba272200139641e16adba995"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a63d8cbd2ba272200139641e16adba995">GetHErrno</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a63d8cbd2ba272200139641e16adba995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return host <em>errno</em> (<em>h_errno</em>) for <a class="el" href="namespacenn_1_1socket.html#a1e9d1531ba7ecd1f6d4438629540517a">GetHostByName()</a> / <a class="el" href="namespacenn_1_1socket.html#a74f8cbca4f89a3a5c6016c343c2e8e49">GetHostByAddr()</a> - This API will be deprecated in an upcoming SDK release.  <a href="#a63d8cbd2ba272200139641e16adba995">[詳解]</a><br /></td></tr>
<tr class="separator:a63d8cbd2ba272200139641e16adba995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a68baef0699e3e0063d3b686176b4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1socket.html#a7d8c1d2e11d6bdbdd12c05bc4505e96e">HErrno</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ad0a68baef0699e3e0063d3b686176b4c">GetHError</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad0a68baef0699e3e0063d3b686176b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to host errno (<em>h_errno</em>) for <a class="el" href="namespacenn_1_1socket.html#a358030926e9e63c2e322de2bd3d26719">GetHostEntByName()</a> and <a class="el" href="namespacenn_1_1socket.html#aaace32e2780295ca03bc72efa4b49406">GetHostEntByAddr()</a>.  <a href="#ad0a68baef0699e3e0063d3b686176b4c">[詳解]</a><br /></td></tr>
<tr class="separator:ad0a68baef0699e3e0063d3b686176b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f8cbca4f89a3a5c6016c343c2e8e49"><td class="memItemLeft" align="right" valign="top">hostent *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a74f8cbca4f89a3a5c6016c343c2e8e49">GetHostByAddr</a> (const void *pAddress, socklen_t length, int addressFamily) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a74f8cbca4f89a3a5c6016c343c2e8e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the address value for a host for AF_INET - This API will be deprecated in an upcoming SDK release.  <a href="#a74f8cbca4f89a3a5c6016c343c2e8e49">[詳解]</a><br /></td></tr>
<tr class="separator:a74f8cbca4f89a3a5c6016c343c2e8e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9d1531ba7ecd1f6d4438629540517a"><td class="memItemLeft" align="right" valign="top">hostent *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a1e9d1531ba7ecd1f6d4438629540517a">GetHostByName</a> (const char *pName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1e9d1531ba7ecd1f6d4438629540517a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up AF_INET host IP address by hostname - This API will be deprecated in an upcoming SDK release.  <a href="#a1e9d1531ba7ecd1f6d4438629540517a">[詳解]</a><br /></td></tr>
<tr class="separator:a1e9d1531ba7ecd1f6d4438629540517a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaace32e2780295ca03bc72efa4b49406"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1socket_1_1_host_ent.html">HostEnt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#aaace32e2780295ca03bc72efa4b49406">GetHostEntByAddr</a> (const void *pAddress, <a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a> length, <a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205d">Family</a> addressFamily) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aaace32e2780295ca03bc72efa4b49406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the address value for a host for <a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205daa4d833d8c15a76105639ddd11bcb614e">Family::Af_Inet</a>.  <a href="#aaace32e2780295ca03bc72efa4b49406">[詳解]</a><br /></td></tr>
<tr class="separator:aaace32e2780295ca03bc72efa4b49406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358030926e9e63c2e322de2bd3d26719"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1socket_1_1_host_ent.html">HostEnt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a358030926e9e63c2e322de2bd3d26719">GetHostEntByName</a> (const char *pName) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a358030926e9e63c2e322de2bd3d26719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up <a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205daa4d833d8c15a76105639ddd11bcb614e">Family::Af_Inet</a> host IP address by hostname.  <a href="#a358030926e9e63c2e322de2bd3d26719">[詳解]</a><br /></td></tr>
<tr class="separator:a358030926e9e63c2e322de2bd3d26719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfb1891ce7a1cc01f95f3e620235b1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#acdfb1891ce7a1cc01f95f3e620235b1a">GetLastErrno</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acdfb1891ce7a1cc01f95f3e620235b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the global variable <em>errno</em> - This API will be deprecated in an upcoming SDK release.  <a href="#acdfb1891ce7a1cc01f95f3e620235b1a">[詳解]</a><br /></td></tr>
<tr class="separator:acdfb1891ce7a1cc01f95f3e620235b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db6951cb084f74f4c17d655ce798890"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06ae">Errno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890">GetLastError</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6db6951cb084f74f4c17d655ce798890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the global variable <em>errno</em>.  <a href="#a6db6951cb084f74f4c17d655ce798890">[詳解]</a><br /></td></tr>
<tr class="separator:a6db6951cb084f74f4c17d655ce798890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef9dd54c970e22be5bce832726cf14e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#acef9dd54c970e22be5bce832726cf14e">GetNameInfo</a> (const sockaddr *socketAddress, socklen_t socketAddressLength, char *host, socklen_t hostLength, char *service, socklen_t serviceLength, int flags) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acef9dd54c970e22be5bce832726cf14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a sockaddr structure to a pair of host name and service strings - This API will be deprecated in an upcoming SDK release.  <a href="#acef9dd54c970e22be5bce832726cf14e">[詳解]</a><br /></td></tr>
<tr class="separator:acef9dd54c970e22be5bce832726cf14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ecfbc5167401b34339e6a5085686b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952a">AiErrno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3">GetNameInfo</a> (const <a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> *socketAddress, <a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a> socketAddressLength, char *host, size_t hostLength, char *service, size_t serviceLength, <a class="el" href="namespacenn_1_1socket.html#ab65d6a3635e193943fa4f95edfbebeae">NameInfoFlag</a> flags) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a27ecfbc5167401b34339e6a5085686b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> structure to a pair of host name and service strings.  <a href="#a27ecfbc5167401b34339e6a5085686b3">[詳解]</a><br /></td></tr>
<tr class="separator:a27ecfbc5167401b34339e6a5085686b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97eb7ccadd9c3c1fb69f4a634a443003"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a97eb7ccadd9c3c1fb69f4a634a443003">GetPeerName</a> (int socket, <a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> *pOutAddress, <a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a> *pOutAddressLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a97eb7ccadd9c3c1fb69f4a634a443003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of connected peer.  <a href="#a97eb7ccadd9c3c1fb69f4a634a443003">[詳解]</a><br /></td></tr>
<tr class="separator:a97eb7ccadd9c3c1fb69f4a634a443003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfa8571353a76695c6518a0825475ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a0bfa8571353a76695c6518a0825475ad">GetPeerName</a> (int socket, sockaddr *pOutAddress, socklen_t *pOutAddressLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0bfa8571353a76695c6518a0825475ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of connected peer - This API will be deprecated in an upcoming SDK release.  <a href="#a0bfa8571353a76695c6518a0825475ad">[詳解]</a><br /></td></tr>
<tr class="separator:a0bfa8571353a76695c6518a0825475ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb89c6a0abfc8befcdc1ce05bf49e0ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#adb89c6a0abfc8befcdc1ce05bf49e0ce">GetSockName</a> (int socket, <a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> *pOutAddress, <a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a> *pOutAddressLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adb89c6a0abfc8befcdc1ce05bf49e0ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get socket name.  <a href="#adb89c6a0abfc8befcdc1ce05bf49e0ce">[詳解]</a><br /></td></tr>
<tr class="separator:adb89c6a0abfc8befcdc1ce05bf49e0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bd1883e48c6c5942fa4b0b058a3ec7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ae5bd1883e48c6c5942fa4b0b058a3ec7">GetSockName</a> (int socket, sockaddr *pOutAddress, socklen_t *pOutAddressLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae5bd1883e48c6c5942fa4b0b058a3ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get socket name - This API will be deprecated in an upcoming SDK release.  <a href="#ae5bd1883e48c6c5942fa4b0b058a3ec7">[詳解]</a><br /></td></tr>
<tr class="separator:ae5bd1883e48c6c5942fa4b0b058a3ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aff7a563a6c808b236246a182996761"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a4aff7a563a6c808b236246a182996761">GetSockOpt</a> (int socket, <a class="el" href="namespacenn_1_1socket.html#a8f9b7859b60d1ee546e472a7e2a9beaa">Level</a> level, <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92c">Option</a> optionName, void *pOutOptionValue, <a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a> *pOutOptionLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4aff7a563a6c808b236246a182996761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get socket options.  <a href="#a4aff7a563a6c808b236246a182996761">[詳解]</a><br /></td></tr>
<tr class="separator:a4aff7a563a6c808b236246a182996761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51ebcc4967c212c6922fe29664d49df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ad51ebcc4967c212c6922fe29664d49df">GetSockOpt</a> (int socket, int level, int optionName, void *pOutOptionValue, socklen_t *pOutOptionLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad51ebcc4967c212c6922fe29664d49df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get socket options - This API will be deprecated in an upcoming SDK release.  <a href="#ad51ebcc4967c212c6922fe29664d49df">[詳解]</a><br /></td></tr>
<tr class="separator:ad51ebcc4967c212c6922fe29664d49df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c63718faf9f078228e3818e19e1de3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a10c63718faf9f078228e3818e19e1de3">HStrError</a> (int errorNumber) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a10c63718faf9f078228e3818e19e1de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a human-readable version of h_error / <a class="el" href="namespacenn_1_1socket.html#ad0a68baef0699e3e0063d3b686176b4c" title="Return pointer to host errno (h_errno) for GetHostEntByName() and GetHostEntByAddr(). ">GetHError()</a> - This API will be deprecated in an upcoming SDK release.  <a href="#a10c63718faf9f078228e3818e19e1de3">[詳解]</a><br /></td></tr>
<tr class="separator:a10c63718faf9f078228e3818e19e1de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba34614a3ddfe25e5bf3e5a77613832e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#aba34614a3ddfe25e5bf3e5a77613832e">HStrError</a> (<a class="el" href="namespacenn_1_1socket.html#a7d8c1d2e11d6bdbdd12c05bc4505e96e">HErrno</a> errorNumber) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aba34614a3ddfe25e5bf3e5a77613832e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a human-readable version of h_error / <a class="el" href="namespacenn_1_1socket.html#ad0a68baef0699e3e0063d3b686176b4c">GetHError()</a>.  <a href="#aba34614a3ddfe25e5bf3e5a77613832e">[詳解]</a><br /></td></tr>
<tr class="separator:aba34614a3ddfe25e5bf3e5a77613832e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19a1109832d37d99f43f1d5789480d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ae19a1109832d37d99f43f1d5789480d1">InetAton</a> (const char *addressStringBuffer, in_addr *pOutNetworkAddress) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae19a1109832d37d99f43f1d5789480d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to network address - This API will be deprecated in an upcoming SDK release.  <a href="#ae19a1109832d37d99f43f1d5789480d1">[詳解]</a><br /></td></tr>
<tr class="separator:ae19a1109832d37d99f43f1d5789480d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ef2c54d6090d3c03393f8ab7cad49e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a85ef2c54d6090d3c03393f8ab7cad49e">InetAton</a> (const char *addressStringBuffer, <a class="el" href="structnn_1_1socket_1_1_in_addr.html">InAddr</a> *pOutNetworkAddress) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a85ef2c54d6090d3c03393f8ab7cad49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to network address.  <a href="#a85ef2c54d6090d3c03393f8ab7cad49e">[詳解]</a><br /></td></tr>
<tr class="separator:a85ef2c54d6090d3c03393f8ab7cad49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24652de2bb3beca4cd692b4c3f7141db"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a24652de2bb3beca4cd692b4c3f7141db">InetHtonl</a> (uint32_t hostValue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a24652de2bb3beca4cd692b4c3f7141db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert 32-bit integer from host to network byte order.  <a href="#a24652de2bb3beca4cd692b4c3f7141db">[詳解]</a><br /></td></tr>
<tr class="separator:a24652de2bb3beca4cd692b4c3f7141db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6e15ce629648357cf10cc8ada6b8d1"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a1b6e15ce629648357cf10cc8ada6b8d1">InetHtons</a> (uint16_t hostValue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1b6e15ce629648357cf10cc8ada6b8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert 16-bit integer from host to network byte order.  <a href="#a1b6e15ce629648357cf10cc8ada6b8d1">[詳解]</a><br /></td></tr>
<tr class="separator:a1b6e15ce629648357cf10cc8ada6b8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90b8239ae0f5fbd70f12f9980fdac76"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#af90b8239ae0f5fbd70f12f9980fdac76">InetNtoa</a> (<a class="el" href="structnn_1_1socket_1_1_in_addr.html">InAddr</a> networkAddress) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af90b8239ae0f5fbd70f12f9980fdac76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Internet address into ASCII string.  <a href="#af90b8239ae0f5fbd70f12f9980fdac76">[詳解]</a><br /></td></tr>
<tr class="separator:af90b8239ae0f5fbd70f12f9980fdac76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1dedf75a8d44ab87d024fe74ecefb8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ade1dedf75a8d44ab87d024fe74ecefb8">InetNtoa</a> (in_addr networkAddress) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ade1dedf75a8d44ab87d024fe74ecefb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Internet address into ASCII string - This API will be deprecated in an upcoming SDK release.  <a href="#ade1dedf75a8d44ab87d024fe74ecefb8">[詳解]</a><br /></td></tr>
<tr class="separator:ade1dedf75a8d44ab87d024fe74ecefb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06113194b65c644a046c8c65ea7c4515"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a06113194b65c644a046c8c65ea7c4515">InetNtohl</a> (uint32_t networkValue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a06113194b65c644a046c8c65ea7c4515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert 32-bit integer from network to host byte order.  <a href="#a06113194b65c644a046c8c65ea7c4515">[詳解]</a><br /></td></tr>
<tr class="separator:a06113194b65c644a046c8c65ea7c4515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8de3f19aaf80d2233a668fc7ebe6f38"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#aa8de3f19aaf80d2233a668fc7ebe6f38">InetNtohs</a> (uint16_t networkValue) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa8de3f19aaf80d2233a668fc7ebe6f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert 16-bit ineger from network to host byte order.  <a href="#aa8de3f19aaf80d2233a668fc7ebe6f38">[詳解]</a><br /></td></tr>
<tr class="separator:aa8de3f19aaf80d2233a668fc7ebe6f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43969e788b0959ef0007b481f45c3a4a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a43969e788b0959ef0007b481f45c3a4a">InetNtop</a> (<a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205d">Family</a> family, const void *pNetworkAddress, char *addressStringBuffer, <a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a> addressStringBufferLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a43969e788b0959ef0007b481f45c3a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert network address to presentation format.  <a href="#a43969e788b0959ef0007b481f45c3a4a">[詳解]</a><br /></td></tr>
<tr class="separator:a43969e788b0959ef0007b481f45c3a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a33f759b752d546f13a4d2470a4d8f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a04a33f759b752d546f13a4d2470a4d8f">InetNtop</a> (int family, const void *pNetworkAddress, char *addressStringBuffer, socklen_t addressStringBufferLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a04a33f759b752d546f13a4d2470a4d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert network address to presentation format - This API will be deprecated in an upcoming SDK release.  <a href="#a04a33f759b752d546f13a4d2470a4d8f">[詳解]</a><br /></td></tr>
<tr class="separator:a04a33f759b752d546f13a4d2470a4d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d1ba1b38eb1c92d1d076f87c0f3912"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a26d1ba1b38eb1c92d1d076f87c0f3912">InetPton</a> (int family, const char *pAddressString, void *pOutAddressBuffer) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a26d1ba1b38eb1c92d1d076f87c0f3912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert address to network format - This API will be deprecated in an upcoming SDK release.  <a href="#a26d1ba1b38eb1c92d1d076f87c0f3912">[詳解]</a><br /></td></tr>
<tr class="separator:a26d1ba1b38eb1c92d1d076f87c0f3912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476ef4e55fd64cf5b9d027e17f10a5e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a476ef4e55fd64cf5b9d027e17f10a5e6">InetPton</a> (<a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205d">Family</a> family, const char *pAddressString, void *pOutAddressBuffer) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a476ef4e55fd64cf5b9d027e17f10a5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert address to network format.  <a href="#a476ef4e55fd64cf5b9d027e17f10a5e6">[詳解]</a><br /></td></tr>
<tr class="separator:a476ef4e55fd64cf5b9d027e17f10a5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacc3405184e8f28fb630745b9f43db0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize</a> (const <a class="el" href="classnn_1_1socket_1_1_config.html">Config</a> &amp;config) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adacc3405184e8f28fb630745b9f43db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize socket library.  <a href="#adacc3405184e8f28fb630745b9f43db0">[詳解]</a><br /></td></tr>
<tr class="separator:adacc3405184e8f28fb630745b9f43db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170b50fa1256bc0ed9d5176ecc2d9a09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a170b50fa1256bc0ed9d5176ecc2d9a09">Initialize</a> (void *memoryPool, size_t memoryPoolSize, size_t allocatorPoolSize, int concurrencyLimit) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a170b50fa1256bc0ed9d5176ecc2d9a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize socket library.  <a href="#a170b50fa1256bc0ed9d5176ecc2d9a09">[詳解]</a><br /></td></tr>
<tr class="separator:a170b50fa1256bc0ed9d5176ecc2d9a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e041f51a4921b2edb1f434f77d0fcb0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a5e041f51a4921b2edb1f434f77d0fcb0">Ioctl</a> (int fd, uint32_t command, void *pData, size_t dataLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5e041f51a4921b2edb1f434f77d0fcb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control I/O device - This API will be deprecated in an upcoming SDK release.  <a href="#a5e041f51a4921b2edb1f434f77d0fcb0">[詳解]</a><br /></td></tr>
<tr class="separator:a5e041f51a4921b2edb1f434f77d0fcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558dc819d133326891523fcaf32303f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a558dc819d133326891523fcaf32303f8">Ioctl</a> (int fd, <a class="el" href="namespacenn_1_1socket.html#a047cb0e8a33ab75269a940a59ac7f62a">IoctlCommand</a> command, void *pData, size_t dataLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a558dc819d133326891523fcaf32303f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control I/O device.  <a href="#a558dc819d133326891523fcaf32303f8">[詳解]</a><br /></td></tr>
<tr class="separator:a558dc819d133326891523fcaf32303f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c2c6b2d1cd467bfdbfb4bf4057338b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ad6c2c6b2d1cd467bfdbfb4bf4057338b">Listen</a> (int socket, int backlog) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad6c2c6b2d1cd467bfdbfb4bf4057338b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listen for connections on a socket.  <a href="#ad6c2c6b2d1cd467bfdbfb4bf4057338b">[詳解]</a><br /></td></tr>
<tr class="separator:ad6c2c6b2d1cd467bfdbfb4bf4057338b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba25bf75426cccb61a32efa1f70792ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#aba25bf75426cccb61a32efa1f70792ad">Open</a> (const char *path, int flags) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aba25bf75426cccb61a32efa1f70792ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open network device for reading/writing - This API will be deprecated in an upcoming SDK release.  <a href="#aba25bf75426cccb61a32efa1f70792ad">[詳解]</a><br /></td></tr>
<tr class="separator:aba25bf75426cccb61a32efa1f70792ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae798003ad15f40cf8127fb06587999cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ae798003ad15f40cf8127fb06587999cf">Poll</a> (pollfd *pSocketDescriptors, nfds_t numberOfDescriptors, int timeoutMilliseconds) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae798003ad15f40cf8127fb06587999cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous I/O multiplexing - This API will be deprecated in an upcoming SDK release.  <a href="#ae798003ad15f40cf8127fb06587999cf">[詳解]</a><br /></td></tr>
<tr class="separator:ae798003ad15f40cf8127fb06587999cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e109d18fb43f275742d74d74d06cde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ad9e109d18fb43f275742d74d74d06cde">Poll</a> (<a class="el" href="structnn_1_1socket_1_1_poll_fd.html">PollFd</a> *pSocketDescriptors, <a class="el" href="namespacenn_1_1socket.html#a8cb8a1b63cc61bb57fe8c8c58ef26591">NfdsT</a> numberOfDescriptors, int timeoutMilliseconds) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad9e109d18fb43f275742d74d74d06cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous I/O multiplexing.  <a href="#ad9e109d18fb43f275742d74d74d06cde">[詳解]</a><br /></td></tr>
<tr class="separator:ad9e109d18fb43f275742d74d74d06cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1fd34e9d084e5bb0f17a6c2361896c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ae1fd34e9d084e5bb0f17a6c2361896c2">Read</a> (int socket, void *outBuffer, size_t outBufferLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae1fd34e9d084e5bb0f17a6c2361896c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read input.  <a href="#ae1fd34e9d084e5bb0f17a6c2361896c2">[詳解]</a><br /></td></tr>
<tr class="separator:ae1fd34e9d084e5bb0f17a6c2361896c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ab796296ba9d510ebad6eb52a40489"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a86ab796296ba9d510ebad6eb52a40489">Recv</a> (int socket, void *outBuffer, size_t outBufferLength, int flags) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a86ab796296ba9d510ebad6eb52a40489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message from a connection-mode or connectionless-mode socket - This API will be deprecated in an upcoming SDK release.  <a href="#a86ab796296ba9d510ebad6eb52a40489">[詳解]</a><br /></td></tr>
<tr class="separator:a86ab796296ba9d510ebad6eb52a40489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5875e388a4010d756c63437dedfe5f14"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14">Recv</a> (int socket, void *outBuffer, size_t outBufferLength, <a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52">MsgFlag</a> flags) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5875e388a4010d756c63437dedfe5f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message from a connection-mode or connectionless-mode socket.  <a href="#a5875e388a4010d756c63437dedfe5f14">[詳解]</a><br /></td></tr>
<tr class="separator:a5875e388a4010d756c63437dedfe5f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae34f509f3ca53315c0400ee7af388f"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#abae34f509f3ca53315c0400ee7af388f">RecvFrom</a> (int socket, void *outBuffer, size_t outBufferLength, int flags, sockaddr *pOutAddress, socklen_t *pOutAddressLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abae34f509f3ca53315c0400ee7af388f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message from a connection-oriented or connectionless-oriented socket - This API will be deprecated in an upcoming SDK release.  <a href="#abae34f509f3ca53315c0400ee7af388f">[詳解]</a><br /></td></tr>
<tr class="separator:abae34f509f3ca53315c0400ee7af388f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab268741c66f0996683c31b1bcd05dc"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#adab268741c66f0996683c31b1bcd05dc">RecvFrom</a> (int socket, void *outBuffer, size_t outBufferLength, <a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52">MsgFlag</a> flags, <a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> *pOutAddress, <a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a> *pOutAddressLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adab268741c66f0996683c31b1bcd05dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message from a connection-oriented or connectionless-oriented socket.  <a href="#adab268741c66f0996683c31b1bcd05dc">[詳解]</a><br /></td></tr>
<tr class="separator:adab268741c66f0996683c31b1bcd05dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd017048f31047060bd14d142cae91eb"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#acd017048f31047060bd14d142cae91eb">RecvMsg</a> (int socket, msghdr *pOutMessage, int flags) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acd017048f31047060bd14d142cae91eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a message from a socket - This API will be deprecated in an upcoming SDK release.  <a href="#acd017048f31047060bd14d142cae91eb">[詳解]</a><br /></td></tr>
<tr class="separator:acd017048f31047060bd14d142cae91eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a52df3f484b631d21496ff6ad23ec9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a3a52df3f484b631d21496ff6ad23ec9e">Select</a> (int numberOfDescriptors, fd_set *pReadDescriptors, fd_set *pWriteDescriptors, fd_set *pExceptDescriptors, timeval *pTimeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3a52df3f484b631d21496ff6ad23ec9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous I/O multiplexing - This API will be deprecated in an upcoming SDK release.  <a href="#a3a52df3f484b631d21496ff6ad23ec9e">[詳解]</a><br /></td></tr>
<tr class="separator:a3a52df3f484b631d21496ff6ad23ec9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa523b16a6004b8748cc0116f9ed65dd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2">Select</a> (int numberOfDescriptors, <a class="el" href="structnn_1_1socket_1_1_fd_set.html">FdSet</a> *pReadDescriptors, <a class="el" href="structnn_1_1socket_1_1_fd_set.html">FdSet</a> *pWriteDescriptors, <a class="el" href="structnn_1_1socket_1_1_fd_set.html">FdSet</a> *pExceptDescriptors, <a class="el" href="structnn_1_1socket_1_1_time_val.html">TimeVal</a> *pTimeout) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa523b16a6004b8748cc0116f9ed65dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous I/O multiplexing.  <a href="#aa523b16a6004b8748cc0116f9ed65dd2">[詳解]</a><br /></td></tr>
<tr class="separator:aa523b16a6004b8748cc0116f9ed65dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15832524d00283a4e6b4af94698931a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ad15832524d00283a4e6b4af94698931a">Send</a> (int socket, const void *buffer, size_t bufferLength, int flags) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad15832524d00283a4e6b4af94698931a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message from a socket - This API will be deprecated in an upcoming SDK release.  <a href="#ad15832524d00283a4e6b4af94698931a">[詳解]</a><br /></td></tr>
<tr class="separator:ad15832524d00283a4e6b4af94698931a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a4c9f486b94e6b19e563ef97a2e412"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ae5a4c9f486b94e6b19e563ef97a2e412">Send</a> (int socket, const void *buffer, size_t bufferLength, <a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52">MsgFlag</a> flags) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae5a4c9f486b94e6b19e563ef97a2e412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message from a socket.  <a href="#ae5a4c9f486b94e6b19e563ef97a2e412">[詳解]</a><br /></td></tr>
<tr class="separator:ae5a4c9f486b94e6b19e563ef97a2e412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6903b76c9ba427731abe0f0349d79a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a5c6903b76c9ba427731abe0f0349d79a">SendMsg</a> (int socket, const msghdr *pMessage, int flags) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5c6903b76c9ba427731abe0f0349d79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message from a socket - This API will be deprecated in an upcoming SDK release.  <a href="#a5c6903b76c9ba427731abe0f0349d79a">[詳解]</a><br /></td></tr>
<tr class="separator:a5c6903b76c9ba427731abe0f0349d79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c2a9e147d01954c74b2e574a90ee01"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ab8c2a9e147d01954c74b2e574a90ee01">SendTo</a> (int socket, const void *buffer, size_t bufferLength, int flags, const sockaddr *pAddress, socklen_t addressLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab8c2a9e147d01954c74b2e574a90ee01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message from a socket - This API will be deprecated in an upcoming SDK release.  <a href="#ab8c2a9e147d01954c74b2e574a90ee01">[詳解]</a><br /></td></tr>
<tr class="separator:ab8c2a9e147d01954c74b2e574a90ee01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd6b8da24d25e5e4f299b833258826f"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#aacd6b8da24d25e5e4f299b833258826f">SendTo</a> (int socket, const void *buffer, size_t bufferLength, <a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52">MsgFlag</a> flags, const <a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> *pAddress, <a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a> addressLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aacd6b8da24d25e5e4f299b833258826f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message from a socket.  <a href="#aacd6b8da24d25e5e4f299b833258826f">[詳解]</a><br /></td></tr>
<tr class="separator:aacd6b8da24d25e5e4f299b833258826f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac588565057dfa936967eb06ff62a2215"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ac588565057dfa936967eb06ff62a2215">SetLastErrno</a> (int error) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac588565057dfa936967eb06ff62a2215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global variable <em>errno</em> - This API will be deprecated in an upcoming SDK release.  <a href="#ac588565057dfa936967eb06ff62a2215">[詳解]</a><br /></td></tr>
<tr class="separator:ac588565057dfa936967eb06ff62a2215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e3e08ff4437c59fe7e2f764279c631"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ab3e3e08ff4437c59fe7e2f764279c631">SetLastError</a> (<a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06ae">Errno</a> error) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab3e3e08ff4437c59fe7e2f764279c631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global variable <em>errno</em>.  <a href="#ab3e3e08ff4437c59fe7e2f764279c631">[詳解]</a><br /></td></tr>
<tr class="separator:ab3e3e08ff4437c59fe7e2f764279c631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa7ccade3133a9884ab0b8e44ac18fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#afaa7ccade3133a9884ab0b8e44ac18fc">SetSockOpt</a> (int socket, <a class="el" href="namespacenn_1_1socket.html#a8f9b7859b60d1ee546e472a7e2a9beaa">Level</a> level, <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92c">Option</a> optionName, const void *pOptionValue, <a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a> optionLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afaa7ccade3133a9884ab0b8e44ac18fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set options on a socket.  <a href="#afaa7ccade3133a9884ab0b8e44ac18fc">[詳解]</a><br /></td></tr>
<tr class="separator:afaa7ccade3133a9884ab0b8e44ac18fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92711556ee5f0122c71d8aedfe8399d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a92711556ee5f0122c71d8aedfe8399d7">SetSockOpt</a> (int socket, int level, int optionName, const void *pOptionValue, socklen_t optionLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a92711556ee5f0122c71d8aedfe8399d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set options on a socket - This API will be deprecated in an upcoming SDK release.  <a href="#a92711556ee5f0122c71d8aedfe8399d7">[詳解]</a><br /></td></tr>
<tr class="separator:a92711556ee5f0122c71d8aedfe8399d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae806aef6ab4c881e23c90a3ea379924"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#aae806aef6ab4c881e23c90a3ea379924">Shutdown</a> (int socket, int how) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aae806aef6ab4c881e23c90a3ea379924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable sends and/or receives on a socket - This API will be deprecated in an upcoming SDK release.  <a href="#aae806aef6ab4c881e23c90a3ea379924">[詳解]</a><br /></td></tr>
<tr class="separator:aae806aef6ab4c881e23c90a3ea379924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895595468f09d14293edd099a8ff7dc5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a895595468f09d14293edd099a8ff7dc5">Shutdown</a> (int socket, <a class="el" href="namespacenn_1_1socket.html#aef8523201363cec26def667e89cbfeae">ShutdownMethod</a> how) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a895595468f09d14293edd099a8ff7dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable sends and/or receives on a socket.  <a href="#a895595468f09d14293edd099a8ff7dc5">[詳解]</a><br /></td></tr>
<tr class="separator:a895595468f09d14293edd099a8ff7dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf72a9cd03a0bce6c4f905089961564"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a1cf72a9cd03a0bce6c4f905089961564">SockAtMark</a> (int socket) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1cf72a9cd03a0bce6c4f905089961564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the read pointer is at the OOB mark.  <a href="#a1cf72a9cd03a0bce6c4f905089961564">[詳解]</a><br /></td></tr>
<tr class="separator:a1cf72a9cd03a0bce6c4f905089961564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d79b0ad360df5623268d140ba8b343"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a02d79b0ad360df5623268d140ba8b343">Socket</a> (int domain, int type, int protocol) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a02d79b0ad360df5623268d140ba8b343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create endpoint for communication - This API will be deprecated in an upcoming SDK release.  <a href="#a02d79b0ad360df5623268d140ba8b343">[詳解]</a><br /></td></tr>
<tr class="separator:a02d79b0ad360df5623268d140ba8b343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afeb564bac1d0c04af2fec1f00c739f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket</a> (<a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205d">Family</a> domain, <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaea">Type</a> type, <a class="el" href="namespacenn_1_1socket.html#a46347de69614965469ac8f3c8056468e">Protocol</a> protocol) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9afeb564bac1d0c04af2fec1f00c739f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create endpoint for communication.  <a href="#a9afeb564bac1d0c04af2fec1f00c739f">[詳解]</a><br /></td></tr>
<tr class="separator:a9afeb564bac1d0c04af2fec1f00c739f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2284c3d5e78619aecbd0b78d3947936"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ab2284c3d5e78619aecbd0b78d3947936">Write</a> (int socket, const void *buffer, size_t bufferLength) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab2284c3d5e78619aecbd0b78d3947936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write output.  <a href="#ab2284c3d5e78619aecbd0b78d3947936">[詳解]</a><br /></td></tr>
<tr class="separator:ab2284c3d5e78619aecbd0b78d3947936"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
変数</h2></td></tr>
<tr class="memitem:a2a7a8125ec9fe395434f0b7f3c0036b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a7a8125ec9fe395434f0b7f3c0036b3"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a2a7a8125ec9fe395434f0b7f3c0036b3">ConcurrencyLimitMax</a> = 14</td></tr>
<tr class="memdesc:a2a7a8125ec9fe395434f0b7f3c0036b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value of concurrency count that can be passed to <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0" title="Initialize socket library. ">Initialize()</a>. <br /></td></tr>
<tr class="separator:a2a7a8125ec9fe395434f0b7f3c0036b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150d80cacbb08735b665a1e061367ee1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a150d80cacbb08735b665a1e061367ee1"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a150d80cacbb08735b665a1e061367ee1">DefaultSocketMemoryPoolSize</a> = (6 * 1024 * 1024)</td></tr>
<tr class="memdesc:a150d80cacbb08735b665a1e061367ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default size of memory allocated on behalf of the client when <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0" title="Initialize socket library. ">Initialize()</a> is called. <br /></td></tr>
<tr class="separator:a150d80cacbb08735b665a1e061367ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc799bf5dda01ef3e09a138f10f27f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fc799bf5dda01ef3e09a138f10f27f3"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a4fc799bf5dda01ef3e09a138f10f27f3">DefaultTcpAutoBufferSizeMax</a> = (256 * 1024)</td></tr>
<tr class="memdesc:a4fc799bf5dda01ef3e09a138f10f27f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum size a tcp socket buffer can automatically resize to. <br /></td></tr>
<tr class="separator:a4fc799bf5dda01ef3e09a138f10f27f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53bcecd4a9fee23b4d042448b0136e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae53bcecd4a9fee23b4d042448b0136e4"></a>
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ae53bcecd4a9fee23b4d042448b0136e4">FdSetSize</a> = 1024</td></tr>
<tr class="memdesc:ae53bcecd4a9fee23b4d042448b0136e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max size of <a class="el" href="structnn_1_1socket_1_1_fd_set.html" title="Structure used for Select(). ">FdSet</a>. <br /></td></tr>
<tr class="separator:ae53bcecd4a9fee23b4d042448b0136e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3922916ed4f1ca3f806132d1735f7e5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3922916ed4f1ca3f806132d1735f7e5d"></a>
const <a class="el" href="namespacenn_1_1socket.html#ac08c7d39c115b363db7819d38172127d">InAddrT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a3922916ed4f1ca3f806132d1735f7e5d">InAddr_AllHosts_Group</a> = 0xe0000001</td></tr>
<tr class="memdesc:a3922916ed4f1ca3f806132d1735f7e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">224.0.0.1. <br /></td></tr>
<tr class="separator:a3922916ed4f1ca3f806132d1735f7e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b92e6f013fc7e4c0e1a277aeff41869"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b92e6f013fc7e4c0e1a277aeff41869"></a>
const <a class="el" href="namespacenn_1_1socket.html#ac08c7d39c115b363db7819d38172127d">InAddrT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a4b92e6f013fc7e4c0e1a277aeff41869">InAddr_AllRtrs_Group</a> = 0xe0000002</td></tr>
<tr class="memdesc:a4b92e6f013fc7e4c0e1a277aeff41869"><td class="mdescLeft">&#160;</td><td class="mdescRight">224.0.0.2. <br /></td></tr>
<tr class="separator:a4b92e6f013fc7e4c0e1a277aeff41869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc37587294a2f6b385cf080b6fafa40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bc37587294a2f6b385cf080b6fafa40"></a>
const <a class="el" href="namespacenn_1_1socket.html#ac08c7d39c115b363db7819d38172127d">InAddrT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a0bc37587294a2f6b385cf080b6fafa40">InAddr_Any</a> = 0x00000000</td></tr>
<tr class="memdesc:a0bc37587294a2f6b385cf080b6fafa40"><td class="mdescLeft">&#160;</td><td class="mdescRight">0.0.0.0. <br /></td></tr>
<tr class="separator:a0bc37587294a2f6b385cf080b6fafa40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a9a87e624e6e91bf9b2c7a6319fd47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51a9a87e624e6e91bf9b2c7a6319fd47"></a>
const <a class="el" href="namespacenn_1_1socket.html#ac08c7d39c115b363db7819d38172127d">InAddrT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a51a9a87e624e6e91bf9b2c7a6319fd47">InAddr_Broadcast</a> = 0xffffffff</td></tr>
<tr class="memdesc:a51a9a87e624e6e91bf9b2c7a6319fd47"><td class="mdescLeft">&#160;</td><td class="mdescRight">255.255.255.255. <br /></td></tr>
<tr class="separator:a51a9a87e624e6e91bf9b2c7a6319fd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473d246a04955e3d71767c9b2150c6af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a473d246a04955e3d71767c9b2150c6af"></a>
const <a class="el" href="namespacenn_1_1socket.html#ac08c7d39c115b363db7819d38172127d">InAddrT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a473d246a04955e3d71767c9b2150c6af">InAddr_Loopback</a> = 0x7f000001</td></tr>
<tr class="memdesc:a473d246a04955e3d71767c9b2150c6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">127.0.0.1. <br /></td></tr>
<tr class="separator:a473d246a04955e3d71767c9b2150c6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43867bd4ae6aacb696a3266dcf67d873"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43867bd4ae6aacb696a3266dcf67d873"></a>
const <a class="el" href="namespacenn_1_1socket.html#ac08c7d39c115b363db7819d38172127d">InAddrT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a43867bd4ae6aacb696a3266dcf67d873">InAddr_Max_Local_Group</a> = 0xe00000ff</td></tr>
<tr class="memdesc:a43867bd4ae6aacb696a3266dcf67d873"><td class="mdescLeft">&#160;</td><td class="mdescRight">224.0.0.255. <br /></td></tr>
<tr class="separator:a43867bd4ae6aacb696a3266dcf67d873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cd4f761b9394ba0842ca8df3adc5df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64cd4f761b9394ba0842ca8df3adc5df"></a>
const <a class="el" href="namespacenn_1_1socket.html#ac08c7d39c115b363db7819d38172127d">InAddrT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a64cd4f761b9394ba0842ca8df3adc5df">InAddr_None</a> = 0xffffffff</td></tr>
<tr class="memdesc:a64cd4f761b9394ba0842ca8df3adc5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">255.255.255.255. <br /></td></tr>
<tr class="separator:a64cd4f761b9394ba0842ca8df3adc5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c80ed5b96778b0daa69eb4ddf8196d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95c80ed5b96778b0daa69eb4ddf8196d"></a>
const <a class="el" href="namespacenn_1_1socket.html#ac08c7d39c115b363db7819d38172127d">InAddrT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a95c80ed5b96778b0daa69eb4ddf8196d">InAddr_Unspec_Group</a> = 0xe0000000</td></tr>
<tr class="memdesc:a95c80ed5b96778b0daa69eb4ddf8196d"><td class="mdescLeft">&#160;</td><td class="mdescRight">224.0.0.0. <br /></td></tr>
<tr class="separator:a95c80ed5b96778b0daa69eb4ddf8196d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8c631133d81cf6494162c0a7ee5028"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d8c631133d81cf6494162c0a7ee5028"></a>
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a9d8c631133d81cf6494162c0a7ee5028">InetAddrStrlen</a> = 16</td></tr>
<tr class="memdesc:a9d8c631133d81cf6494162c0a7ee5028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size required to convert an Af_Inet address, including null terminator. <br /></td></tr>
<tr class="separator:a9d8c631133d81cf6494162c0a7ee5028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63165d8f4ab675489cda23034aa9eeb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac63165d8f4ab675489cda23034aa9eeb"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ac63165d8f4ab675489cda23034aa9eeb">InfTim</a> = -1</td></tr>
<tr class="memdesc:ac63165d8f4ab675489cda23034aa9eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If poll timeout is InfTim (-1), the poll blocks indefinitely. <br /></td></tr>
<tr class="separator:ac63165d8f4ab675489cda23034aa9eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65be255411a9490136fe573fa8dc8124"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65be255411a9490136fe573fa8dc8124"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a65be255411a9490136fe573fa8dc8124">InvalidSocket</a> = -1</td></tr>
<tr class="memdesc:a65be255411a9490136fe573fa8dc8124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket Errors within our namespace. <br /></td></tr>
<tr class="separator:a65be255411a9490136fe573fa8dc8124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa810d67bee3a2f1f5790f2483f78510f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa810d67bee3a2f1f5790f2483f78510f"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#aa810d67bee3a2f1f5790f2483f78510f">LibraryVersion</a> = 4</td></tr>
<tr class="memdesc:aa810d67bee3a2f1f5790f2483f78510f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current version of the socket library. <br /></td></tr>
<tr class="separator:aa810d67bee3a2f1f5790f2483f78510f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf77c262305bc3c44f653c197beb864"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accf77c262305bc3c44f653c197beb864"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#accf77c262305bc3c44f653c197beb864">MemoryPoolAlignment</a> = 4096</td></tr>
<tr class="memdesc:accf77c262305bc3c44f653c197beb864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alignment requirement for socket library memory pools. <br /></td></tr>
<tr class="separator:accf77c262305bc3c44f653c197beb864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfeb3704c8d57239f730a25ab70ef147"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfeb3704c8d57239f730a25ab70ef147"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#adfeb3704c8d57239f730a25ab70ef147">MinSocketAllocatorSize</a> = (128 * 1024)</td></tr>
<tr class="memdesc:adfeb3704c8d57239f730a25ab70ef147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum size of the memory used for resolver that can be passed to <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a>. <br /></td></tr>
<tr class="separator:adfeb3704c8d57239f730a25ab70ef147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710315a7c48bceff146c5c7b07223b65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a710315a7c48bceff146c5c7b07223b65"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a710315a7c48bceff146c5c7b07223b65">MinSocketMemoryPoolSize</a> = (<a class="el" href="namespacenn_1_1socket.html#a2b601ff8a9eb73cd9a1877d1988c66d6">MinTransferMemorySize</a> + <a class="el" href="namespacenn_1_1socket.html#adfeb3704c8d57239f730a25ab70ef147">MinSocketAllocatorSize</a>)</td></tr>
<tr class="memdesc:a710315a7c48bceff146c5c7b07223b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total minimum size of the memory that can be passed to <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0" title="Initialize socket library. ">Initialize()</a>. <br /></td></tr>
<tr class="separator:a710315a7c48bceff146c5c7b07223b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b601ff8a9eb73cd9a1877d1988c66d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b601ff8a9eb73cd9a1877d1988c66d6"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a2b601ff8a9eb73cd9a1877d1988c66d6">MinTransferMemorySize</a> = (2 * <a class="el" href="namespacenn_1_1socket.html#a4fc799bf5dda01ef3e09a138f10f27f3">DefaultTcpAutoBufferSizeMax</a> + 128 * 1024)</td></tr>
<tr class="memdesc:a2b601ff8a9eb73cd9a1877d1988c66d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum size of the memory for socket buffers that can be passed to <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a>. <br /></td></tr>
<tr class="separator:a2b601ff8a9eb73cd9a1877d1988c66d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81b81a7e0e59a763648ed91c81febaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad81b81a7e0e59a763648ed91c81febaf"></a>
const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#ad81b81a7e0e59a763648ed91c81febaf">SockMaxAddrLen</a> = 255</td></tr>
<tr class="memdesc:ad81b81a7e0e59a763648ed91c81febaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Longest possible address. <br /></td></tr>
<tr class="separator:ad81b81a7e0e59a763648ed91c81febaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed21151d8d68e8ac820299786ad8667"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ed21151d8d68e8ac820299786ad8667"></a>
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a9ed21151d8d68e8ac820299786ad8667">SoMaxConn</a> = 128</td></tr>
<tr class="memdesc:a9ed21151d8d68e8ac820299786ad8667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of pending connections. <br /></td></tr>
<tr class="separator:a9ed21151d8d68e8ac820299786ad8667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94557172fe4fe334394d2d2721d58ab7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94557172fe4fe334394d2d2721d58ab7"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1socket.html#a94557172fe4fe334394d2d2721d58ab7">TcpCaNameMax</a> = 16</td></tr>
<tr class="memdesc:a94557172fe4fe334394d2d2721d58ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max congestion control name length. <br /></td></tr>
<tr class="separator:a94557172fe4fe334394d2d2721d58ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p>ソケットライブラリの名前空間です。 </p>
</div><h2 class="groupheader">列挙型詳解</h2>
<a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06ae">nn::socket::Errno</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global variable <em>errno</em> values, also returned by <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890">nn::socket::GetLastError()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aead87a63798e8be82fcb6b21bf1389ebb3"></a>ESuccess&#160;</td><td class="fielddoc">
<p>0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea8cb8036f66c3dfbaaf7c62a5e0a92ce9"></a>EPerm&#160;</td><td class="fielddoc">
<p>1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeae9dfa78f47aa1a9ae898a456edeb3fdf"></a>ENoEnt&#160;</td><td class="fielddoc">
<p>2 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea94262e2ab3d109b69027b3976ec8585c"></a>ESrch&#160;</td><td class="fielddoc">
<p>3 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaa9b197bd177776afbc2d1a323bf3b929"></a>EIntr&#160;</td><td class="fielddoc">
<p>4 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea9aa6aea17a595d5edf68646fa2d15383"></a>EIo&#160;</td><td class="fielddoc">
<p>5 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeac238316b78246eeed4b7786dc622be53"></a>ENxIo&#160;</td><td class="fielddoc">
<p>6 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea481b5ef7382eb2ea7906e96b83018691"></a>E2Big&#160;</td><td class="fielddoc">
<p>7 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea032bc39a8be16a062b0663cfff115c00"></a>ENoExec&#160;</td><td class="fielddoc">
<p>8 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327"></a>EBadf&#160;</td><td class="fielddoc">
<p>9 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeab03f18641ecf1c34a97116a65f901c1f"></a>EChild&#160;</td><td class="fielddoc">
<p>10 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb"></a>EAgain&#160;</td><td class="fielddoc">
<p>11 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaeef22a2860814281d48b1e798808eb01"></a>ENoMem&#160;</td><td class="fielddoc">
<p>12 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeac382e6a51872c6a43d968c2462a2d3be"></a>EAcces&#160;</td><td class="fielddoc">
<p>13 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea3fdc41982aa0e73be04ddc708c157a7b"></a>EFault&#160;</td><td class="fielddoc">
<p>14 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea7ddba288471ecbe5a3a03ffb2c5ef2de"></a>ENotBlk&#160;</td><td class="fielddoc">
<p>15 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea99d02c0b2c99135d3bb7d041a119609c"></a>EBusy&#160;</td><td class="fielddoc">
<p>16 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea3d8c5ab131894728bc3324147d27683e"></a>EExist&#160;</td><td class="fielddoc">
<p>17 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaede9c068704964dc47ebad0a85de9bcc"></a>EXDev&#160;</td><td class="fielddoc">
<p>18 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea353dd408073cecdf73344f6ee37d3577"></a>ENoDev&#160;</td><td class="fielddoc">
<p>19 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaa036977d257701b74035e7b27639cb6d"></a>ENotDir&#160;</td><td class="fielddoc">
<p>20 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeae3f3602dbfee7cfd783ca5dd8cc27b29"></a>EIsDir&#160;</td><td class="fielddoc">
<p>21 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f"></a>EInval&#160;</td><td class="fielddoc">
<p>22 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeae2a9ccfa0eb433b4573729569317d7de"></a>ENFile&#160;</td><td class="fielddoc">
<p>23 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeab3f5564877c20a778d6e7b4e80c080bd"></a>EMFile&#160;</td><td class="fielddoc">
<p>24 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea7259324ba5d862aaba5087583e8404a3"></a>ENotTy&#160;</td><td class="fielddoc">
<p>25 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea2155c3e8f97b702b092a897a2a0d8f9d"></a>ETxtBsy&#160;</td><td class="fielddoc">
<p>26 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea7594267c68c9883209f58150b19a6ec4"></a>EFBig&#160;</td><td class="fielddoc">
<p>27 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea5a15b5dc74aea8072e75da3f41cc08c8"></a>ENoSpc&#160;</td><td class="fielddoc">
<p>28 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea76d2318325d33c3a63e04e369785457c"></a>ESPipe&#160;</td><td class="fielddoc">
<p>29 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea2b2a5ace1385019b28a6192572243703"></a>ERofs&#160;</td><td class="fielddoc">
<p>30 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaf9af2489821fd5296454151f1d61a9b8"></a>EMLink&#160;</td><td class="fielddoc">
<p>31 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaf09952a7a43905596163dee3291e06f2"></a>EPipe&#160;</td><td class="fielddoc">
<p>32 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea8e85d2487bfcde46c46ad44c85fecca4"></a>EDom&#160;</td><td class="fielddoc">
<p>33 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaa7ed7ab95d3141a0a84b06d889e00b1d"></a>ERange&#160;</td><td class="fielddoc">
<p>34 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea99bc84d1fee6f5e097b3bdd372bc914f"></a>EDeadLk&#160;</td><td class="fielddoc">
<p>35 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea0a8835335a60c7bf038a6c42ae669745"></a>ENameTooLong&#160;</td><td class="fielddoc">
<p>36 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea0b65c5e43ec5a9ba372624270883ae53"></a>ENoLck&#160;</td><td class="fielddoc">
<p>37 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeab65b727f3eafd0629c5986511656875c"></a>ENoSys&#160;</td><td class="fielddoc">
<p>38 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea36fa6025bf27ade7aaf59811f28cdbe3"></a>ENotEmpty&#160;</td><td class="fielddoc">
<p>39 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaaee63432c3362be93935e1855de31281"></a>ELoop&#160;</td><td class="fielddoc">
<p>40 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea5d63aa85f4278c762a695b787e5e20b4"></a>EWouldBlock&#160;</td><td class="fielddoc">
<p>11 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaeb4f7d7103ecf7106a8a34e335db604d"></a>ENoMsg&#160;</td><td class="fielddoc">
<p>42 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea86fcf9e8f1df22cb57bd9cc46abe29a1"></a>EIdrm&#160;</td><td class="fielddoc">
<p>43 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaa1806e60358990b585e9ebbf3bd4cb45"></a>EChrng&#160;</td><td class="fielddoc">
<p>44 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaa96c7ac811f484535930e716937d0e51"></a>EL2NSync&#160;</td><td class="fielddoc">
<p>45 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea267c68029d67983fa737bad281e73c65"></a>EL3Hlt&#160;</td><td class="fielddoc">
<p>46 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea5a7f23fcd4f8f7e3024165be95eddffb"></a>EL3Rst&#160;</td><td class="fielddoc">
<p>47 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeac085198eab87c32a83f2302e54bd63f3"></a>ELnrng&#160;</td><td class="fielddoc">
<p>48 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea49f3ca511be782138dc36e300b3ec77d"></a>EUnatch&#160;</td><td class="fielddoc">
<p>49 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeac6fbf79d425cac6aa3a7647c648db7a9"></a>ENoCsi&#160;</td><td class="fielddoc">
<p>50 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea754e4a149c2bef94f597fd18aad1942e"></a>EL2Hlt&#160;</td><td class="fielddoc">
<p>51 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea98a2c035dc14ffe381438c5a01a71e5b"></a>EBade&#160;</td><td class="fielddoc">
<p>52 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea6dc080b07103aec2872a56b5a95f87f2"></a>EBadr&#160;</td><td class="fielddoc">
<p>53 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaf543b8d05f23df49fd94345d665142ad"></a>EXFull&#160;</td><td class="fielddoc">
<p>54 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeab6a3ca11021fd08f6ca9612b6756b47d"></a>ENoAno&#160;</td><td class="fielddoc">
<p>55 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaf0af4df7f25af6e90e9925677d631a91"></a>EBadRqc&#160;</td><td class="fielddoc">
<p>56 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea22cd0d41773f55130d34199b602a7e3f"></a>EBadSsl&#160;</td><td class="fielddoc">
<p>57 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaa51209c0ef37d581997c721138fbde41"></a>EDeadLock&#160;</td><td class="fielddoc">
<p>35 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaaf1977c1079d808c8223e903ee066394"></a>EBFont&#160;</td><td class="fielddoc">
<p>59 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeab8aeae1f148aeb1b00a8ccef3e8332d1"></a>ENoStr&#160;</td><td class="fielddoc">
<p>60 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeae5b187b5ed40557fb744d0cf69b73351"></a>ENoData&#160;</td><td class="fielddoc">
<p>61 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaedf113fb19efb25f3b46f1b99d11d69d"></a>ETime&#160;</td><td class="fielddoc">
<p>62 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aead41a1d27c02d53137652889638aa4138"></a>ENoSr&#160;</td><td class="fielddoc">
<p>63 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea08c9024db7b48774ef44b0c8a103d388"></a>ENoNet&#160;</td><td class="fielddoc">
<p>64 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaec81a97edcf4772d610f708f49d16e45"></a>ENoPkg&#160;</td><td class="fielddoc">
<p>65 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaa01032c7629608efdfd7253fe0c5dbb1"></a>ERemote&#160;</td><td class="fielddoc">
<p>66 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeafa0104095220ecf07759933ab1e10b33"></a>ENoLink&#160;</td><td class="fielddoc">
<p>67 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea282bfaddb76098fec2111c26b82ce85d"></a>EAdv&#160;</td><td class="fielddoc">
<p>68 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaf8b86149f324f791fab7ecfb12916595"></a>ESrmnt&#160;</td><td class="fielddoc">
<p>69 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea77872136029e815a5a3756c9a6f4279d"></a>EComm&#160;</td><td class="fielddoc">
<p>70 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea93e6b9fa5def179ed993b29254ff95e7"></a>EProto&#160;</td><td class="fielddoc">
<p>71 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea0be074eb8d9371b337b057b6ad2a2207"></a>EMultiHop&#160;</td><td class="fielddoc">
<p>72 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea05093bab5e645d217995d00c511dcd1e"></a>EDotDot&#160;</td><td class="fielddoc">
<p>73 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea2012ba78cb82480bbc7a499e105e68e2"></a>EBadMsg&#160;</td><td class="fielddoc">
<p>74 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea4cbbf7e70525cecf368c4fcf90457d4a"></a>EOverflow&#160;</td><td class="fielddoc">
<p>75 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea1975215dabd3b158590d70dc7c7bd3d6"></a>ENotUnuq&#160;</td><td class="fielddoc">
<p>76 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea768786ee873b0d516097ba570626e0ef"></a>EBadFd&#160;</td><td class="fielddoc">
<p>77 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea709157bbce9f8d21813d3e4aa9c3da71"></a>ERemChg&#160;</td><td class="fielddoc">
<p>78 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaea49a6d33feb1d380c3ca35bec00a2a2"></a>ELibAcc&#160;</td><td class="fielddoc">
<p>79 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaf24a082c490b0a274088c14392880d28"></a>ELibBad&#160;</td><td class="fielddoc">
<p>80 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeac44b613805edd820f39406847276eb28"></a>ELibScn&#160;</td><td class="fielddoc">
<p>81 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeab04713ab44ec88a625f518886623300d"></a>ELibMax&#160;</td><td class="fielddoc">
<p>82 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea7cb0887230f830194a839ad259de4dc5"></a>ELibExec&#160;</td><td class="fielddoc">
<p>83 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeae2f22fccaae58fb6a1511791ec2ab48a"></a>EIlSeq&#160;</td><td class="fielddoc">
<p>84 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeac888d9b9c48639ba474f73d7fae8a1fa"></a>ERestart&#160;</td><td class="fielddoc">
<p>85 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea85f3fa8f2af7fa459898318ff03403c9"></a>EStrPipe&#160;</td><td class="fielddoc">
<p>86 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeae92fcfd186d87a32e655aa7d30728ddd"></a>EUsers&#160;</td><td class="fielddoc">
<p>87 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea2ee283d2ea4a7035cf02f4401ad6e8c4"></a>ENotSock&#160;</td><td class="fielddoc">
<p>88 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeab6f06c9908647268602ee06dfe4de82e"></a>EDestAddrReq&#160;</td><td class="fielddoc">
<p>89 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aead50e4ce04c6d8fa3bcedc355c71e6908"></a>EMsgSize&#160;</td><td class="fielddoc">
<p>90 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea42dc875635f09bfea546420510ac0ab1"></a>EPrototype&#160;</td><td class="fielddoc">
<p>91 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaaceea24a2e74e865ad49c5235aa80390"></a>ENoProtoOpt&#160;</td><td class="fielddoc">
<p>92 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea0b862e14b0970b149efcc374d17116e9"></a>EProtoNoSupport&#160;</td><td class="fielddoc">
<p>93 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea75f70195d7962cf82c8222f4cce70f39"></a>ESocktNoSupport&#160;</td><td class="fielddoc">
<p>94 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeac2dd8a9d9020d692236fe36e327a0790"></a>EOpNotSupp&#160;</td><td class="fielddoc">
<p>95 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea55d425f0db40e77288d34ab4ed070f18"></a>ENotSup&#160;</td><td class="fielddoc">
<p>95 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea1720dfd2feee6b1db8936ab2ab34eb97"></a>EPfNoSupport&#160;</td><td class="fielddoc">
<p>96 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea8aa5fd58e6123e002dd6794a9dd41d19"></a>EAfNoSupport&#160;</td><td class="fielddoc">
<p>97 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea5d70ce827609b95db47cb2801a9a3f02"></a>EAddrInUse&#160;</td><td class="fielddoc">
<p>98 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea80a6ebced38fdfd7e5fe5a2263b0fdfd"></a>EAddrNotAvail&#160;</td><td class="fielddoc">
<p>99 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeae57b86c74a54b9dfc0a43f20885d531b"></a>ENetDown&#160;</td><td class="fielddoc">
<p>100 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeae9e5813d133d21c50d5b9d2821b5c7d5"></a>ENetUnreach&#160;</td><td class="fielddoc">
<p>101 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeab57c2bd2da5b8a225fd2ed15216279b5"></a>ENetReset&#160;</td><td class="fielddoc">
<p>102 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeafe202ba38fe5506795fa6f3ac18b1d7e"></a>EConnAborted&#160;</td><td class="fielddoc">
<p>103 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea35b0f4b6f7c078dbf75d488c08d644d7"></a>EConnReset&#160;</td><td class="fielddoc">
<p>104 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea8c84e92e411b15ee2a52955b1a4c7f59"></a>ENoBufs&#160;</td><td class="fielddoc">
<p>105 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea7e42ca49cd604842cf40a55a6fb1da37"></a>EIsConn&#160;</td><td class="fielddoc">
<p>106 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea49ef25c2845d57c542b75ebf74c22d32"></a>ENotConn&#160;</td><td class="fielddoc">
<p>107 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea729df151046a4792119264f623eb80e1"></a>EShutDown&#160;</td><td class="fielddoc">
<p>108 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea092cb05e83ae8bf3fbf945987f17ff16"></a>ETooManyRefs&#160;</td><td class="fielddoc">
<p>109 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeab8b3b473d7a87bc0787d270847504b62"></a>ETimedOut&#160;</td><td class="fielddoc">
<p>110 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea06cb83b76f73aee6a739e690d8a615e0"></a>EConnRefused&#160;</td><td class="fielddoc">
<p>111 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea03738213bb11b2d3c3d4296514be9544"></a>EHostDown&#160;</td><td class="fielddoc">
<p>112 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea4d13a4e176134b1b99e47bc557803186"></a>EHostUnreach&#160;</td><td class="fielddoc">
<p>113 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea01a1169f10a84bd5ca327117f7357ffc"></a>EAlready&#160;</td><td class="fielddoc">
<p>114 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaa912f0d27a490f37dd216b352c5bafc4"></a>EInProgress&#160;</td><td class="fielddoc">
<p>115 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea1c3b5910a911d1f3e41edba2f06594b5"></a>EStale&#160;</td><td class="fielddoc">
<p>116 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea9d732f137d84e7da1b32b9cb736d1ddc"></a>EUClean&#160;</td><td class="fielddoc">
<p>117 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea6282a4dccf34458154ae15890b37d659"></a>ENotNam&#160;</td><td class="fielddoc">
<p>118 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea23e17817410df3175208154a51b25a55"></a>ENAvail&#160;</td><td class="fielddoc">
<p>119 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeae9e3ed355fc29e0dad6d05c848e451c8"></a>EIsNam&#160;</td><td class="fielddoc">
<p>120 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea25f7ffafd2d0599fc5cbee65c14684af"></a>ERemoteIo&#160;</td><td class="fielddoc">
<p>121 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea82395bcac4c12e9c7c114484e7d75adc"></a>EDQuot&#160;</td><td class="fielddoc">
<p>122 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea3875301196f736df1fc0723290bce35a"></a>ENoMedium&#160;</td><td class="fielddoc">
<p>123 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea7c28e4df0019f6dd00c2cfb26ce6b99d"></a>EMediumType&#160;</td><td class="fielddoc">
<p>124 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aeaa1e822d71d55e23ef9fdd62d3f00186f"></a>ECanceled&#160;</td><td class="fielddoc">
<p>125 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea1d533f04c62e336634a34c5d2682d2b4"></a>ENoKey&#160;</td><td class="fielddoc">
<p>126 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea36e49b905c1ebbea57e42090b42f6d36"></a>EKeyExpired&#160;</td><td class="fielddoc">
<p>127 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea270c5f22a81c83e17ae57842341b31c6"></a>EKeyRevoked&#160;</td><td class="fielddoc">
<p>128 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea399cb55edc8e96b594f10358c8ebbdca"></a>EKeyRejected&#160;</td><td class="fielddoc">
<p>129 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea06bc3b94addadc4c4f6415bd684823bb"></a>EOwnerDead&#160;</td><td class="fielddoc">
<p>130 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea0bffc159cd62dee50d8f41c1eb13cac8"></a>ENotRecoverable&#160;</td><td class="fielddoc">
<p>131 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea1997f833be90d1e8062107d8cb1217ea"></a>ERfKill&#160;</td><td class="fielddoc">
<p>132 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea67b3313d2dc7e38962494c534e3e0235"></a>EHwPoison&#160;</td><td class="fielddoc">
<p>133 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad1ade4838b158c7aaf9c9a78338e06aea99205299258cb573335d080cb4f7c2de"></a>EProcLim&#160;</td><td class="fielddoc">
<p>156 </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a7d8c1d2e11d6bdbdd12c05bc4505e96e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1socket.html#a7d8c1d2e11d6bdbdd12c05bc4505e96e">nn::socket::HErrno</a> : int32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Error return codes from <a class="el" href="namespacenn_1_1socket.html#a358030926e9e63c2e322de2bd3d26719">nn::socket::GetHostEntByName()</a> and <a class="el" href="namespacenn_1_1socket.html#aaace32e2780295ca03bc72efa4b49406">nn::socket::GetHostEntByAddr()</a> </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a7d8c1d2e11d6bdbdd12c05bc4505e96ea12a4c4b6f764342d7774ec0b61507035"></a>Netdb_Internal&#160;</td><td class="fielddoc">
<p>See <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890">GetLastError()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7d8c1d2e11d6bdbdd12c05bc4505e96ea974fb47430ce74d9c031981a1ba70449"></a>Netdb_Success&#160;</td><td class="fielddoc">
<p>No problem. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7d8c1d2e11d6bdbdd12c05bc4505e96ea8815b22a3d45c4582c575a4ddf301f27"></a>Host_Not_Found&#160;</td><td class="fielddoc">
<p>Authoritative Answer Host not found. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7d8c1d2e11d6bdbdd12c05bc4505e96ea75a5b439512277f31d1165a59f32c21b"></a>Try_Again&#160;</td><td class="fielddoc">
<p>Non-Authoritive Host not found, or SERVERFAIL. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7d8c1d2e11d6bdbdd12c05bc4505e96ea1b315dd1ed4bffa191e3c42162cd86e3"></a>No_Recovery&#160;</td><td class="fielddoc">
<p>Non recoverable errors, FORMERR, REFUSED, NOTIMP. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7d8c1d2e11d6bdbdd12c05bc4505e96eaf0a483b6ea00b43c8e211e4d5bf2e630"></a>No_Data&#160;</td><td class="fielddoc">
<p>Valid name, no data record of requested type. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7d8c1d2e11d6bdbdd12c05bc4505e96ea6643bf2c5cc3c9c98495983e431cddad"></a>No_Address&#160;</td><td class="fielddoc">
<p>No address, look for MX record. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="af622578590c2fb499d0c41023de4952a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952a">nn::socket::AiErrno</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Error return codes from <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60">nn::socket::GetAddrInfo()</a> and <a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3">nn::socket::GetNameInfo()</a> </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="af622578590c2fb499d0c41023de4952aa063e46c2edc044d4eb15ff1881c61617"></a>EAi_Success&#160;</td><td class="fielddoc">
<p>No problem. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af622578590c2fb499d0c41023de4952aa7dedf0718f97c8239662b8eb48051ec3"></a>EAi_AddrFamily&#160;</td><td class="fielddoc">
<p>Address family for hostname not supported. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af622578590c2fb499d0c41023de4952aa39c09b23fe2d1d3727cabe8374db3f32"></a>EAi_Again&#160;</td><td class="fielddoc">
<p>Temporary failure in name resolution. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af622578590c2fb499d0c41023de4952aa2d629ab06248d8373abced5a838e16e1"></a>EAi_BadFlags&#160;</td><td class="fielddoc">
<p>Invalid value for ai_flags. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af622578590c2fb499d0c41023de4952aa0af973135fb5e1f7e6b4928735cab38b"></a>EAi_Fail&#160;</td><td class="fielddoc">
<p>Non-recoverable failure in name resolution. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af622578590c2fb499d0c41023de4952aa249e58b45b4f5d5d3c7d829fd0838007"></a>EAi_Family&#160;</td><td class="fielddoc">
<p>Family not supported. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af622578590c2fb499d0c41023de4952aa4eb196554f2312d8e76fe54ec43f9732"></a>EAi_Memory&#160;</td><td class="fielddoc">
<p>Memory allocation failure. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af622578590c2fb499d0c41023de4952aad39f7a0b221378921dbabe9ddb42e91c"></a>EAi_NoData&#160;</td><td class="fielddoc">
<p>No address associated with hostname. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af622578590c2fb499d0c41023de4952aa49ba37cc879f6a8bd0ed14ca7dd7b900"></a>EAi_NoName&#160;</td><td class="fielddoc">
<p>Hostname or servname not provided, or not known. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af622578590c2fb499d0c41023de4952aa6d4318baa1c030e5a7bd4bf5847895b8"></a>EAi_Service&#160;</td><td class="fielddoc">
<p>Servname not supported for ai_socktype. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af622578590c2fb499d0c41023de4952aa862515285580e8bbd7cdd9197eb610fc"></a>EAi_SockType&#160;</td><td class="fielddoc">
<p>Socket <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaea">Type</a> not supported. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af622578590c2fb499d0c41023de4952aa3a66c0aef3e90e7853328eaba9c70a24"></a>EAi_System&#160;</td><td class="fielddoc">
<p>System error returned in errno. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af622578590c2fb499d0c41023de4952aa3cd3fdba16234bd5004596f5bd1eff8a"></a>EAi_BadHints&#160;</td><td class="fielddoc">
<p>Invalid value for hints. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af622578590c2fb499d0c41023de4952aaf760c4b7855651610ab6e6d0262b3250"></a>EAi_Protocol&#160;</td><td class="fielddoc">
<p>Resolved protocol is unknown. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af622578590c2fb499d0c41023de4952aab42b238abde7f85eb903e64a0cdd51a6"></a>EAi_Overflow&#160;</td><td class="fielddoc">
<p>Argument buffer overflow. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af622578590c2fb499d0c41023de4952aa21cbeb8fe93b42d2e15c7d9719efa52d"></a>EAi_Max&#160;</td><td class="fielddoc">
<p>Used for bounds checking. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a8f9b7859b60d1ee546e472a7e2a9beaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1socket.html#a8f9b7859b60d1ee546e472a7e2a9beaa">nn::socket::Level</a> : int32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket option level. </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a8f9b7859b60d1ee546e472a7e2a9beaaa4418133767fb2aecc740f56abdda0a07"></a>Sol_Socket&#160;</td><td class="fielddoc">
<p>Socket level. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8f9b7859b60d1ee546e472a7e2a9beaaaa6c6737dec8d29d339301143d6d0ed79"></a>Sol_Ip&#160;</td><td class="fielddoc">
<p>IP level. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8f9b7859b60d1ee546e472a7e2a9beaaa064e9643ad5bd7963ac529d40422c41e"></a>Sol_Icmp&#160;</td><td class="fielddoc">
<p>ICMP level. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8f9b7859b60d1ee546e472a7e2a9beaaa07877ef6eba5cd50e7fd156ab490e25e"></a>Sol_Tcp&#160;</td><td class="fielddoc">
<p>TCP level. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8f9b7859b60d1ee546e472a7e2a9beaaa28ce2e827de6e03222cb031dd7262005"></a>Sol_Udp&#160;</td><td class="fielddoc">
<p>UDP level. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8f9b7859b60d1ee546e472a7e2a9beaaa20031d70d0159b1e9216a32ed067d4ba"></a>Sol_UdpLite&#160;</td><td class="fielddoc">
<p>UDP-Lite level. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92c">nn::socket::Option</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creation flags, OR'ed into <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a> type argument. </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca2f86c3240686e886bf04673b6dfa1774"></a>So_Debug&#160;</td><td class="fielddoc">
<p>Enables recording of debugging information. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca56f0c4e92af8ae866a97313e10f27825"></a>So_AcceptConn&#160;</td><td class="fielddoc">
<p>Get listening status of the socket (get only). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca4ff047a311170a7b1b91fbf572b27827"></a>So_ReuseAddr&#160;</td><td class="fielddoc">
<p>Enables local address reuse. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca7c793a7e8f86558ba08b3ef3c45cb65a"></a>So_KeepAlive&#160;</td><td class="fielddoc">
<p>Keep connections alive. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca593d609439615cf3bb8fcb4e033212f6"></a>So_DontRoute&#160;</td><td class="fielddoc">
<p>Enables routing bypass for outgoing messages. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca71f2d3c1f2b815034748923c95b3c7c2"></a>So_Broadcast&#160;</td><td class="fielddoc">
<p>Enables permission to transmit broadcast messages. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca063d4fa19cacacc94e1eb4ab53c69583"></a>So_UseLoopback&#160;</td><td class="fielddoc">
<p>Bypass hardware when possible. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca77f52d4d2b4cb0a18003473b82fe62fa"></a>So_Linger&#160;</td><td class="fielddoc">
<p><a class="el" href="structnn_1_1socket_1_1_linger.html" title="Structure used for manipulating linger option. ">Linger</a> on close if data present. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca83cd727bfab799ab2c3282993bc4890e"></a>So_OobInline&#160;</td><td class="fielddoc">
<p>Enables reception of out-of-band data in band. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca98f34f2098b46d53adb82302fd9fd3cc"></a>So_ReusePort&#160;</td><td class="fielddoc">
<p>Enables duplicate address and port bindings. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca4078c1b605c4c29f21a0bf25944c0cd4"></a>So_SndBuf&#160;</td><td class="fielddoc">
<p>Send buffer size. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca1600030ecdfa4988343a0182c2716781"></a>So_RcvBuf&#160;</td><td class="fielddoc">
<p>Receive buffer size. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92cacae1d771853d17e6345e649b6f5268c3"></a>So_SndLoWat&#160;</td><td class="fielddoc">
<p>Send low-water mark. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92cac06b98b070f9197dd3cae7e9426beb8f"></a>So_RcvLoWat&#160;</td><td class="fielddoc">
<p>Receive low-water mark. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca9b65d34203dd13d8c6477fb765edd60a"></a>So_SndTimeo&#160;</td><td class="fielddoc">
<p>Send timeout. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92cab5605811c9cdb8e46fa16b737d6473b8"></a>So_RcvTimeo&#160;</td><td class="fielddoc">
<p>Receive timeout. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92caa09b2054c97d538ca128022bdb5d70ff"></a>So_Error&#160;</td><td class="fielddoc">
<p>Get error status and clear. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca290eb4182e53294ce5d51f5ddb9faaf4"></a>So_Type&#160;</td><td class="fielddoc">
<p>Get socket type. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca13b81ea29143e0f425217f0cc1e1d947"></a>So_Label&#160;</td><td class="fielddoc">
<p>Socket's MAC label. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca0ad5d7204fe937a474e3bee89a8911c5"></a>So_PeerLabel&#160;</td><td class="fielddoc">
<p>Socket's peer's MAC label. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92cadcf2eab57ae78219999a1f3c0220606f"></a>So_ListenQLimit&#160;</td><td class="fielddoc">
<p>Socket's backlog limit. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca1ccb3b4f5df5d298d6634435264cf552"></a>So_ListenQLen&#160;</td><td class="fielddoc">
<p>Socket's complete queue length. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca1ab76ba3c3c726d472d8b67a408c6e2f"></a>So_ListenIncQLen&#160;</td><td class="fielddoc">
<p>Socket's incomplete queue length. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca5a873168505d4f5805a0f479afefbd7a"></a>So_SetFib&#160;</td><td class="fielddoc">
<p>Use this FIB to route. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca0a0e7b92f66b475e7f263a1f47517ab4"></a>So_User_Cookie&#160;</td><td class="fielddoc">
<p>User cookie (dummynet etc.). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92cad6a9f6dc315317276189f9dbda9e2142"></a>So_Protocol&#160;</td><td class="fielddoc">
<p>Get socket protocol (Linux name). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92caab7d92ab038534d93c3a247917928cb7"></a>So_Nn_Linger&#160;</td><td class="fielddoc">
<p>Upon completion of <a class="el" href="namespacenn_1_1socket.html#ae01110d228e2148d830b1ecfb9aaa425">Close()</a>, this version of linger always drops the connection entirely, freeing associated resources. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92cacfc84cbe560a8aad1c718a7861e33d71"></a>Ip_Options&#160;</td><td class="fielddoc">
<p>Set/get IP options. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca2ea192d20c0bb4351564aca953d62e87"></a>Ip_HdrIncl&#160;</td><td class="fielddoc">
<p>Header is included with data. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92caa981510ed4830206d7a6c3d118dc9392"></a>Ip_Tos&#160;</td><td class="fielddoc">
<p>IP type of service and preced.. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca1f884d211d51f87827c58fa2a8b53e76"></a>Ip_Ttl&#160;</td><td class="fielddoc">
<p>IP time to live. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca7d421a52a6a6930d432e4a6b7c8e8fe5"></a>Ip_RecvOpts&#160;</td><td class="fielddoc">
<p>Receive all IP opts w/dgram. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92cafe12b995ba510bc29c236f12bce3b972"></a>Ip_Multicast_If&#160;</td><td class="fielddoc">
<p>Set/get IP multicast i/f. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca32ee18abf563ea6ee9912737d312655c"></a>Ip_Multicast_Ttl&#160;</td><td class="fielddoc">
<p>Set/get IP multicast ttl. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca02f8ec2a469d61c090f3472089a4ab36"></a>Ip_Multicast_Loop&#160;</td><td class="fielddoc">
<p>Set/get IP multicast loopback. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92cac8ec2fe65eaf9fdbc23297dfd36a9e1c"></a>Ip_Add_Membership&#160;</td><td class="fielddoc">
<p>Add an IP group membership. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca091584d2877be7911a41c16f2acf0814"></a>Ip_Drop_Membership&#160;</td><td class="fielddoc">
<p>Drop an IP group membership. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92cac7ec079d666c2ffea2fc0d8759b72d7f"></a>Ip_Multicast_Vif&#160;</td><td class="fielddoc">
<p>Set/get IP mcast virt. iface. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92cab3e067b0aba5e72268f07dcd455f6ded"></a>Ip_Rsvp_On&#160;</td><td class="fielddoc">
<p>Enable RSVP in kernel. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca5cdbe7531950912a74f908d990c26295"></a>Ip_Rsvp_Off&#160;</td><td class="fielddoc">
<p>Disable RSVP in kernel. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca301f39b550212b09d1e173bb96d8ac15"></a>Ip_Rsvp_Vif_On&#160;</td><td class="fielddoc">
<p>Set RSVP per-vif socket. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca4e184874353ac4f02d70fe94a67a344f"></a>Ip_Rsvp_Vif_Off&#160;</td><td class="fielddoc">
<p>Unset RSVP per-vif socket. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca12ca196d5fb48531054942f9ba700d15"></a>Ip_PortRange&#160;</td><td class="fielddoc">
<p>Range to choose for unspec port. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92cacebde55581618620bacce1c92d246328"></a>Ip_Faith&#160;</td><td class="fielddoc">
<p>Accept FAITH'ed connections. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca009cfa491615a4710953fa9c3c0c7afd"></a>Ip_OnesBcast&#160;</td><td class="fielddoc">
<p>Send all-ones broadcast. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92caad3f23ed3b1fad7b0ba236a40734e381"></a>Ip_BindAny&#160;</td><td class="fielddoc">
<p>Allow bind to any address. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca726abe575b22d7c088bff64f17b6b44b"></a>Ip_RecvTtl&#160;</td><td class="fielddoc">
<p>Receive IP TTL w/dgram. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92cad126866d462a421818799f793e87ebcf"></a>Ip_MinTtl&#160;</td><td class="fielddoc">
<p>Minimum TTL for packet or drop. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca1307d6c88fcc4ef7d6a541488f70e777"></a>Ip_DontFrag&#160;</td><td class="fielddoc">
<p>Don't fragment packet. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca42706217d313156a41db74a1cc7c96f0"></a>Ip_RecvTos&#160;</td><td class="fielddoc">
<p>Receive IP TOS w/dgram. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca7f5b507de957ab754cfbcae70ee9d8d8"></a>Ip_Add_Source_Membership&#160;</td><td class="fielddoc">
<p>Join a source-specific group. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca34b4c9a8fbbef3ccc7a610f45df33133"></a>Ip_Drop_Source_Membership&#160;</td><td class="fielddoc">
<p>Drop a single source. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca42fccf017ac8a271f88ec603b2862164"></a>Ip_Block_Source&#160;</td><td class="fielddoc">
<p>Block a source. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca4f2e75d3a2af1d30ae44ebfccbee668c"></a>Ip_Unblock_Source&#160;</td><td class="fielddoc">
<p>Unblock a source. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca2d22a30cb3647dfc45e9cf81c9d7c92e"></a>Tcp_NoDelay&#160;</td><td class="fielddoc">
<p>Don't delay send to coalesce packets. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca3803ae0a82bbc2976fb7d037c66f1e9d"></a>Tcp_MaxSeg&#160;</td><td class="fielddoc">
<p>Set maximum segment size. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92cab15153f4944a9fddf656bc872f1e4177"></a>Tcp_NoPush&#160;</td><td class="fielddoc">
<p>Don't push last block of write. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca79acf2a72d56c802833bca601b678969"></a>Tcp_NoOpt&#160;</td><td class="fielddoc">
<p>Don't use TCP options. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca74b6412fc6ea85cbe84a85d1d20f4bce"></a>Tcp_Md5Sig&#160;</td><td class="fielddoc">
<p>Use MD5 digests (RFC2385). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca702daca3186e133db09b35f6f08dd7a0"></a>Tcp_Info&#160;</td><td class="fielddoc">
<p>Retrieve <a class="el" href="structnn_1_1socket_1_1_tcp_info.html">TcpInfo</a> structure. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca2e75bc9c4246e5aa93361746bfd8d053"></a>Tcp_Congestion&#160;</td><td class="fielddoc">
<p>Get/set congestion control algorithm. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92cadb6dbfbe2b1f7554bc0c74e3b79b2256"></a>Tcp_KeepInit&#160;</td><td class="fielddoc">
<p>Time to establish connection. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca3b7b30a418f99590551e9c817ff6eda1"></a>Tcp_KeepIdle&#160;</td><td class="fielddoc">
<p>Start keeplives after this period. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca31d953fbd5cadf801a1bb6ee9d2037f0"></a>Tcp_KeepIntvl&#160;</td><td class="fielddoc">
<p>Interval between keepalives. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9706518d71ec37371e9aa3ae9a2fa92ca6ced1ae2c7ebbc4173ac523590632bc5"></a>Tcp_KeepCnt&#160;</td><td class="fielddoc">
<p>Number of keepalives before close. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a96fd860616eebd9a4ca188a750539572"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1socket.html#a96fd860616eebd9a4ca188a750539572">nn::socket::TcpInfoOption</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structnn_1_1socket_1_1_tcp_info.html" title="Structure to be passed to nn::socket::SetSockOpt() when setting the Option::Tcp_Info option...">TcpInfo</a> options. </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a96fd860616eebd9a4ca188a750539572ad57cdccdc23f4ba4c8fe5d272155b49e"></a>Tcpi_Opt_None&#160;</td><td class="fielddoc">
<p>No flags set. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a96fd860616eebd9a4ca188a750539572adf980a96851be8fe7039b3c2b0c2f7f6"></a>Tcpi_Opt_Timestamps&#160;</td><td class="fielddoc">
<p>Timestamps. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a96fd860616eebd9a4ca188a750539572adeb8b2e5cc324d8502070ab9c7dcc9c1"></a>Tcpi_Opt_Sack&#160;</td><td class="fielddoc">
<p>Selective acknowledgements. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a96fd860616eebd9a4ca188a750539572a7c7b64d43d00289a2ae237a0f052337c"></a>Tcpi_Opt_WScale&#160;</td><td class="fielddoc">
<p>Window scale. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a96fd860616eebd9a4ca188a750539572ae7114f77789abb146f37c238e28e6819"></a>Tcpi_Opt_Ecn&#160;</td><td class="fielddoc">
<p>Explicit congestion notification. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a96fd860616eebd9a4ca188a750539572a3aca115b57cc3e563e1f7ae548e790b2"></a>Tcpi_Opt_Toe&#160;</td><td class="fielddoc">
<p>TCP offload engine. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a821ac1738bb13dce9aa9d83fe5950e52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52">nn::socket::MsgFlag</a> : int32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Message flags. </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a821ac1738bb13dce9aa9d83fe5950e52a7a99ac706c1462eb6f473b328821257e"></a>Msg_None&#160;</td><td class="fielddoc">
<p>No flags set. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a821ac1738bb13dce9aa9d83fe5950e52a14e4712b9ac705dd2c8cbb473bede526"></a>Msg_Oob&#160;</td><td class="fielddoc">
<p>Process out-of-band data. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a821ac1738bb13dce9aa9d83fe5950e52a1aa484a90bed28ad47fd226459e15faa"></a>Msg_Peek&#160;</td><td class="fielddoc">
<p>Peek at incoming message. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a821ac1738bb13dce9aa9d83fe5950e52ac9a7ddcbf8db795e5c91d656a22b732a"></a>Msg_DontRoute&#160;</td><td class="fielddoc">
<p>Send without using routing tables. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a821ac1738bb13dce9aa9d83fe5950e52a5d31324825e019d3755c5b5eea5cddf6"></a>Msg_Eor&#160;</td><td class="fielddoc">
<p>Data completes record. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a821ac1738bb13dce9aa9d83fe5950e52aaf8c9241ace744a91fdac5bb1af8edb9"></a>Msg_Trunc&#160;</td><td class="fielddoc">
<p>Data discarded before delivery. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a821ac1738bb13dce9aa9d83fe5950e52ae891367d63615cef0b025c484c813bba"></a>Msg_CTrunc&#160;</td><td class="fielddoc">
<p>Control data lost before delivery. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a821ac1738bb13dce9aa9d83fe5950e52aa7788a6088ac1aa8889be821288b9c27"></a>Msg_WaitAll&#160;</td><td class="fielddoc">
<p>Wait for full request or error. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a821ac1738bb13dce9aa9d83fe5950e52a7fba2ade674c746aff1d987a7c23498d"></a>Msg_DontWait&#160;</td><td class="fielddoc">
<p>This message should be nonblocking. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a821ac1738bb13dce9aa9d83fe5950e52a7f014516b662a223d74679cc3eb2808f"></a>Msg_Eof&#160;</td><td class="fielddoc">
<p>Data completes connection. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a821ac1738bb13dce9aa9d83fe5950e52a453a9db8f1ba520722d49137ad4a0785"></a>Msg_Notification&#160;</td><td class="fielddoc">
<p>SCTP notification. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a821ac1738bb13dce9aa9d83fe5950e52aa812cfecd484f40a7d10b32686bc6442"></a>Msg_Nbio&#160;</td><td class="fielddoc">
<p>FIONBIO mode, used by fifofs. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a821ac1738bb13dce9aa9d83fe5950e52a2ca7dca75281c108b1fcc487a7eefe86"></a>Msg_Compat&#160;</td><td class="fielddoc">
<p>Used in sendit(). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a821ac1738bb13dce9aa9d83fe5950e52a1b6e6ae71d15f3af3a41cd07db319f28"></a>Msg_SoCallbck&#160;</td><td class="fielddoc">
<p>For use by socket callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a821ac1738bb13dce9aa9d83fe5950e52a7122062c2353a3f567ef0ea82727da75"></a>Msg_NoSignal&#160;</td><td class="fielddoc">
<p>Do not generate SIGPIPE on EOF. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a821ac1738bb13dce9aa9d83fe5950e52ac65aa2182e54666b95d4ffa9693d105d"></a>Msg_CMsg_CloExec&#160;</td><td class="fielddoc">
<p>Make received fds close-on-exec. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a46347de69614965469ac8f3c8056468e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1socket.html#a46347de69614965469ac8f3c8056468e">nn::socket::Protocol</a> : int32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IP protocols. </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a46347de69614965469ac8f3c8056468eae6688e7ecb2b86a2bdedd14a8f5794b2"></a>IpProto_Ip&#160;</td><td class="fielddoc">
<p>Internet protocol. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a46347de69614965469ac8f3c8056468eacfaf0973ac4989b34204076e08018320"></a>IpProto_Icmp&#160;</td><td class="fielddoc">
<p>Control message protocol. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a46347de69614965469ac8f3c8056468eaf07a075529789e7d91eefbce84c55d90"></a>IpProto_Tcp&#160;</td><td class="fielddoc">
<p>Transmission control protocol. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a46347de69614965469ac8f3c8056468ea48e0b0b8eaaf71a2c2c0ebfa0e802b1a"></a>IpProto_Udp&#160;</td><td class="fielddoc">
<p>User datagram protocol. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a46347de69614965469ac8f3c8056468ea747b4da735a7d4f75f94d49bac3668c6"></a>IpProto_None&#160;</td><td class="fielddoc">
<p>No protocol. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a46347de69614965469ac8f3c8056468eace84ba4f81c9b91654d34b5e5ffff266"></a>IpProto_UdpLite&#160;</td><td class="fielddoc">
<p>User datagram protocol, lite mode. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a46347de69614965469ac8f3c8056468ea5f2672872a021cf5f726af1e84f26960"></a>IpProto_Raw&#160;</td><td class="fielddoc">
<p>Raw IP packets protocol. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a1db675083dcccec6500d1435c5dfeaea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaea">nn::socket::Type</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket type, which specifies the semantics of communication. </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a1db675083dcccec6500d1435c5dfeaeaa221076d68c5f73ca9d81b6dd6c2e18d4"></a>Sock_Default&#160;</td><td class="fielddoc">
<p>Default socket type for the protocol, if any. This is used for the <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> call. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1db675083dcccec6500d1435c5dfeaeaae703319723c99d2d3a7ba1ad0dc8f572"></a>Sock_Stream&#160;</td><td class="fielddoc">
<p>Stream socket. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1db675083dcccec6500d1435c5dfeaeaa4cc079142a1be58955eb22bed651ebba"></a>Sock_Dgram&#160;</td><td class="fielddoc">
<p>Datagram socket. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1db675083dcccec6500d1435c5dfeaeaadbce0ab5f7ffb036b16d28b8e258f720"></a>Sock_Raw&#160;</td><td class="fielddoc">
<p>Raw-protocol interface. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1db675083dcccec6500d1435c5dfeaeaa3ee64579e9e60354dc99756954340e99"></a>Sock_SeqPacket&#160;</td><td class="fielddoc">
<p>Sequenced packet stream. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1db675083dcccec6500d1435c5dfeaeaa6aa760fecb3b3f81a3c5ed0425f99762"></a>Sock_NonBlock&#160;</td><td class="fielddoc">
<p>Set non-blocking mode on the new socket. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a057d985148e23267303e6d00d7ed205d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205d">nn::socket::Family</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Address and protocol families. </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a057d985148e23267303e6d00d7ed205daf71f2e4ba3e999c5a27fdd7ad7044628"></a>Af_Unspec&#160;</td><td class="fielddoc">
<p>Unspecified. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a057d985148e23267303e6d00d7ed205da3e60ee00982f3876225add01b048d51c"></a>Pf_Unspec&#160;</td><td class="fielddoc">
<p>Unspecified. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a057d985148e23267303e6d00d7ed205daa4d833d8c15a76105639ddd11bcb614e"></a>Af_Inet&#160;</td><td class="fielddoc">
<p>Internet Version 4. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a057d985148e23267303e6d00d7ed205dab67c056bcb9139a61ab2022bf23270c4"></a>Pf_Inet&#160;</td><td class="fielddoc">
<p>Internet Version 4. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a057d985148e23267303e6d00d7ed205da53d19d3503b80a25464b42ea2b842570"></a>Af_Route&#160;</td><td class="fielddoc">
<p>Communication with kernel routing layer. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a057d985148e23267303e6d00d7ed205daf382a0598ba805d89710d4aa2b572371"></a>Pf_Route&#160;</td><td class="fielddoc">
<p>Communication with kernel routing layer. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a057d985148e23267303e6d00d7ed205da286989897035d6bfc1481a71643368de"></a>Af_Link&#160;</td><td class="fielddoc">
<p>Raw link-layer access. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a057d985148e23267303e6d00d7ed205dad55e05ade1d509f24b1e731722f38490"></a>Pf_Link&#160;</td><td class="fielddoc">
<p>Raw link-layer access. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a057d985148e23267303e6d00d7ed205daf734c28714ec9e1040af4f8f4c30b824"></a>Af_Inet6&#160;</td><td class="fielddoc">
<p>Internet Version 6. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a057d985148e23267303e6d00d7ed205da27e24d2ad16f16c9ee6d44c72fbfa310"></a>Pf_Inet6&#160;</td><td class="fielddoc">
<p>Internet Version 6. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a2b8c53cba8a2be170c93a76742b092c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9">nn::socket::PollEvent</a> : int16_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Poll events. </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a2b8c53cba8a2be170c93a76742b092c9a1b0bed7d85ba6b2cbe91629776e3ee6d"></a>PollIn&#160;</td><td class="fielddoc">
<p>Data other than high priority data may be read without blocking. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2b8c53cba8a2be170c93a76742b092c9a1034fc649394d42b19fead1ab1828e54"></a>PollPri&#160;</td><td class="fielddoc">
<p>High priority data may be read without blocking. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2b8c53cba8a2be170c93a76742b092c9aca8de23660319dc20822f6e6059a727b"></a>PollOut&#160;</td><td class="fielddoc">
<p>File descriptor is writeable. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2b8c53cba8a2be170c93a76742b092c9a6aee635278505dd8cc1da7f50c4a651d"></a>PollErr&#160;</td><td class="fielddoc">
<p>An exceptional condition has occurred on the device or socket. </p>
<p>This flag is always checked, even if not present in the events bitmask. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2b8c53cba8a2be170c93a76742b092c9a2421093408548ab23a7a93500e8cccd3"></a>PollHup&#160;</td><td class="fielddoc">
<p>The device or socket has been disconnected. </p>
<p>This flag is always checked, even if not present in the events bitmask. Note that PollHup and PollOut should never be present in the revents bitmask at the same time. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2b8c53cba8a2be170c93a76742b092c9aecf0948bef1a1db017a0d4e714f05c04"></a>PollNVal&#160;</td><td class="fielddoc">
<p>The file descriptor is not open. </p>
<p>This flag is always checked, even if not present in the events bitmask. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2b8c53cba8a2be170c93a76742b092c9aaf909a6e6a64bebd393ae9fbc33f200a"></a>PollRdNorm&#160;</td><td class="fielddoc">
<p>Normal data may be read without blocking. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2b8c53cba8a2be170c93a76742b092c9a9b8ce4bb4c25d8b2abc5e5648c9cd54a"></a>PollRdBand&#160;</td><td class="fielddoc">
<p>Data with a non-zero priority may be read without blocking. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2b8c53cba8a2be170c93a76742b092c9af5abb7d0050a44e425556082ae71b547"></a>PollWrNorm&#160;</td><td class="fielddoc">
<p>Normal data may be written without blocking. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2b8c53cba8a2be170c93a76742b092c9a70417b0dc75887023e5fa42ca645d4c9"></a>PollWrBand&#160;</td><td class="fielddoc">
<p>Data with a non-zero priority may be written without blocking. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a2c63ce69dddbb1c78d89626f2c43e736"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736">nn::socket::AddrInfoFlag</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag values for <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60">nn::socket::GetAddrInfo()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a2c63ce69dddbb1c78d89626f2c43e736af5758c7e9b74944ef16fe00171db2626"></a>Ai_None&#160;</td><td class="fielddoc">
<p>No flags set. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2c63ce69dddbb1c78d89626f2c43e736a07f3aa8bca15327f9ff738676c87a17b"></a>Ai_Passive&#160;</td><td class="fielddoc">
<p>If this bit is set, it indicates that the returned socket address structure is intended for use in a call to <a class="el" href="namespacenn_1_1socket.html#a09255737b952ba3ad3a647607fc2af0a">Bind()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2c63ce69dddbb1c78d89626f2c43e736a1a2e6d6759bb114a41af8185090c58e3"></a>Ai_CanonName&#160;</td><td class="fielddoc">
<p>If this bit is set, a successful call to <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60">GetAddrInfo()</a> will return a NULL-terminated string containing the canonical name of the specified hostname in the <em>ai_canonname</em> element of the first <a class="el" href="structnn_1_1socket_1_1_addr_info.html">AddrInfo</a> structure returned. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2c63ce69dddbb1c78d89626f2c43e736a4e9c7347da15e21e33637e92a8c5357a"></a>Ai_NumericHost&#160;</td><td class="fielddoc">
<p>If this bit is set, it indicates that hostname should be treated as a numeric string defining an IPv4 address and no name resolution should be attempted. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2c63ce69dddbb1c78d89626f2c43e736a25bb67f3036a24405c49021582b87048"></a>Ai_NumericServ&#160;</td><td class="fielddoc">
<p>If this bit is set, then a non-null servname string supplied shall be a numeric port string. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2c63ce69dddbb1c78d89626f2c43e736adc37ac841acdd2d44f66639c607345d2"></a>Ai_AddrConfig&#160;</td><td class="fielddoc">
<p>If this bit is set, IPv4 addresses shall be returned only if an IPv4 address is configured on the local system. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ab65d6a3635e193943fa4f95edfbebeae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1socket.html#ab65d6a3635e193943fa4f95edfbebeae">nn::socket::NameInfoFlag</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag values for <a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3">nn::socket::GetNameInfo()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="ab65d6a3635e193943fa4f95edfbebeaea71fedd318bedd821cec9abb5af3505ed"></a>Ni_None&#160;</td><td class="fielddoc">
<p>No flags set. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab65d6a3635e193943fa4f95edfbebeaea2b7218595524993b8a5e6f28be48a06e"></a>Ni_NoFqdn&#160;</td><td class="fielddoc">
<p>A fully qualified domain name is not required for local hosts. </p>
<p>The local part of the fully qualified domain name is returned instead. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab65d6a3635e193943fa4f95edfbebeaeabce932039fed36ee2d7f93f65888d7cd"></a>Ni_NumericHost&#160;</td><td class="fielddoc">
<p>Return the address in numeric form, as if calling <a class="el" href="namespacenn_1_1socket.html#a43969e788b0959ef0007b481f45c3a4a">InetNtop()</a>, instead of a host name. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab65d6a3635e193943fa4f95edfbebeaead52a0caf970660226eabd510f35a6d4b"></a>Ni_NameReqd&#160;</td><td class="fielddoc">
<p>A name is required. </p>
<p>If the host name cannot be found in DNS and this flag is set, a non-zero error code is returned. If the host name is not found and the flag is not set, the address is returned in numeric form. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab65d6a3635e193943fa4f95edfbebeaea1424d526e3e5f2ce5e6e62387181fa3c"></a>Ni_NumericServ&#160;</td><td class="fielddoc">
<p>The service name is returned as a digit string representing the port number. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab65d6a3635e193943fa4f95edfbebeaea2a229d7a05bf4eafb5480f2b0e67b84e"></a>Ni_Dgram&#160;</td><td class="fielddoc">
<p>Specifies that the service being looked up is a datagram service. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aef8523201363cec26def667e89cbfeae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1socket.html#aef8523201363cec26def667e89cbfeae">nn::socket::ShutdownMethod</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shutdown method used for <a class="el" href="namespacenn_1_1socket.html#a895595468f09d14293edd099a8ff7dc5">nn::socket::Shutdown()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="aef8523201363cec26def667e89cbfeaea4c491712eb09285fbca6d544778ce617"></a>Shut_Rd&#160;</td><td class="fielddoc">
<p>Shut down the reading side. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aef8523201363cec26def667e89cbfeaea92c4cf816a81e278824998e27103d833"></a>Shut_Wr&#160;</td><td class="fielddoc">
<p>Shut down the writing side. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aef8523201363cec26def667e89cbfeaea026146e0cdfc1f3e09c9f6a838eb42ef"></a>Shut_RdWr&#160;</td><td class="fielddoc">
<p>Shut down both sides. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a047cb0e8a33ab75269a940a59ac7f62a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1socket.html#a047cb0e8a33ab75269a940a59ac7f62a">nn::socket::IoctlCommand</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commands used for <a class="el" href="namespacenn_1_1socket.html#a558dc819d133326891523fcaf32303f8">nn::socket::Ioctl()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a047cb0e8a33ab75269a940a59ac7f62aa84615c987f017ddb39fcd935e4745258"></a>FionRead&#160;</td><td class="fielddoc">
<p>Get the number of bytes that are immediately available for reading. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a047cb0e8a33ab75269a940a59ac7f62aa316efa79f1d14b40adaa703d8483610b"></a>FionWrite&#160;</td><td class="fielddoc">
<p>Get the number of bytes in the descriptor's send queue. </p>
<p>These bytes are data which has been written to the descriptor but which are being held by the kernel for further processing. The nature of the required processing depends on the underlying device. For TCP sockets, these bytes have not yet been acknowledged by the other side of the connection. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a047cb0e8a33ab75269a940a59ac7f62aad4c0438bde575cc3318c3ca43dee2192"></a>FionSpace&#160;</td><td class="fielddoc">
<p>Get the free space in the descriptor's send queue. </p>
<p>This value is the size of the send queue minus the number of bytes being held in the queue. Note: while this value represents the number of bytes that may be added to the queue, other resource limitations may cause a write not larger than the send queue's space to be blocked. One such limitation would be a lack of network buffers for a write to a network connection. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ae03bdb6384cac8b1ba7617743144d09f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1socket.html#ae03bdb6384cac8b1ba7617743144d09f">nn::socket::FcntlCommand</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commands used for <a class="el" href="namespacenn_1_1socket.html#a92cb62635aca20860e3ab848f347ec6f">nn::socket::Fcntl()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="ae03bdb6384cac8b1ba7617743144d09fa02772fa35d3b587e7642cbf50c753d08"></a>F_GetFl&#160;</td><td class="fielddoc">
<p>Get descriptor status flags. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae03bdb6384cac8b1ba7617743144d09fada2f7613aac1b87c8679a7b8c03ac9ca"></a>F_SetFl&#160;</td><td class="fielddoc">
<p>Set descriptor status flags. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aa04c2b32bf6fe54bdbb1a3f5febdc477"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1socket.html#aa04c2b32bf6fe54bdbb1a3f5febdc477">nn::socket::FcntlFlag</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commands used for <a class="el" href="namespacenn_1_1socket.html#a92cb62635aca20860e3ab848f347ec6f">nn::socket::Fcntl()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="aa04c2b32bf6fe54bdbb1a3f5febdc477a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc">
<p>No flags set. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa04c2b32bf6fe54bdbb1a3f5febdc477a5693df4e99113d8216f084412a7a3849"></a>O_NonBlock&#160;</td><td class="fielddoc">
<p>Non-blocking mode. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a class="anchor" id="a6db6951cb084f74f4c17d655ce798890"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06ae">Errno</a> nn::socket::GetLastError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the global variable <em>errno</em>. </p>
<dl class="section return"><dt>戻り値</dt><dd>Returns <em>errno</em> value.</dd></dl>
<p><b>詳細</b> <br />
 When a network function call detects an error, it returns an integer value indicating failure (-1) and sets the global variable <em>errno</em> accordingly. In Windows builds, <em>errno</em> cannot be accessed directly. Instead, this function needs to be called to retrieve that value. It can also be used in NX builds but it is not necessary.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#ab3e3e08ff4437c59fe7e2f764279c631" title="Set the global variable errno. ">SetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_libcurl_speed_test_8cpp-example.html#a6">LibcurlSpeedTest.cpp</a>, <a class="el" href="_socket_basic_8cpp-example.html#a10">SocketBasic.cpp</a>, <a class="el" href="_socket_resolver_8cpp-example.html#a15">SocketResolver.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab3e3e08ff4437c59fe7e2f764279c631"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::socket::SetLastError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06ae">Errno</a>&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global variable <em>errno</em>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">error</td><td>The error to which to set the global variable <em>errno</em> to.</td></tr>
  </table>
  </dd>
</dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#ab3e3e08ff4437c59fe7e2f764279c631" title="Set the global variable errno. ">SetLastError()</a> routine can be used to set the global variable <em>errno</em>. Certain components of the network stack may choose to set or override the global variable <em>errno</em>. Since <em>errno</em> cannot be accessed directly in Windows builds, this function is necessary in those cases. It can also be used in NX builds but it is not necessary.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a476ef4e55fd64cf5b9d027e17f10a5e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::InetPton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205d">Family</a>&#160;</td>
          <td class="paramname"><em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pAddressString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pOutAddressBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert address to network format. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">family</td><td>Type of the network address, only <a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205daa4d833d8c15a76105639ddd11bcb614e">Family::Af_Inet</a> is supported </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pAddressString</td><td>Address in presentation format </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAddressBuffer</td><td>Address in network format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns 1 if the address was valid for the specified address family, or 0 if the address was not parseable in the specified address family, or -1 if some system error occurred (in which case the global variable <em>errno</em> will have been set). This function is presently valid only for <a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205daa4d833d8c15a76105639ddd11bcb614e">Family::Af_Inet</a>.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a476ef4e55fd64cf5b9d027e17f10a5e6" title="Convert address to network format. ">InetPton()</a> function converts a presentation format address (that is, printable form as held in a character string) to network format (usually an <a class="el" href="structnn_1_1socket_1_1_in_addr.html">InAddr</a> structure or some other internal binary representation, in network byte order). This function can be used without calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> first.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a85ef2c54d6090d3c03393f8ab7cad49e" title="Convert string to network address. ">InetAton()</a>, <a class="el" href="namespacenn_1_1socket.html#af90b8239ae0f5fbd70f12f9980fdac76" title="Convert Internet address into ASCII string. ">InetNtoa()</a>, <a class="el" href="namespacenn_1_1socket.html#a43969e788b0959ef0007b481f45c3a4a" title="Convert network address to presentation format. ">InetNtop()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_socket_resolver_8cpp-example.html#a16">SocketResolver.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a85ef2c54d6090d3c03393f8ab7cad49e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::InetAton </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addressStringBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1socket_1_1_in_addr.html">InAddr</a> *&#160;</td>
          <td class="paramname"><em>pOutNetworkAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to network address. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addressStringBuffer</td><td>Address string in ASCII format </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutNetworkAddress</td><td>Address in network format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns 1 if the string was successfully interpreted, or 0 if the string is invalid.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a85ef2c54d6090d3c03393f8ab7cad49e" title="Convert string to network address. ">InetAton()</a> routine interprets the specified character string as an Internet address, placing the address into the structure provided. This function can be used without calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> first.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a476ef4e55fd64cf5b9d027e17f10a5e6" title="Convert address to network format. ">InetPton()</a>, <a class="el" href="namespacenn_1_1socket.html#af90b8239ae0f5fbd70f12f9980fdac76" title="Convert Internet address into ASCII string. ">InetNtoa()</a>, <a class="el" href="namespacenn_1_1socket.html#a43969e788b0959ef0007b481f45c3a4a" title="Convert network address to presentation format. ">InetNtop()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_socket_basic_8cpp-example.html#a32">SocketBasic.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af90b8239ae0f5fbd70f12f9980fdac76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* nn::socket::InetNtoa </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1socket_1_1_in_addr.html">InAddr</a>&#160;</td>
          <td class="paramname"><em>networkAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert Internet address into ASCII string. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">networkAddress</td><td>Address in network format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns network address in ASCII representation.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#af90b8239ae0f5fbd70f12f9980fdac76" title="Convert Internet address into ASCII string. ">InetNtoa()</a> routine takes an Internet address and returns an ASCII string representing the address in '.' notation. The return value is managed internally, so if you wish to maintain the value between calls, a copy must be made. This function is not thread safe so there is a chance for the returned string to not be what is expected if called from another thread at the same time. This function can be used without calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> first.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a476ef4e55fd64cf5b9d027e17f10a5e6" title="Convert address to network format. ">InetPton()</a>, <a class="el" href="namespacenn_1_1socket.html#a85ef2c54d6090d3c03393f8ab7cad49e" title="Convert string to network address. ">InetAton()</a>, <a class="el" href="namespacenn_1_1socket.html#a43969e788b0959ef0007b481f45c3a4a" title="Convert network address to presentation format. ">InetNtop()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_libcurl_speed_test_8cpp-example.html#a16">LibcurlSpeedTest.cpp</a>, <a class="el" href="_socket_basic_8cpp-example.html#a22">SocketBasic.cpp</a>, <a class="el" href="_socket_resolver_8cpp-example.html#a6">SocketResolver.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a43969e788b0959ef0007b481f45c3a4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::socket::InetNtop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205d">Family</a>&#160;</td>
          <td class="paramname"><em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pNetworkAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>addressStringBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a>&#160;</td>
          <td class="paramname"><em>addressStringBufferLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert network address to presentation format. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">family</td><td>Type of network address, only <a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205daa4d833d8c15a76105639ddd11bcb614e">Family::Af_Inet</a> is supported </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pNetworkAddress</td><td>Address in network format </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addressStringBuffer</td><td>Address in presentation format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addressStringBufferLength</td><td>Size of the buffer for address in presentation format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns NULL if a system error occurs (in which case, the global variable <em>errno</em> will have been set), or it returns a pointer to the destination string (<em>addressStringBuffer</em>).</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a43969e788b0959ef0007b481f45c3a4a" title="Convert network address to presentation format. ">InetNtop()</a> routine converts an address stored at <em>pNetworkAddress</em> from network format (usually an <a class="el" href="structnn_1_1socket_1_1_in_addr.html">InAddr</a> structure or some other binary form, in network byte order) to presentation format (suitable for external display purposes). This function can be used without calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> first.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a476ef4e55fd64cf5b9d027e17f10a5e6" title="Convert address to network format. ">InetPton()</a>, <a class="el" href="namespacenn_1_1socket.html#a85ef2c54d6090d3c03393f8ab7cad49e" title="Convert string to network address. ">InetAton()</a>, <a class="el" href="namespacenn_1_1socket.html#af90b8239ae0f5fbd70f12f9980fdac76" title="Convert Internet address into ASCII string. ">InetNtoa()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1b6e15ce629648357cf10cc8ada6b8d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t nn::socket::InetHtons </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hostValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert 16-bit integer from host to network byte order. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hostValue</td><td>16-bit unsigned integer in host byte order</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns 16-bit unsigned integer in network byte order</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a1b6e15ce629648357cf10cc8ada6b8d1" title="Convert 16-bit integer from host to network byte order. ">InetHtons()</a> routine converts 16-bit unsigned integer <em>hostValue</em> from host byte order to network byte order. This function can be used without calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> first.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a24652de2bb3beca4cd692b4c3f7141db" title="Convert 32-bit integer from host to network byte order. ">InetHtonl()</a>, <a class="el" href="namespacenn_1_1socket.html#aa8de3f19aaf80d2233a668fc7ebe6f38" title="Convert 16-bit ineger from network to host byte order. ">InetNtohs()</a>, <a class="el" href="namespacenn_1_1socket.html#a06113194b65c644a046c8c65ea7c4515" title="Convert 32-bit integer from network to host byte order. ">InetNtohl()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_access_point_8cpp-example.html#a43">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a36">LdnStation.cpp</a>, <a class="el" href="_libcurl_speed_test_8cpp-example.html#a25">LibcurlSpeedTest.cpp</a>, <a class="el" href="_socket_basic_8cpp-example.html#a16">SocketBasic.cpp</a>, <a class="el" href="_socket_resolver_8cpp-example.html#a27">SocketResolver.cpp</a>, <a class="el" href="_ssl_simple_8cpp-example.html#a31">SslSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a24652de2bb3beca4cd692b4c3f7141db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nn::socket::InetHtonl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hostValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert 32-bit integer from host to network byte order. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hostValue</td><td>32-bit unsigned integer in host byte order</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns 32-bit unsigned integer in network byte order.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a24652de2bb3beca4cd692b4c3f7141db" title="Convert 32-bit integer from host to network byte order. ">InetHtonl()</a> routine converts 32-bit unsigned integer <em>hostValue</em> from host byte order to network byte order. This function can be used without calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> first.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a1b6e15ce629648357cf10cc8ada6b8d1" title="Convert 16-bit integer from host to network byte order. ">InetHtons()</a>, <a class="el" href="namespacenn_1_1socket.html#aa8de3f19aaf80d2233a668fc7ebe6f38" title="Convert 16-bit ineger from network to host byte order. ">InetNtohs()</a>, <a class="el" href="namespacenn_1_1socket.html#a06113194b65c644a046c8c65ea7c4515" title="Convert 32-bit integer from network to host byte order. ">InetNtohl()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_access_point_8cpp-example.html#a46">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a39">LdnStation.cpp</a>, <a class="el" href="_socket_basic_8cpp-example.html#a13">SocketBasic.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa8de3f19aaf80d2233a668fc7ebe6f38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t nn::socket::InetNtohs </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>networkValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert 16-bit ineger from network to host byte order. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">networkValue</td><td>16-bit unsigned integer in network byte order</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns 16-bit unsigned integer in host byte order</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#aa8de3f19aaf80d2233a668fc7ebe6f38" title="Convert 16-bit ineger from network to host byte order. ">InetNtohs()</a> routine converts 16-bit unsigned integer <em>networkValue</em> from network byte order to host byte order. This function can be used without calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> first.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a1b6e15ce629648357cf10cc8ada6b8d1" title="Convert 16-bit integer from host to network byte order. ">InetHtons()</a>, <a class="el" href="namespacenn_1_1socket.html#a24652de2bb3beca4cd692b4c3f7141db" title="Convert 32-bit integer from host to network byte order. ">InetHtonl()</a>, <a class="el" href="namespacenn_1_1socket.html#a06113194b65c644a046c8c65ea7c4515" title="Convert 32-bit integer from network to host byte order. ">InetNtohl()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_socket_basic_8cpp-example.html#a23">SocketBasic.cpp</a>, <a class="el" href="_ssl_simple_8cpp-example.html#a34">SslSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a06113194b65c644a046c8c65ea7c4515"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nn::socket::InetNtohl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>networkValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert 32-bit integer from network to host byte order. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">networkValue</td><td>32-bit unsigned integer in network byte order</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns 32-bit unsigned integer in host byte order.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a06113194b65c644a046c8c65ea7c4515" title="Convert 32-bit integer from network to host byte order. ">InetNtohl()</a> routine converts 32-bit unsigned integer <em>networkValue</em> from network byte order to host byte order. This function can be used without calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> first.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a1b6e15ce629648357cf10cc8ada6b8d1" title="Convert 16-bit integer from host to network byte order. ">InetHtons()</a>, <a class="el" href="namespacenn_1_1socket.html#a24652de2bb3beca4cd692b4c3f7141db" title="Convert 32-bit integer from host to network byte order. ">InetHtonl()</a>, <a class="el" href="namespacenn_1_1socket.html#aa8de3f19aaf80d2233a668fc7ebe6f38" title="Convert 16-bit ineger from network to host byte order. ">InetNtohs()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_access_point_8cpp-example.html#a55">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a46">LdnStation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="adab268741c66f0996683c31b1bcd05dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nn::socket::RecvFrom </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outBufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52">MsgFlag</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> *&#160;</td>
          <td class="paramname"><em>pOutAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a> *&#160;</td>
          <td class="paramname"><em>pOutAddressLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives a message from a connection-oriented or connectionless-oriented socket. </p>
<p>It is normally used with connectionless-oriented sockets because it permits the application to retrieve the source address of received data.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outBuffer</td><td>Buffer for message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outBufferLength</td><td>Size of the message to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags modifying behavior of the function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAddress</td><td>Buffer for message source address </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutAddressLength</td><td>Size of the message source address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns number of bytes received, or -1 if an error occurred. If no messages are available to be received and the peer has performed an orderly shutdown, <a class="el" href="namespacenn_1_1socket.html#adab268741c66f0996683c31b1bcd05dc" title="Receives a message from a connection-oriented or connectionless-oriented socket. ">RecvFrom()</a> shall return 0.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327">Errno::EBadf</a> </td><td>The argument socket is an invalid descriptor </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea35b0f4b6f7c078dbf75d488c08d644d7">Errno::EConnReset</a> </td><td>The remote socket end is forcibly closed </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeae57b86c74a54b9dfc0a43f20885d531b">Errno::ENetDown</a> </td><td>The network interface has been removed and the socket has been shut down. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea49ef25c2845d57c542b75ebf74c22d32">Errno::ENotConn</a> </td><td>The socket is associated with a connection-oriented protocol and has not been connected (see <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f">Connect()</a> and <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a>). </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea2ee283d2ea4a7035cf02f4401ad6e8c4">Errno::ENotSock</a> </td><td>The argument socket does not refer to a socket. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>The socket is marked non-blocking, and the receive operation would block, or a receive timeout had been set, and the timeout expired before data was received. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>A non-zero <em>outBufferLength</em> was provided with a null <em>outBuffer</em>. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea3fdc41982aa0e73be04ddc708c157a7b">Errno::EFault</a> </td><td>The address range referred to by <em>outBuffer</em> and <em>outBufferLength</em> does not refer to a valid part of the process address space. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#adab268741c66f0996683c31b1bcd05dc" title="Receives a message from a connection-oriented or connectionless-oriented socket. ">RecvFrom()</a> routine is used to receive messages from a socket, and may be used to receive data on a socket whether or not it is connection-oriented.</p>
<p>If <em>pOutAddress</em> is not a null pointer and the socket is not connection-oriented, the source address of the message is filled in. The <em>pOutAddressLength</em> argument is a value-result argument, initialized to the size of the buffer associated with <em>pOutAddress</em>, and modified on return to indicate the actual size of the address stored there. If the actual length of the address is greater than the length of the supplied <a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> structure, the stored address will be truncated.</p>
<p>If no messages are available at the socket, the receive call waits for a message to arrive, unless the socket is non-blocking (see <a class="el" href="namespacenn_1_1socket.html#a92cb62635aca20860e3ab848f347ec6f">Fcntl()</a>) in which case the value -1 is returned and the global variable <em>errno</em> is set to <a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a>. The receive calls normally return any data available, up to the requested amount, rather than waiting for receipt of the full amount requested; this behavior is affected by the socket-level options <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cac06b98b070f9197dd3cae7e9426beb8f">Option::So_RcvLoWat</a> and <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cab5605811c9cdb8e46fa16b737d6473b8">Option::So_RcvTimeo</a> described in <a class="el" href="namespacenn_1_1socket.html#a4aff7a563a6c808b236246a182996761">GetSockOpt()</a>.</p>
<p>The <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2">Select()</a> function call may be used to determine when more data arrives.</p>
<p>The <em>flags</em> argument is formed by or'ing one or more of the values:</p>
<table class="doxtable">
<tr>
<th>Flag </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a14e4712b9ac705dd2c8cbb473bede526">MsgFlag::Msg_Oob</a> </td><td>Process out-of-band data </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a1aa484a90bed28ad47fd226459e15faa">MsgFlag::Msg_Peek</a> </td><td>Peek at incoming message </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52aa7788a6088ac1aa8889be821288b9c27">MsgFlag::Msg_WaitAll</a> </td><td>Wait for full request or error </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a7fba2ade674c746aff1d987a7c23498d">MsgFlag::Msg_DontWait</a> </td><td>Do not block </td></tr>
</table>
<p>The <a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a14e4712b9ac705dd2c8cbb473bede526">MsgFlag::Msg_Oob</a> flag requests receipt of out-of-band data that would not be received in the normal data stream. Some protocols place expedited data at the head of the normal data queue, and thus this flag cannot be used with such protocols. The <a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a1aa484a90bed28ad47fd226459e15faa">MsgFlag::Msg_Peek</a> flag causes the receive operation to return data from the beginning of the receive queue without removing that data from the queue. Thus, a subsequent receive call will return the same data. The <a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52aa7788a6088ac1aa8889be821288b9c27">MsgFlag::Msg_WaitAll</a> flag requests that the operation block until the full request is satisfied. However, the call may still return less data than requested if an error or disconnect occurs, or the next data to be received is of a different type than that returned. The <a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a7fba2ade674c746aff1d987a7c23498d">MsgFlag::Msg_DontWait</a> flag requests the call to return when it would block otherwise. If no data is available, the global variable <em>errno</em> is set to <a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a>.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a92cb62635aca20860e3ab848f347ec6f" title="File control. ">Fcntl()</a>, <a class="el" href="namespacenn_1_1socket.html#a4aff7a563a6c808b236246a182996761" title="Get socket options. ">GetSockOpt()</a>, <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select()</a>, <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f" title="Initiate a connection on a socket. ">Connect()</a>, <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_access_point_8cpp-example.html#a54">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a45">LdnStation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a5875e388a4010d756c63437dedfe5f14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nn::socket::Recv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outBufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52">MsgFlag</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives a message from a connection-mode or connectionless-mode socket. </p>
<p>It is normally used with connected sockets because it does not permit the application to retrieve the source address of received data.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outBuffer</td><td>Buffer for message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outBufferLength</td><td>Size of the message to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags modifying behavior of the function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns number of bytes received, or -1 if an error occurred. If no messages are available to be received and the peer has performed an orderly shutdown, <a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14" title="Receives a message from a connection-mode or connectionless-mode socket. ">Recv()</a> shall return 0.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14" title="Receives a message from a connection-mode or connectionless-mode socket. ">Recv()</a> routine is similar in behavior to <a class="el" href="namespacenn_1_1socket.html#adab268741c66f0996683c31b1bcd05dc">RecvFrom()</a>; however, it is normally used only on a connected socket (see <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f">Connect()</a>).</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a92cb62635aca20860e3ab848f347ec6f" title="File control. ">Fcntl()</a>, <a class="el" href="namespacenn_1_1socket.html#a4aff7a563a6c808b236246a182996761" title="Get socket options. ">GetSockOpt()</a>, <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select()</a>, <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f" title="Initiate a connection on a socket. ">Connect()</a>, <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a>, <a class="el" href="namespacenn_1_1socket.html#adab268741c66f0996683c31b1bcd05dc" title="Receives a message from a connection-oriented or connectionless-oriented socket. ">RecvFrom()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_socket_basic_8cpp-example.html#a28">SocketBasic.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aacd6b8da24d25e5e4f299b833258826f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nn::socket::SendTo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52">MsgFlag</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> *&#160;</td>
          <td class="paramname"><em>pAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a>&#160;</td>
          <td class="paramname"><em>addressLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message from a socket. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer containing the message to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferLength</td><td>Size of the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags modifying behavior of the function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pAddress</td><td>Buffer containing address of the recipient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addressLength</td><td>Size of the recipient address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the number of characters sent, or -1 if an error occurred.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327">Errno::EBadf</a> </td><td>An invalid descriptor was specified. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeac382e6a51872c6a43d968c2462a2d3be">Errno::EAcces</a> </td><td>The destination address is a broadcast address, and <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca71f2d3c1f2b815034748923c95b3c7c2">Option::So_Broadcast</a> has not been set on the socket. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea2ee283d2ea4a7035cf02f4401ad6e8c4">Errno::ENotSock</a> </td><td>The argument <em>socket</em> is not a socket. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aead50e4ce04c6d8fa3bcedc355c71e6908">Errno::EMsgSize</a> </td><td>The socket requires that message be sent atomically, and the size of the message to be sent made this impossible. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>The socket is marked non-blocking and the requested operation would block. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea8c84e92e411b15ee2a52955b1a4c7f59">Errno::ENoBufs</a> </td><td>The system was unable to allocate an internal buffer. The operation may succeed when buffers become available. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea4d13a4e176134b1b99e47bc557803186">Errno::EHostUnreach</a> </td><td>The remote host was unreachable. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea7e42ca49cd604842cf40a55a6fb1da37">Errno::EIsConn</a> </td><td>A destination address was specified and the socket is already connected. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea06cb83b76f73aee6a739e690d8a615e0">Errno::EConnRefused</a> </td><td>The socket received an ICMP destination unreachable message from the last message sent. This typically means that the receiver is not listening on the remote port. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea03738213bb11b2d3c3d4296514be9544">Errno::EHostDown</a> </td><td>The remote host was down. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeae57b86c74a54b9dfc0a43f20885d531b">Errno::ENetDown</a> </td><td>The local network interface is down. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeae9e5813d133d21c50d5b9d2821b5c7d5">Errno::ENetUnreach</a> </td><td>The network is not reachable from this host. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaf09952a7a43905596163dee3291e06f2">Errno::EPipe</a> </td><td>The socket is unable to send any more data (SBS_CANTSENDMORE has been set on the socket). This typically means that the socket is not connected. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>A non-zero <em>bufferLength</em> was provided with a null <em>buffer</em>. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea3fdc41982aa0e73be04ddc708c157a7b">Errno::EFault</a> </td><td>The address range referred to by <em>buffer</em> and <em>bufferLength</em> does not refer to a valid part of the process address space. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#aacd6b8da24d25e5e4f299b833258826f" title="Send a message from a socket. ">SendTo()</a> routine is used to transmit a message to another socket. The address of the target is given by <em>pAddress</em> with <em>addressLength</em> specifying its size. The length of the message is given by <em>bufferLength</em>. If the message is too long to pass atomically through the underlying protocol, the error <a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aead50e4ce04c6d8fa3bcedc355c71e6908">Errno::EMsgSize</a> is returned, and the message is not transmitted.</p>
<p>If no message space is available at the socket to hold the message to be transmitted, then <a class="el" href="namespacenn_1_1socket.html#aacd6b8da24d25e5e4f299b833258826f" title="Send a message from a socket. ">SendTo()</a> normally blocks, unless the socket has been placed in non-blocking I/O mode. The <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2">Select()</a> call may be used to determine when it is possible to send more data.</p>
<p>The flags argument may include one or more of the following:</p>
<table class="doxtable">
<tr>
<th>Flag </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a14e4712b9ac705dd2c8cbb473bede526">MsgFlag::Msg_Oob</a> </td><td>Process out-of-band data </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52ac9a7ddcbf8db795e5c91d656a22b732a">MsgFlag::Msg_DontRoute</a> </td><td>Bypass routing, use direct interface </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a5d31324825e019d3755c5b5eea5cddf6">MsgFlag::Msg_Eor</a> </td><td>Data completes record </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a7f014516b662a223d74679cc3eb2808f">MsgFlag::Msg_Eof</a> </td><td>Data completes transaction </td></tr>
</table>
<p>The flag <a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a14e4712b9ac705dd2c8cbb473bede526">MsgFlag::Msg_Oob</a> is used to send "out-of-band" data on sockets that support this notion (e.g. <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaae703319723c99d2d3a7ba1ad0dc8f572">Type::Sock_Stream</a>); the underlying protocol must also support "out-of-band" data. <a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a5d31324825e019d3755c5b5eea5cddf6">MsgFlag::Msg_Eor</a> is used to indicate a record mark for protocols which support the concept. <a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a7f014516b662a223d74679cc3eb2808f">MsgFlag::Msg_Eof</a> requests that the sender side of a socket be shut down, and that an appropriate indication be sent at the end of the specified data; this flag is only implemented for <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaae703319723c99d2d3a7ba1ad0dc8f572">Type::Sock_Stream</a> sockets in the <a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205daa4d833d8c15a76105639ddd11bcb614e">Family::Af_Inet</a> protocol family. <a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52ac9a7ddcbf8db795e5c91d656a22b732a">MsgFlag::Msg_DontRoute</a> is usually used only by diagnostic or routing programs.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a92cb62635aca20860e3ab848f347ec6f" title="File control. ">Fcntl()</a>, <a class="el" href="namespacenn_1_1socket.html#a4aff7a563a6c808b236246a182996761" title="Get socket options. ">GetSockOpt()</a>, <a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14" title="Receives a message from a connection-mode or connectionless-mode socket. ">Recv()</a>, <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select()</a>, <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#ab2284c3d5e78619aecbd0b78d3947936" title="Write output. ">Write()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_access_point_8cpp-example.html#a50">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a42">LdnStation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ae5a4c9f486b94e6b19e563ef97a2e412"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nn::socket::Send </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52">MsgFlag</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message from a socket. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer containing the message to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferLength</td><td>Size of the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags modifying behavior of the function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the number of characters sent, or -1 if an error occurred.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#ae5a4c9f486b94e6b19e563ef97a2e412" title="Send a message from a socket. ">Send()</a> routine is similar in behavior to <a class="el" href="namespacenn_1_1socket.html#aacd6b8da24d25e5e4f299b833258826f">SendTo()</a>; however, it is normally used only on a connected socket (see <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f">Connect()</a>).</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a92cb62635aca20860e3ab848f347ec6f" title="File control. ">Fcntl()</a>, <a class="el" href="namespacenn_1_1socket.html#a4aff7a563a6c808b236246a182996761" title="Get socket options. ">GetSockOpt()</a>, <a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14" title="Receives a message from a connection-mode or connectionless-mode socket. ">Recv()</a>, <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select()</a>, <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#ab2284c3d5e78619aecbd0b78d3947936" title="Write output. ">Write()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_socket_basic_8cpp-example.html#a31">SocketBasic.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a56b1fbede96c61d4c94ba51a3cc563b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Accept </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> *&#160;</td>
          <td class="paramname"><em>pOutAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a> *&#160;</td>
          <td class="paramname"><em>pOutAddressLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept connection on a socket. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket desciptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAddress</td><td>Address of the remote host </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutAddressLength</td><td>Size of the buffer containing remote host address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns -1 on error. If it succeeds, it returns a non-negative integer that is a descriptor for the accepted socket.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327">Errno::EBadf</a> </td><td>The descriptor is invalid. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaa9b197bd177776afbc2d1a323bf3b929">Errno::EIntr</a> </td><td>The accept operation was interrupted. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeab3f5564877c20a778d6e7b4e80c080bd">Errno::EMFile</a> </td><td>The per-process descriptor table is full. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea2ee283d2ea4a7035cf02f4401ad6e8c4">Errno::ENotSock</a> </td><td>The descriptor references a file, not a socket. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td><a class="el" href="namespacenn_1_1socket.html#ad6c2c6b2d1cd467bfdbfb4bf4057338b">Listen()</a> has not been called on the socket descriptor. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>A non-zero <em>pOutAddressLength</em> was passed with a null <em>pOutAddress</em>. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea5d63aa85f4278c762a695b787e5e20b4">Errno::EWouldBlock</a> or <a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>The socket is marked non-blocking and no connections are present to be accepted. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeafe202ba38fe5506795fa6f3ac18b1d7e">Errno::EConnAborted</a> </td><td>A connection arrived, but it was closed while waiting on the listen queue. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea3fdc41982aa0e73be04ddc708c157a7b">Errno::EFault</a> </td><td>The address range referred to by <em>pOutAddress</em> and <em>pOutAddressLength</em> does not refer to a valid part of the process address space. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a> routine can be used to accept connection on a socket. The argument <em>socket</em> is a socket that has been created with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a>, bound to an address with <a class="el" href="namespacenn_1_1socket.html#a09255737b952ba3ad3a647607fc2af0a">Bind()</a>, and is listening for connections after a <a class="el" href="namespacenn_1_1socket.html#ad6c2c6b2d1cd467bfdbfb4bf4057338b">Listen()</a>. The <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a> function call extracts the first connection request on the queue of pending connections, creates a new socket, and allocates a new file descriptor for the socket which inherits the state of the O_NONBLOCK property from the original socket.</p>
<p>If no pending connections are present on the queue, and the original socket is not marked as non-blocking, <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a> blocks the caller until a connection is present. If the original socket is marked non-blocking and no pending connections are present on the queue, <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a> returns an error as described below. The accepted socket may not be used to accept more connections. The original socket remains open.</p>
<p>The argument <em>pOutAddress</em> is a result argument that is filled-in with the address of the connecting entity, as known to the communications layer. The exact format of the <em>pOutAddress</em> argument is determined by the domain in which the communication is occurring. A null pointer may be specified for <em>pOutAddress</em> if the address information is not desired; in this case, <em>pOutAddressLength</em> is not used and should also be null. Otherwise, the <em>pOutAddressLength</em> argument is a value-result argument; it should initially contain the amount of space pointed to by <em>pOutAddress</em>; on return it will contain the actual length (in bytes) of the address returned. This call is used with connection-based socket types, currently with <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaae703319723c99d2d3a7ba1ad0dc8f572">Type::Sock_Stream</a>.</p>
<p>It is possible to <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2">Select()</a> a socket for the purposes of doing an <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a> by selecting it for read.</p>
<p>When using <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a>, portable programs should not rely on the O_NONBLOCK property and the signal destination being inherited, but should set them explicitly using <a class="el" href="namespacenn_1_1socket.html#a92cb62635aca20860e3ab848f347ec6f">Fcntl()</a>.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a09255737b952ba3ad3a647607fc2af0a" title="Assign a local protocol address to a socket. ">Bind()</a>, <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f" title="Initiate a connection on a socket. ">Connect()</a>, <a class="el" href="namespacenn_1_1socket.html#a97eb7ccadd9c3c1fb69f4a634a443003" title="Get name of connected peer. ">GetPeerName()</a>, <a class="el" href="namespacenn_1_1socket.html#adb89c6a0abfc8befcdc1ce05bf49e0ce" title="Get socket name. ">GetSockName()</a>, <a class="el" href="namespacenn_1_1socket.html#ad6c2c6b2d1cd467bfdbfb4bf4057338b" title="Listen for connections on a socket. ">Listen()</a>, <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select()</a>, <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_socket_basic_8cpp-example.html#a27">SocketBasic.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a09255737b952ba3ad3a647607fc2af0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Bind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> *&#160;</td>
          <td class="paramname"><em>pAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a>&#160;</td>
          <td class="paramname"><em>addressLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a local protocol address to a socket. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pAddress</td><td>Buffer containing address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addressLength</td><td>Length of the address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the value 0 if successful; otherwise the value -1 is returned.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327">Errno::EBadf</a> </td><td>The socket argument is not a valid descriptor. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The socket is already bound to an address, and the protocol does not support binding to a new address; or the socket has been shut down. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The <em>addressLength</em> argument is not a valid length for the address family. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The <em>pAddress</em> argument is null. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea2ee283d2ea4a7035cf02f4401ad6e8c4">Errno::ENotSock</a> </td><td>The <em>socket</em> argument is not a socket. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea80a6ebced38fdfd7e5fe5a2263b0fdfd">Errno::EAddrNotAvail</a> </td><td>The specified address is not available from the local machine. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea5d70ce827609b95db47cb2801a9a3f02">Errno::EAddrInUse</a> </td><td>The specified address is already in use. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea8aa5fd58e6123e002dd6794a9dd41d19">Errno::EAfNoSupport</a> </td><td>Addresses in the specified address family cannot be used with this socket. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeac382e6a51872c6a43d968c2462a2d3be">Errno::EAcces</a> </td><td>The requested address is protected, and the current user has inadequate permission to access it. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea3fdc41982aa0e73be04ddc708c157a7b">Errno::EFault</a> </td><td>The address range referred to by <em>pAddress</em> and <em>addressLength</em> does not refer to a valid part of the process address space. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a09255737b952ba3ad3a647607fc2af0a" title="Assign a local protocol address to a socket. ">Bind()</a> routine assigns the local protocol address to a socket. When a socket is created with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> it exists in an address family space but has no protocol address assigned. The <a class="el" href="namespacenn_1_1socket.html#a09255737b952ba3ad3a647607fc2af0a" title="Assign a local protocol address to a socket. ">Bind()</a> function call requests that address stored at <em>pAddress</em> be assigned to the socket.</p>
<p>For maximum portability, you should always zero the socket address structure before populating it and passing it to <a class="el" href="namespacenn_1_1socket.html#a09255737b952ba3ad3a647607fc2af0a" title="Assign a local protocol address to a socket. ">Bind()</a>.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f" title="Initiate a connection on a socket. ">Connect()</a>, <a class="el" href="namespacenn_1_1socket.html#adb89c6a0abfc8befcdc1ce05bf49e0ce" title="Get socket name. ">GetSockName()</a>, <a class="el" href="namespacenn_1_1socket.html#ad6c2c6b2d1cd467bfdbfb4bf4057338b" title="Listen for connections on a socket. ">Listen()</a>, <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_access_point_8cpp-example.html#a85">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a81">LdnStation.cpp</a>, <a class="el" href="_socket_basic_8cpp-example.html#a18">SocketBasic.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a3aded7f0c8c072c7beb68a670d03d36f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Connect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> *&#160;</td>
          <td class="paramname"><em>pAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a>&#160;</td>
          <td class="paramname"><em>addressLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate a connection on a socket. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pAddress</td><td>Buffer containing address of the remote host </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addressLength</td><td>Size of the buffer containing address of the remote host</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the value 0 if successful; otherwise the value -1 is returned.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327">Errno::EBadf</a> </td><td>The <em>socket</em> argument is not a valid descriptor. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The <em>addressLength</em> argument is not a valid length for the address family. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea3fdc41982aa0e73be04ddc708c157a7b">Errno::EFault</a> </td><td>The address range referred to by <em>pAddress</em> and <em>addressLength</em> does not refer to a valid part of the process address space. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea2ee283d2ea4a7035cf02f4401ad6e8c4">Errno::ENotSock</a> </td><td>The <em>socket</em> argument is a descriptor for a file, not a socket. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea80a6ebced38fdfd7e5fe5a2263b0fdfd">Errno::EAddrNotAvail</a> </td><td>The specified address is not available on this machine. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea8aa5fd58e6123e002dd6794a9dd41d19">Errno::EAfNoSupport</a> </td><td>Addresses in the specified address family cannot be used with this socket. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea7e42ca49cd604842cf40a55a6fb1da37">Errno::EIsConn</a> </td><td>The socket is already connected. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeab8b3b473d7a87bc0787d270847504b62">Errno::ETimedOut</a> </td><td>Connection establishment timed out without establishing a connection. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea06cb83b76f73aee6a739e690d8a615e0">Errno::EConnRefused</a> </td><td>The attempt to connect was forcefully rejected. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea35b0f4b6f7c078dbf75d488c08d644d7">Errno::EConnReset</a> </td><td>The connection was reset by the remote host. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeae9e5813d133d21c50d5b9d2821b5c7d5">Errno::ENetUnreach</a> </td><td>The network is not reachable from this host. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea4d13a4e176134b1b99e47bc557803186">Errno::EHostUnreach</a> </td><td>The remote host is not reachable from this host. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea5d70ce827609b95db47cb2801a9a3f02">Errno::EAddrInUse</a> </td><td>The address is already in use. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaa912f0d27a490f37dd216b352c5bafc4">Errno::EInProgress</a> </td><td>The socket is non-blocking and the connection cannot be completed immediately. It is possible to <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2">Select()</a> for completion by selecting the socket for writing. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea01a1169f10a84bd5ca327117f7357ffc">Errno::EAlready</a> </td><td>A previous connection attempt has not yet been completed. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeac382e6a51872c6a43d968c2462a2d3be">Errno::EAcces</a> </td><td>An attempt is made to connect to a broadcast address (obtained through the <a class="el" href="namespacenn_1_1socket.html#a51a9a87e624e6e91bf9b2c7a6319fd47">InAddr_Broadcast</a> constant or the <a class="el" href="namespacenn_1_1socket.html#a64cd4f761b9394ba0842ca8df3adc5df">InAddr_None</a> return value) through a socket that does not provide broadcast functionality. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>An auto-assigned port number was requested but no auto-assigned ports are available. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f" title="Initiate a connection on a socket. ">Connect()</a> routine initiates connection on a socket. If socket is of type <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaa4cc079142a1be58955eb22bed651ebba">Type::Sock_Dgram</a>, this call specifies the peer with which the socket is to be associated; this address is that to which datagrams are to be sent, and the only address from which datagrams are to be received.</p>
<p>If the socket is of type <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaae703319723c99d2d3a7ba1ad0dc8f572">Type::Sock_Stream</a>, this call attempts to make a connection to another socket. The other socket is specified by name, which is an address in the communications space of the socket. Each communications space interprets the name argument in its own way.</p>
<p>Generally, stream sockets may successfully connect only once; datagram sockets may use connect multiple times to change their association. Datagram sockets may dissolve the association by connecting to an invalid address, such as a null address.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a>, <a class="el" href="namespacenn_1_1socket.html#a97eb7ccadd9c3c1fb69f4a634a443003" title="Get name of connected peer. ">GetPeerName()</a>, <a class="el" href="namespacenn_1_1socket.html#adb89c6a0abfc8befcdc1ce05bf49e0ce" title="Get socket name. ">GetSockName()</a>, <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select()</a>, <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_libcurl_speed_test_8cpp-example.html#a27">LibcurlSpeedTest.cpp</a>, <a class="el" href="_socket_basic_8cpp-example.html#a33">SocketBasic.cpp</a>, <a class="el" href="_ssl_simple_8cpp-example.html#a32">SslSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a97eb7ccadd9c3c1fb69f4a634a443003"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::GetPeerName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> *&#160;</td>
          <td class="paramname"><em>pOutAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a> *&#160;</td>
          <td class="paramname"><em>pOutAddressLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get name of connected peer. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAddress</td><td>Buffer for storing name of the peer </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutAddressLength</td><td>Size of the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the value 0 if successful; otherwise the value -1 is returned.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327">Errno::EBadf</a> </td><td>The argument <em>socket</em> is not a valid descriptor. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea35b0f4b6f7c078dbf75d488c08d644d7">Errno::EConnReset</a> </td><td>The connection has been reset by the peer. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The value of the <em>pOutAddressLength</em> argument is not valid. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The <em>pOutAddress</em> argument or <em>pOutAddressLength</em> argument are null. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea3fdc41982aa0e73be04ddc708c157a7b">Errno::EFault</a> </td><td>The address range referred to by <em>outAddress</em> and <em>pOutAddressLength</em> does not refer to a valid part of the process address space. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea2ee283d2ea4a7035cf02f4401ad6e8c4">Errno::ENotSock</a> </td><td>The argument <em>socket</em> is not a socket. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea49ef25c2845d57c542b75ebf74c22d32">Errno::ENotConn</a> </td><td>The socket is not connected. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea8c84e92e411b15ee2a52955b1a4c7f59">Errno::ENoBufs</a> </td><td>Insufficient resources were available in the system to perform the operation. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a97eb7ccadd9c3c1fb69f4a634a443003" title="Get name of connected peer. ">GetPeerName()</a> routine returns the name of the peer connected to socket. The <em>pOutAddressLength</em> argument should be initialized to indicate the amount of space pointed to by <em>pOutAddress</em>. On return it contains the actual size of the name returned (in bytes). The name is truncated if the buffer provided is too small.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a>, <a class="el" href="namespacenn_1_1socket.html#a09255737b952ba3ad3a647607fc2af0a" title="Assign a local protocol address to a socket. ">Bind()</a>, <a class="el" href="namespacenn_1_1socket.html#adb89c6a0abfc8befcdc1ce05bf49e0ce" title="Get socket name. ">GetSockName()</a>, <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adb89c6a0abfc8befcdc1ce05bf49e0ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::GetSockName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> *&#160;</td>
          <td class="paramname"><em>pOutAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a> *&#160;</td>
          <td class="paramname"><em>pOutAddressLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get socket name. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAddress</td><td>Buffer for name </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutAddressLength</td><td>Size of the buffer for name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the value 0 if successful; otherwise the value -1 is returned.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327">Errno::EBadf</a> </td><td>The argument <em>socket</em> is not a valid descriptor. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea35b0f4b6f7c078dbf75d488c08d644d7">Errno::EConnReset</a> </td><td>The connection has been reset by the peer. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The value of the <em>pOutAddressLength</em> argument is not valid. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The <em>pOutAddress</em> argument or <em>pOutAddressLength</em> argument are null. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea3fdc41982aa0e73be04ddc708c157a7b">Errno::EFault</a> </td><td>The address range referred to by <em>outAddress</em> and <em>pOutAddressLength</em> does not refer to a valid part of the process address space. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea2ee283d2ea4a7035cf02f4401ad6e8c4">Errno::ENotSock</a> </td><td>The argument <em>socket</em> is not a socket. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea8c84e92e411b15ee2a52955b1a4c7f59">Errno::ENoBufs</a> </td><td>Insufficient resources were available in the system to perform the operation. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#adb89c6a0abfc8befcdc1ce05bf49e0ce" title="Get socket name. ">GetSockName()</a> routine returns the current name for the specified socket. The <em>pOutAddressLength</em> argument should be initialized to indicate the amount of space pointed to by <em>pOutAddress</em>. On return it contains the actual size of the name returned (in bytes).</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a09255737b952ba3ad3a647607fc2af0a" title="Assign a local protocol address to a socket. ">Bind()</a>, <a class="el" href="namespacenn_1_1socket.html#a97eb7ccadd9c3c1fb69f4a634a443003" title="Get name of connected peer. ">GetPeerName()</a>, <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_socket_basic_8cpp-example.html#a19">SocketBasic.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="afaa7ccade3133a9884ab0b8e44ac18fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::SetSockOpt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a8f9b7859b60d1ee546e472a7e2a9beaa">Level</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92c">Option</a>&#160;</td>
          <td class="paramname"><em>optionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pOptionValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a>&#160;</td>
          <td class="paramname"><em>optionLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set options on a socket. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Level of the option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optionName</td><td>Type of the option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pOptionValue</td><td>Buffer containing option value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optionLength</td><td>Size of the pOptionValue buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the value 0 if successful; otherwise the value -1 is returned.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327">Errno::EBadf</a> </td><td>The argument <em>socket</em> is not a valid descriptor. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea2ee283d2ea4a7035cf02f4401ad6e8c4">Errno::ENotSock</a> </td><td>The argument <em>socket</em> is not a socket. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaaceea24a2e74e865ad49c5235aa80390">Errno::ENoProtoOpt</a> </td><td>The <em>optionName</em> is unknown at the level indicated. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The <em>pOptionValue</em> argument is null or the value of the <em>optionLength</em> argument is not valid. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea3fdc41982aa0e73be04ddc708c157a7b">Errno::EFault</a> </td><td>The address range referred to by <em>pOptionValue</em> and <em>optionLength</em> does not refer to a valid part of the process address space. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#afaa7ccade3133a9884ab0b8e44ac18fc" title="Set options on a socket. ">SetSockOpt()</a> routine manipulates the options associated with a socket. Options may exist at multiple protocol levels; they are always present at the uppermost "socket" level.</p>
<p>When manipulating socket options the level at which the option resides and the name of the option must be specified. To manipulate options at the socket level, level is specified as <a class="el" href="namespacenn_1_1socket.html#a8f9b7859b60d1ee546e472a7e2a9beaaa4418133767fb2aecc740f56abdda0a07">Level::Sol_Socket</a>. To manipulate options at any other level the protocol number of the appropriate protocol controlling the option is supplied. For example, to indicate that an option is to be interpreted by the TCP protocol, level should be set to the protocol number of TCP.</p>
<p>The following are supported levels:</p>
<p><a class="el" href="namespacenn_1_1socket.html#a8f9b7859b60d1ee546e472a7e2a9beaaaa6c6737dec8d29d339301143d6d0ed79">Level::Sol_Ip</a>, <a class="el" href="namespacenn_1_1socket.html#a8f9b7859b60d1ee546e472a7e2a9beaaa064e9643ad5bd7963ac529d40422c41e">Level::Sol_Icmp</a>, <a class="el" href="namespacenn_1_1socket.html#a8f9b7859b60d1ee546e472a7e2a9beaaa07877ef6eba5cd50e7fd156ab490e25e">Level::Sol_Tcp</a>, <a class="el" href="namespacenn_1_1socket.html#a8f9b7859b60d1ee546e472a7e2a9beaaa28ce2e827de6e03222cb031dd7262005">Level::Sol_Udp</a>, <a class="el" href="namespacenn_1_1socket.html#a8f9b7859b60d1ee546e472a7e2a9beaaa4418133767fb2aecc740f56abdda0a07">Level::Sol_Socket</a>.</p>
<p>The <em>pOptionValue</em> and <em>optionLength</em> arguments are used to access option values. The <em>optionName</em> argument and any specified options are passed uninterpreted to the appropriate protocol module for interpretation.</p>
<p>Most socket-level options utilize an int argument for option value. For <a class="el" href="namespacenn_1_1socket.html#afaa7ccade3133a9884ab0b8e44ac18fc" title="Set options on a socket. ">SetSockOpt()</a>, the argument should be non-zero to enable a boolean option, or zero if the option is to be disabled. <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca77f52d4d2b4cb0a18003473b82fe62fa">Option::So_Linger</a> uses a <a class="el" href="structnn_1_1socket_1_1_linger.html">Linger</a> argument which specifies the desired state of the option and the linger interval (see below). <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca9b65d34203dd13d8c6477fb765edd60a">Option::So_SndTimeo</a> and <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cab5605811c9cdb8e46fa16b737d6473b8">Option::So_RcvTimeo</a> use a <a class="el" href="structnn_1_1socket_1_1_time_val.html">TimeVal</a> argument.</p>
<p>The following options are recognized at the socket level.</p>
<table class="doxtable">
<tr>
<th>Option </th><th>Short description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca4ff047a311170a7b1b91fbf572b27827">Option::So_ReuseAddr</a> </td><td>Enables local address reuse </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca98f34f2098b46d53adb82302fd9fd3cc">Option::So_ReusePort</a> </td><td>Enables duplicate address and port bindings </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca7c793a7e8f86558ba08b3ef3c45cb65a">Option::So_KeepAlive</a> </td><td>Enables keep connections alive </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca593d609439615cf3bb8fcb4e033212f6">Option::So_DontRoute</a> </td><td>Enables routing bypass for outgoing messages </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca77f52d4d2b4cb0a18003473b82fe62fa">Option::So_Linger</a> </td><td><a class="el" href="structnn_1_1socket_1_1_linger.html" title="Structure used for manipulating linger option. ">Linger</a> on close if data present </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92caab7d92ab038534d93c3a247917928cb7">Option::So_Nn_Linger</a> </td><td>Upon completion of <a class="el" href="namespacenn_1_1socket.html#ae01110d228e2148d830b1ecfb9aaa425">Close()</a>, this version of linger always drops the connection entirely, freeing associated resources </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca71f2d3c1f2b815034748923c95b3c7c2">Option::So_Broadcast</a> </td><td>Enables permission to transmit broadcast messages </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca83cd727bfab799ab2c3282993bc4890e">Option::So_OobInline</a> </td><td>Enables reception of out-of-band data in band </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca4078c1b605c4c29f21a0bf25944c0cd4">Option::So_SndBuf</a> </td><td>Set buffer size for output </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca1600030ecdfa4988343a0182c2716781">Option::So_RcvBuf</a> </td><td>Set buffer size for input </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cacae1d771853d17e6345e649b6f5268c3">Option::So_SndLoWat</a> </td><td>Set minimum count for output (not supported on Windows) </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cac06b98b070f9197dd3cae7e9426beb8f">Option::So_RcvLoWat</a> </td><td>Set minimum count for input (not supported on Windows) </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca9b65d34203dd13d8c6477fb765edd60a">Option::So_SndTimeo</a> </td><td>Set timeout value for output </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cab5605811c9cdb8e46fa16b737d6473b8">Option::So_RcvTimeo</a> </td><td>Set timeout value for input </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca56f0c4e92af8ae866a97313e10f27825">Option::So_AcceptConn</a> </td><td>Get listening status of the socket (get only, not supported on Windows) </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca290eb4182e53294ce5d51f5ddb9faaf4">Option::So_Type</a> </td><td>Get the type of the socket (get only, not supported on Windows) </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cad6a9f6dc315317276189f9dbda9e2142">Option::So_Protocol</a> </td><td>Get the protocol number for the socket (get only) </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92caa09b2054c97d538ca128022bdb5d70ff">Option::So_Error</a> </td><td>Get and clear error on the socket (get only) </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cadcf2eab57ae78219999a1f3c0220606f">Option::So_ListenQLimit</a> </td><td>Get backlog limit of the socket (get only) </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca1ccb3b4f5df5d298d6634435264cf552">Option::So_ListenQLen</a> </td><td>Get complete queue length of the socket (get only) </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca1ab76ba3c3c726d472d8b67a408c6e2f">Option::So_ListenIncQLen</a> </td><td>Get incomplete queue length of the socket (get only) </td></tr>
</table>
<p><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca4ff047a311170a7b1b91fbf572b27827">Option::So_ReuseAddr</a> indicates that the rules used in validating addresses supplied in a <a class="el" href="namespacenn_1_1socket.html#a09255737b952ba3ad3a647607fc2af0a">Bind()</a> system call should allow reuse of local addresses.</p>
<p><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca98f34f2098b46d53adb82302fd9fd3cc">Option::So_ReusePort</a> allows completely duplicate bindings by multiple processes if they all set <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca98f34f2098b46d53adb82302fd9fd3cc">Option::So_ReusePort</a> before binding the port. This option permits multiple instances of a program to each receive UDP/IP multicast or broadcast datagrams destined for the bound port.</p>
<p><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca7c793a7e8f86558ba08b3ef3c45cb65a">Option::So_KeepAlive</a> enables the periodic transmission of messages on a connected socket. Should the connected party fail to respond to these messages, the connection is considered broken and processes using the socket are notified via a SIGPIPE signal when attempting to send data.</p>
<p><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca593d609439615cf3bb8fcb4e033212f6">Option::So_DontRoute</a> indicates that outgoing messages should bypass the standard routing facilities. Instead, messages are directed to the appropriate network interface according to the network portion of the destination address.</p>
<p><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca77f52d4d2b4cb0a18003473b82fe62fa">Option::So_Linger</a> controls the action taken when unsent messages are queued on socket and a <a class="el" href="namespacenn_1_1socket.html#ae01110d228e2148d830b1ecfb9aaa425">Close()</a> is performed. If the socket promises reliable delivery of data and <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca77f52d4d2b4cb0a18003473b82fe62fa">Option::So_Linger</a> is set, the system will block the process on the <a class="el" href="namespacenn_1_1socket.html#ae01110d228e2148d830b1ecfb9aaa425">Close()</a> attempt until it is able to transmit the data or until it decides it is unable to deliver the information (a timeout period, termed the linger interval, is specified in seconds in the <a class="el" href="namespacenn_1_1socket.html#afaa7ccade3133a9884ab0b8e44ac18fc" title="Set options on a socket. ">SetSockOpt()</a> system call when <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca77f52d4d2b4cb0a18003473b82fe62fa">Option::So_Linger</a> is requested). If <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca77f52d4d2b4cb0a18003473b82fe62fa">Option::So_Linger</a> is disabled and a <a class="el" href="namespacenn_1_1socket.html#ae01110d228e2148d830b1ecfb9aaa425">Close()</a> is issued, the system will process the close in a manner that allows the process to continue as quickly as possible.</p>
<p>The option <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca71f2d3c1f2b815034748923c95b3c7c2">Option::So_Broadcast</a> requests permission to send broadcast datagrams on the socket.</p>
<p>With protocols that support out-of-band data, the <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca83cd727bfab799ab2c3282993bc4890e">Option::So_OobInline</a> option requests that out-of-band data be placed in the normal data input queue as received; it will then be accessible with <a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14">Recv()</a> or <a class="el" href="namespacenn_1_1socket.html#ae1fd34e9d084e5bb0f17a6c2361896c2">Read()</a> calls without the <a class="el" href="namespacenn_1_1socket.html#a821ac1738bb13dce9aa9d83fe5950e52a14e4712b9ac705dd2c8cbb473bede526">MsgFlag::Msg_Oob</a> flag. Some protocols always behave as if this option is set.</p>
<p><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca4078c1b605c4c29f21a0bf25944c0cd4">Option::So_SndBuf</a> and <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca1600030ecdfa4988343a0182c2716781">Option::So_RcvBuf</a> are options to adjust the normal buffer sizes allocated for output and input buffers, respectively. The buffer size may be increased for high-volume connections, or may be decreased to limit the possible backlog of incoming data.</p>
<p><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cacae1d771853d17e6345e649b6f5268c3">Option::So_SndLoWat</a> is an option to set the minimum count for output operations. Most output operations process all of the data supplied by the call, delivering data to the protocol for transmission and blocking as necessary for flow control. Nonblocking output operations will process as much data as permitted subject to flow control without blocking, but will process no data if flow control does not allow the smaller of the low water mark value or the entire request to be processed. A <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2">Select()</a> operation testing the ability to write to a socket will return true only if the low water mark amount could be processed. The default value for <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cacae1d771853d17e6345e649b6f5268c3">Option::So_SndLoWat</a> is set to a convenient size for network efficiency, often 1024.</p>
<p><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cac06b98b070f9197dd3cae7e9426beb8f">Option::So_RcvLoWat</a> is an option to set the minimum count for input operations. In general, receive calls will block until any (non-zero) amount of data is received, then return with the smaller of the amount available or the amount requested. The default value for <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cac06b98b070f9197dd3cae7e9426beb8f">Option::So_RcvLoWat</a> is 1. If <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cac06b98b070f9197dd3cae7e9426beb8f">Option::So_RcvLoWat</a> is set to a larger value, blocking receive calls normally wait until they have received the smaller of the low water mark value or the requested amount. Receive calls may still return less than the low water mark if an error occurs, or the type of data next in the receive queue is different from that which was returned.</p>
<p><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca9b65d34203dd13d8c6477fb765edd60a">Option::So_SndTimeo</a> is an option to set a timeout value for output operations. It accepts a <a class="el" href="structnn_1_1socket_1_1_time_val.html">TimeVal</a> argument with the number of seconds and microseconds used to limit waits for output operations to complete. If a send operation has blocked for this much time, it returns with a partial count or with the error <a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea5d63aa85f4278c762a695b787e5e20b4">Errno::EWouldBlock</a> if no data was sent. In the current implementation, this timer is restarted each time additional data are delivered to the protocol, implying that the limit applies to output portions ranging in size from the low water mark to the high water mark for output.</p>
<p><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cab5605811c9cdb8e46fa16b737d6473b8">Option::So_RcvTimeo</a> is an option to set a timeout value for input operations. It accepts a <a class="el" href="structnn_1_1socket_1_1_time_val.html">TimeVal</a> argument with the number of seconds and microseconds used to limit waits for input operations to complete. In the current implementation, this timer is restarted each time additional data are received by the protocol, and thus the limit is in effect an inactivity timer. If a receive operation has been blocked for this much time without receiving additional data, it returns with a short count or with the error <a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea5d63aa85f4278c762a695b787e5e20b4">Errno::EWouldBlock</a> if no data was received.</p>
<p><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca56f0c4e92af8ae866a97313e10f27825">Option::So_AcceptConn</a>, <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca290eb4182e53294ce5d51f5ddb9faaf4">Option::So_Type</a>, <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cad6a9f6dc315317276189f9dbda9e2142">Option::So_Protocol</a> and <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92caa09b2054c97d538ca128022bdb5d70ff">Option::So_Error</a> are options used only with <a class="el" href="namespacenn_1_1socket.html#a4aff7a563a6c808b236246a182996761">GetSockOpt()</a>. <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca56f0c4e92af8ae866a97313e10f27825">Option::So_AcceptConn</a> returns whether the socket is currently accepting connections, that is, whether or not the <a class="el" href="namespacenn_1_1socket.html#ad6c2c6b2d1cd467bfdbfb4bf4057338b">Listen()</a> system call was invoked on the socket. <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca290eb4182e53294ce5d51f5ddb9faaf4">Option::So_Type</a> returns the type of the socket, such as <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaae703319723c99d2d3a7ba1ad0dc8f572">Type::Sock_Stream</a>; it is useful for servers that inherit sockets on startup. <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cad6a9f6dc315317276189f9dbda9e2142">Option::So_Protocol</a> returns the protocol number for the socket, for <a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205daa4d833d8c15a76105639ddd11bcb614e">Family::Af_Inet</a> family. <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92caa09b2054c97d538ca128022bdb5d70ff">Option::So_Error</a> returns any pending error on the socket and clears the error status. It may be used to check for asynchronous errors on connected datagram sockets or for other asynchronous errors.</p>
<p><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92cadcf2eab57ae78219999a1f3c0220606f">Option::So_ListenQLimit</a> returns the maximal number of queued connections, as set by <a class="el" href="namespacenn_1_1socket.html#ad6c2c6b2d1cd467bfdbfb4bf4057338b">Listen()</a>. <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca1ccb3b4f5df5d298d6634435264cf552">Option::So_ListenQLen</a> returns the number of unaccepted complete connections. <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca1ab76ba3c3c726d472d8b67a408c6e2f">Option::So_ListenIncQLen</a> returns the number of unaccepted incomplete connections.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#ad6c2c6b2d1cd467bfdbfb4bf4057338b" title="Listen for connections on a socket. ">Listen()</a>, <a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14" title="Receives a message from a connection-mode or connectionless-mode socket. ">Recv()</a>, <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_access_point_8cpp-example.html#a86">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a82">LdnStation.cpp</a>, <a class="el" href="_libcurl_speed_test_8cpp-example.html#a2">LibcurlSpeedTest.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a4aff7a563a6c808b236246a182996761"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::GetSockOpt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a8f9b7859b60d1ee546e472a7e2a9beaa">Level</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92c">Option</a>&#160;</td>
          <td class="paramname"><em>optionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pOutOptionValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a> *&#160;</td>
          <td class="paramname"><em>pOutOptionLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get socket options. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Level of the option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optionName</td><td>Type of the option </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutOptionValue</td><td>Buffer containing option value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutOptionLength</td><td>Size of the buffer with option value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the value 0 if successful; otherwise the value -1 is returned.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327">Errno::EBadf</a> </td><td>The argument <em>socket</em> is not a valid descriptor. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea2ee283d2ea4a7035cf02f4401ad6e8c4">Errno::ENotSock</a> </td><td>The argument <em>socket</em> is not a socket. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaaceea24a2e74e865ad49c5235aa80390">Errno::ENoProtoOpt</a> </td><td>The <em>optionName</em> is unknown at the level indicated. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The <em>pOutOptionValue</em> argument or <em>pOutOptionLength</em> argument are null. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The value of the <em>pOutOptionLength</em> argument is not valid. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea3fdc41982aa0e73be04ddc708c157a7b">Errno::EFault</a> </td><td>The address range referred to by <em>pOutOptionValue</em> and the value of <em>pOutOptionLength</em> does not refer to a valid part of the process address space. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a4aff7a563a6c808b236246a182996761" title="Get socket options. ">GetSockOpt()</a> routine obtains socket options, See <a class="el" href="namespacenn_1_1socket.html#afaa7ccade3133a9884ab0b8e44ac18fc">SetSockOpt()</a> for supported options and their description.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#ad6c2c6b2d1cd467bfdbfb4bf4057338b" title="Listen for connections on a socket. ">Listen()</a>, <a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14" title="Receives a message from a connection-mode or connectionless-mode socket. ">Recv()</a>, <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#afaa7ccade3133a9884ab0b8e44ac18fc" title="Set options on a socket. ">SetSockOpt()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad6c2c6b2d1cd467bfdbfb4bf4057338b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Listen </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Listen for connections on a socket. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backlog</td><td>Length of the connection queue. Negative values or values greater than <a class="el" href="namespacenn_1_1socket.html#a9ed21151d8d68e8ac820299786ad8667">SoMaxConn</a> will set queue length to <a class="el" href="namespacenn_1_1socket.html#a9ed21151d8d68e8ac820299786ad8667">SoMaxConn</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the value 0 if successful; otherwise the value -1 is returned.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327">Errno::EBadf</a> </td><td>The argument <em>socket</em> is not a valid descriptor. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeab6f06c9908647268602ee06dfe4de82e">Errno::EDestAddrReq</a> </td><td>The socket is not bound to a local address, and the protocol does not support listening on an unbound socket. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The socket is already connected, or in the process of being connected. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea2ee283d2ea4a7035cf02f4401ad6e8c4">Errno::ENotSock</a> </td><td>The argument <em>socket</em> is not a socket. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeac2dd8a9d9020d692236fe36e327a0790">Errno::EOpNotSupp</a> </td><td>The socket is not of a type that supports the operation Listen. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#ad6c2c6b2d1cd467bfdbfb4bf4057338b" title="Listen for connections on a socket. ">Listen()</a> routine can be used to listen for connection on a socket. To accept connections, a socket is first created with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a>, a willingness to accept incoming connections and a queue limit for incoming connections are specified with <a class="el" href="namespacenn_1_1socket.html#ad6c2c6b2d1cd467bfdbfb4bf4057338b" title="Listen for connections on a socket. ">Listen()</a>, and then the connections are accepted with <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a>. The <a class="el" href="namespacenn_1_1socket.html#ad6c2c6b2d1cd467bfdbfb4bf4057338b" title="Listen for connections on a socket. ">Listen()</a> applies only to sockets of type <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaae703319723c99d2d3a7ba1ad0dc8f572">Type::Sock_Stream</a> or <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaa3ee64579e9e60354dc99756954340e99">Type::Sock_SeqPacket</a>.</p>
<p>The <em>backlog</em> argument defines the maximum length the queue of pending connections may grow to. The real maximum queue length will be 1.5 times more than the value specified in the backlog argument. A subsequent listen call on the listening socket allows the caller to change the maximum queue length using a new backlog argument. If a connection request arrives with the queue full the client may receive an error with an indication of <a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea06cb83b76f73aee6a739e690d8a615e0">Errno::EConnRefused</a>, or, in the case of TCP, the connection will be silently dropped.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a>, <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f" title="Initiate a connection on a socket. ">Connect()</a>, <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#afaa7ccade3133a9884ab0b8e44ac18fc" title="Set options on a socket. ">SetSockOpt()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_socket_basic_8cpp-example.html#a25">SocketBasic.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1cf72a9cd03a0bce6c4f905089961564"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::SockAtMark </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the read pointer is at the OOB mark. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>1 Read pointer points at mark. </dd>
<dd>
0 Read pointer does not point at mark. </dd>
<dd>
-1 Error occurred.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327">Errno::EBadf</a> </td><td>The <em>socket</em> argument is not a valid descriptor. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea7259324ba5d862aaba5087583e8404a3">Errno::ENotTy</a> </td><td>The <em>socket</em> argument is not a socket descriptor </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a1cf72a9cd03a0bce6c4f905089961564" title="Determine whether the read pointer is at the OOB mark. ">SockAtMark()</a> routine can be used to find out if the read pointer is currently pointing at the mark in the data stream. If <a class="el" href="namespacenn_1_1socket.html#a1cf72a9cd03a0bce6c4f905089961564" title="Determine whether the read pointer is at the OOB mark. ">SockAtMark()</a> returns 1, the next read will return data after the mark. Otherwise (assuming out of band data has arrived), the next read will provide data sent by the client prior to transmission of the out of band signal.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a>, <a class="el" href="namespacenn_1_1socket.html#ae1fd34e9d084e5bb0f17a6c2361896c2" title="Read input. ">Read()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a895595468f09d14293edd099a8ff7dc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Shutdown </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#aef8523201363cec26def667e89cbfeae">ShutdownMethod</a>&#160;</td>
          <td class="paramname"><em>how</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable sends and/or receives on a socket. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">how</td><td>Shutdown method</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the value 0 if successful; otherwise the value -1 is returned.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327">Errno::EBadf</a> </td><td>The <em>socket</em> argument is not a valid file descriptor. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The <em>how</em> argument is invalid. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeac2dd8a9d9020d692236fe36e327a0790">Errno::EOpNotSupp</a> </td><td>The socket associated with the file descriptor <em>socket</em> does not support this operation. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea49ef25c2845d57c542b75ebf74c22d32">Errno::ENotConn</a> </td><td>The <em>socket</em> argument specifies a <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaae703319723c99d2d3a7ba1ad0dc8f572">Type::Sock_Stream</a> socket which is not connected. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea2ee283d2ea4a7035cf02f4401ad6e8c4">Errno::ENotSock</a> </td><td>The <em>socket</em> argument does not refer to a socket. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a895595468f09d14293edd099a8ff7dc5" title="Disable sends and/or receives on a socket. ">Shutdown()</a> routine disables sends or receives on a socket. The <em>how</em> argument specifies the type of shutdown.</p>
<p>Possible values are:</p>
<table class="doxtable">
<tr>
<th>Value </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#aef8523201363cec26def667e89cbfeaea4c491712eb09285fbca6d544778ce617">ShutdownMethod::Shut_Rd</a> </td><td>Further receives will be disallowed. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#aef8523201363cec26def667e89cbfeaea92c4cf816a81e278824998e27103d833">ShutdownMethod::Shut_Wr</a> </td><td>Further sends will be disallowed. This may cause actions specific to the protocol family of the socket to happen. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#aef8523201363cec26def667e89cbfeaea026146e0cdfc1f3e09c9f6a838eb42ef">ShutdownMethod::Shut_RdWr</a> </td><td>Further sends and receives will be disallowed. Implies SHUT_WR. </td></tr>
</table>
<p>If the file descriptor <em>socket</em> is associated with a <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaae703319723c99d2d3a7ba1ad0dc8f572">Type::Sock_Stream</a> socket, all or part of the full-duplex connection will be shut down.</p>
<p>IMPLEMENTATION NOTES:</p>
<p>The following protocol-specific actions apply to the use of SHUT_WR (and potentially also SHUT_RDWR), based on the properties of the socket associated with the file descriptor socket.</p>
<table class="doxtable">
<tr>
<th>Domain </th><th>Type </th><th>Protocol </th><th>Return value and action  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205daa4d833d8c15a76105639ddd11bcb614e">Family::Af_Inet</a> </td><td><a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaa4cc079142a1be58955eb22bed651ebba">Type::Sock_Dgram</a> </td><td><a class="el" href="namespacenn_1_1socket.html#a46347de69614965469ac8f3c8056468ea48e0b0b8eaaf71a2c2c0ebfa0e802b1a">Protocol::IpProto_Udp</a> </td><td>Return 0. ICMP messages will not be generated </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205daa4d833d8c15a76105639ddd11bcb614e">Family::Af_Inet</a> </td><td><a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaae703319723c99d2d3a7ba1ad0dc8f572">Type::Sock_Stream</a> </td><td><a class="el" href="namespacenn_1_1socket.html#a46347de69614965469ac8f3c8056468eaf07a075529789e7d91eefbce84c55d90">Protocol::IpProto_Tcp</a> </td><td>Return 0. Send queued data, wait for ACK, then send FIN </td></tr>
</table>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f" title="Initiate a connection on a socket. ">Connect()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_access_point_8cpp-example.html#a89">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a85">LdnStation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a9afeb564bac1d0c04af2fec1f00c739f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205d">Family</a>&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaea">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a46347de69614965469ac8f3c8056468e">Protocol</a>&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create endpoint for communication. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Communication domain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Socket type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol</td><td>Protocol type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns -1 on error. If it succeeds, it returns a non-negative integer that is a descriptor for the created socket.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeac382e6a51872c6a43d968c2462a2d3be">Errno::EAcces</a> </td><td>Permission to create a socket of the specified type and/or protocol is denied. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea8aa5fd58e6123e002dd6794a9dd41d19">Errno::EAfNoSupport</a> </td><td>The address family (domain) is not supported or the specified domain is not supported by this protocol family. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeab3f5564877c20a778d6e7b4e80c080bd">Errno::EMFile</a> </td><td>The per-process descriptor table is full. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea8c84e92e411b15ee2a52955b1a4c7f59">Errno::ENoBufs</a> </td><td>Insufficient buffer space is available. The socket cannot be created until sufficient resources are freed. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea8cb8036f66c3dfbaaf7c62a5e0a92ce9">Errno::EPerm</a> </td><td>User has insufficient privileges to carry out the requested operation. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea0b862e14b0970b149efcc374d17116e9">Errno::EProtoNoSupport</a> </td><td>The protocol type or the specified protocol is not supported within this domain. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea42dc875635f09bfea546420510ac0ab1">Errno::EPrototype</a> </td><td>The socket type is not supported by the protocol. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a> routine creates an endpoint for communication and returns a descriptor. The <em>domain</em> argument specifies a communications domain within which communication will take place; this selects the protocol family which should be used.</p>
<p>The currently understood formats are:</p>
<table class="doxtable">
<tr>
<th>Format </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205daa4d833d8c15a76105639ddd11bcb614e">Family::Af_Inet</a> </td><td>Internet version 4 protocols </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205da53d19d3503b80a25464b42ea2b842570">Family::Af_Route</a> </td><td>Internal Routing protocol </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205da286989897035d6bfc1481a71643368de">Family::Af_Link</a> </td><td>Link layer interface </td></tr>
</table>
<p>The socket has the indicated <em>type</em>, which specifies the semantics of communication.</p>
<p>Currently defined types are:</p>
<table class="doxtable">
<tr>
<th>Type </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaae703319723c99d2d3a7ba1ad0dc8f572">Type::Sock_Stream</a> </td><td>Stream socket, </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaa4cc079142a1be58955eb22bed651ebba">Type::Sock_Dgram</a> </td><td>Datagram socket, </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaadbce0ab5f7ffb036b16d28b8e258f720">Type::Sock_Raw</a> </td><td>Raw-protocol interface </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaa3ee64579e9e60354dc99756954340e99">Type::Sock_SeqPacket</a> </td><td>Sequenced packet stream </td></tr>
</table>
<p>A <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaae703319723c99d2d3a7ba1ad0dc8f572">Type::Sock_Stream</a> type provides sequenced, reliable, two-way connection based byte streams. An out-of-band data transmission mechanism may be supported.</p>
<p>A <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaa4cc079142a1be58955eb22bed651ebba">Type::Sock_Dgram</a> socket supports datagrams (connectionless, unreliable messages of a fixed (typically small) maximum length).</p>
<p>A <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaa3ee64579e9e60354dc99756954340e99">Type::Sock_SeqPacket</a> socket may provide a sequenced, reliable, two-way connection-based data transmission path for datagrams of fixed maximum length; a consumer may be required to read an entire packet with each read system call. This facility is protocol specific, and presently unimplemented.</p>
<p><a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaadbce0ab5f7ffb036b16d28b8e258f720">Type::Sock_Raw</a> sockets provide access to internal network protocols and interfaces.</p>
<p>The types <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaadbce0ab5f7ffb036b16d28b8e258f720">Type::Sock_Raw</a>, which is available only to the super-user, is not described here.</p>
<p>Additionally, the following flag is allowed in the <em>type</em> argument:</p>
<table class="doxtable">
<tr>
<th>Flag </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaa6aa760fecb3b3f81a3c5ed0425f99762">Option::Sock_NonBlock</a> </td><td>Set non-blocking mode on the new socket </td></tr>
</table>
<p>The <em>protocol</em> argument specifies a particular protocol to be used with the socket. Normally only a single protocol exists to support a particular socket type within a given protocol family. However, it is possible that many protocols may exist, in which case a particular protocol must be specified in this manner. The <em>protocol</em> number to use is particular to the "communication domain" in which communication is to take place.</p>
<p>The <em>protocol</em> argument may be set to <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaa221076d68c5f73ca9d81b6dd6c2e18d4">Type::Sock_Default</a> to request the default implementation of a socket type for the protocol, if any.</p>
<p>Sockets of type <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaae703319723c99d2d3a7ba1ad0dc8f572">Type::Sock_Stream</a> are full-duplex byte streams, similar to pipes. A stream socket must be in a connected state before any data may be sent or received on it. A connection to another socket is created with a <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f">Connect()</a> system call. Once connected, data may be transferred using <a class="el" href="namespacenn_1_1socket.html#ae1fd34e9d084e5bb0f17a6c2361896c2">Read()</a> and <a class="el" href="namespacenn_1_1socket.html#ab2284c3d5e78619aecbd0b78d3947936">Write()</a> calls or some variant of the <a class="el" href="namespacenn_1_1socket.html#ae5a4c9f486b94e6b19e563ef97a2e412">Send()</a> and <a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14">Recv()</a> functions. (Some protocol families, such as the Internet family, support the notion of an "implied connect", which permits data to be sent piggybacked onto a connect operation by using the <a class="el" href="namespacenn_1_1socket.html#aacd6b8da24d25e5e4f299b833258826f">SendTo()</a> system call.) When a session has been completed a <a class="el" href="namespacenn_1_1socket.html#ae01110d228e2148d830b1ecfb9aaa425">Close()</a> may be performed. Out-of-band data may also be transmitted as described in <a class="el" href="namespacenn_1_1socket.html#ae5a4c9f486b94e6b19e563ef97a2e412">Send()</a> and received as described in <a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14">Recv()</a>.</p>
<p>The communications protocols used to implement a <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaae703319723c99d2d3a7ba1ad0dc8f572">Type::Sock_Stream</a> ensure that data is not lost or duplicated. If a piece of data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length of time, then the connection is considered broken and calls will indicate an error with -1 returns and with <a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeab8b3b473d7a87bc0787d270847504b62">Errno::ETimedOut</a> as the specific code in the global variable <em>errno</em>. The protocols optionally keep sockets "warm" by forcing transmissions roughly every minute in the absence of other activity. An error is then indicated if no response can be elicited on an otherwise idle connection for an extended period (e.g. 5 minutes).</p>
<p><a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaa3ee64579e9e60354dc99756954340e99">Type::Sock_SeqPacket</a> sockets employ the same system calls as <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaae703319723c99d2d3a7ba1ad0dc8f572">Type::Sock_Stream</a> sockets. The only difference is that <a class="el" href="namespacenn_1_1socket.html#ae1fd34e9d084e5bb0f17a6c2361896c2">Read()</a> calls will return only the amount of data requested, and any remaining in the arriving packet will be discarded.</p>
<p><a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaa4cc079142a1be58955eb22bed651ebba">Type::Sock_Dgram</a> and <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaadbce0ab5f7ffb036b16d28b8e258f720">Type::Sock_Raw</a> sockets allow sending of datagrams to correspondents named in <a class="el" href="namespacenn_1_1socket.html#ae5a4c9f486b94e6b19e563ef97a2e412">Send()</a> calls. Datagrams are generally received with <a class="el" href="namespacenn_1_1socket.html#adab268741c66f0996683c31b1bcd05dc">RecvFrom()</a>, which returns the next datagram with its return address.</p>
<p>The operation of sockets is controlled by socket level options with <a class="el" href="namespacenn_1_1socket.html#afaa7ccade3133a9884ab0b8e44ac18fc">SetSockOpt()</a> and <a class="el" href="namespacenn_1_1socket.html#a4aff7a563a6c808b236246a182996761">GetSockOpt()</a>.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a>, <a class="el" href="namespacenn_1_1socket.html#a09255737b952ba3ad3a647607fc2af0a" title="Assign a local protocol address to a socket. ">Bind()</a>, <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f" title="Initiate a connection on a socket. ">Connect()</a>, <a class="el" href="namespacenn_1_1socket.html#a97eb7ccadd9c3c1fb69f4a634a443003" title="Get name of connected peer. ">GetPeerName()</a>, <a class="el" href="namespacenn_1_1socket.html#adb89c6a0abfc8befcdc1ce05bf49e0ce" title="Get socket name. ">GetSockName()</a>, <a class="el" href="namespacenn_1_1socket.html#a4aff7a563a6c808b236246a182996761" title="Get socket options. ">GetSockOpt()</a>, <a class="el" href="namespacenn_1_1socket.html#a558dc819d133326891523fcaf32303f8" title="Control I/O device. ">Ioctl()</a>, <a class="el" href="namespacenn_1_1socket.html#ad6c2c6b2d1cd467bfdbfb4bf4057338b" title="Listen for connections on a socket. ">Listen()</a>, <a class="el" href="namespacenn_1_1socket.html#ae1fd34e9d084e5bb0f17a6c2361896c2" title="Read input. ">Read()</a>, <a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14" title="Receives a message from a connection-mode or connectionless-mode socket. ">Recv()</a>, <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select()</a>, <a class="el" href="namespacenn_1_1socket.html#a895595468f09d14293edd099a8ff7dc5" title="Disable sends and/or receives on a socket. ">Shutdown()</a>, <a class="el" href="namespacenn_1_1socket.html#ab2284c3d5e78619aecbd0b78d3947936" title="Write output. ">Write()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_access_point_8cpp-example.html#a80">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a75">LdnStation.cpp</a>, <a class="el" href="_libcurl_speed_test_8cpp-example.html#a17">LibcurlSpeedTest.cpp</a>, <a class="el" href="_socket_basic_8cpp-example.html#a6">SocketBasic.cpp</a>, <a class="el" href="_ssl_simple_8cpp-example.html#a19">SslSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab2284c3d5e78619aecbd0b78d3947936"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Write </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write output. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferLength</td><td>Length of the buffer to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the number of characters written, or -1 if an error occurred.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327">Errno::EBadf</a> </td><td>An invalid descriptor was specified. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea2ee283d2ea4a7035cf02f4401ad6e8c4">Errno::ENotSock</a> </td><td>The argument <em>socket</em> is not a socket. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aead50e4ce04c6d8fa3bcedc355c71e6908">Errno::EMsgSize</a> </td><td>The socket requires that message be sent atomically, and the size of the message to be sent made this impossible. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>The socket is marked non-blocking and the requested operation would block. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeac382e6a51872c6a43d968c2462a2d3be">Errno::EAcces</a> </td><td>The destination address is a broadcast address, and <a class="el" href="namespacenn_1_1socket.html#a9706518d71ec37371e9aa3ae9a2fa92ca71f2d3c1f2b815034748923c95b3c7c2">Option::So_Broadcast</a> has not been set on the socket. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea8c84e92e411b15ee2a52955b1a4c7f59">Errno::ENoBufs</a> </td><td>The system was unable to allocate an internal buffer. The operation may succeed when buffers become available. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea4d13a4e176134b1b99e47bc557803186">Errno::EHostUnreach</a> </td><td>The remote host was unreachable. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea7e42ca49cd604842cf40a55a6fb1da37">Errno::EIsConn</a> </td><td>A destination address was specified and the socket is already connected. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea06cb83b76f73aee6a739e690d8a615e0">Errno::EConnRefused</a> </td><td>The socket received an ICMP destination unreachable message from the last message sent. This typically means that the receiver is not listening on the remote port. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea03738213bb11b2d3c3d4296514be9544">Errno::EHostDown</a> </td><td>The remote host was down. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeae57b86c74a54b9dfc0a43f20885d531b">Errno::ENetDown</a> </td><td>The local network interface is down. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeae9e5813d133d21c50d5b9d2821b5c7d5">Errno::ENetUnreach</a> </td><td>The network is not reachable from this host. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeaf09952a7a43905596163dee3291e06f2">Errno::EPipe</a> </td><td>The socket is unable to send anymore data (SBS_CANTSENDMORE has been set on the socket). This typically means that the socket is not connected. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The <em>buffer</em> argument is null with non-zero <em>bufferLength</em> argument. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea3fdc41982aa0e73be04ddc708c157a7b">Errno::EFault</a> </td><td>The address range referred to by <em>buffer</em> and <em>bufferLength</em> does not refer to a valid part of the process address space. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#ab2284c3d5e78619aecbd0b78d3947936" title="Write output. ">Write()</a> routine attempts to write <em>bufferLength</em> bytes of data to the socket referenced by the descriptor <em>socket</em> from the buffer pointed to by <em>buffer</em>.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#ae5a4c9f486b94e6b19e563ef97a2e412" title="Send a message from a socket. ">Send()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae1fd34e9d084e5bb0f17a6c2361896c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Read </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outBufferLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read input. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outBuffer</td><td>Buffer for data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outBufferLength</td><td>Size of the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>If successful, the number of bytes actually read is returned. Upon reading end-of-file, zero is returned. A -1 is returned if an error occurred.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327">Errno::EBadf</a> </td><td>The argument <em>socket</em> is an invalid descriptor. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea35b0f4b6f7c078dbf75d488c08d644d7">Errno::EConnReset</a> </td><td>The remote socket end is forcibly closed. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeae57b86c74a54b9dfc0a43f20885d531b">Errno::ENetDown</a> </td><td>The network interface has been removed and the socket has been shut down. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea49ef25c2845d57c542b75ebf74c22d32">Errno::ENotConn</a> </td><td>The socket is associated with a connection-oriented protocol and has not been connected (see <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f">Connect()</a> and <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a>). </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea2ee283d2ea4a7035cf02f4401ad6e8c4">Errno::ENotSock</a> </td><td>The argument <em>socket</em> does not refer to a socket. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>The socket is marked non-blocking, and the receive operation would block. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>A receive timeout had been set, and the timeout expired before data was received. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The <em>outBuffer</em> argument is null with non-zero <em>outBufferLength</em> argument. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea3fdc41982aa0e73be04ddc708c157a7b">Errno::EFault</a> </td><td>The address range referred to by <em>outBuffer</em> and <em>outBufferLength</em> does not refer to a valid part of the process address space. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#ae1fd34e9d084e5bb0f17a6c2361896c2" title="Read input. ">Read()</a> routine attempts to read <em>outBufferLength</em> bytes of data from the object referenced by the descriptor <em>socket</em> into the buffer pointed to by <em>outBuffer</em>.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#ae1fd34e9d084e5bb0f17a6c2361896c2" title="Read input. ">Read()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae01110d228e2148d830b1ecfb9aaa425"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Close </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a descriptor. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the value 0 if successful; otherwise the value -1 is returned.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327">Errno::EBadf</a> </td><td>The <em>socket</em> argument is not an active descriptor. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea35b0f4b6f7c078dbf75d488c08d644d7">Errno::EConnReset</a> </td><td>The underlying object was a stream socket that was shut down by the peer before all pending data was delivered. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#ae01110d228e2148d830b1ecfb9aaa425" title="Delete a descriptor. ">Close()</a> routine deletes a descriptor from the per-process object reference table. The underlying object is deleted on the first close call. All subsequent calls to the same object from other processes/threads after the first close will return an error. This behavior deviates from POSIX standard.</p>
<p>When a process exists, all associated descriptors are freed and all objects created by that process are destroyed.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_access_point_8cpp-example.html#a91">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a87">LdnStation.cpp</a>, <a class="el" href="_libcurl_speed_test_8cpp-example.html#a28">LibcurlSpeedTest.cpp</a>, <a class="el" href="_socket_basic_8cpp-example.html#a30">SocketBasic.cpp</a>, <a class="el" href="_ssl_simple_8cpp-example.html#a42">SslSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad9e109d18fb43f275742d74d74d06cde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1socket_1_1_poll_fd.html">PollFd</a> *&#160;</td>
          <td class="paramname"><em>pSocketDescriptors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a8cb8a1b63cc61bb57fe8c8c58ef26591">NfdsT</a>&#160;</td>
          <td class="paramname"><em>numberOfDescriptors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeoutMilliseconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous I/O multiplexing. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pSocketDescriptors</td><td>Array of <a class="el" href="structnn_1_1socket_1_1_poll_fd.html">PollFd</a> structures </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numberOfDescriptors</td><td>Number of <a class="el" href="structnn_1_1socket_1_1_poll_fd.html">PollFd</a> structures </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMilliseconds</td><td>Timeout in milliseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Number of descriptors that are ready for I/O, or -1 if an error occurred. If the time limit expires, <a class="el" href="namespacenn_1_1socket.html#ad9e109d18fb43f275742d74d74d06cde" title="Synchronous I/O multiplexing. ">Poll()</a> returns 0. If <a class="el" href="namespacenn_1_1socket.html#ad9e109d18fb43f275742d74d74d06cde" title="Synchronous I/O multiplexing. ">Poll()</a> returns with an error, file descriptor array will be unmodified.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The specified time limit is invalid. One of its components is negative or too large. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The <em>pSocketDescriptors</em> argument is null with non-zero <em>outBufferLength</em> argument. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea3fdc41982aa0e73be04ddc708c157a7b">Errno::EFault</a> </td><td>The address range referred to by <em>pSocketDescriptors</em> and <em>numberOfDescriptors</em> * sizeof(<a class="el" href="structnn_1_1socket_1_1_poll_fd.html">PollFd</a>) does not refer to a valid part of the process address space. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#ad9e109d18fb43f275742d74d74d06cde" title="Synchronous I/O multiplexing. ">Poll()</a> system call examines a set of file descriptors to see if some of them are ready for I/O. The <em>pSocketDescriptors</em> argument is a pointer to an array of <a class="el" href="structnn_1_1socket_1_1_poll_fd.html">PollFd</a> structures). The <em>numberOfDescriptors</em> argument determines the size of the array.</p>
<p>The event bitmasks in events and revents have the following bits:</p>
<table class="doxtable">
<tr>
<th>Event </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9a1b0bed7d85ba6b2cbe91629776e3ee6d">PollEvent::PollIn</a> </td><td>Data other than high priority data may be read without blocking. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9aaf909a6e6a64bebd393ae9fbc33f200a">PollEvent::PollRdNorm</a> </td><td>Normal data may be read without blocking. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9a9b8ce4bb4c25d8b2abc5e5648c9cd54a">PollEvent::PollRdBand</a> </td><td>Data with a non-zero priority may be read without blocking. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9a1034fc649394d42b19fead1ab1828e54">PollEvent::PollPri</a> </td><td>High priority data may be read without blocking. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9aca8de23660319dc20822f6e6059a727b">PollEvent::PollOut</a> </td><td>Normal data may be written without blocking. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9af5abb7d0050a44e425556082ae71b547">PollEvent::PollWrNorm</a> </td><td>Normal data may be written without blocking. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9a70417b0dc75887023e5fa42ca645d4c9">PollEvent::PollWrBand</a> </td><td>Data with a non-zero priority may be written without blocking. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9a6aee635278505dd8cc1da7f50c4a651d">PollEvent::PollErr</a> </td><td>An exceptional condition has occurred on the device or socket. This flag is always checked, even if not present in the events bitmask. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9a2421093408548ab23a7a93500e8cccd3">PollEvent::PollHup</a> </td><td>The device or socket has been disconnected. This flag is always checked, even if not present in the events bitmask. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9aecf0948bef1a1db017a0d4e714f05c04">PollEvent::PollNVal</a> </td><td>The file descriptor is not open. This flag is always checked, even if not present in the events bitmask. </td></tr>
</table>
<p>Note that <a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9a2421093408548ab23a7a93500e8cccd3">PollEvent::PollHup</a> and <a class="el" href="namespacenn_1_1socket.html#a2b8c53cba8a2be170c93a76742b092c9aca8de23660319dc20822f6e6059a727b">PollEvent::PollOut</a> should never be present in the revents bitmask at the same time.</p>
<p>If <em>timeout</em> is neither zero nor <a class="el" href="namespacenn_1_1socket.html#ac63165d8f4ab675489cda23034aa9eeb">nn::socket::InfTim</a> (-1), it specifies a maximum interval to wait for any file descriptor to become ready, in milliseconds. If <em>timeout</em> is <a class="el" href="namespacenn_1_1socket.html#ac63165d8f4ab675489cda23034aa9eeb">nn::socket::InfTim</a> (-1), the poll blocks indefinitely. If <em>timeout</em> is zero, then <a class="el" href="namespacenn_1_1socket.html#ad9e109d18fb43f275742d74d74d06cde" title="Synchronous I/O multiplexing. ">Poll()</a> will return without blocking.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a92cb62635aca20860e3ab848f347ec6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Fcntl </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#ae03bdb6384cac8b1ba7617743144d09f">FcntlCommand</a>&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>File control. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">command</td><td>Control command</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the value 0 if successful; otherwise the value -1 is returned.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327">Errno::EBadf</a> </td><td>The argument <em>socket</em> is not a valid descriptor. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea2ee283d2ea4a7035cf02f4401ad6e8c4">Errno::ENotSock</a> </td><td>The argument <em>socket</em> does not refer to a socket. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeac2dd8a9d9020d692236fe36e327a0790">Errno::EOpNotSupp</a> </td><td>Command is not supported </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a92cb62635aca20860e3ab848f347ec6f" title="File control. ">Fcntl()</a> routine provides control over descriptors. The argument <em>socket</em> is a descriptor to be operated on by <em>command</em> as described below. Depending on the value of command, <a class="el" href="namespacenn_1_1socket.html#a92cb62635aca20860e3ab848f347ec6f" title="File control. ">Fcntl()</a> can take additional arguments.</p>
<p>Supported commands:</p>
<p><a class="el" href="namespacenn_1_1socket.html#ae03bdb6384cac8b1ba7617743144d09fa02772fa35d3b587e7642cbf50c753d08">nn::socket::FcntlCommand::F_GetFl</a> Get descriptor status flags. Additional arguments are ignored.</p>
<p>The descriptor flags for the <a class="el" href="namespacenn_1_1socket.html#ae03bdb6384cac8b1ba7617743144d09fa02772fa35d3b587e7642cbf50c753d08">nn::socket::FcntlCommand::F_GetFl</a> command are returned from fcntl. Flags that are supported to be modified are documented in the <a class="el" href="namespacenn_1_1socket.html#ae03bdb6384cac8b1ba7617743144d09fada2f7613aac1b87c8679a7b8c03ac9ca">nn::socket::FcntlCommand::F_SetFl</a> command below.</p>
<p><a class="el" href="namespacenn_1_1socket.html#ae03bdb6384cac8b1ba7617743144d09fada2f7613aac1b87c8679a7b8c03ac9ca">nn::socket::FcntlCommand::F_SetFl</a> Set descriptor status flags. Takes an additional argument - 'flags'</p>
<p>The flags for the <a class="el" href="namespacenn_1_1socket.html#ae03bdb6384cac8b1ba7617743144d09fada2f7613aac1b87c8679a7b8c03ac9ca">nn::socket::FcntlCommand::F_SetFl</a> flags are as follows:</p>
<p><a class="el" href="namespacenn_1_1socket.html#aa04c2b32bf6fe54bdbb1a3f5febdc477a5693df4e99113d8216f084412a7a3849">nn::socket::FcntlFlag::O_NonBlock</a> Non-blocking I/O; if no data is available to a <a class="el" href="namespacenn_1_1socket.html#ae1fd34e9d084e5bb0f17a6c2361896c2">Read</a> system call, or if a <a class="el" href="namespacenn_1_1socket.html#ab2284c3d5e78619aecbd0b78d3947936">Write</a> operation would block, the read or write call returns -1 with the error <a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a>.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa523b16a6004b8748cc0116f9ed65dd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Select </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberOfDescriptors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1socket_1_1_fd_set.html">FdSet</a> *&#160;</td>
          <td class="paramname"><em>pReadDescriptors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1socket_1_1_fd_set.html">FdSet</a> *&#160;</td>
          <td class="paramname"><em>pWriteDescriptors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1socket_1_1_fd_set.html">FdSet</a> *&#160;</td>
          <td class="paramname"><em>pExceptDescriptors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1socket_1_1_time_val.html">TimeVal</a> *&#160;</td>
          <td class="paramname"><em>pTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous I/O multiplexing. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numberOfDescriptors</td><td>Highest descriptor id plus 1 </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pReadDescriptors</td><td>Read descriptor <a class="el" href="structnn_1_1socket_1_1_fd_set.html">FdSet</a> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pWriteDescriptors</td><td>Write descriptor <a class="el" href="structnn_1_1socket_1_1_fd_set.html">FdSet</a> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pExceptDescriptors</td><td>Exception descriptor <a class="el" href="structnn_1_1socket_1_1_fd_set.html">FdSet</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pTimeout</td><td>Timeout</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the number of ready descriptors that are contained in the descriptor sets, or -1 if an error occurred. If the time limit expires, <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select()</a> returns 0. If <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select()</a> returns with an error, the descriptor sets will be unmodified.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327">Errno::EBadf</a> </td><td>One of the descriptor sets specified an invalid descriptor. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The specified time limit is invalid. One of its components is negative or too large. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The <em>numberOfDescriptors</em> argument was invalid. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea3fdc41982aa0e73be04ddc708c157a7b">Errno::EFault</a> </td><td>One of the arguments <em>pReadDescriptors</em>, <em>pWriteDescriptors</em>, <em>pExceptDescriptors</em>, or <em>pTimeout</em> points to an invalid address. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select()</a> routine examines the I/O descriptor sets whose addresses are passed in <em>pReadDescriptors</em>, <em>pWriteDescriptors</em>, and <em>pExceptDescriptors</em> to see if some of their descriptors are ready for reading, are ready for writing, or have an exceptional condition pending, respectively. The only exceptional condition detectable is out-of-band data received on a socket. The first <em>numberOfDescriptors</em> descriptors are checked in each set; i.e., the descriptors from 0 through <em>numberOfDescriptors-1</em> in the descriptor sets are examined. On return, <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select()</a> replaces the given descriptor sets with subsets consisting of those descriptors that are ready for the requested operation. The <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select()</a> system call returns the total number of ready descriptors in all the sets.</p>
<p>The descriptor sets are stored as bit fields in arrays of integers. The following macros are provided for manipulating such descriptor sets: <a class="el" href="namespacenn_1_1socket.html#aa62380fb58406f3d7e83ea25c6deab35">FdSetZero()</a> initializes a descriptor set fdset to the null set. <a class="el" href="namespacenn_1_1socket.html#a1ea80c65c3a931a374bf2f0aab5153d1">FdSetSet()</a> includes a particular descriptor <em>fd</em> in fdset. <a class="el" href="namespacenn_1_1socket.html#a6ea3461fc5a67e39a6f8b6bb71a163b9">FdSetClr()</a> removes <em>fd</em> from fdset. <a class="el" href="namespacenn_1_1socket.html#a8f66b219c3bb6d59b09f26ee75348f82">FdSetIsSet()</a> is non- zero if <em>fd</em> is a member of fdset, zero otherwise. The behavior of these functions is undefined if a descriptor value is less than zero or greater than or equal to <a class="el" href="namespacenn_1_1socket.html#ae53bcecd4a9fee23b4d042448b0136e4">FdSetSize</a>, which is normally at least equal to the maximum number of descriptors supported by the system.</p>
<p>If <em>timeout</em> is not a null pointer, it specifies the maximum interval to wait for the selection to complete. System activity can lengthen the interval by an indeterminate amount.</p>
<p>If <em>timeout</em> is a null pointer, the select blocks indefinitely.</p>
<p>To effect a poll, the timeout argument should not be a null pointer, but it should point to a zero-valued <a class="el" href="structnn_1_1socket_1_1_time_val.html">TimeVal</a> structure.</p>
<p>Any of descriptor sets may be given as null pointers if no descriptors are of interest.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a>, <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f" title="Initiate a connection on a socket. ">Connect()</a>, <a class="el" href="namespacenn_1_1socket.html#ad9e109d18fb43f275742d74d74d06cde" title="Synchronous I/O multiplexing. ">Poll()</a>, <a class="el" href="namespacenn_1_1socket.html#ae1fd34e9d084e5bb0f17a6c2361896c2" title="Read input. ">Read()</a>, <a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14" title="Receives a message from a connection-mode or connectionless-mode socket. ">Recv()</a>, <a class="el" href="namespacenn_1_1socket.html#ae5a4c9f486b94e6b19e563ef97a2e412" title="Send a message from a socket. ">Send()</a>, <a class="el" href="namespacenn_1_1socket.html#ab2284c3d5e78619aecbd0b78d3947936" title="Write output. ">Write()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a>, Fd_Zero(), Fd_Set(), Fd_Clr(), Fd_IsSet() </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_libcurl_speed_test_8cpp-example.html#a36">LibcurlSpeedTest.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa62380fb58406f3d7e83ea25c6deab35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::socket::FdSetZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1socket_1_1_fd_set.html">FdSet</a> *&#160;</td>
          <td class="paramname"><em>pFdset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a descriptor set <em>s</em> to the null set. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pFdset</td><td>Descriptor set to be initialized to the null set.</td></tr>
  </table>
  </dd>
</dl>
<p><b>詳細</b> <br />
 Initializes a descriptor set <em>s</em> to the null set.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_libcurl_speed_test_8cpp-example.html#a33">LibcurlSpeedTest.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1ea80c65c3a931a374bf2f0aab5153d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long nn::socket::FdSetSet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1socket_1_1_fd_set.html">FdSet</a> *&#160;</td>
          <td class="paramname"><em>pFdset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Includes a particular descriptor <em>fd</em> in <em>fdset</em>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>Descriptor which should be included. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pFdset</td><td>Set which descriptor should be included in.</td></tr>
  </table>
  </dd>
</dl>
<p><b>詳細</b> <br />
 Includes a particular descriptor <em>fd</em> in <em>pFdset</em>. The behavior of this function is undefined if a descriptor value is less than zero or greater than or equal to <a class="el" href="namespacenn_1_1socket.html#ae53bcecd4a9fee23b4d042448b0136e4">FdSetSize</a>, which is normally at least equal to the maximum number of descriptors supported by the system.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6ea3461fc5a67e39a6f8b6bb71a163b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::socket::FdSetClr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1socket_1_1_fd_set.html">FdSet</a> *&#160;</td>
          <td class="paramname"><em>pFdset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes <em>fd</em> from <em>fdset</em>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>Descriptor which should be removed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pFdset</td><td>Set which descriptor should be removed from.</td></tr>
  </table>
  </dd>
</dl>
<p><b>詳細</b> <br />
 Removes <em>fd</em> from <em>pFdset</em>. The behavior of this function is undefined if a descriptor value is less than zero or greater than or equal to <a class="el" href="namespacenn_1_1socket.html#ae53bcecd4a9fee23b4d042448b0136e4">FdSetSize</a>, which is normally at least equal to the maximum number of descriptors supported by the system.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8f66b219c3bb6d59b09f26ee75348f82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::socket::FdSetIsSet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1socket_1_1_fd_set.html">FdSet</a> *&#160;</td>
          <td class="paramname"><em>pFdset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-zero if <em>fd</em> is a member of <em>pFdset</em>, zero otherwise. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>Descriptor which should be included. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFdset</td><td>Set which descriptor should be checked for set state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Non-zero if <em>fd</em> is a member of <em>pFdset</em>, zero otherwise.</dd></dl>
<p><b>詳細</b> <br />
 Returns non-zero if <em>fd</em> is a member of <em>pFdset</em>, zero otherwise. The behavior of this function is undefined if a descriptor value is less than zero or greater than or equal to <a class="el" href="namespacenn_1_1socket.html#ae53bcecd4a9fee23b4d042448b0136e4">FdSetSize</a>, which is normally at least equal to the maximum number of descriptors supported by the system.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a558dc819d133326891523fcaf32303f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Ioctl </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a047cb0e8a33ab75269a940a59ac7f62a">IoctlCommand</a>&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control I/O device. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>File descriptor for socket or device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">command</td><td>Device control command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pData</td><td>Buffer containing command data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataLength</td><td>Size of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns result of the ioctl operation. If an error has occurred, a value of -1 is returned.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd></dl>
<table class="doxtable">
<tr>
<th>Error </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea53272de64d582812159315d6265f6327">Errno::EBadf</a> </td><td>The <em>fd</em> argument is not a valid descriptor. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea7259324ba5d862aaba5087583e8404a3">Errno::ENotTy</a> </td><td>The specified request does not apply to the kind of object that the descriptor fd references. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea7259324ba5d862aaba5087583e8404a3">Errno::ENotTy</a> </td><td>The specified request does not apply to the kind of object that the descriptor fd references. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a> </td><td>The request or <em>pData</em> argument is not valid. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeac382e6a51872c6a43d968c2462a2d3be">Errno::EAcces</a> </td><td>Command is not allowed. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aea54cafc2ec81f6d1fe8ba661ade3931cb">Errno::EAgain</a> </td><td>Resources to complete the request are temporarily unavailable. </td></tr>
</table>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a558dc819d133326891523fcaf32303f8" title="Control I/O device. ">Ioctl()</a> routine manipulates the underlying device parameters of special files. The argument <em>fd</em> must be an open file descriptor obtained with either <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a>.</p>
<p>The following Ioctl commands are supported:</p>
<table class="doxtable">
<tr>
<th>Command </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a047cb0e8a33ab75269a940a59ac7f62aa84615c987f017ddb39fcd935e4745258">nn::socket::IoctlCommand::FionRead</a> </td><td>Get the number of bytes that are immediately available for reading. For this command, <em>pData</em> should be a pointer to an int. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a047cb0e8a33ab75269a940a59ac7f62aa316efa79f1d14b40adaa703d8483610b">nn::socket::IoctlCommand::FionWrite</a> </td><td>Get the number of bytes in the descriptor's send queue. These bytes are data which has been written to the descriptor but which are being held by the kernel for further processing. The nature of the required processing depends on the underlying device. For TCP sockets, these bytes have not yet been acknowledged by the other side of the connection. For this command, <em>pData</em> should be a pointer to an int. This command is not supported on Windows builds. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a047cb0e8a33ab75269a940a59ac7f62aad4c0438bde575cc3318c3ca43dee2192">nn::socket::IoctlCommand::FionSpace</a> </td><td>Get the free space in the descriptor's send queue. This value is the size of the send queue minus the number of bytes being held in the queue. Note: while this value represents the number of bytes that may be added to the queue, other resource limitations may cause a write not larger than the send queue's space to be blocked. One such limitation would be a lack of network buffers for a write to a network connection. For this command, <em>pData</em> should be a pointer to an int. This command is not supported on Windows builds. </td></tr>
</table>
<p>Please note that <a class="el" href="namespacenn_1_1socket.html#a047cb0e8a33ab75269a940a59ac7f62aa316efa79f1d14b40adaa703d8483610b">nn::socket::IoctlCommand::FionWrite</a> and <a class="el" href="namespacenn_1_1socket.html#a047cb0e8a33ab75269a940a59ac7f62aad4c0438bde575cc3318c3ca43dee2192">nn::socket::IoctlCommand::FionSpace</a> are not supported in Windows builds. In the case that these commands are used for Windows builds, this function will return -1 and the global variable errno will be set to <a class="el" href="namespacenn_1_1socket.html#ad1ade4838b158c7aaf9c9a78338e06aeadd96cfedd831334afedda59f7937c41f">Errno::EInval</a>.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad0a68baef0699e3e0063d3b686176b4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1socket.html#a7d8c1d2e11d6bdbdd12c05bc4505e96e">HErrno</a>* nn::socket::GetHError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return pointer to host errno (<em>h_errno</em>) for <a class="el" href="namespacenn_1_1socket.html#a358030926e9e63c2e322de2bd3d26719">GetHostEntByName()</a> and <a class="el" href="namespacenn_1_1socket.html#aaace32e2780295ca03bc72efa4b49406">GetHostEntByAddr()</a>. </p>
<dl class="section return"><dt>戻り値</dt><dd>Returns pointer to host errno (<em>h_errno</em>) for <a class="el" href="namespacenn_1_1socket.html#a358030926e9e63c2e322de2bd3d26719">GetHostEntByName()</a> and <a class="el" href="namespacenn_1_1socket.html#aaace32e2780295ca03bc72efa4b49406">GetHostEntByAddr()</a>.</dd></dl>
<p><b>詳細</b> <br />
 This function is used only to determine error conditions, it is also thread-localized.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a358030926e9e63c2e322de2bd3d26719" title="Look up Family::Af_Inet host IP address by hostname. ">GetHostEntByName()</a>, <a class="el" href="namespacenn_1_1socket.html#aaace32e2780295ca03bc72efa4b49406" title="Look up the address value for a host for Family::Af_Inet. ">GetHostEntByAddr()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_socket_resolver_8cpp-example.html#a13">SocketResolver.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a358030926e9e63c2e322de2bd3d26719"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1socket_1_1_host_ent.html">HostEnt</a>* nn::socket::GetHostEntByName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up <a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205daa4d833d8c15a76105639ddd11bcb614e">Family::Af_Inet</a> host IP address by hostname. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pName</td><td>The name of the host to look up (e.g. www.nintendo.com).</td></tr>
  </table>
  </dd>
</dl>
<p><b>詳細</b> <br />
 The return value of this function is thread-localized, this deviates from some POSIX implementations. The return value is managed internally, so if you wish to keep the value between calls, a deep copy must be performed.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#ad0a68baef0699e3e0063d3b686176b4c" title="Return pointer to host errno (h_errno) for GetHostEntByName() and GetHostEntByAddr(). ">GetHError()</a>, <a class="el" href="namespacenn_1_1socket.html#aba34614a3ddfe25e5bf3e5a77613832e" title="Return a human-readable version of h_error / GetHError(). ">HStrError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_libcurl_speed_test_8cpp-example.html#a14">LibcurlSpeedTest.cpp</a>, <a class="el" href="_socket_resolver_8cpp-example.html#a12">SocketResolver.cpp</a>, <a class="el" href="_ssl_simple_8cpp-example.html#a24">SslSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aaace32e2780295ca03bc72efa4b49406"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1socket_1_1_host_ent.html">HostEnt</a>* nn::socket::GetHostEntByAddr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205d">Family</a>&#160;</td>
          <td class="paramname"><em>addressFamily</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up the address value for a host for <a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205daa4d833d8c15a76105639ddd11bcb614e">Family::Af_Inet</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAddress</td><td>This value shall be pointer to an <a class="el" href="structnn_1_1socket_1_1_in_addr.html">InAddr</a> structure that contains a binary address in network byte order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The size of the structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addressFamily</td><td>Currently only <a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205daa4d833d8c15a76105639ddd11bcb614e">Family::Af_Inet</a> is supported</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns a pointer to a <a class="el" href="structnn_1_1socket_1_1_host_ent.html">HostEnt</a> structure or NULL on error with error detail in <a class="el" href="namespacenn_1_1socket.html#ad0a68baef0699e3e0063d3b686176b4c">GetHError()</a>.</dd></dl>
<p><b>詳細</b> <br />
 The return value of this function is thread-localized, which deviates from some POSIX implementations. The return value is managed internally, so if you wish to keep the value between calls, a deep copy must be performed.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#ad0a68baef0699e3e0063d3b686176b4c" title="Return pointer to host errno (h_errno) for GetHostEntByName() and GetHostEntByAddr(). ">GetHError()</a>, <a class="el" href="namespacenn_1_1socket.html#aba34614a3ddfe25e5bf3e5a77613832e" title="Return a human-readable version of h_error / GetHError(). ">HStrError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_socket_resolver_8cpp-example.html#a17">SocketResolver.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aba34614a3ddfe25e5bf3e5a77613832e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::socket::HStrError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a7d8c1d2e11d6bdbdd12c05bc4505e96e">HErrno</a>&#160;</td>
          <td class="paramname"><em>errorNumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a human-readable version of h_error / <a class="el" href="namespacenn_1_1socket.html#ad0a68baef0699e3e0063d3b686176b4c">GetHError()</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">errorNumber</td><td>The h_errno.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns a string representing the error number or NULL if out-of-memory.</dd></dl>
<p><b>詳細</b> <br />
 The return value of this function is thread-localized, this deviates from some POSIX implementations. The return value is managed internally, so if you wish to maintain the value between calls, a copy must be made.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#ad0a68baef0699e3e0063d3b686176b4c" title="Return pointer to host errno (h_errno) for GetHostEntByName() and GetHostEntByAddr(). ">GetHError()</a>, <a class="el" href="namespacenn_1_1socket.html#a358030926e9e63c2e322de2bd3d26719" title="Look up Family::Af_Inet host IP address by hostname. ">GetHostEntByName()</a>, <a class="el" href="namespacenn_1_1socket.html#aaace32e2780295ca03bc72efa4b49406" title="Look up the address value for a host for Family::Af_Inet. ">GetHostEntByAddr()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_socket_resolver_8cpp-example.html#a14">SocketResolver.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aba7c9ca6a33baa3c3216c2de2c320f60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952a">AiErrno</a> nn::socket::GetAddrInfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pNodeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pServername</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1socket_1_1_addr_info.html">AddrInfo</a> *&#160;</td>
          <td class="paramname"><em>pHints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1socket_1_1_addr_info.html">AddrInfo</a> **&#160;</td>
          <td class="paramname"><em>pResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of IP addresses and port numbers. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pNodeName</td><td>The name of the host or NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pServername</td><td>The name of the service or NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pHints</td><td>An optional pointer to an <a class="el" href="structnn_1_1socket_1_1_addr_info.html">AddrInfo</a> structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pResult</td><td>An out parameter containing 0, 1, or many (via <em>ai_next</em>) <a class="el" href="structnn_1_1socket_1_1_addr_info.html">AddrInfo</a> structures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns <a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952aa063e46c2edc044d4eb15ff1881c61617">AiErrno::EAi_Success</a> on success or one of the error codes listed in <a class="el" href="namespacenn_1_1socket.html#a790112f00a11cf992ba2e04795c9590f">GAIStrError()</a> if an error occurs.</dd></dl>
<p><b>詳細</b> <br />
 <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60" title="Get a list of IP addresses and port numbers. ">GetAddrInfo()</a> routine can be used to obtain list of IP addresses and port numbers for host <em>pNodename</em> and service <em>pServername</em>. It provides more flexibility than <a class="el" href="namespacenn_1_1socket.html#a358030926e9e63c2e322de2bd3d26719">GetHostEntByName()</a>.</p>
<p>Please note that <em>pNodename</em> and <em>pServername</em> cannot both be NULL at the same time.</p>
<p>The <a class="el" href="structnn_1_1socket_1_1_addr_info.html">AddrInfo</a> result <em>pResult</em> returned by this function can be deallocated via <a class="el" href="namespacenn_1_1socket.html#a243828270d581fb029a86292031a30cf">FreeAddrInfo()</a>.</p>
<p>The optional <em>pHints</em> can be used to provide hints concerning the type of socket that the caller supports or wishes to use. The caller can supply the following structure elements in <em>pHints:</em> </p>
<table class="doxtable">
<tr>
<th>Element </th><th>Description  </th></tr>
<tr>
<td><em>ai_family</em>  </td><td>The protocol family that should be used. When <em>ai_family</em> is set to <a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205daf71f2e4ba3e999c5a27fdd7ad7044628">Family::Af_Unspec</a>, it means the caller will accept any protocol family supported by the operating system.   </td></tr>
<tr>
<td><em>ai_socktype</em>  </td><td>Denotes the type of socket that is wanted: <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaae703319723c99d2d3a7ba1ad0dc8f572">Type::Sock_Stream</a>, <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaa4cc079142a1be58955eb22bed651ebba">Type::Sock_Dgram</a>, or <a class="el" href="namespacenn_1_1socket.html#a1db675083dcccec6500d1435c5dfeaeaadbce0ab5f7ffb036b16d28b8e258f720">Type::Sock_Raw</a>. When <em>ai_socktype</em> is zero the caller will accept any socket type.   </td></tr>
<tr>
<td><em>ai_protocol</em>  </td><td>Indicates which transport protocol is desired, <a class="el" href="namespacenn_1_1socket.html#a46347de69614965469ac8f3c8056468ea48e0b0b8eaaf71a2c2c0ebfa0e802b1a">Protocol::IpProto_Udp</a> or <a class="el" href="namespacenn_1_1socket.html#a46347de69614965469ac8f3c8056468eaf07a075529789e7d91eefbce84c55d90">Protocol::IpProto_Tcp</a>. If <em>ai_protocol</em> is zero the caller will accept any protocol.  </td></tr>
<tr>
<td><em>ai_flags</em>  </td><td>The <em>ai_flags</em> field to which the hints parameter points shall be set to zero or be the bitwise-inclusive OR of one or more of the values: <table class="doxtable">
<tr>
<th>Flag </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736adc37ac841acdd2d44f66639c607345d2">AddrInfoFlag::Ai_AddrConfig</a> </td><td>If the <a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736adc37ac841acdd2d44f66639c607345d2">AddrInfoFlag::Ai_AddrConfig</a> bit is set, IPv4 addresses shall be returned only if an IPv4 address is configured on the local system, and IPv6 addresses shall be returned only if an IPv6 address is configured on the local system.   </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736a1a2e6d6759bb114a41af8185090c58e3">AddrInfoFlag::Ai_CanonName</a> </td><td>If the <a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736a1a2e6d6759bb114a41af8185090c58e3">AddrInfoFlag::Ai_CanonName</a> bit is set, a successful call to <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60">GetAddrInfo()</a> will return a NULL-terminated string containing the canonical name of the specified hostname in the <em>ai_canonname</em> element of the first <a class="el" href="structnn_1_1socket_1_1_addr_info.html">AddrInfo</a> structure returned.   </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736a4e9c7347da15e21e33637e92a8c5357a">AddrInfoFlag::Ai_NumericHost</a> </td><td>If the <a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736a4e9c7347da15e21e33637e92a8c5357a">AddrInfoFlag::Ai_NumericHost</a> bit is set, it indicates that hostname should be treated as a numeric string defining an IPv4 or IPv6 address and resolution should be attempted.   </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736a25bb67f3036a24405c49021582b87048">AddrInfoFlag::Ai_NumericServ</a> </td><td>If the <a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736a25bb67f3036a24405c49021582b87048">AddrInfoFlag::Ai_NumericServ</a> bit is set, then a non-NULL servname string supplied shall be a numeric port string. Otherwise, an <a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952aa49ba37cc879f6a8bd0ed14ca7dd7b900">AiErrno::EAi_NoName</a> error shall be returned. This bit shall prevent any type of name resolution service (for example, NIS+) from being invoked.   </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736a07f3aa8bca15327f9ff738676c87a17b">AddrInfoFlag::Ai_Passive</a> </td><td>If the <a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736a07f3aa8bca15327f9ff738676c87a17b">AddrInfoFlag::Ai_Passive</a> bit is set it indicates that the returned socket address structure is intended for use in a call to <a class="el" href="namespacenn_1_1socket.html#a09255737b952ba3ad3a647607fc2af0a">Bind()</a>. In this case, if the hostname argument is the null pointer, then the IP address portion of the socket address structure will be set to <a class="el" href="namespacenn_1_1socket.html#a0bc37587294a2f6b385cf080b6fafa40">InAddr_Any</a> for an IPv4 address. If the <a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736a07f3aa8bca15327f9ff738676c87a17b">AddrInfoFlag::Ai_Passive</a> bit is not set, the returned socket address structure will be ready for use in a call to <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f">Connect()</a> for a connection-oriented protocol or <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f">Connect()</a> or <a class="el" href="namespacenn_1_1socket.html#aacd6b8da24d25e5e4f299b833258826f">SendTo()</a> if a connectionless protocol was chosen. The IP address portion of the socket address structure will be set to the loopback address if hostname is the null pointer and <a class="el" href="namespacenn_1_1socket.html#a2c63ce69dddbb1c78d89626f2c43e736a07f3aa8bca15327f9ff738676c87a17b">AddrInfoFlag::Ai_Passive</a> is not set.   </td></tr>
</table>
</td></tr>
</table>
<p>All other elements of the <a class="el" href="structnn_1_1socket_1_1_addr_info.html">AddrInfo</a> structure passed via <em>pHints</em> must be zero or the null pointer.</p>
<p>If <em>pHints</em> is the null pointer, <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60" title="Get a list of IP addresses and port numbers. ">GetAddrInfo()</a> behaves as if the caller provided an <a class="el" href="structnn_1_1socket_1_1_addr_info.html">AddrInfo</a> structure with <em>ai_family</em> set to <a class="el" href="namespacenn_1_1socket.html#a057d985148e23267303e6d00d7ed205daf71f2e4ba3e999c5a27fdd7ad7044628">Family::Af_Unspec</a> and all other elements set to zero or NULL.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a243828270d581fb029a86292031a30cf" title="Free the address info structure. ">FreeAddrInfo()</a>, <a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3" title="Convert a SockAddr structure to a pair of host name and service strings. ">GetNameInfo()</a>, <a class="el" href="namespacenn_1_1socket.html#a790112f00a11cf992ba2e04795c9590f" title="Return a human-readable version of the return value from GetAddrInfo() or GetNameInfo(). ">GAIStrError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_socket_resolver_8cpp-example.html#a22">SocketResolver.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a243828270d581fb029a86292031a30cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::socket::FreeAddrInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1socket_1_1_addr_info.html">AddrInfo</a> *&#160;</td>
          <td class="paramname"><em>addrInfoStorage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the address info structure. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addrInfoStorage</td><td>Pointer to an <a class="el" href="structnn_1_1socket_1_1_addr_info.html">AddrInfo</a> structure that was returned by <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60">GetAddrInfo()</a> or <a class="el" href="namespacenn_1_1socket.html#a243828270d581fb029a86292031a30cf">FreeAddrInfo()</a></td></tr>
  </table>
  </dd>
</dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a243828270d581fb029a86292031a30cf" title="Free the address info structure. ">FreeAddrInfo()</a> routine can be used to free structured returned by <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60">GetAddrInfo()</a> / <a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3">GetNameInfo()</a>.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3" title="Convert a SockAddr structure to a pair of host name and service strings. ">GetNameInfo()</a>, <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60" title="Get a list of IP addresses and port numbers. ">GetAddrInfo()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_socket_resolver_8cpp-example.html#a24">SocketResolver.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a790112f00a11cf992ba2e04795c9590f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::socket::GAIStrError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952a">AiErrno</a>&#160;</td>
          <td class="paramname"><em>errorCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a human-readable version of the return value from <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60">GetAddrInfo()</a> or <a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3">GetNameInfo()</a>. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">errorCode</td><td>Error code for translation to human readable format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns a c-string human readable representation of the error code provided.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a790112f00a11cf992ba2e04795c9590f" title="Return a human-readable version of the return value from GetAddrInfo() or GetNameInfo(). ">GAIStrError()</a> routine is used to obtain human readable version of the return value from <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60">GetAddrInfo()</a> and <a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3">GetNameInfo()</a>. The return value of this function is thread-localized, which deviates from some POSIX implementations. The return value is managed internally, so if you wish to maintain the value between calls a copy must be made.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3" title="Convert a SockAddr structure to a pair of host name and service strings. ">GetNameInfo()</a>, <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60" title="Get a list of IP addresses and port numbers. ">GetAddrInfo()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_socket_resolver_8cpp-example.html#a23">SocketResolver.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a27ecfbc5167401b34339e6a5085686b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952a">AiErrno</a> nn::socket::GetNameInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> *&#160;</td>
          <td class="paramname"><em>socketAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#a0da164bafc83a64e6a51068805e5df52">SockLenT</a>&#160;</td>
          <td class="paramname"><em>socketAddressLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hostLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>serviceLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1socket.html#ab65d6a3635e193943fa4f95edfbebeae">NameInfoFlag</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> structure to a pair of host name and service strings. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socketAddress</td><td>The <a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> structure socketAddress should point to a <a class="el" href="structnn_1_1socket_1_1_sock_addr_in.html">SockAddrIn</a> that is socketAddressLength bytes long. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">socketAddressLength</td><td>The size of the socckaddr structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">host</td><td>The hostname buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hostLength</td><td>The length of the hostname buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">service</td><td>The service name buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">serviceLength</td><td>The length of the service name buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns <a class="el" href="namespacenn_1_1socket.html#af622578590c2fb499d0c41023de4952aa063e46c2edc044d4eb15ff1881c61617">AiErrno::EAi_Success</a> on success or one of the error codes listed in <a class="el" href="namespacenn_1_1socket.html#a790112f00a11cf992ba2e04795c9590f">GAIStrError()</a> if an error occurs.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3" title="Convert a SockAddr structure to a pair of host name and service strings. ">GetNameInfo()</a> function is used to convert a <a class="el" href="structnn_1_1socket_1_1_sock_addr.html">SockAddr</a> structure to a pair of host name and service strings. It provides more flexibility than <a class="el" href="namespacenn_1_1socket.html#aaace32e2780295ca03bc72efa4b49406">GetHostEntByAddr()</a> and is the converse of the <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60">GetAddrInfo()</a> function.</p>
<p>The <em>flags</em> argument is formed by OR'ing the following values from socket_Types.h:</p>
<table class="doxtable">
<tr>
<th>Flag </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ab65d6a3635e193943fa4f95edfbebeaea2b7218595524993b8a5e6f28be48a06e">NameInfoFlag::Ni_NoFqdn</a> </td><td>A fully qualified domain name is not required for local hosts. The local part of the fully qualified domain name is returned instead. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ab65d6a3635e193943fa4f95edfbebeaeabce932039fed36ee2d7f93f65888d7cd">NameInfoFlag::Ni_NumericHost</a> </td><td>Return the address in numeric form, as if calling <a class="el" href="namespacenn_1_1socket.html#a43969e788b0959ef0007b481f45c3a4a">InetNtop()</a>, instead of a host name. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ab65d6a3635e193943fa4f95edfbebeaead52a0caf970660226eabd510f35a6d4b">NameInfoFlag::Ni_NameReqd</a> </td><td>A name is required. If the host name cannot be found in DNS and this flag is set, a non-zero error code is returned. If the host name is not found and the flag is not set, the address is returned in numeric form. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ab65d6a3635e193943fa4f95edfbebeaea1424d526e3e5f2ce5e6e62387181fa3c">NameInfoFlag::Ni_NumericServ</a> </td><td>The service name is returned as a digit string representing the port number. </td></tr>
<tr>
<td><a class="el" href="namespacenn_1_1socket.html#ab65d6a3635e193943fa4f95edfbebeaea2a229d7a05bf4eafb5480f2b0e67b84e">NameInfoFlag::Ni_Dgram</a> </td><td>Specifies that the service being looked up is a datagram service. </td></tr>
</table>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a243828270d581fb029a86292031a30cf" title="Free the address info structure. ">FreeAddrInfo()</a>, <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60" title="Get a list of IP addresses and port numbers. ">GetAddrInfo()</a>, <a class="el" href="namespacenn_1_1socket.html#a790112f00a11cf992ba2e04795c9590f" title="Return a human-readable version of the return value from GetAddrInfo() or GetNameInfo(). ">GAIStrError()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_socket_resolver_8cpp-example.html#a28">SocketResolver.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="adacc3405184e8f28fb630745b9f43db0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::socket::Initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1socket_1_1_config.html">Config</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize socket library. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>An instance of <a class="el" href="classnn_1_1socket_1_1_config.html">Config</a>, which supplies socket library configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns one of the following values: </dd>
<dd>
<a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">nn::ResultSuccess()</a> Call was successful. </dd>
<dd>
ResultInsufficientProvidedMemory() Insufficient Memory Provided. <a class="el" href="namespacenn_1_1socket.html#a710315a7c48bceff146c5c7b07223b65">nn::socket::MinSocketMemoryPoolSize</a> is required.</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>The socket library is not in the initialized state.</li>
<li>The socket library user will make no further adjustments to passed <em>config</em> object.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>The socket library is in the initialized state.</li>
<li>Memory supplied via <em>config</em> object is used exclusively by socket library and should not be accessed or freed.</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 This method must be called first before attempting to call any other socket library API. It is not valid to call this API multiple times in succession without first calling <a class="el" href="namespacenn_1_1socket.html#a28a801f086aadf0b731a721567f3e4b2">Finalize()</a>.</p>
<p>Upon call to <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> memory supplied via <em>config</em> object will be used exclusively by the socket library.</p>
<p>See socket library functional overview documentation for details about how to instantiate <em>config</em>.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a28a801f086aadf0b731a721567f3e4b2" title="Finalize socket library. ">Finalize()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_friends_profile_image_8cpp-example.html#a37">FriendsProfileImage.cpp</a>, <a class="el" href="_ldn_access_point_8cpp-example.html#a98">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_simple_2_main_8cpp-example.html#a11">LdnSimple/Main.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a98">LdnStation.cpp</a>, <a class="el" href="_libcurl_basic_8cpp-example.html#a16">LibcurlBasic.cpp</a>, <a class="el" href="_libcurl_speed_test_8cpp-example.html#a47">LibcurlSpeedTest.cpp</a>, <a class="el" href="_libcurl_ssl_context_import_8cpp-example.html#a16">LibcurlSslContextImport.cpp</a>, <a class="el" href="_nifm_network_connection_simple_8cpp-example.html#a4">NifmNetworkConnectionSimple.cpp</a>, <a class="el" href="_socket_basic_8cpp-example.html#a44">SocketBasic.cpp</a>, <a class="el" href="_socket_resolver_8cpp-example.html#a40">SocketResolver.cpp</a>, <a class="el" href="_ssl_simple_8cpp-example.html#a55">SslSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a170b50fa1256bc0ed9d5176ecc2d9a09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::socket::Initialize </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memoryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memoryPoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>allocatorPoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>concurrencyLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize socket library. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">memoryPool</td><td>Pointer to the start of the memory region; must be 4kB aligned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memoryPoolSize</td><td>Total size of the memory region; must be a multiple of 4kB. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocatorPoolSize</td><td>Portion of the memory region to be used for resolver; must be a multiple of 4kB. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">concurrencyLimit</td><td>nn::socket::DefaultConcurrencyLimit should always be passed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>This function currently cannot fail and always returns <a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">nn::ResultSuccess()</a>. Failure would mean a fatal OS error has occurred.</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>The socket library is not in the initialized state.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>The socket library is in the initialized state.</li>
<li>Memory supplied via <em>memoryPool</em> is used exclusively by socket library and should not be accessed or freed.</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 Use of this API is discouraged. It is preferred to instead use <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize(const Config&amp; config)</a>. It is not valid to call this API multiple times in succession without first calling <a class="el" href="namespacenn_1_1socket.html#a28a801f086aadf0b731a721567f3e4b2">Finalize()</a>.</p>
<p>Upon call to <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0" title="Initialize socket library. ">Initialize()</a>, memory supplied via <em>memoryPool</em> will be used exclusively by the socket library.</p>
<p>See socket library functional overview documentation for details about how to appropriately size parameters <em>memoryPoolSize</em> and <em>allocatorPoolSize</em>.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a28a801f086aadf0b731a721567f3e4b2" title="Finalize socket library. ">Finalize()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a28a801f086aadf0b731a721567f3e4b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::socket::Finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize socket library. </p>
<dl class="section return"><dt>戻り値</dt><dd>This function currently cannot fail and always returns <a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">nn::ResultSuccess()</a>. Failure would mean a fatal OS error has occurred.</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>The socket library is in the initialized state.</li>
<li>The socket library user has synchronized its threads to prevent subsequent socket library API calls.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>Remaining allocated socket descriptors will have been automatically closed.</li>
<li>The socket library is no longer in the initialized state.</li>
<li>Memory supplied via <em>config</em> upon prior call to <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> may now be freed or repurposed.</li>
<li>Subsequent calls to socket library API will fail.</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 This method sets the library to an uninitialized state. Memory supplied upon prior call to <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> will no longer be used by the socket library.</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0" title="Initialize socket library. ">Initialize()</a> </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_ldn_access_point_8cpp-example.html#a113">LdnAccessPoint.cpp</a>, <a class="el" href="_ldn_simple_2_main_8cpp-example.html#a16">LdnSimple/Main.cpp</a>, <a class="el" href="_ldn_station_8cpp-example.html#a112">LdnStation.cpp</a>, <a class="el" href="_libcurl_basic_8cpp-example.html#a20">LibcurlBasic.cpp</a>, <a class="el" href="_libcurl_speed_test_8cpp-example.html#a51">LibcurlSpeedTest.cpp</a>, <a class="el" href="_libcurl_ssl_context_import_8cpp-example.html#a20">LibcurlSslContextImport.cpp</a>, <a class="el" href="_nifm_network_connection_simple_8cpp-example.html#a5">NifmNetworkConnectionSimple.cpp</a>, <a class="el" href="_socket_basic_8cpp-example.html#a45">SocketBasic.cpp</a>, <a class="el" href="_socket_resolver_8cpp-example.html#a43">SocketResolver.cpp</a>, <a class="el" href="_ssl_simple_8cpp-example.html#a59">SslSimple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="acdfb1891ce7a1cc01f95f3e620235b1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::GetLastErrno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the global variable <em>errno</em> - This API will be deprecated in an upcoming SDK release. </p>
<dl class="section return"><dt>戻り値</dt><dd>Returns errno value.</dd></dl>
<p><b>詳細</b> <br />
 When a network function call detects an error, it returns an integer value indicating failure (-1) and sets the global variable <em>errno</em> accordingly. In Windows builds, <em>errno</em> cannot be accessed directly. Instead, this function needs to be called to retrieve that value. It can also be used in NX builds but it is not necessary.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#ab3e3e08ff4437c59fe7e2f764279c631">SetLastError()</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#ab3e3e08ff4437c59fe7e2f764279c631" title="Set the global variable errno. ">SetLastError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac588565057dfa936967eb06ff62a2215"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::socket::SetLastErrno </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global variable <em>errno</em> - This API will be deprecated in an upcoming SDK release. </p>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#ac588565057dfa936967eb06ff62a2215" title="Set the global variable errno - This API will be deprecated in an upcoming SDK release. ">SetLastErrno()</a> routine can be used to set the global variable <em>errno</em>. Certain components of the network stack may choose to set or override the global variable <em>errno</em>. Since <em>errno</em> cannot be accessed directly in Windows builds, this function is necessary in those cases. It can also be used in NX builds but it is not necessary.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890">GetLastError()</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a26d1ba1b38eb1c92d1d076f87c0f3912"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::InetPton </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pAddressString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pOutAddressBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert address to network format - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">family</td><td>Type of the network address, only AF_INET is supported </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pAddressString</td><td>Address in presentation format </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAddressBuffer</td><td>Address in network format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns 1 if the address was valid for the specified address family, or 0 if the address was not parseable in the specified address family, or -1 if some system error occurred (in which case the global variable <em>errno</em> will have been set). This function is presently valid for AF_INET.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a476ef4e55fd64cf5b9d027e17f10a5e6" title="Convert address to network format. ">InetPton()</a> function converts a presentation format address (that is, printable form as held in a character string) to network format (usually a struct in_addr or some other internal binary representation, in network byte order). This function can be used without calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> first.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#a476ef4e55fd64cf5b9d027e17f10a5e6">InetPton(nn::socket::Family, const char*, void*)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a476ef4e55fd64cf5b9d027e17f10a5e6" title="Convert address to network format. ">InetPton(nn::socket::Family, const char*, void*)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae19a1109832d37d99f43f1d5789480d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::InetAton </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addressStringBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in_addr *&#160;</td>
          <td class="paramname"><em>pOutNetworkAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to network address - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addressStringBuffer</td><td>Address string in ASCII format </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutNetworkAddress</td><td>Address in network format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns 1 if the string was successfully interpreted, or 0 if the string is invalid.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a85ef2c54d6090d3c03393f8ab7cad49e" title="Convert string to network address. ">InetAton()</a> routine interprets the specified character string as an Internet address, placing the address into the structure provided. This function can be used without calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> first.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#a85ef2c54d6090d3c03393f8ab7cad49e">InetAton(const char*, nn::socket::InAddr*)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a85ef2c54d6090d3c03393f8ab7cad49e" title="Convert string to network address. ">InetAton(const char*, nn::socket::InAddr*)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ade1dedf75a8d44ab87d024fe74ecefb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* nn::socket::InetNtoa </td>
          <td>(</td>
          <td class="paramtype">in_addr&#160;</td>
          <td class="paramname"><em>networkAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert Internet address into ASCII string - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">networkAddress</td><td>Address in network format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns network address in ASCII representation.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#af90b8239ae0f5fbd70f12f9980fdac76" title="Convert Internet address into ASCII string. ">InetNtoa()</a> routine takes an Internet address and returns an ASCII string representing the address in '.' notation. The return value is managed internally, so if you wish to maintain the value between calls, a copy must be made. This function is not thread safe so there is a chance for the returned string to not be what is expected if called from another thread at the same time. This function can be used without calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> first.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#af90b8239ae0f5fbd70f12f9980fdac76">InetNtoa(nn::socket::InAddr)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#af90b8239ae0f5fbd70f12f9980fdac76" title="Convert Internet address into ASCII string. ">InetNtoa(nn::socket::InAddr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a04a33f759b752d546f13a4d2470a4d8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::socket::InetNtop </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pNetworkAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>addressStringBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addressStringBufferLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert network address to presentation format - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">family</td><td>Type of network address, only AF_INET is supported </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pNetworkAddress</td><td>Address in network format </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addressStringBuffer</td><td>Address in presentation format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addressStringBufferLength</td><td>Size of the buffer for address in presentation format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns NULL if a system error occurs (in which case, the global variable <em>errno</em> will have been set), or it returns a pointer to the destination string (<em>addressStringBuffer</em>).</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a43969e788b0959ef0007b481f45c3a4a" title="Convert network address to presentation format. ">InetNtop()</a> routine converts an address stored at <em>pNetworkAddress</em> from network format (usually a struct in_addr or some other binary form, in network byte order) to presentation format (suitable for external display purposes). This function can be used without calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> first.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#a43969e788b0959ef0007b481f45c3a4a">InetNtop(nn::socket::Family, const void*, char*, nn::socket::SockLenT)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a43969e788b0959ef0007b481f45c3a4a" title="Convert network address to presentation format. ">InetNtop(nn::socket::Family, const void*, char*, nn::socket::SockLenT)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abae34f509f3ca53315c0400ee7af388f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nn::socket::RecvFrom </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outBufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sockaddr *&#160;</td>
          <td class="paramname"><em>pOutAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>pOutAddressLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives a message from a connection-oriented or connectionless-oriented socket - This API will be deprecated in an upcoming SDK release. </p>
<p>It is normally used with connectionless-oriented sockets because it permits the application to retrieve the source address of received data.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outBuffer</td><td>Buffer for message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outBufferLength</td><td>Size of the message to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags modifying behavior of the function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAddress</td><td>Buffer for message source address </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutAddressLength</td><td>Size of the message source address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns number of bytes received, or -1 if an error occurred. If no messages are available to be received and the peer has performed an orderly shutdown, <a class="el" href="namespacenn_1_1socket.html#adab268741c66f0996683c31b1bcd05dc" title="Receives a message from a connection-oriented or connectionless-oriented socket. ">RecvFrom()</a> shall return 0.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd>
<dd>
[EBADF] The argument socket is an invalid descriptor </dd>
<dd>
[ECONNRESET] The remote socket end is forcibly closed </dd>
<dd>
[ENETDOWN] The network interface has been removed and the socket has been shut down. </dd>
<dd>
[ENOTCONN] The socket is associated with a connection-oriented protocol and has not been connected (see <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f">Connect()</a> and <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a>). </dd>
<dd>
[ENOTSOCK] The argument socket does not refer to a socket. </dd>
<dd>
[EAGAIN] The socket is marked non-blocking, and the receive operation would block, or a receive timeout had been set, and the timeout expired before data were received. </dd>
<dd>
[EAGAIN] Resources to complete the request are temporarily unavailable. </dd>
<dd>
[EINVAL] A non-zero <em>outBufferLength</em> was provided with a null <em>outBuffer</em>. </dd>
<dd>
[EFAULT] The address range referred to by <em>outBuffer</em> and <em>outBufferLength</em> does not refer to a valid part of the process address space.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#adab268741c66f0996683c31b1bcd05dc" title="Receives a message from a connection-oriented or connectionless-oriented socket. ">RecvFrom()</a> routine is used to receive messages from a socket, and may be used to receive data on a socket whether or not it is connection-oriented.</p>
<p>If <em>pOutAddress</em> is not a null pointer and the socket is not connection-oriented, the source address of the message is filled in. The <em>pOutAddressLength</em> argument is a value-result argument, initialized to the size of the buffer associated with <em>pOutAddress</em>, and modified on return to indicate the actual size of the address stored there. If the actual length of the address is greater than the length of the supplied sockaddr structure, the stored address will be truncated.</p>
<p>If no messages are available at the socket, the receive call waits for a message to arrive, unless the socket is non-blocking (see <a class="el" href="namespacenn_1_1socket.html#a92cb62635aca20860e3ab848f347ec6f">Fcntl()</a>) in which case the value -1 is returned and the global variable <em>errno</em> is set to EAGAIN. The receive calls normally return any data available, up to the requested amount, rather than waiting for receipt of the full amount requested; this behavior is affected by the socket-level options SO_RCVLOWAT and SO_RCVTIMEO described in <a class="el" href="namespacenn_1_1socket.html#a4aff7a563a6c808b236246a182996761">GetSockOpt()</a>.</p>
<p>The <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2">Select()</a> function call may be used to determine when more data arrives.</p>
<p>The flags argument is formed by or'ing one or more of the values:</p>
<table class="doxtable">
<tr>
<th>Flag </th><th>Description  </th></tr>
<tr>
<td>MSG_OOB </td><td>Process out-of-band data </td></tr>
<tr>
<td>MSG_PEEK </td><td>Peek at incoming message </td></tr>
<tr>
<td>MSG_WAITALL </td><td>Wait for full request or error </td></tr>
<tr>
<td>MSG_DONTWAIT </td><td>Do not block </td></tr>
</table>
<p>The MSG_OOB flag requests receipt of out-of-band data that would not be received in the normal data stream. Some protocols place expedited data at the head of the normal data queue, and thus this flag cannot be used with such protocols. The MSG_PEEK flag causes the receive operation to return data from the beginning of the receive queue without removing that data from the queue. Thus, a subsequent receive call will return the same data. The MSG_WAITALL flag requests that the operation block until the full request is satisfied. However, the call may still return less data than requested if an error or disconnect occurs, or the next data to be received is of a different type than that returned. The MSG_DONTWAIT flag requests the call to return when it would block otherwise. If no data is available, the global variable <em>errno</em> is set to EAGAIN.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#adab268741c66f0996683c31b1bcd05dc">RecvFrom(int, void*, size_t, nn::socket::MsgFlag, nn::socket::SockAddr*, nn::socket::SockLenT*)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#adab268741c66f0996683c31b1bcd05dc" title="Receives a message from a connection-oriented or connectionless-oriented socket. ">RecvFrom(int, void*, size_t, nn::socket::MsgFlag, nn::socket::SockAddr*, nn::socket::SockLenT*)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a86ab796296ba9d510ebad6eb52a40489"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nn::socket::Recv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outBufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives a message from a connection-mode or connectionless-mode socket - This API will be deprecated in an upcoming SDK release. </p>
<p>It is normally used with connected sockets because it does not permit the application to retrieve the source address of received data.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outBuffer</td><td>Buffer for message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outBufferLength</td><td>Size of the message to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags modifying behavior of the function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns number of bytes received, or -1 if an error occurred. If no messages are available to be received and the peer has performed an orderly shutdown, <a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14" title="Receives a message from a connection-mode or connectionless-mode socket. ">Recv()</a> shall return 0.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14" title="Receives a message from a connection-mode or connectionless-mode socket. ">Recv()</a> routine is similar in behavior to <a class="el" href="namespacenn_1_1socket.html#adab268741c66f0996683c31b1bcd05dc">RecvFrom()</a>; however, it is normally used only on a connected socket (see <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f">Connect()</a>).</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14">Recv(int, void*, size_t, nn::socket::MsgFlag)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14" title="Receives a message from a connection-mode or connectionless-mode socket. ">Recv(int, void*, size_t, nn::socket::MsgFlag)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab8c2a9e147d01954c74b2e574a90ee01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nn::socket::SendTo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sockaddr *&#160;</td>
          <td class="paramname"><em>pAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addressLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message from a socket - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer containing the message to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferLength</td><td>Size of the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags modifying behavior of the function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pAddress</td><td>Buffer containing address of the recipient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addressLength</td><td>Size of the recipient address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the number of characters sent, or -1 if an error occurred.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd>
<dd>
[EBADF] An invalid descriptor was specified. </dd>
<dd>
[EACCES] The destination address is a broadcast address, and SO_BROADCAST has not been set on the socket. </dd>
<dd>
[ENOTSOCK] The argument socket is not a socket. </dd>
<dd>
[EMSGSIZE] The socket requires that message be sent atomically, and the size of the message to be sent made this impossible. </dd>
<dd>
[EAGAIN] The socket is marked non-blocking and the requested operation would block. </dd>
<dd>
[EAGAIN] Resources to complete the request are temporarily unavailable. </dd>
<dd>
[ENOBUFS] The system was unable to allocate an internal buffer. The operation may succeed when buffers become available. </dd>
<dd>
[EHOSTUNREACH] The remote host was unreachable. </dd>
<dd>
[EISCONN] A destination address was specified and the socket is already connected. </dd>
<dd>
[ECONNREFUSED] The socket received an ICMP destination unreachable message from the last message sent. This typically means that the receiver is not listening on the remote port. </dd>
<dd>
[EHOSTDOWN] The remote host was down. </dd>
<dd>
[ENETDOWN] The local network interface is down. </dd>
<dd>
[ENETUNREACH] The network is not reachable from this host. </dd>
<dd>
[EPIPE] The socket is unable to send anymore data (SBS_CANTSENDMORE has been set on the socket). This typically means that the socket is not connected. </dd>
<dd>
[EINVAL] A non-zero <em>bufferLength</em> was provided with a null <em>buffer</em>. </dd>
<dd>
[EFAULT] The address range referred to by <em>buffer</em> and <em>bufferLength</em> does not refer to a valid part of the process address space.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#aacd6b8da24d25e5e4f299b833258826f" title="Send a message from a socket. ">SendTo()</a> routine is used to transmit a message to another socket. The address of the target is given by <em>pAddress</em> with <em>addressLength</em> specifying its size. The length of the message is given by <em>bufferLength</em>. If the message is too long to pass atomically through the underlying protocol, the error EMSGSIZE is returned, and the message is not transmitted.</p>
<p>If no message space is available at the socket to hold the message to be transmitted, then <a class="el" href="namespacenn_1_1socket.html#aacd6b8da24d25e5e4f299b833258826f" title="Send a message from a socket. ">SendTo()</a> normally blocks, unless the socket has been placed in non-blocking I/O mode. The <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2">Select()</a> call may be used to determine when it is possible to send more data.</p>
<p>The flags argument may include one or more of the following:</p>
<table class="doxtable">
<tr>
<th>Flag </th><th>Description  </th></tr>
<tr>
<td>MSG_OOB </td><td>Process out-of-band data </td></tr>
<tr>
<td>MSG_DONTROUTE </td><td>Bypass routing, use direct interface </td></tr>
<tr>
<td>MSG_EOR </td><td>Data completes record </td></tr>
<tr>
<td>MSG_EOF </td><td>Data completes transaction </td></tr>
</table>
<p>The flag MSG_OOB is used to send "out-of-band" data on sockets that support this notion (e.g. SOCK_STREAM); the underlying protocol must also support "out-of-band" data. MSG_EOR is used to indicate a record mark for protocols which support the concept. MSG_EOF requests that the sender side of a socket be shut down, and that an appropriate indication be sent at the end of the specified data; this flag is only implemented for SOCK_STREAM sockets in the PF_INET protocol family. MSG_DONTROUTE is usually used only by diagnostic or routing programs.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#aacd6b8da24d25e5e4f299b833258826f">SendTo(int, const void*, size_t, nn::socket::MsgFlag, const nn::socket::SockAddr*, nn::socket::SockLenT)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#aacd6b8da24d25e5e4f299b833258826f" title="Send a message from a socket. ">SendTo(int, const void*, size_t, nn::socket::MsgFlag, const nn::socket::SockAddr*, nn::socket::SockLenT)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad15832524d00283a4e6b4af94698931a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nn::socket::Send </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message from a socket - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer containing the message to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferLength</td><td>Size of the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags modifying behavior of the function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the number of characters sent, or -1 if an error occurred.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#ae5a4c9f486b94e6b19e563ef97a2e412" title="Send a message from a socket. ">Send()</a> routine is similar in behavior to <a class="el" href="namespacenn_1_1socket.html#aacd6b8da24d25e5e4f299b833258826f">SendTo()</a>; however, it is normally used only on a connected socket (see <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f">Connect()</a>).</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#ae5a4c9f486b94e6b19e563ef97a2e412">Send(int, const void*, size_t, nn::socket::MsgFlag)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#ae5a4c9f486b94e6b19e563ef97a2e412" title="Send a message from a socket. ">Send(int, const void*, size_t, nn::socket::MsgFlag)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acd017048f31047060bd14d142cae91eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nn::socket::RecvMsg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">msghdr *&#160;</td>
          <td class="paramname"><em>pOutMessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a message from a socket - This API will be deprecated in an upcoming SDK release. </p>
<dl class="section return"><dt>戻り値</dt><dd>Returns -1, the global variable <em>errno</em> is set to [EOPNOTSUPP].</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#acd017048f31047060bd14d142cae91eb" title="Receive a message from a socket - This API will be deprecated in an upcoming SDK release. ">RecvMsg()</a> routine is used to receive a message from a socket. It uses msghdr structure to minimize the number of directly supplied arguments.</p>
<p>In the current implementation this function is disabled.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated with no replacement.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14" title="Receives a message from a connection-mode or connectionless-mode socket. ">Recv(int, void*, size_t, nn::socket::MsgFlag)</a>, <a class="el" href="namespacenn_1_1socket.html#adab268741c66f0996683c31b1bcd05dc" title="Receives a message from a connection-oriented or connectionless-oriented socket. ">RecvFrom(int, void*, size_t, nn::socket::MsgFlag, nn::socket::SockAddr*, nn::socket::SockLenT*)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5c6903b76c9ba427731abe0f0349d79a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t nn::socket::SendMsg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const msghdr *&#160;</td>
          <td class="paramname"><em>pMessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message from a socket - This API will be deprecated in an upcoming SDK release. </p>
<dl class="section return"><dt>戻り値</dt><dd>Returns -1, the global variable <em>errno</em> is set to [EOPNOTSUPP].</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a5c6903b76c9ba427731abe0f0349d79a" title="Send a message from a socket - This API will be deprecated in an upcoming SDK release. ">SendMsg()</a> routine is used to send a message from a socket. It uses msghdr structure to minimize the number of directly supplied arguments.</p>
<p>In the current implementation this function is disabled.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated with no replacement.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#ae5a4c9f486b94e6b19e563ef97a2e412" title="Send a message from a socket. ">Send(int, const void*, size_t, nn::socket::MsgFlag)</a>, <a class="el" href="namespacenn_1_1socket.html#aacd6b8da24d25e5e4f299b833258826f" title="Send a message from a socket. ">SendTo(int, const void*, size_t, nn::socket::MsgFlag, const nn::socket::SockAddr*, nn::socket::SockLenT)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8d9950d093e134087776f1b96b8d9af7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Accept </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sockaddr *&#160;</td>
          <td class="paramname"><em>pOutAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>pOutAddressLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept connection on a socket - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket desciptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAddress</td><td>Address of the remote host </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutAddressLength</td><td>Size of the buffer containing remote host address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns -1 on error. If it succeeds, it returns a non-negative integer that is a descriptor for the accepted socket.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd>
<dd>
[EBADF] The descriptor is invalid. </dd>
<dd>
[EINTR] The accept operation was interrupted. </dd>
<dd>
[EMFILE] The per-process descriptor table is full. </dd>
<dd>
[ENOTSOCK] The descriptor references a file, not a socket. </dd>
<dd>
[EINVAL] <a class="el" href="namespacenn_1_1socket.html#ad6c2c6b2d1cd467bfdbfb4bf4057338b">Listen()</a> has not been called on the socket descriptor. </dd>
<dd>
[EINVAL] A non-zero <em>pOutAddressLength</em> was passed with a null <em>pOutAddress</em>. </dd>
<dd>
[EWOULDBLOCK] or [EAGAIN] The socket is marked non-blocking and no connections are present to be accepted. </dd>
<dd>
[ECONNABORTED] A connection arrived, but it was closed while waiting on the listen queue. </dd>
<dd>
[EFAULT] The address range referred to by <em>pOutAddress</em> and <em>pOutAddressLength</em> does not refer to a valid part of the process address space. </dd>
<dd>
[EAGAIN] Resources to complete the request are temporarily unavailable.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a> routine can be used to accept connection on a socket. The argument <em>socket</em> is a socket that has been created with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a>, bound to an address with <a class="el" href="namespacenn_1_1socket.html#a09255737b952ba3ad3a647607fc2af0a">Bind()</a>, and is listening for connections after a <a class="el" href="namespacenn_1_1socket.html#ad6c2c6b2d1cd467bfdbfb4bf4057338b">Listen()</a>. The <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a> function call extracts the first connection request on the queue of pending connections, creates a new socket, and allocates a new file descriptor for the socket which inherits the state of the O_NONBLOCK property from the original socket.</p>
<p>If no pending connections are present on the queue, and the original socket is not marked as non-blocking, <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a> blocks the caller until a connection is present. If the original socket is marked non-blocking and no pending connections are present on the queue, <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a> returns an error as described below. The accepted socket may not be used to accept more connections. The original socket remains open.</p>
<p>The argument <em>pOutAddress</em> is a result argument that is filled-in with the address of the connecting entity, as known to the communications layer. The exact format of the <em>pOutAddress</em> argument is determined by the domain in which the communication is occurring. A null pointer may be specified for <em>pOutAddress</em> if the address information is not desired; in this case, <em>pOutAddressLength</em> is not used and should also be null. Otherwise, the <em>pOutAddressLength</em> argument is a value-result argument; it should initially contain the amount of space pointed to by <em>pOutAddress</em>; on return it will contain the actual length (in bytes) of the address returned. This call is used with connection-based socket types, currently with SOCK_STREAM.</p>
<p>It is possible to <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2">Select()</a> a socket for the purposes of doing an <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a> by selecting it for read.</p>
<p>When using <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept()</a>, portable programs should not rely on the O_NONBLOCK property and the signal destination being inherited, but should set them explicitly using <a class="el" href="namespacenn_1_1socket.html#a92cb62635aca20860e3ab848f347ec6f">Fcntl()</a>.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept(int, nn::socket::SockAddr*, nn::socket::SockLenT*)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept(int, nn::socket::SockAddr*, nn::socket::SockLenT*)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ade8632820906d88c202c0940ff227059"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Bind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sockaddr *&#160;</td>
          <td class="paramname"><em>pAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addressLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a local protocol address to a socket - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pAddress</td><td>Buffer containing address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addressLength</td><td>Length of the address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the value 0 if successful; otherwise the value -1 is returned.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd>
<dd>
[EAGAIN] Resources to complete the request are temporarily unavailable. </dd>
<dd>
[EBADF] The socket argument is not a valid descriptor. </dd>
<dd>
[EINVAL] The socket is already bound to an address, and the protocol does not support binding to a new address; or the socket has been shut down. </dd>
<dd>
[EINVAL] The <em>addressLength</em> argument is not a valid length for the address family. </dd>
<dd>
[EINVAL] The <em>pAddress</em> argument is null. </dd>
<dd>
[ENOTSOCK] The <em>socket</em> argument is not a socket. </dd>
<dd>
[EADDRNOTAVAIL] The specified address is not available from the local machine. </dd>
<dd>
[EADDRINUSE] The specified address is already in use. </dd>
<dd>
[EAFNOSUPPORT] Addresses in the specified address family cannot be used with this socket. </dd>
<dd>
[EACCES] The requested address is protected, and the current user has inadequate permission to access it. </dd>
<dd>
[EFAULT] The address range referred to by <em>pAddress</em> and <em>addressLength</em> does not refer to a valid part of the process address space.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a09255737b952ba3ad3a647607fc2af0a" title="Assign a local protocol address to a socket. ">Bind()</a> routine assigns the local protocol address to a socket. When a socket is created with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> it exists in an address family space but has no protocol address assigned. The <a class="el" href="namespacenn_1_1socket.html#a09255737b952ba3ad3a647607fc2af0a" title="Assign a local protocol address to a socket. ">Bind()</a> function call requests that address stored at <em>pAddress</em> be assigned to the socket.</p>
<p>For maximum portability, you should always zero the socket address structure before populating it and passing it to <a class="el" href="namespacenn_1_1socket.html#a09255737b952ba3ad3a647607fc2af0a" title="Assign a local protocol address to a socket. ">Bind()</a>.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#a09255737b952ba3ad3a647607fc2af0a">Bind(int, const nn::socket::SockAddr*, nn::socket::SockLenT)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a09255737b952ba3ad3a647607fc2af0a" title="Assign a local protocol address to a socket. ">Bind(int, const nn::socket::SockAddr*, nn::socket::SockLenT)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6b827725f713f2618b9a7b68bb7dd744"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Connect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sockaddr *&#160;</td>
          <td class="paramname"><em>pAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addressLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate a connection on a socket - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pAddress</td><td>Buffer containing address of the remote host </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addressLength</td><td>Size of the buffer containing address of the remote host</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the value 0 if successful; otherwise the value -1 is returned.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd>
<dd>
[EBADF] The <em>socket</em> argument is not a valid descriptor. </dd>
<dd>
[EINVAL] The <em>addressLength</em> argument is not a valid length for the address family. </dd>
<dd>
[EINVAL] The <em>pAddress</em> argument is null. </dd>
<dd>
[EFAULT] The address range referred to by <em>pAddress</em> and <em>addressLength</em> does not refer to a valid part of the process address space. </dd>
<dd>
[ENOTSOCK] The <em>socket</em> argument is a descriptor for a file, not a socket. </dd>
<dd>
[EADDRNOTAVAIL] The specified address is not available on this machine. </dd>
<dd>
[EAFNOSUPPORT] Addresses in the specified address family cannot be used with this socket. </dd>
<dd>
[EISCONN] The socket is already connected. </dd>
<dd>
[ETIMEDOUT] Connection establishment timed out without establishing a connection. </dd>
<dd>
[ECONNREFUSED] The attempt to connect was forcefully rejected. </dd>
<dd>
[ECONNRESET] The connection was reset by the remote host. </dd>
<dd>
[ENETUNREACH] The network is not reachable from this host. </dd>
<dd>
[EHOSTUNREACH] The remote host is not reachable from this host. </dd>
<dd>
[EADDRINUSE] The address is already in use. </dd>
<dd>
[EINPROGRESS] The socket is non-blocking and the connection cannot be completed immediately. It is possible to <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2">Select()</a> for completion by selecting the socket for writing. </dd>
<dd>
[EALREADY] A previous connection attempt has not yet been completed. </dd>
<dd>
[EACCES] An attempt is made to connect to a broadcast address (obtained through the INADDR_BROADCAST constant or the INADDR_NONE return value) through a socket that does not provide broadcast functionality. </dd>
<dd>
[EAGAIN] An auto-assigned port number was requested but no auto-assigned ports are available. </dd>
<dd>
[EAGAIN] Resources to complete the request are temporarily unavailable.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f" title="Initiate a connection on a socket. ">Connect()</a> routine initiates connection on a socket. If socket is of type SOCK_DGRAM, this call specifies the peer with which the socket is to be associated; this address is that to which datagrams are to be sent, and the only address from which datagrams are to be received.</p>
<p>If the socket is of type SOCK_STREAM, this call attempts to make a connection to another socket. The other socket is specified by name, which is an address in the communications space of the socket. Each communications space interprets the name argument in its own way.</p>
<p>Generally, stream sockets may successfully connect only once; datagram sockets may use connect multiple times to change their association. Datagram sockets may dissolve the association by connecting to an invalid address, such as a null address.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f">Connect(int, const nn::socket::SockAddr*, nn::socket::SockLenT)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f" title="Initiate a connection on a socket. ">Connect(int, const nn::socket::SockAddr*, nn::socket::SockLenT)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0bfa8571353a76695c6518a0825475ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::GetPeerName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sockaddr *&#160;</td>
          <td class="paramname"><em>pOutAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>pOutAddressLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get name of connected peer - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAddress</td><td>Buffer for storing name of the peer </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutAddressLength</td><td>Size of the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the value 0 if successful; otherwise the value -1 is returned.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd>
<dd>
[EBADF] The argument <em>socket</em> is not a valid descriptor. </dd>
<dd>
[ECONNRESET] The connection has been reset by the peer. </dd>
<dd>
[EINVAL] The value of the <em>pOutAddressLength</em> argument is not valid. </dd>
<dd>
[EINVAL] The <em>pOutAddress</em> argument or <em>pOutAddressLength</em> argument are null. </dd>
<dd>
[EFAULT] The address range referred to by <em>outAddress</em> and <em>pOutAddressLength</em> does not refer to a valid part of the process address space. </dd>
<dd>
[ENOTSOCK] The argument <em>socket</em> is not a socket. </dd>
<dd>
[ENOTCONN] The socket is not connected. </dd>
<dd>
[ENOBUFS] Insufficient resources were available in the system to perform the operation. </dd>
<dd>
[EAGAIN] Resources to complete the request are temporarily unavailable.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a97eb7ccadd9c3c1fb69f4a634a443003" title="Get name of connected peer. ">GetPeerName()</a> routine returns the name of the peer connected to socket. The <em>pOutAddressLength</em> argument should be initialized to indicate the amount of space pointed to by <em>pOutAddress</em>. On return it contains the actual size of the name returned (in bytes). The name is truncated if the buffer provided is too small.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#a97eb7ccadd9c3c1fb69f4a634a443003">GetPeerName(int, nn::socket::SockAddr*, nn::socket::SockLenT*)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a97eb7ccadd9c3c1fb69f4a634a443003" title="Get name of connected peer. ">GetPeerName(int, nn::socket::SockAddr*, nn::socket::SockLenT*)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae5bd1883e48c6c5942fa4b0b058a3ec7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::GetSockName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sockaddr *&#160;</td>
          <td class="paramname"><em>pOutAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>pOutAddressLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get socket name - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutAddress</td><td>Buffer for name </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutAddressLength</td><td>Size of the buffer for name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the value 0 if successful; otherwise the value -1 is returned.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd>
<dd>
[EBADF] The argument <em>socket</em> is not a valid descriptor. </dd>
<dd>
[ECONNRESET] The connection has been reset by the peer. </dd>
<dd>
[EINVAL] The value of the <em>pOutAddressLength</em> argument is not valid. </dd>
<dd>
[EINVAL] The <em>pOutAddress</em> argument or <em>pOutAddressLength</em> argument are null. </dd>
<dd>
[EFAULT] The address range referred to by <em>outAddress</em> and <em>pOutAddressLength</em> does not refer to a valid part of the process address space. </dd>
<dd>
[ENOTSOCK] The argument <em>socket</em> is not a socket. </dd>
<dd>
[ENOBUFS] Insufficient resources were available in the system to perform the operation. </dd>
<dd>
[EAGAIN] Resources to complete the request are temporarily unavailable.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#adb89c6a0abfc8befcdc1ce05bf49e0ce" title="Get socket name. ">GetSockName()</a> routine returns the current name for the specified socket. The <em>pOutAddressLength</em> argument should be initialized to indicate the amount of space pointed to by <em>pOutAddress</em>. On return it contains the actual size of the name returned (in bytes).</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#adb89c6a0abfc8befcdc1ce05bf49e0ce">GetSockName(int, nn::socket::SockAddr*, nn::socket::SockLenT*)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#adb89c6a0abfc8befcdc1ce05bf49e0ce" title="Get socket name. ">GetSockName(int, nn::socket::SockAddr*, nn::socket::SockLenT*)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a92711556ee5f0122c71d8aedfe8399d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::SetSockOpt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pOptionValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>optionLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set options on a socket - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Level of the option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optionName</td><td>Type of the option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pOptionValue</td><td>Buffer containing option value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optionLength</td><td>Size of the buffer with option value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the value 0 if successful; otherwise the value -1 is returned.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd>
<dd>
[EBADF] The argument <em>socket</em> is not a valid descriptor. </dd>
<dd>
[ENOTSOCK] The argument <em>socket</em> is not a socket. </dd>
<dd>
[ENOPROTOOPT] The <em>optionName</em> is unknown at the level indicated. </dd>
<dd>
[EINVAL] The <em>pOptionValue</em> argument is null or the value of the <em>optionLength</em> argument is not valid. </dd>
<dd>
[EFAULT] The address range referred to by <em>pOptionValue</em> and <em>optionLength</em> does not refer to a valid part of the process address space. </dd>
<dd>
[EPERM] User has insufficient privileges to carry out the requested operation. </dd>
<dd>
[EAGAIN] Resources to complete the request are temporarily unavailable.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#afaa7ccade3133a9884ab0b8e44ac18fc" title="Set options on a socket. ">SetSockOpt()</a> routine manipulates the options associated with a socket. Options may exist at multiple protocol levels; they are always present at the uppermost "socket" level.</p>
<p>When manipulating socket options the level at which the option resides and the name of the option must be specified. To manipulate options at the socket level, level is specified as SOL_SOCKET. To manipulate options at any other level the protocol number of the appropriate protocol controlling the option is supplied. For example, to indicate that an option is to be interpreted by the TCP protocol, level should be set to the protocol number of TCP.</p>
<p>The following are supported levels:</p>
<p>SOL_IP, SOL_ICMP, SOL_TCP, SOL_UDP, SOL_SOCKET.</p>
<p>The <em>pOptionValue</em> and <em>optionLength</em> arguments are used to access option values. The <em>optionName</em> argument and any specified options are passed uninterpreted to the appropriate protocol module for interpretation.</p>
<p>Most socket-level options utilize an int argument for option value. For <a class="el" href="namespacenn_1_1socket.html#afaa7ccade3133a9884ab0b8e44ac18fc" title="Set options on a socket. ">SetSockOpt()</a>, the argument should be non-zero to enable a boolean option, or zero if the option is to be disabled. SO_LINGER uses a struct linger argument which specifies the desired state of the option and the linger interval (see below). SO_SNDTIMEO and SO_RCVTIMEO use a struct timeval argument.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>linger</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span>         l_onoff;    <span class="comment">// option on/off</span></div>
<div class="line">    <span class="keywordtype">int</span>         l_linger;   <span class="comment">// linger time</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>timeval</div>
<div class="line">{</div>
<div class="line">    time_t      tv_sec;     <span class="comment">// seconds</span></div>
<div class="line">    suseconds_t tv_usec;    <span class="comment">// microseconds</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The following options are recognized at the socket level.</p>
<table class="doxtable">
<tr>
<th>Option </th><th>Short description  </th></tr>
<tr>
<td>SO_REUSEADDR </td><td>Enables local address reuse </td></tr>
<tr>
<td>SO_REUSEPORT </td><td>Enables duplicate address and port bindings </td></tr>
<tr>
<td>SO_KEEPALIVE </td><td>Enables keep connections alive </td></tr>
<tr>
<td>SO_DONTROUTE </td><td>Enables routing bypass for outgoing messages </td></tr>
<tr>
<td>SO_LINGER </td><td><a class="el" href="structnn_1_1socket_1_1_linger.html" title="Structure used for manipulating linger option. ">Linger</a> on close if data present </td></tr>
<tr>
<td>SO_BROADCAST </td><td>Enables permission to transmit broadcast messages </td></tr>
<tr>
<td>SO_OOBINLINE </td><td>Enables reception of out-of-band data in band </td></tr>
<tr>
<td>SO_SNDBUF </td><td>Set buffer size for output </td></tr>
<tr>
<td>SO_RCVBUF </td><td>Set buffer size for input </td></tr>
<tr>
<td>SO_SNDLOWAT </td><td>Set minimum count for output (not supported on Windows) </td></tr>
<tr>
<td>SO_RCVLOWAT </td><td>Set minimum count for input (not supported on Windows) </td></tr>
<tr>
<td>SO_SNDTIMEO </td><td>Set timeout value for output </td></tr>
<tr>
<td>SO_RCVTIMEO </td><td>Set timeout value for input </td></tr>
<tr>
<td>SO_ACCEPTFILTER </td><td>Set accept filter on listening socket </td></tr>
<tr>
<td>SO_ACCEPTCONN </td><td>Get listening status of the socket (get only, not supported on Windows) </td></tr>
<tr>
<td>SO_TYPE </td><td>Get the type of the socket (get only, not supported on Windows) </td></tr>
<tr>
<td>SO_PROTOCOL </td><td>Get the protocol number for the socket (get only) </td></tr>
<tr>
<td>SO_ERROR </td><td>Get and clear error on the socket (get only) </td></tr>
<tr>
<td>SO_LISTENQLIMIT </td><td>Get backlog limit of the socket (get only) </td></tr>
<tr>
<td>SO_LISTENQLEN </td><td>Get complete queue length of the socket (get only) </td></tr>
<tr>
<td>SO_LISTENINCQLEN</td><td>Get incomplete queue length of the socket (get only) </td></tr>
</table>
<p>SO_REUSEADDR indicates that the rules used in validating addresses supplied in a <a class="el" href="namespacenn_1_1socket.html#a09255737b952ba3ad3a647607fc2af0a">Bind()</a> system call should allow reuse of local addresses.</p>
<p>SO_REUSEPORT allows completely duplicate bindings by multiple processes if they all set SO_REUSEPORT before binding the port. This option permits multiple instances of a program to each receive UDP/IP multicast or broadcast datagrams destined for the bound port.</p>
<p>SO_KEEPALIVE enables the periodic transmission of messages on a connected socket. Should the connected party fail to respond to these messages, the connection is considered broken and processes using the socket are notified via a SIGPIPE signal when attempting to send data.</p>
<p>SO_DONTROUTE indicates that outgoing messages should bypass the standard routing facilities. Instead, messages are directed to the appropriate network interface according to the network portion of the destination address.</p>
<p>SO_LINGER controls the action taken when unsent messages are queued on socket and a <a class="el" href="namespacenn_1_1socket.html#ae01110d228e2148d830b1ecfb9aaa425">Close()</a> is performed. If the socket promises reliable delivery of data and SO_LINGER is set, the system will block the process on the <a class="el" href="namespacenn_1_1socket.html#ae01110d228e2148d830b1ecfb9aaa425">Close()</a> attempt until it is able to transmit the data or until it decides it is unable to deliver the information (a timeout period, termed the linger interval, is specified in seconds in the <a class="el" href="namespacenn_1_1socket.html#afaa7ccade3133a9884ab0b8e44ac18fc" title="Set options on a socket. ">SetSockOpt()</a> system call when SO_LINGER is requested). If SO_LINGER is disabled and a <a class="el" href="namespacenn_1_1socket.html#ae01110d228e2148d830b1ecfb9aaa425">Close()</a> is issued, the system will process the close in a manner that allows the process to continue as quickly as possible.</p>
<p>The option SO_BROADCAST requests permission to send broadcast datagrams on the socket.</p>
<p>With protocols that support out-of-band data, the SO_OOBINLINE option requests that out-of-band data be placed in the normal data input queue as received; it will then be accessible with <a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14">Recv()</a> or <a class="el" href="namespacenn_1_1socket.html#ae1fd34e9d084e5bb0f17a6c2361896c2">Read()</a> calls without the MSG_OOB flag. Some protocols always behave as if this option is set.</p>
<p>SO_SNDBUF and SO_RCVBUF are options to adjust the normal buffer sizes allocated for output and input buffers, respectively. The buffer size may be increased for high-volume connections, or may be decreased to limit the possible backlog of incoming data.</p>
<p>SO_SNDLOWAT is an option to set the minimum count for output operations. Most output operations process all of the data supplied by the call, delivering data to the protocol for transmission and blocking as necessary for flow control. Nonblocking output operations will process as much data as permitted subject to flow control without blocking, but will process no data if flow control does not allow the smaller of the low water mark value or the entire request to be processed. A <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2">Select()</a> operation testing the ability to write to a socket will return true only if the low water mark amount could be processed. The default value for SO_SNDLOWAT is set to a convenient size for network efficiency, often 1024.</p>
<p>SO_RCVLOWAT is an option to set the minimum count for input operations. In general, receive calls will block until any (non-zero) amount of data is received, then return with the smaller of the amount available or the amount requested. The default value for SO_RCVLOWAT is 1. If SO_RCVLOWAT is set to a larger value, blocking receive calls normally wait until they have received the smaller of the low water mark value or the requested amount. Receive calls may still return less than the low water mark if an error occurs, or the type of data next in the receive queue is different from that which was returned.</p>
<p>SO_SNDTIMEO is an option to set a timeout value for output operations. It accepts a struct timeval argument with the number of seconds and microseconds used to limit waits for output operations to complete. If a send operation has blocked for this much time, it returns with a partial count or with the error EWOULDBLOCK if no data were sent. In the current implementation, this timer is restarted each time additional data are delivered to the protocol, implying that the limit applies to output portions ranging in size from the low water mark to the high water mark for output.</p>
<p>SO_RCVTIMEO is an option to set a timeout value for input operations. It accepts a struct timeval argument with the number of seconds and microseconds used to limit waits for input operations to complete. In the current implementation, this timer is restarted each time additional data are received by the protocol, and thus the limit is in effect an inactivity timer. If a receive operation has been blocked for this much time without receiving additional data, it returns with a short count or with the error EWOULDBLOCK if no data were received.</p>
<p>SO_ACCEPTCONN, SO_TYPE, SO_PROTOCOL (and its alias SO_PROTOTYPE) and SO_ERROR are options used only with <a class="el" href="namespacenn_1_1socket.html#a4aff7a563a6c808b236246a182996761">GetSockOpt()</a>. SO_ACCEPTCONN returns whether the socket is currently accepting connections, that is, whether or not the <a class="el" href="namespacenn_1_1socket.html#ad6c2c6b2d1cd467bfdbfb4bf4057338b">Listen()</a> system call was invoked on the socket. SO_TYPE returns the type of the socket, such as SOCK_STREAM; it is useful for servers that inherit sockets on startup. SO_PROTOCOL returns the protocol number for the socket, for AF_INET and AF_INET6 address families. SO_ERROR returns any pending error on the socket and clears the error status. It may be used to check for asynchronous errors on connected datagram sockets or for other asynchronous errors.</p>
<p>SO_LISTENQLIMIT returns the maximal number of queued connections, as set by <a class="el" href="namespacenn_1_1socket.html#ad6c2c6b2d1cd467bfdbfb4bf4057338b">Listen()</a>. SO_LISTENQLEN returns the number of unaccepted complete connections. SO_LISTENINCQLEN returns the number of unaccepted incomplete connections.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#afaa7ccade3133a9884ab0b8e44ac18fc">SetSockOpt(int, nn::socket::Level, nn::socket::Option, const void*, nn::socket::SockLenT)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#afaa7ccade3133a9884ab0b8e44ac18fc" title="Set options on a socket. ">SetSockOpt(int, nn::socket::Level, nn::socket::Option, const void*, nn::socket::SockLenT)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad51ebcc4967c212c6922fe29664d49df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::GetSockOpt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pOutOptionValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>pOutOptionLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get socket options - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Level of the option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optionName</td><td>Type of the option </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutOptionValue</td><td>Buffer containing option value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutOptionLength</td><td>Size of the buffer with option value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd>
<dd>
[EBADF] The argument <em>socket</em> is not a valid descriptor. </dd>
<dd>
[ENOTSOCK] The argument <em>socket</em> is not a socket. </dd>
<dd>
[ENOPROTOOPT] The <em>optionName</em> is unknown at the level indicated. </dd>
<dd>
[EINVAL] The <em>pOutOptionValue</em> argument or <em>pOutOptionLength</em> argument are null. </dd>
<dd>
[EINVAL] The value of the <em>pOutOptionLength</em> argument is not valid. </dd>
<dd>
[EFAULT] The address range referred to by <em>pOutOptionValue</em> and the value of <em>pOutOptionLength</em> does not refer to a valid part of the process address space. </dd>
<dd>
[EAGAIN] Resources to complete the request are temporarily unavailable.</dd></dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the value 0 if successful; otherwise the value -1 is returned.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a4aff7a563a6c808b236246a182996761" title="Get socket options. ">GetSockOpt()</a> routine obtains socket options, See <a class="el" href="namespacenn_1_1socket.html#afaa7ccade3133a9884ab0b8e44ac18fc">SetSockOpt()</a> for supported options and their description.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#a4aff7a563a6c808b236246a182996761">GetSockOpt(int, nn::socket::Level, nn::socket::Option, void*, nn::socket::SockLenT*)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a4aff7a563a6c808b236246a182996761" title="Get socket options. ">GetSockOpt(int, nn::socket::Level, nn::socket::Option, void*, nn::socket::SockLenT*)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aae806aef6ab4c881e23c90a3ea379924"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Shutdown </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>how</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable sends and/or receives on a socket - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">how</td><td>Shutdown method</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the value 0 if successful; otherwise the value -1 is returned.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd>
<dd>
[EBADF] The <em>socket</em> argument is not a valid file descriptor. </dd>
<dd>
[EINVAL] The <em>how</em> argument is invalid. </dd>
<dd>
[EOPNOTSUPP] The socket associated with the file descriptor <em>socket</em> does not support this operation. </dd>
<dd>
[ENOTCONN] The <em>socket</em> argument specifies a SOCK_STREAM socket which is not connected. </dd>
<dd>
[ENOTSOCK] The <em>socket</em> argument does not refer to a socket. </dd>
<dd>
[EAGAIN] Resources to complete the request are temporarily unavailable.</dd></dl>
<p><b>詳細</b> <br />
 The shutdown() routine disables sends or receives on a socket. The how argument specifies the type of shutdown.</p>
<p>Possible values are:</p>
<p>SHUT_RD Further receives will be disallowed.</p>
<p>SHUT_WR Further sends will be disallowed. This may cause actions specific to the protocol family of the socket to happen.</p>
<p>SHUT_RDWR Further sends and receives will be disallowed. Implies SHUT_WR.</p>
<p>If the file descriptor <em>socket</em> is associated with a SOCK_STREAM socket, all or part of the full-duplex connection will be shut down.</p>
<p>IMPLEMENTATION NOTES</p>
<p>The following protocol specific actions apply to the use of SHUT_WR (and potentially also SHUT_RDWR), based on the properties of the socket associated with the file descriptor socket.</p>
<table class="doxtable">
<tr>
<th>Domain </th><th>Type </th><th>Protocol </th><th>Return value and action  </th></tr>
<tr>
<td>PF_INET </td><td>SOCK_DGRAM </td><td>IPPROTO_SCTP </td><td>Return -1. The global variable <em>errno</em> will be set to EOPNOTSUPP </td></tr>
<tr>
<td>PF_INET </td><td>SOCK_DGRAM </td><td>IPPROTO_UDP </td><td>Return 0. ICMP messages will not be generated </td></tr>
<tr>
<td>PF_INET </td><td>SOCK_STREAM </td><td>IPPROTO_SCTP </td><td>Return 0. Send queued data and tear down association </td></tr>
<tr>
<td>PF_INET </td><td>SOCK_STREAM </td><td>IPPROTO_TCP </td><td>Return 0. Send queued data, wait for ACK, then send FIN </td></tr>
<tr>
<td>PF_INET6 </td><td>SOCK_DGRAM </td><td>IPPROTO_SCTP </td><td>Return -1. The global variable <em>errno</em> will be set to EOPNOTSUPP </td></tr>
<tr>
<td>PF_INET6 </td><td>SOCK_DGRAM </td><td>IPPROTO_UDP </td><td>Return 0. ICMP messages will not be generated </td></tr>
<tr>
<td>PF_INET6 </td><td>SOCK_STREAM </td><td>IPPROTO_SCTP </td><td>Return 0. Send queued data and tear down association </td></tr>
<tr>
<td>PF_INET6 </td><td>SOCK_STREAM </td><td>IPPROTO_TCP </td><td>Return 0. Send queued data, wait for ACK, then send FIN </td></tr>
</table>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#a895595468f09d14293edd099a8ff7dc5">Shutdown(int, nn::socket::ShutdownMethod)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a895595468f09d14293edd099a8ff7dc5" title="Disable sends and/or receives on a socket. ">Shutdown(int, nn::socket::ShutdownMethod)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a02d79b0ad360df5623268d140ba8b343"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Socket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create endpoint for communication - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Communication domain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Socket type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol</td><td>Protocol type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns -1 on error. If it succeeds, it returns a non-negative integer that is a descriptor for the created socket.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd>
<dd>
[EACCES] Permission to create a socket of the specified type and/or protocol is denied. </dd>
<dd>
[EAFNOSUPPORT] The address family (domain) is not supported or the specified domain is not supported by this protocol family. </dd>
<dd>
[EMFILE] The per-process descriptor table is full. </dd>
<dd>
[ENOBUFS] Insufficient buffer space is available. The socket cannot be created until sufficient resources are freed. </dd>
<dd>
[EPERM] User has insufficient privileges to carry out the requested operation. </dd>
<dd>
[EPROTONOSUPPORT] The protocol type or the specified protocol is not supported within this domain. </dd>
<dd>
[EPROTOTYPE] The socket type is not supported by the protocol. </dd>
<dd>
[EAGAIN] Resources to complete the request are temporarily unavailable.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket()</a> routine creates an endpoint for communication and returns a descriptor. The <em>domain</em> argument specifies a communications domain within which communication will take place; this selects the protocol family which should be used.</p>
<p>The currently understood formats are:</p>
<table class="doxtable">
<tr>
<th>Format </th><th>Description  </th></tr>
<tr>
<td>PF_INET </td><td>Internet version 4 protocols </td></tr>
<tr>
<td>PF_ROUTE </td><td>Internal Routing protocol </td></tr>
<tr>
<td>PF_LINK </td><td>Link layer interface </td></tr>
</table>
<p>The socket has the indicated <em>type</em>, which specifies the semantics of communication.</p>
<p>Currently defined types are:</p>
<table class="doxtable">
<tr>
<th>Type </th><th>Description  </th></tr>
<tr>
<td>SOCK_STREAM </td><td>Stream socket, </td></tr>
<tr>
<td>SOCK_DGRAM </td><td>Datagram socket, </td></tr>
<tr>
<td>SOCK_RAW </td><td>Raw-protocol interface </td></tr>
<tr>
<td>SOCK_RDM </td><td>Reliably-delivered packet </td></tr>
<tr>
<td>SOCK_SEQPACKET </td><td>Sequenced packet stream </td></tr>
</table>
<p>A SOCK_STREAM type provides sequenced, reliable, two-way connection based byte streams. An out-of-band data transmission mechanism may be supported.</p>
<p>A SOCK_DGRAM socket supports datagrams (connectionless, unreliable messages of a fixed (typically small) maximum length).</p>
<p>A SOCK_SEQPACKET socket may provide a sequenced, reliable, two-way connection-based data transmission path for datagrams of fixed maximum length; a consumer may be required to read an entire packet with each read system call. This facility is protocol specific, and presently unimplemented.</p>
<p>SOCK_RAW sockets provide access to internal network protocols and interfaces.</p>
<p>The types SOCK_RAW, which is available only to the super-user, and SOCK_RDM, which is planned, but not yet implemented, are not described here.</p>
<p>Additionally, the following flags are allowed in the type argument:</p>
<p>SOCK_NONBLOCK Set non-blocking mode on the new socket</p>
<p>The protocol argument specifies a particular protocol to be used with the socket. Normally only a single protocol exists to support a particular socket type within a given protocol family. However, it is possible that many protocols may exist, in which case a particular protocol must be specified in this manner. The <em>protocol</em> number to use is particular to the "communication domain" in which communication is to take place.</p>
<p>The <em>protocol</em> argument may be set to zero (0) to request the default implementation of a socket type for the protocol, if any.</p>
<p>Sockets of type SOCK_STREAM are full-duplex byte streams, similar to pipes. A stream socket must be in a connected state before any data may be sent or received on it. A connection to another socket is created with a <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f">Connect()</a> system call. Once connected, data may be transferred using <a class="el" href="namespacenn_1_1socket.html#ae1fd34e9d084e5bb0f17a6c2361896c2">Read()</a> and <a class="el" href="namespacenn_1_1socket.html#ab2284c3d5e78619aecbd0b78d3947936">Write()</a> calls or some variant of the <a class="el" href="namespacenn_1_1socket.html#ae5a4c9f486b94e6b19e563ef97a2e412">Send()</a> and <a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14">Recv()</a> functions. (Some protocol families, such as the Internet family, support the notion of an "implied connect", which permits data to be sent piggybacked onto a connect operation by using the <a class="el" href="namespacenn_1_1socket.html#aacd6b8da24d25e5e4f299b833258826f">SendTo()</a> system call.) When a session has been completed a <a class="el" href="namespacenn_1_1socket.html#ae01110d228e2148d830b1ecfb9aaa425">Close()</a> may be performed. Out-of-band data may also be transmitted as described in <a class="el" href="namespacenn_1_1socket.html#ae5a4c9f486b94e6b19e563ef97a2e412">Send()</a> and received as described in <a class="el" href="namespacenn_1_1socket.html#a5875e388a4010d756c63437dedfe5f14">Recv()</a>.</p>
<p>The communications protocols used to implement a SOCK_STREAM ensure that data is not lost or duplicated. If a piece of data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length of time, then the connection is considered broken and calls will indicate an error with -1 returns and with ETIMEDOUT as the specific code in the global variable <em>errno</em>. The protocols optionally keep sockets "warm" by forcing transmissions roughly every minute in the absence of other activity. An error is then indicated if no response can be elicited on an otherwise idle connection for an extended period (e.g. 5 minutes).</p>
<p>SOCK_SEQPACKET sockets employ the same system calls as SOCK_STREAM sockets. The only difference is that <a class="el" href="namespacenn_1_1socket.html#ae1fd34e9d084e5bb0f17a6c2361896c2">Read()</a> calls will return only the amount of data requested, and any remaining in the arriving packet will be discarded.</p>
<p>SOCK_DGRAM and SOCK_RAW sockets allow sending of datagrams to correspondents named in <a class="el" href="namespacenn_1_1socket.html#ae5a4c9f486b94e6b19e563ef97a2e412">Send()</a> calls. Datagrams are generally received with <a class="el" href="namespacenn_1_1socket.html#adab268741c66f0996683c31b1bcd05dc">RecvFrom()</a>, which returns the next datagram with its return address.</p>
<p>The operation of sockets is controlled by socket level options with <a class="el" href="namespacenn_1_1socket.html#afaa7ccade3133a9884ab0b8e44ac18fc">SetSockOpt()</a> and <a class="el" href="namespacenn_1_1socket.html#a4aff7a563a6c808b236246a182996761">GetSockOpt()</a>.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket(nn::socket::Family, nn::socket::Type, nn::socket::Protocol)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket(nn::socket::Family, nn::socket::Type, nn::socket::Protocol)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae798003ad15f40cf8127fb06587999cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Poll </td>
          <td>(</td>
          <td class="paramtype">pollfd *&#160;</td>
          <td class="paramname"><em>pSocketDescriptors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nfds_t&#160;</td>
          <td class="paramname"><em>numberOfDescriptors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeoutMilliseconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous I/O multiplexing - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pSocketDescriptors</td><td>Array of pollfd structures </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numberOfDescriptors</td><td>Number of pollfd structures </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMilliseconds</td><td>Timeout in milliseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Number of descriptors that are ready for I/O, or -1 if an error occurred. If the time limit expires, <a class="el" href="namespacenn_1_1socket.html#ad9e109d18fb43f275742d74d74d06cde" title="Synchronous I/O multiplexing. ">Poll()</a> returns 0. If <a class="el" href="namespacenn_1_1socket.html#ad9e109d18fb43f275742d74d74d06cde" title="Synchronous I/O multiplexing. ">Poll()</a> returns with an error, file descriptor array will be unmodified.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following: </dd>
<dd>
[EINVAL] The specified time limit is invalid. One of its components is negative or too large. </dd>
<dd>
[EINVAL] The <em>pSocketDescriptors</em> argument is null with non-zero <em>outBufferLength</em> argument. </dd>
<dd>
[EFAULT] The address range referred to by <em>pSocketDescriptors</em> and <em>numberOfDescriptors</em> * sizeof(pollfd) does not refer to a valid part of the process address space. </dd>
<dd>
[EAGAIN] Resources to complete the request are temporarily unavailable.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#ad9e109d18fb43f275742d74d74d06cde" title="Synchronous I/O multiplexing. ">Poll()</a> system call examines a set of file descriptors to see if some of them are ready for I/O. The <em>pSocketDescriptors</em> argument is a pointer to an array of pollfd structures defined as shown below). The <em>numberOfDescriptors</em> argument determines the size of the array.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>pollfd</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span>    fd;       <span class="comment">// file descriptor</span></div>
<div class="line">    <span class="keywordtype">short</span>  events;   <span class="comment">// events to look for</span></div>
<div class="line">    <span class="keywordtype">short</span>  revents;  <span class="comment">// events returned</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>The event bitmasks in events and revents have the following bits:</p>
<table class="doxtable">
<tr>
<th>Event </th><th>Description  </th></tr>
<tr>
<td>POLLIN </td><td>Data other than high priority data may be read without blocking. </td></tr>
<tr>
<td>POLLRDNORM </td><td>Normal data may be read without blocking. </td></tr>
<tr>
<td>POLLRDBAND </td><td>Data with a non-zero priority may be read without blocking. </td></tr>
<tr>
<td>POLLPRI </td><td>High priority data may be read without blocking. </td></tr>
<tr>
<td>POLLOUT </td><td>Normal data may be written without blocking. </td></tr>
<tr>
<td>POLLWRNORM </td><td>Normal data may be written without blocking. </td></tr>
<tr>
<td>POLLWRBAND </td><td>Data with a non-zero priority may be written without blocking. </td></tr>
<tr>
<td>POLLERR </td><td>An exceptional condition has occurred on the device or socket. This flag is always checked, even if not present in the events bitmask. </td></tr>
<tr>
<td>POLLHUP </td><td>The device or socket has been disconnected. This flag is always checked, even if not present in the events bitmask. </td></tr>
<tr>
<td>POLLNVAL </td><td>The file descriptor is not open. This flag is always checked, even if not present in the events bitmask. </td></tr>
</table>
<p>Note that POLLHUP and POLLOUT should never be present in the revents bitmask at the same time.</p>
<p>If <em>timeout</em> is neither zero nor INFTIM (-1), it specifies a maximum interval to wait for any file descriptor to become ready, in milliseconds. If <em>timeout</em> is INFTIM (-1), the poll blocks indefinitely. If <em>timeout</em> is zero, then <a class="el" href="namespacenn_1_1socket.html#ad9e109d18fb43f275742d74d74d06cde" title="Synchronous I/O multiplexing. ">Poll()</a> will return without blocking.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#ad9e109d18fb43f275742d74d74d06cde">Poll(nn::socket::PollFd*, nn::socket::NfdsT, int)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#ad9e109d18fb43f275742d74d74d06cde" title="Synchronous I/O multiplexing. ">Poll(nn::socket::PollFd*, nn::socket::NfdsT, int)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad646fa3b59d55042faa555f9fbd4d501"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Fcntl </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>File control - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket descriptor obtained with <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a> or <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">command</td><td>Control command</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the value 0 if successful; otherwise the value -1 is returned.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd>
<dd>
[EBADF] The argument <em>socket</em> is not a valid descriptor. </dd>
<dd>
[ENOTSOCK] The argument <em>socket</em> does not refer to a socket. </dd>
<dd>
[EOPNOTSUPP] Command is not supported </dd>
<dd>
[EAGAIN] Resources to complete the request are temporarily unavailable.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a92cb62635aca20860e3ab848f347ec6f" title="File control. ">Fcntl()</a> routine provides control over descriptors. The argument <em>socket</em> is a descriptor to be operated on by <em>command</em> as described below. Depending on the value of command, <a class="el" href="namespacenn_1_1socket.html#a92cb62635aca20860e3ab848f347ec6f" title="File control. ">Fcntl()</a> can take additional arguments.</p>
<p>Supported commands:</p>
<p>F_GETFL Get descriptor status flags. Additional arguments are ignored.</p>
<p>The descriptor flags for the F_GETFL command are returned from fcntl. Flags that are supported to be modified are documented in the F_SETFL command below.</p>
<p>F_SETFL Set descriptor status flags. Takes an additional argument - 'flags'</p>
<p>The flags for the F_SETFL flags are as follows:</p>
<p>O_NONBLOCK Non-blocking I/O; if no data is available to a <a class="el" href="namespacenn_1_1socket.html#ae1fd34e9d084e5bb0f17a6c2361896c2">Read</a> system call, or if a <a class="el" href="namespacenn_1_1socket.html#ab2284c3d5e78619aecbd0b78d3947936">Write</a> operation would block, the read or write call returns -1 with the error EAGAIN.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#a92cb62635aca20860e3ab848f347ec6f">Fcntl</a>(int, <a class="el" href="namespacenn_1_1socket.html#ae03bdb6384cac8b1ba7617743144d09f" title="Commands used for nn::socket::Fcntl(). ">nn::socket::FcntlCommand</a>, ...).</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a92cb62635aca20860e3ab848f347ec6f" title="File control. ">Fcntl</a>(int, <a class="el" href="namespacenn_1_1socket.html#ae03bdb6384cac8b1ba7617743144d09f" title="Commands used for nn::socket::Fcntl(). ">nn::socket::FcntlCommand</a>, ...) </dd></dl>

</div>
</div>
<a class="anchor" id="a3a52df3f484b631d21496ff6ad23ec9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Select </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberOfDescriptors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *&#160;</td>
          <td class="paramname"><em>pReadDescriptors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *&#160;</td>
          <td class="paramname"><em>pWriteDescriptors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *&#160;</td>
          <td class="paramname"><em>pExceptDescriptors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timeval *&#160;</td>
          <td class="paramname"><em>pTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous I/O multiplexing - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numberOfDescriptors</td><td>Highest descriptor id plus 1 </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pReadDescriptors</td><td>Read descriptor fdset </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pWriteDescriptors</td><td>Write descriptor fdset </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pExceptDescriptors</td><td>Exception descriptor fdset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pTimeout</td><td>Timeout</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns the number of ready descriptors that are contained in the descriptor sets, or -1 if an error occurred. If the time limit expires, select() returns 0. If select() returns with an error, the descriptor sets will be unmodified.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd>
<dd>
[EBADF] One of the descriptor sets specified an invalid descriptor. </dd>
<dd>
[EINVAL] The specified time limit is invalid. One of its components is negative or too large. </dd>
<dd>
[EINVAL] The <em>numberOfDescriptors</em> argument was invalid. </dd>
<dd>
[EFAULT] One of the arguments <em>pReadDescriptors</em>, <em>pWriteDescriptors</em>, <em>pExceptDescriptors</em>, or <em>pTimeout</em> points to an invalid address. </dd>
<dd>
[EAGAIN] Resources to complete the request are temporarily unavailable.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select()</a> routine examines the I/O descriptor sets whose addresses are passed in <em>pReadDescriptors</em>, <em>pWriteDescriptors</em>, and <em>pExceptDescriptors</em> to see if some of their descriptors are ready for reading, are ready for writing, or have an exceptional condition pending, respectively. The only exceptional condition detectable is out-of-band data received on a socket. The first <em>numberOfDescriptors</em> descriptors are checked in each set; i.e., the descriptors from 0 through <em>numberOfDescriptors-1</em> in the descriptor sets are examined. On return, <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select()</a> replaces the given descriptor sets with subsets consisting of those descriptors that are ready for the requested operation. The <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select()</a> system call returns the total number of ready descriptors in all the sets.</p>
<p>The descriptor sets are stored as bit fields in arrays of integers. The following macros are provided for manipulating such descriptor sets: FD_ZERO(_fdset) initializes a descriptor set fdset to the null set. FD_SET(fd, _fdset) includes a particular descriptor fd in fdset. FD_CLR(fd, _fdset) removes fd from fdset. FD_ISSET(fd, _fdset) is non- zero if fd is a member of fdset, zero otherwise. The behavior of these macros is undefined if a descriptor value is less than zero or greater than or equal to FD_SETSIZE, which is normally at least equal to the maximum number of descriptors supported by the system.</p>
<p>If <em>timeout</em> is not a null pointer, it specifies the maximum interval to wait for the selection to complete. System activity can lengthen the interval by an indeterminate amount.</p>
<p>If <em>timeout</em> is a null pointer, the select blocks indefinitely.</p>
<p>To effect a poll, the timeout argument should not be a null pointer, but it should point to a zero-valued timeval structure.</p>
<p>Any of descriptor sets may be given as null pointers if no descriptors are of interest.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2">Select(int, nn::socket::FdSet*, nn::socket::FdSet*, nn::socket::FdSet*, nn::socket::TimeVal*)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#aa523b16a6004b8748cc0116f9ed65dd2" title="Synchronous I/O multiplexing. ">Select(int, nn::socket::FdSet*, nn::socket::FdSet*, nn::socket::FdSet*, nn::socket::TimeVal*)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5e041f51a4921b2edb1f434f77d0fcb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Ioctl </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control I/O device - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>File descriptor for socket or device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">command</td><td>Device control command </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pData</td><td>Buffer containing command data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataLength</td><td>Size of the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns result of the ioctl operation. If an error has occurred, a value of -1 is returned.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd>
<dd>
[EBADF] The <em>socket</em> argument is not a valid descriptor. </dd>
<dd>
[ENOTTY] The specified request does not apply to the kind of object that the descriptor socket references. </dd>
<dd>
[EINVAL] The request or <em>pData</em> argument is not valid. </dd>
<dd>
[EACCES] Command is not allowed. </dd>
<dd>
[EAGAIN] Resources to complete the request are temporarily unavailable.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a558dc819d133326891523fcaf32303f8" title="Control I/O device. ">Ioctl()</a> routine manipulates the underlying device parameters of special files. The argument <em>fd</em> must be an open file descriptor obtained with either <a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f">Socket()</a>, <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3">Accept()</a>.</p>
<p>The following ioctl commands are supported:</p>
<p>FIONREAD Get the number of bytes that are immediately available for reading. For this command, <em>pData</em> should be a pointer to an int.</p>
<p>FIONWRITE Get the number of bytes in the descriptor's send queue. These bytes are data which has been written to the descriptor but which are being held by the kernel for further processing. The nature of the required processing depends on the underlying device. For TCP sockets, these bytes have not yet been acknowledged by the other side of the connection. For this command, <em>pData</em> should be a pointer to an int.</p>
<p>FIONSPACE Get the free space in the descriptor's send queue. This value is the size of the send queue minus the number of bytes being held in the queue. Note: while this value represents the number of bytes that may be added to the queue, other resource limitations may cause a write not larger than the send queue's space to be blocked. One such limitation would be a lack of network buffers for a write to a network connection. For this command, <em>pData</em> should be a pointer to an int.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated with no replacement.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a9afeb564bac1d0c04af2fec1f00c739f" title="Create endpoint for communication. ">Socket(nn::socket::Family, nn::socket::Type, nn::socket::Protocol)</a>, <a class="el" href="namespacenn_1_1socket.html#a56b1fbede96c61d4c94ba51a3cc563b3" title="Accept connection on a socket. ">Accept(int, nn::socket::SockAddr*, nn::socket::SockLenT*)</a>, <a class="el" href="namespacenn_1_1socket.html#a6db6951cb084f74f4c17d655ce798890" title="Read the global variable errno. ">GetLastError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a63d8cbd2ba272200139641e16adba995"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* nn::socket::GetHErrno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return host <em>errno</em> (<em>h_errno</em>) for <a class="el" href="namespacenn_1_1socket.html#a1e9d1531ba7ecd1f6d4438629540517a">GetHostByName()</a> / <a class="el" href="namespacenn_1_1socket.html#a74f8cbca4f89a3a5c6016c343c2e8e49">GetHostByAddr()</a> - This API will be deprecated in an upcoming SDK release. </p>
<dl class="section return"><dt>戻り値</dt><dd>This function returns on of the following: </dd>
<dd>
NETDB_INTERNAL </dd>
<dd>
NETDB_SUCCESS </dd>
<dd>
HOST_NOT_FOUND </dd>
<dd>
TRY_AGAIN </dd>
<dd>
NO_RECOVERY </dd>
<dd>
NO_DATA </dd>
<dd>
NO_ADDRESS</dd></dl>
<p><b>詳細</b> <br />
 This function is used only to determine error conditions, it is also thread-localized.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#ad0a68baef0699e3e0063d3b686176b4c">GetHError()</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#ad0a68baef0699e3e0063d3b686176b4c" title="Return pointer to host errno (h_errno) for GetHostEntByName() and GetHostEntByAddr(). ">GetHError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1e9d1531ba7ecd1f6d4438629540517a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hostent* nn::socket::GetHostByName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up AF_INET host IP address by hostname - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pName</td><td>The name of the host to look up (e.g. www.nintendo.com)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns a struct hostent or NULL on error with error detail in <a class="el" href="namespacenn_1_1socket.html#a63d8cbd2ba272200139641e16adba995">GetHErrno()</a>.</dd></dl>
<p><b>詳細</b> <br />
 The return value of this function is thread-localized, this deviates from some POSIX implementations. The return value is managed internally, so if you wish to keep the value between calls, a deep copy must be performed.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#a358030926e9e63c2e322de2bd3d26719">GetHostEntByName(const char*)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a358030926e9e63c2e322de2bd3d26719" title="Look up Family::Af_Inet host IP address by hostname. ">GetHostEntByName(const char*)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a74f8cbca4f89a3a5c6016c343c2e8e49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hostent* nn::socket::GetHostByAddr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addressFamily</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up the address value for a host for AF_INET - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAddress</td><td>This value shall be an in_addr structure that contains a binary address in network byte order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The size of the structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addressFamily</td><td>Currently only AF_INET is supported</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns a struct hostent or NULL on error with error detail in <a class="el" href="namespacenn_1_1socket.html#a63d8cbd2ba272200139641e16adba995">GetHErrno()</a>.</dd></dl>
<p><b>詳細</b> <br />
 The return value of this function is thread-localized, which deviates from some POSIX implementations. The return value is managed internally, so if you wish to keep the value between calls, a deep copy must be performed.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#aaace32e2780295ca03bc72efa4b49406">GetHostEntByAddr(const void*, nn::socket::SockLenT, nn::socket::Family)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#aaace32e2780295ca03bc72efa4b49406" title="Look up the address value for a host for Family::Af_Inet. ">GetHostEntByAddr(const void*, nn::socket::SockLenT, nn::socket::Family)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a10c63718faf9f078228e3818e19e1de3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::socket::HStrError </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>errorNumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a human-readable version of h_error / <a class="el" href="namespacenn_1_1socket.html#ad0a68baef0699e3e0063d3b686176b4c" title="Return pointer to host errno (h_errno) for GetHostEntByName() and GetHostEntByAddr(). ">GetHError()</a> - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">errorNumber</td><td>The <em>h_errno</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns a string representing the error number or NULL if out-of-memory.</dd></dl>
<p><b>詳細</b> <br />
 The return value of this function is thread-localized, this deviates from some POSIX implementations. The return value is managed internally, so if you wish to maintain the value between calls, a copy must be made.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#aba34614a3ddfe25e5bf3e5a77613832e">HStrError(nn::socket::HErrno)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#aba34614a3ddfe25e5bf3e5a77613832e" title="Return a human-readable version of h_error / GetHError(). ">HStrError(nn::socket::HErrno)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa323d8a7f14fd5b1e10c35a552f1c877"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::GetAddrInfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pNodeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pServername</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const addrinfo *&#160;</td>
          <td class="paramname"><em>pHints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">addrinfo **&#160;</td>
          <td class="paramname"><em>pResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of IP addresses and port numbers - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pNodeName</td><td>the name of the host or NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pServername</td><td>the name of the service or NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pHints</td><td>is an optional pointer to a struct addrinfo as defined by netdb.h. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pResult</td><td>an out parameter containing 0, 1, or many (via ai_next) addrinfo structures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns one of the following values: </dd>
<dd>
NETDB_INTERNAL see <a class="el" href="namespacenn_1_1socket.html#acdfb1891ce7a1cc01f95f3e620235b1a">GetLastErrno()</a> </dd>
<dd>
NETDB_SUCCESS no problem </dd>
<dd>
HOST_NOT_FOUND Authoritative Answer Host not found </dd>
<dd>
TRY_AGAIN Non-Authoritative Host not found, or SERVERFAIL </dd>
<dd>
NO_RECOVERY Non recoverable errors, FORMERR, REFUSED, NOTIMP </dd>
<dd>
NO_DATA Valid name, no data record of requested type </dd>
<dd>
NO_ADDRESS no address, look for MX record</dd></dl>
<p><b>詳細</b> <br />
 <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60" title="Get a list of IP addresses and port numbers. ">GetAddrInfo()</a> routine can be used to obtain list of IP addresses and port numbers for host <em>pNodename</em> and service <em>pServername</em>. It provides more flexibility than <a class="el" href="namespacenn_1_1socket.html#a1e9d1531ba7ecd1f6d4438629540517a">GetHostByName()</a>.</p>
<p>Please note that <em>pNodename</em> and <em>pServername</em> cannot both be NULL at the same time.</p>
<p>The addrinfo result <em>pResult</em> returned by this function can be deallocated via <a class="el" href="namespacenn_1_1socket.html#a243828270d581fb029a86292031a30cf">FreeAddrInfo()</a>.</p>
<p>The optional pHint can be used to provide hints concerning the type of socket that the caller supports or wishes to use. The caller can supply the following structure elements in hints:</p>
<p>ai_family The protocol family that should be used. When ai_family is set to PF_UNSPEC, it means the caller will accept any protocol family supported by the operating system.</p>
<p>ai_socktype Denotes the type of socket that is wanted: SOCK_STREAM, SOCK_DGRAM, or SOCK_RAW. When ai_socktype is zero the caller will accept any socket type.</p>
<p>ai_protocol Indicates which transport protocol is desired, IPPROTO_UDP or IPPROTO_TCP. If ai_protocol is zero the caller will accept any protocol.</p>
<p>ai_flags The ai_flags field to which the hints parameter points shall be set to zero or be the bitwise-inclusive OR of one or more of the values AI_ADDRCONFIG, AI_CANONNAME, AI_NUMERICHOST, AI_NUMERICSERV and AI_PASSIVE.</p>
<p>AI_ADDRCONFIG If the AI_ADDRCONFIG bit is set, IPv4 addresses shall be returned only if an IPv4 address is configured on the local system, and IPv6 addresses shall be returned only if an IPv6 address is configured on the local system.</p>
<p>AI_CANONNAME If the AI_CANONNAME bit is set, a successful call to <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60">GetAddrInfo()</a> will return a NUL-terminated string containing the canonical name of the specified hostname in the ai_canonname element of the first addrinfo structure returned.</p>
<p>AI_NUMERICHOST If the AI_NUMERICHOST bit is set, it indicates that hostname should be treated as a numeric string defining an IPv4 or IPv6 address and resolution should be attempted.</p>
<p>AI_NUMERICSERV If the AI_NUMERICSERV bit is set, then a non-null servname string supplied shall be a numeric port string. Otherwise, an EAI_NONAME error shall be returned. This bit shall prevent any type of name resolution service (for example, NIS+) from being invoked.</p>
<p>AI_PASSIVE If the AI_PASSIVE bit is set it indicates that the returned socket address structure is intended for use in a call to bind(2). In this case, if the hostname argument is the null pointer, then the IP address portion of the socket address structure will be set to INADDR_ANY for an IPv4 address or IN6ADDR_ANY_INIT for an IPv6 address.</p>
<p>If the AI_PASSIVE bit is not set, the returned socket address structure will be ready for use in a call to <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f" title="Initiate a connection on a socket. ">Connect()</a> for a connection-oriented protocol or <a class="el" href="namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f" title="Initiate a connection on a socket. ">Connect()</a>, <a class="el" href="namespacenn_1_1socket.html#aacd6b8da24d25e5e4f299b833258826f" title="Send a message from a socket. ">SendTo()</a>, or <a class="el" href="namespacenn_1_1socket.html#a5c6903b76c9ba427731abe0f0349d79a" title="Send a message from a socket - This API will be deprecated in an upcoming SDK release. ">SendMsg()</a> if a connectionless protocol was chosen. The IP address portion of the socket address structure will be set to the loopback address if hostname is the null pointer and AI_PASSIVE is not set.</p>
<p>All other elements of the addrinfo structure passed via hints must be zero or the null pointer.</p>
<p>If hints is the null pointer, getaddrinfo() behaves as if the caller provided a struct addrinfo with ai_family set to PF_UNSPEC and all other elements set to zero or NULL.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60">GetAddrInfo(const char*, const char*, const nn::socket::AddrInfo*, nn::socket::AddrInfo**)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60" title="Get a list of IP addresses and port numbers. ">GetAddrInfo(const char*, const char*, const nn::socket::AddrInfo*, nn::socket::AddrInfo**)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0b36451977a644918fa15c7197175280"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::socket::FreeAddrInfo </td>
          <td>(</td>
          <td class="paramtype">addrinfo *&#160;</td>
          <td class="paramname"><em>addrInfoStorage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the address info structure - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addrInfoStorage</td><td>pointer to an addrinfo structure that was returned by <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60" title="Get a list of IP addresses and port numbers. ">GetAddrInfo()</a> / <a class="el" href="namespacenn_1_1socket.html#a243828270d581fb029a86292031a30cf" title="Free the address info structure. ">FreeAddrInfo()</a></td></tr>
  </table>
  </dd>
</dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a243828270d581fb029a86292031a30cf" title="Free the address info structure. ">FreeAddrInfo()</a> routine can be used to free structured returned by <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60">GetAddrInfo()</a> / <a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3">GetNameInfo()</a>.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#a243828270d581fb029a86292031a30cf">FreeAddrInfo(nn::socket::AddrInfo*)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a243828270d581fb029a86292031a30cf" title="Free the address info structure. ">FreeAddrInfo(nn::socket::AddrInfo*)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab7205d9966bbcd59d74851c6a49c8af9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::socket::GAIStrError </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>errorCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a human-readable version of the return value from <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60" title="Get a list of IP addresses and port numbers. ">GetAddrInfo()</a> / <a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3" title="Convert a SockAddr structure to a pair of host name and service strings. ">GetNameInfo()</a> - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">errorCode</td><td>Error code for translation to human readable format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns a c-string human readable representation of the error code provided</dd></dl>
<p><b>詳細</b> <br />
 The GAIStrError routine() is used to obtain human readable version of the return value from <a class="el" href="namespacenn_1_1socket.html#aba7c9ca6a33baa3c3216c2de2c320f60">GetAddrInfo()</a> and <a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3">GetNameInfo()</a>. The return value of this function is thread-localized, this deviates from some POSIX implementations. The return value is managed internally, if you wish to maintain the value between calls a copy must be made.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#a790112f00a11cf992ba2e04795c9590f">GAIStrError(nn::socket::AiErrno)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a790112f00a11cf992ba2e04795c9590f" title="Return a human-readable version of the return value from GetAddrInfo() or GetNameInfo(). ">GAIStrError(nn::socket::AiErrno)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acef9dd54c970e22be5bce832726cf14e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::GetNameInfo </td>
          <td>(</td>
          <td class="paramtype">const sockaddr *&#160;</td>
          <td class="paramname"><em>socketAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>socketAddressLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>hostLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>serviceLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a sockaddr structure to a pair of host name and service strings - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socketAddress</td><td>The sockaddr structure socketAddress should point to a sockaddr_in that is socketAddressLength bytes long. Note: sockaddr_in6 / sockaddr_dl are not currently supported. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">socketAddressLength</td><td>The size of the socckaddr structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">host</td><td>The hostname buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hostLength</td><td>The length of the hostname buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">service</td><td>The service name buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">serviceLength</td><td>The length of the service name buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns one of the following values: </dd>
<dd>
NETDB_INTERNAL see <a class="el" href="namespacenn_1_1socket.html#acdfb1891ce7a1cc01f95f3e620235b1a">GetLastErrno()</a>. </dd>
<dd>
NETDB_SUCCESS No problem. </dd>
<dd>
HOST_NOT_FOUND Authoritative Answer Host not found. </dd>
<dd>
TRY_AGAIN Non-Authoritative Host not found, or SERVERFAIL. </dd>
<dd>
NO_RECOVERY Non recoverable errors, FORMERR, REFUSED, NOTIMP. </dd>
<dd>
NO_DATA Valid name, no data record of requested type. </dd>
<dd>
NO_ADDRESS No address, look for MX record.</dd></dl>
<p><b>詳細</b> <br />
 The <a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3" title="Convert a SockAddr structure to a pair of host name and service strings. ">GetNameInfo()</a> function is used to convert a sockaddr structure to a pair of host name and service strings. It provides more flexibility than the <a class="el" href="namespacenn_1_1socket.html#a74f8cbca4f89a3a5c6016c343c2e8e49">GetHostByAddr()</a>. The addrinfo result <em>pResult</em> returned by this function can be deallocated via <a class="el" href="namespacenn_1_1socket.html#a243828270d581fb029a86292031a30cf">FreeAddrInfo()</a>.</p>
<p><em>flags</em> argument is formed by OR'ing the following values from netdb.h:</p>
<p>NI_NOFQDN A fully qualified domain name is not required for local hosts. The local part of the fully qualified domain name is returned instead.</p>
<p>NI_NUMERICHOST Return the address in numeric form, as if calling <a class="el" href="namespacenn_1_1socket.html#a43969e788b0959ef0007b481f45c3a4a">InetNtop()</a>, instead of a host name.</p>
<p>NI_NAMEREQD A name is required. If the host name cannot be found in DNS and this flag is set, a non-zero error code is returned. If the host name is not found and the flag is not set, the address is returned in numeric form.</p>
<p>NI_NUMERICSERV The service name is returned as a digit string repre- senting the port number.</p>
<p>NI_DGRAM Specifies that the service being looked up is a datagram service.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated. Please use <a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3">GetNameInfo(const nn::socket::SockAddr*, nn::socket::SockLenT, char*, size_t, char*, size_t, nn::socket::NameInfoFlag)</a>.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1socket.html#a27ecfbc5167401b34339e6a5085686b3" title="Convert a SockAddr structure to a pair of host name and service strings. ">GetNameInfo(const nn::socket::SockAddr*, nn::socket::SockLenT, char*, size_t, char*, size_t, nn::socket::NameInfoFlag)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aba25bf75426cccb61a32efa1f70792ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::socket::Open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open network device for reading/writing - This API will be deprecated in an upcoming SDK release. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Ignored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Returns non-negative file descriptor, or -1 if an error occurred.</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd>In the case of an error, the global variable <em>errno</em> will be set to one of the following:</dd>
<dd>
[EOPNOTSUPP] Invalid path or device does not support open call. </dd>
<dd>
[EINVAL] The <em>path</em> argument is null. </dd>
<dd>
[EPERM] User has insufficient privileges to carry out the requested operation. </dd>
<dd>
[EFAULT] The <em>path</em> argument points outside the process's allocated address space. </dd>
<dd>
[EAGAIN] Resources to complete the request are temporarily unavailable.</dd></dl>
<p><b>詳細</b> <br />
 The file name specified by <em>path</em> is opened for reading and/or writing as specified by the argument <em>flags</em>, and the file descriptor returned to the calling process. When operations on fd are completed, file descriptor needs to be released by calling <a class="el" href="namespacenn_1_1socket.html#ae01110d228e2148d830b1ecfb9aaa425">Close()</a>.</p>
<p>In the current implementation only '/dev/bpf' device can be accessed via <a class="el" href="namespacenn_1_1socket.html#aba25bf75426cccb61a32efa1f70792ad" title="Open network device for reading/writing - This API will be deprecated in an upcoming SDK release...">Open()</a>. 'flags' argument is not used.</p>
<p>This function requires calling <a class="el" href="namespacenn_1_1socket.html#adacc3405184e8f28fb630745b9f43db0">Initialize()</a> before it can be used.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This function will soon be deprecated with no replacement.</dd></dl>
<dl class="section see"><dt>参照</dt><dd>Open(const char* path, nn::socket::OpenFlag) </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
