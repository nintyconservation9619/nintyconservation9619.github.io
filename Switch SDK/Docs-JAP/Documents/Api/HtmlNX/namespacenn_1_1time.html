<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>NintendoSDK API Reference: nn::time 名前空間</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>総合概要</span></a></li>
      <li><a href="pages.html"><span>諸情報</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li class="current"><a href="namespaces.html"><span>名前空間</span></a></li>
      <li><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>名前空間一覧</span></a></li>
      <li><a href="namespacemembers.html"><span>名前空間メンバ</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1time.html">time</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">クラス</a> &#124;
<a href="#enum-members">列挙型</a> &#124;
<a href="#var-members">変数</a>  </div>
  <div class="headertitle">
<div class="title">nn::time 名前空間</div>  </div>
</div><!--header-->
<div class="contents">

<p>TIME ライブラリの名前空間です。  
<a href="#details">[詳解]</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
クラス</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1time_1_1_adjustable_network_system_clock.html">AdjustableNetworkSystemClock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">システム側時刻に任意のタイミングで揃えることが可能な、ネットワークから自動補正される時計を表すクロックです。  <a href="classnn_1_1time_1_1_adjustable_network_system_clock.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1time_1_1_adjustable_user_system_clock.html">AdjustableUserSystemClock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">システム側時刻に任意のタイミングで揃えることが可能な、ユーザー時計を表すクロックです。  <a href="classnn_1_1time_1_1_adjustable_user_system_clock.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1time_1_1_calendar_additional_info.html">CalendarAdditionalInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">カレンダーの追加情報を扱う構造体です。  <a href="structnn_1_1time_1_1_calendar_additional_info.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1time_1_1_calendar_time.html">CalendarTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">カレンダー情報を扱う構造体です。  <a href="structnn_1_1time_1_1_calendar_time.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1time_1_1_check_calendar_time_callback.html">CheckCalendarTimeCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">日時を確認するためのコールバッククラス  <a href="classnn_1_1time_1_1_check_calendar_time_callback.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1time_1_1_clock_snapshot.html">ClockSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">時計の各種情報を保持するクラスです。  <a href="classnn_1_1time_1_1_clock_snapshot.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1time_1_1_location_name.html">LocationName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">地域名を扱う構造体です。  <a href="structnn_1_1time_1_1_location_name.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1time_1_1_periodic_benefit_claim_context.html">PeriodicBenefitClaimContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">定期的な利益を得られるかどうかの判定に用いる情報を保持する構造体です。  <a href="structnn_1_1time_1_1_periodic_benefit_claim_context.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1time_1_1_posix_time.html">PosixTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">POSIX 標準の時刻を表す構造体です。  <a href="structnn_1_1time_1_1_posix_time.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1time_1_1_result_clock_invalid.html">ResultClockInvalid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (time: 時計が無効になっています) を表すクラスです。  <a href="classnn_1_1time_1_1_result_clock_invalid.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1time_1_1_result_no_capability.html">ResultNoCapability</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (time: 適切な権限がありません) を表すクラスです。  <a href="classnn_1_1time_1_1_result_no_capability.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1time_1_1_result_not_comparable.html">ResultNotComparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (time: 与えられた2つの値に連続性がなく、比較・減算できません) を表すクラスです。  <a href="classnn_1_1time_1_1_result_not_comparable.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1time_1_1_result_not_initialized.html">ResultNotInitialized</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (time: ライブラリが初期化されていません) を表すクラスです。  <a href="classnn_1_1time_1_1_result_not_initialized.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1time_1_1_result_out_of_memory.html">ResultOutOfMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (time: 内部メモリが不足しています) を表すクラスです。  <a href="classnn_1_1time_1_1_result_out_of_memory.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1time_1_1_result_out_of_resource.html">ResultOutOfResource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (time: 内部リソースが不足しています) を表すクラスです。  <a href="classnn_1_1time_1_1_result_out_of_resource.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1time_1_1_result_overflowed.html">ResultOverflowed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1_result.html">エラー Result</a> (time: オーバーフローまたはアンダーフローが発生しました) を表すクラスです。  <a href="classnn_1_1time_1_1_result_overflowed.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1time_1_1_standard_network_system_clock.html">StandardNetworkSystemClock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ネットワークから自動補正される時計を表すクロックです。  <a href="classnn_1_1time_1_1_standard_network_system_clock.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1time_1_1_standard_steady_clock.html">StandardSteadyClock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SoC 外部に電源を持つ単調増加クロックです。  <a href="classnn_1_1time_1_1_standard_steady_clock.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1time_1_1_standard_user_system_clock.html">StandardUserSystemClock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザーが操作可能なデバイスの時計(ユーザー時計)を表すクロックです。  <a href="classnn_1_1time_1_1_standard_user_system_clock.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1time_1_1_steady_clock_time_point.html">SteadyClockTimePoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">単調増加クロックが指し示す値を表す構造体です。  <a href="structnn_1_1time_1_1_steady_clock_time_point.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1time_1_1_system_clock_context.html">SystemClockContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">日時を返すクロックのコンテキストを表す構造体です。  <a href="structnn_1_1time_1_1_system_clock_context.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1time_1_1_system_clock_traits.html">SystemClockTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NintendoSDK のシステムクロックが扱う型を定義しているクラスです。  <a href="classnn_1_1time_1_1_system_clock_traits.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1time_1_1_time_zone.html">TimeZone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ある地域の特定時期に適用されるタイムゾーンを表す構造体です。  <a href="structnn_1_1time_1_1_time_zone.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnn_1_1time_1_1_time_zone_rule.html">TimeZoneRule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">タイムゾーンルールを表す型です。  <a href="structnn_1_1time_1_1_time_zone_rule.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
列挙型</h2></td></tr>
<tr class="memitem:a177bcc334d2637177f1b116a416b2c43"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#a177bcc334d2637177f1b116a416b2c43">DayOfWeek</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1time.html#a177bcc334d2637177f1b116a416b2c43aa602069842f184fcbe971b3f6a2bfd27">DayOfWeek_Sunday</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1time.html#a177bcc334d2637177f1b116a416b2c43aa90ad97eba8a9c95d6c2c7eb36d2c1fb">DayOfWeek_Monday</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1time.html#a177bcc334d2637177f1b116a416b2c43a7204b58630553e4c2c92b22865f5069b">DayOfWeek_Tuesday</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1time.html#a177bcc334d2637177f1b116a416b2c43aaaafd54d67f6485cd36f770041d8fc6d">DayOfWeek_Wednesday</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1time.html#a177bcc334d2637177f1b116a416b2c43a28dbbe40c3f2bba2848f9548c23adb81">DayOfWeek_Thursday</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1time.html#a177bcc334d2637177f1b116a416b2c43a6928999430b5f5086786536021cda79d">DayOfWeek_Friday</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1time.html#a177bcc334d2637177f1b116a416b2c43ae60a88e9a46bcf59a66e62e206b167f3">DayOfWeek_Saturday</a>
<br />
 }<tr class="memdesc:a177bcc334d2637177f1b116a416b2c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">曜日を表す列挙型です。  <a href="namespacenn_1_1time.html#a177bcc334d2637177f1b116a416b2c43">[詳解]</a><br /></td></tr>
<tr class="separator:a177bcc334d2637177f1b116a416b2c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:abc313af281fff1f227bad03284e1c2ad"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#abc313af281fff1f227bad03284e1c2ad">PeriodicBenefitClaimResult</a> { <br />
&#160;&#160;<a class="el" href="namespacenn_1_1time.html#abc313af281fff1f227bad03284e1c2ada8a0603d107ba2cda011ae792b7cc3a39">PeriodicBenefitClaimResult_Success</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1time.html#abc313af281fff1f227bad03284e1c2ada38e1826e9ae5442c64a8dec9d2604af8">PeriodicBenefitClaimResult_NotReceivableTiming</a>, 
<br />
&#160;&#160;<a class="el" href="namespacenn_1_1time.html#abc313af281fff1f227bad03284e1c2ada7d525d793c5f7200173a1f49355861cc">PeriodicBenefitClaimResult_Penalty</a>
<br />
 }<tr class="memdesc:abc313af281fff1f227bad03284e1c2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">利益を得られるかどうかの判定結果を表す列挙型です。  <a href="namespacenn_1_1time.html#abc313af281fff1f227bad03284e1c2ad">[詳解]</a><br /></td></tr>
<tr class="separator:abc313af281fff1f227bad03284e1c2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
関数</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">初期化と終了処理</div></td></tr>
<tr class="memitem:af3d5226ce5093e581b3892fbb2fbc34c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#af3d5226ce5093e581b3892fbb2fbc34c">Initialize</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af3d5226ce5093e581b3892fbb2fbc34c"><td class="mdescLeft">&#160;</td><td class="mdescRight">TIME ライブラリの初期化をおこない、機能を使用可能な状態にします。  <a href="#af3d5226ce5093e581b3892fbb2fbc34c">[詳解]</a><br /></td></tr>
<tr class="separator:af3d5226ce5093e581b3892fbb2fbc34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5d341f8b8024312cbb9ad67f205938"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#acd5d341f8b8024312cbb9ad67f205938">IsInitialized</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acd5d341f8b8024312cbb9ad67f205938"><td class="mdescLeft">&#160;</td><td class="mdescRight">TIME ライブラリが初期化済みかを判定します。  <a href="#acd5d341f8b8024312cbb9ad67f205938">[詳解]</a><br /></td></tr>
<tr class="separator:acd5d341f8b8024312cbb9ad67f205938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316a48243971bfac1dfcc1ea07466563"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#a316a48243971bfac1dfcc1ea07466563">Finalize</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a316a48243971bfac1dfcc1ea07466563"><td class="mdescLeft">&#160;</td><td class="mdescRight">TIME ライブラリの利用を終了します。  <a href="#a316a48243971bfac1dfcc1ea07466563">[詳解]</a><br /></td></tr>
<tr class="separator:a316a48243971bfac1dfcc1ea07466563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ユーティリティ API</div></td></tr>
<tr class="memitem:a029976fde1c33e311557957f3fc57a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#a029976fde1c33e311557957f3fc57a6b">GetSpanBetween</a> (int64_t *pOutSeconds, const <a class="el" href="structnn_1_1time_1_1_steady_clock_time_point.html">SteadyClockTimePoint</a> &amp;from, const <a class="el" href="structnn_1_1time_1_1_steady_clock_time_point.html">SteadyClockTimePoint</a> &amp;to) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a029976fde1c33e311557957f3fc57a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">2つの <a class="el" href="structnn_1_1time_1_1_steady_clock_time_point.html" title="単調増加クロックが指し示す値を表す構造体です。 ">nn::time::SteadyClockTimePoint</a> 間の経過秒数を計算します。  <a href="#a029976fde1c33e311557957f3fc57a6b">[詳解]</a><br /></td></tr>
<tr class="separator:a029976fde1c33e311557957f3fc57a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a30636ce435336011030d45327e17d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#a73a30636ce435336011030d45327e17d">IsLeapYear</a> (int year) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a73a30636ce435336011030d45327e17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定した西暦がうるう年かどうかを判定します。  <a href="#a73a30636ce435336011030d45327e17d">[詳解]</a><br /></td></tr>
<tr class="separator:a73a30636ce435336011030d45327e17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd9bd6af9ce3c2302e8bbb7ac28fdc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#abfd9bd6af9ce3c2302e8bbb7ac28fdc4">IsValidDate</a> (int year, int month, int day) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:abfd9bd6af9ce3c2302e8bbb7ac28fdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定した年月日が有効かどうかをチェックします。  <a href="#abfd9bd6af9ce3c2302e8bbb7ac28fdc4">[詳解]</a><br /></td></tr>
<tr class="separator:abfd9bd6af9ce3c2302e8bbb7ac28fdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c5cca1bcbbdff76aa6dedf156ef12a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#a85c5cca1bcbbdff76aa6dedf156ef12a">GetDaysInMonth</a> (int year, int month) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a85c5cca1bcbbdff76aa6dedf156ef12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">年月を指定してその月が何日あるかを取得します。  <a href="#a85c5cca1bcbbdff76aa6dedf156ef12a">[詳解]</a><br /></td></tr>
<tr class="separator:a85c5cca1bcbbdff76aa6dedf156ef12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3ec0bb884c0797a5f593318e505fac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#aaf3ec0bb884c0797a5f593318e505fac">DateToDays</a> (int year, int month, int day) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aaf3ec0bb884c0797a5f593318e505fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">年月日を 西暦1年1月1日 からの経過日数へ変換します。  <a href="#aaf3ec0bb884c0797a5f593318e505fac">[詳解]</a><br /></td></tr>
<tr class="separator:aaf3ec0bb884c0797a5f593318e505fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a1933058acb7121d73b209dffc71e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#a93a1933058acb7121d73b209dffc71e9">DaysToDate</a> (int *pOutYear, int *pOutMonth, int *pOutDay, int days) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a93a1933058acb7121d73b209dffc71e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">西暦1年1月1日 からの経過日数を年月日へ変換します。  <a href="#a93a1933058acb7121d73b209dffc71e9">[詳解]</a><br /></td></tr>
<tr class="separator:a93a1933058acb7121d73b209dffc71e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826bc69f7d326cda6bfbea67228fe0e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1time.html#a177bcc334d2637177f1b116a416b2c43">DayOfWeek</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#a826bc69f7d326cda6bfbea67228fe0e5">GetDayOfWeek</a> (int year, int month, int day) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a826bc69f7d326cda6bfbea67228fe0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">年月日を指定して曜日を取得します。  <a href="#a826bc69f7d326cda6bfbea67228fe0e5">[詳解]</a><br /></td></tr>
<tr class="separator:a826bc69f7d326cda6bfbea67228fe0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ClockSnapshot 向けAPI</div></td></tr>
<tr class="memitem:aa5e24f241a0806d6ac316075b655b3f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1time.html#abc313af281fff1f227bad03284e1c2ad">PeriodicBenefitClaimResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#aa5e24f241a0806d6ac316075b655b3f7">ClaimPeriodicBenefitWithUserSystemClock</a> (<a class="el" href="structnn_1_1time_1_1_periodic_benefit_claim_context.html">PeriodicBenefitClaimContext</a> *pHandover, const <a class="el" href="classnn_1_1time_1_1_clock_snapshot.html">ClockSnapshot</a> &amp;currentSnapshot, const <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> &amp;maxPenaltyTimeSpan, const <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> &amp;acceptableOperationTimeSpan, const <a class="el" href="classnn_1_1time_1_1_check_calendar_time_callback.html">CheckCalendarTimeCallback</a> *pCheckCalendarTimeCallback) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa5e24f241a0806d6ac316075b655b3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザー時計の操作を考慮した上で、定期的な利益を得られるかどうかを判定します。  <a href="#aa5e24f241a0806d6ac316075b655b3f7">[詳解]</a><br /></td></tr>
<tr class="separator:aa5e24f241a0806d6ac316075b655b3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebe8af7470bcbe489878e09cde9f3cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#a7ebe8af7470bcbe489878e09cde9f3cd">CalculateStandardUserSystemClockDifferenceByUser</a> (const <a class="el" href="classnn_1_1time_1_1_clock_snapshot.html">ClockSnapshot</a> &amp;from, const <a class="el" href="classnn_1_1time_1_1_clock_snapshot.html">ClockSnapshot</a> &amp;to) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7ebe8af7470bcbe489878e09cde9f3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザー時計がユーザーによって意図的に操作された量を取得します。  <a href="#a7ebe8af7470bcbe489878e09cde9f3cd">[詳解]</a><br /></td></tr>
<tr class="separator:a7ebe8af7470bcbe489878e09cde9f3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992889d77943f2f8f8d0c827ebd7eef1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#a992889d77943f2f8f8d0c827ebd7eef1">CalculateSpanBetween</a> (<a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> *pOut, const <a class="el" href="classnn_1_1time_1_1_clock_snapshot.html">ClockSnapshot</a> &amp;from, const <a class="el" href="classnn_1_1time_1_1_clock_snapshot.html">ClockSnapshot</a> &amp;to) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a992889d77943f2f8f8d0c827ebd7eef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">2つの <a class="el" href="classnn_1_1time_1_1_clock_snapshot.html" title="時計の各種情報を保持するクラスです。 ">nn::time::ClockSnapshot</a> 間の実時間での経過時間を計算します。  <a href="#a992889d77943f2f8f8d0c827ebd7eef1">[詳解]</a><br /></td></tr>
<tr class="separator:a992889d77943f2f8f8d0c827ebd7eef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">タイムゾーンを扱う API</div></td></tr>
<tr class="memitem:a8e7d7a0e92e652c83c9ec02fdd76d92f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#a8e7d7a0e92e652c83c9ec02fdd76d92f">GetDeviceLocationName</a> (<a class="el" href="structnn_1_1time_1_1_location_name.html">LocationName</a> *pOut) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8e7d7a0e92e652c83c9ec02fdd76d92f"><td class="mdescLeft">&#160;</td><td class="mdescRight">デバイスに設定されている地域名を取得します。  <a href="#a8e7d7a0e92e652c83c9ec02fdd76d92f">[詳解]</a><br /></td></tr>
<tr class="separator:a8e7d7a0e92e652c83c9ec02fdd76d92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f1303ca25d1cb0625a6f1187b2b0f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#a44f1303ca25d1cb0625a6f1187b2b0f6">LoadTimeZoneRule</a> (<a class="el" href="structnn_1_1time_1_1_time_zone_rule.html">TimeZoneRule</a> *pOut, const <a class="el" href="structnn_1_1time_1_1_location_name.html">LocationName</a> &amp;name) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a44f1303ca25d1cb0625a6f1187b2b0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">地域名を指定してタイムゾーンルールを読み込みます。  <a href="#a44f1303ca25d1cb0625a6f1187b2b0f6">[詳解]</a><br /></td></tr>
<tr class="separator:a44f1303ca25d1cb0625a6f1187b2b0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607660798bed9111b9157807fce0a413"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#a607660798bed9111b9157807fce0a413">ToCalendarTime</a> (<a class="el" href="structnn_1_1time_1_1_calendar_time.html">CalendarTime</a> *pOutCalendar, <a class="el" href="structnn_1_1time_1_1_calendar_additional_info.html">CalendarAdditionalInfo</a> *pOutCalendarAdditionalInfo, const <a class="el" href="structnn_1_1time_1_1_posix_time.html">PosixTime</a> &amp;posixTime, const <a class="el" href="structnn_1_1time_1_1_time_zone_rule.html">TimeZoneRule</a> &amp;rule) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a607660798bed9111b9157807fce0a413"><td class="mdescLeft">&#160;</td><td class="mdescRight">絶対時刻から現地時刻へ変換します。  <a href="#a607660798bed9111b9157807fce0a413">[詳解]</a><br /></td></tr>
<tr class="separator:a607660798bed9111b9157807fce0a413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7632c59223c9ffb9fcfb4d81e293ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#acb7632c59223c9ffb9fcfb4d81e293ef">ToCalendarTime</a> (<a class="el" href="structnn_1_1time_1_1_calendar_time.html">CalendarTime</a> *pOutCalendar, <a class="el" href="structnn_1_1time_1_1_calendar_additional_info.html">CalendarAdditionalInfo</a> *pOutCalendarAdditionalInfo, const <a class="el" href="structnn_1_1time_1_1_posix_time.html">PosixTime</a> &amp;posixTime) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acb7632c59223c9ffb9fcfb4d81e293ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">絶対時刻から現地時刻へ変換します。 デバイスの設定に従ったタイムゾーンルールが自動で利用されます。  <a href="#acb7632c59223c9ffb9fcfb4d81e293ef">[詳解]</a><br /></td></tr>
<tr class="separator:acb7632c59223c9ffb9fcfb4d81e293ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a9d8766ae95d7336758e1531928c5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1time_1_1_calendar_time.html">CalendarTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#a56a9d8766ae95d7336758e1531928c5f">ToCalendarTimeInUtc</a> (const <a class="el" href="structnn_1_1time_1_1_posix_time.html">PosixTime</a> &amp;posixTime) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a56a9d8766ae95d7336758e1531928c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">絶対時刻を協定世界時 (UTC) の日時へ変換します。  <a href="#a56a9d8766ae95d7336758e1531928c5f">[詳解]</a><br /></td></tr>
<tr class="separator:a56a9d8766ae95d7336758e1531928c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dee0854e0a9f287e495129b37fcf2ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#a5dee0854e0a9f287e495129b37fcf2ff">ToPosixTime</a> (int *pOutCount, <a class="el" href="structnn_1_1time_1_1_posix_time.html">PosixTime</a> *pOutPosixTimeList, int count, const <a class="el" href="structnn_1_1time_1_1_calendar_time.html">CalendarTime</a> &amp;calendarTime, const <a class="el" href="structnn_1_1time_1_1_time_zone_rule.html">TimeZoneRule</a> &amp;rule) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5dee0854e0a9f287e495129b37fcf2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">現地時刻から絶対時刻へ変換します。  <a href="#a5dee0854e0a9f287e495129b37fcf2ff">[詳解]</a><br /></td></tr>
<tr class="separator:a5dee0854e0a9f287e495129b37fcf2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7759cf28be555a9a19d209173bb938"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnn_1_1_result.html">nn::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#aff7759cf28be555a9a19d209173bb938">ToPosixTime</a> (int *pOutCount, <a class="el" href="structnn_1_1time_1_1_posix_time.html">PosixTime</a> *pOutPosixTimeList, int count, const <a class="el" href="structnn_1_1time_1_1_calendar_time.html">CalendarTime</a> &amp;calendarTime) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aff7759cf28be555a9a19d209173bb938"><td class="mdescLeft">&#160;</td><td class="mdescRight">現地時刻から絶対時刻へ変換します。 デバイスの設定に従ったタイムゾーンルールが自動で利用されます。  <a href="#aff7759cf28be555a9a19d209173bb938">[詳解]</a><br /></td></tr>
<tr class="separator:aff7759cf28be555a9a19d209173bb938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22f757df13de784e8913f9e93a307a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1time_1_1_posix_time.html">PosixTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#ac22f757df13de784e8913f9e93a307a4">ToPosixTimeFromUtc</a> (const <a class="el" href="structnn_1_1time_1_1_calendar_time.html">CalendarTime</a> &amp;calendarTime) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac22f757df13de784e8913f9e93a307a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">協定世界時 (UTC) の日時を絶対時刻へ変換します。  <a href="#ac22f757df13de784e8913f9e93a307a4">[詳解]</a><br /></td></tr>
<tr class="separator:ac22f757df13de784e8913f9e93a307a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
変数</h2></td></tr>
<tr class="memitem:add20d1747d5576dacf4a50fffd3d85e6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structnn_1_1time_1_1_posix_time.html">PosixTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#add20d1747d5576dacf4a50fffd3d85e6">InputPosixTimeMax</a> = { 4102444800 }</td></tr>
<tr class="memdesc:add20d1747d5576dacf4a50fffd3d85e6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacenn_1_1time.html#a607660798bed9111b9157807fce0a413">ToCalendarTime</a> 関数で動作保証している入力の最大値です。  <a href="#add20d1747d5576dacf4a50fffd3d85e6">[詳解]</a><br /></td></tr>
<tr class="separator:add20d1747d5576dacf4a50fffd3d85e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41baeb3eba3afcee4baddbb8487ec827"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structnn_1_1time_1_1_posix_time.html">PosixTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenn_1_1time.html#a41baeb3eba3afcee4baddbb8487ec827">InputPosixTimeMin</a> = { 946598400 }</td></tr>
<tr class="memdesc:a41baeb3eba3afcee4baddbb8487ec827"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacenn_1_1time.html#a607660798bed9111b9157807fce0a413">ToCalendarTime</a> 関数で動作保証している入力の最小値です。  <a href="#a41baeb3eba3afcee4baddbb8487ec827">[詳解]</a><br /></td></tr>
<tr class="separator:a41baeb3eba3afcee4baddbb8487ec827"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p>TIME ライブラリの名前空間です。 </p>
<h3>機能概要</h3>
<p>TIME ライブラリは、時間・時刻の取得・計算・変換などにまつわる機能を提供します。<br />
 </p><h3>共通の事前条件</h3>
<ul>
<li>TIME ライブラリが提供する API は原則として、利用前に <a class="el" href="namespacenn_1_1time.html#af3d5226ce5093e581b3892fbb2fbc34c" title="TIME ライブラリの初期化をおこない、機能を使用可能な状態にします。 ">nn::time::Initialize</a> 関数でライブラリを初期化しておく必要があります。</li>
</ul>
<h3>Windows 上での挙動</h3>
<p>Windows 上での動作環境では、内部で利用する一定のペースで単調増加するカウンタに PC の時計を代用しています。 <br />
 よって PC の時計が操作された場合には、TIME ライブラリを通して得られる時刻がその操作の分だけずれます。 このずれが発生したことを TIME ライブラリで検知する方法はありません。 <br />
 ただし、TIME ライブラリの初期化から終了までの間に PC の時計が操作されても、TIME ライブラリを通して得られる時刻は影響を受けません。</p>
<p>Windows 上で動作させた場合、このライブラリは fs ライブラリの機能を使用します。 <a class="el" href="namespacenn_1_1fs.html#ac021c163ba94a44a2b53cb848c462930" title="fs ライブラリが使用するメモリアロケータを設定します。 ">nn::fs::SetAllocator()</a> で設定したアロケータか malloc() によって fs ライブラリがメモリを確保できる状態で利用してください。 詳細は fs ライブラリのマニュアルを参照してください。</p>
<h3><a class="anchor" id="about_time_zone_api"></a>タイムゾーンを扱う API について</h3>
<ul>
<li>現地時刻・絶対時刻 を計算するために必要な <a class="el" href="structnn_1_1time_1_1_time_zone_rule.html">TimeZoneRule</a> の内部仕様は変更される可能性があるので、セーブデータ等に保存して次回起動時に使いまわすようなことはしないでください。</li>
<li>本体設定や DevMenu で選択可能な <a class="el" href="structnn_1_1time_1_1_location_name.html">LocationName</a> は、将来の運用によって変わる可能性があります。ただし、一度でも選択可能であったものは将来に渡って TIME ライブラリで扱えるようサポートします。</li>
<li><a class="el" href="namespacenn_1_1time.html#a607660798bed9111b9157807fce0a413">ToCalendarTime</a> 関数で動作保証する入力範囲は <a class="el" href="namespacenn_1_1time.html#a41baeb3eba3afcee4baddbb8487ec827">InputPosixTimeMin</a> から <a class="el" href="namespacenn_1_1time.html#add20d1747d5576dacf4a50fffd3d85e6">InputPosixTimeMax</a> までです。</li>
<li><a class="el" href="namespacenn_1_1time.html#a5dee0854e0a9f287e495129b37fcf2ff">ToPosixTime</a> 関数で動作保証する入力範囲は 2000年1月1日午前0時0分0秒 から 2100年1月1日午前0時0分0秒 までです。</li>
<li>タイムゾーンごとの時差の運用ルールは、本体更新等で更新される可能性があり、将来に渡って同じルールが適用される保証はありません。</li>
<li>未来における時差の運用ルールにおいては、現時点で分かっている最新のルールが未来でもそのまま適用されているとして計算されます。</li>
<li>TIME ライブラリを通して得られる時刻は必ず動作保証の範囲内であることが保証されます。ただし、 Windows 上での動作環境においてはこの限りではありません。 </li>
</ul>
</div><h2 class="groupheader">列挙型詳解</h2>
<a class="anchor" id="abc313af281fff1f227bad03284e1c2ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1time.html#abc313af281fff1f227bad03284e1c2ad">nn::time::PeriodicBenefitClaimResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>利益を得られるかどうかの判定結果を表す列挙型です。 </p>
<p><b>詳細</b> <br />
 </p><dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1time.html#aa5e24f241a0806d6ac316075b655b3f7" title="ユーザー時計の操作を考慮した上で、定期的な利益を得られるかどうかを判定します。 ">nn::time::ClaimPeriodicBenefitWithUserSystemClock()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="abc313af281fff1f227bad03284e1c2ada8a0603d107ba2cda011ae792b7cc3a39"></a>PeriodicBenefitClaimResult_Success&#160;</td><td class="fielddoc">
<p>利益を得ることができる </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abc313af281fff1f227bad03284e1c2ada38e1826e9ae5442c64a8dec9d2604af8"></a>PeriodicBenefitClaimResult_NotReceivableTiming&#160;</td><td class="fielddoc">
<p>利益を得られるタイミングではない </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abc313af281fff1f227bad03284e1c2ada7d525d793c5f7200173a1f49355861cc"></a>PeriodicBenefitClaimResult_Penalty&#160;</td><td class="fielddoc">
<p>ペナルティによって利益を得られない </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a177bcc334d2637177f1b116a416b2c43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacenn_1_1time.html#a177bcc334d2637177f1b116a416b2c43">nn::time::DayOfWeek</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>曜日を表す列挙型です。 </p>
<p><b>詳細</b> <br />
</p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a177bcc334d2637177f1b116a416b2c43aa602069842f184fcbe971b3f6a2bfd27"></a>DayOfWeek_Sunday&#160;</td><td class="fielddoc">
<p>日曜日 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a177bcc334d2637177f1b116a416b2c43aa90ad97eba8a9c95d6c2c7eb36d2c1fb"></a>DayOfWeek_Monday&#160;</td><td class="fielddoc">
<p>月曜日 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a177bcc334d2637177f1b116a416b2c43a7204b58630553e4c2c92b22865f5069b"></a>DayOfWeek_Tuesday&#160;</td><td class="fielddoc">
<p>火曜日 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a177bcc334d2637177f1b116a416b2c43aaaafd54d67f6485cd36f770041d8fc6d"></a>DayOfWeek_Wednesday&#160;</td><td class="fielddoc">
<p>水曜日 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a177bcc334d2637177f1b116a416b2c43a28dbbe40c3f2bba2848f9548c23adb81"></a>DayOfWeek_Thursday&#160;</td><td class="fielddoc">
<p>木曜日 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a177bcc334d2637177f1b116a416b2c43a6928999430b5f5086786536021cda79d"></a>DayOfWeek_Friday&#160;</td><td class="fielddoc">
<p>金曜日 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a177bcc334d2637177f1b116a416b2c43ae60a88e9a46bcf59a66e62e206b167f3"></a>DayOfWeek_Saturday&#160;</td><td class="fielddoc">
<p>土曜日 </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a class="anchor" id="af3d5226ce5093e581b3892fbb2fbc34c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::time::Initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TIME ライブラリの初期化をおこない、機能を使用可能な状態にします。 </p>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。事前条件を満たしていない場合、以下に列挙されていない失敗が返ることがあります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000224">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。</dd></dl>
<p><b>詳細</b> <br />
 TIME ライブラリが提供する API は原則として、利用前にこの関数でライブラリを初期化しておく必要があります。<br />
 ライブラリがすでに初期化された状態でも重ねて呼ぶことができますが、その場合、ライブラリの利用を完全に終了するにはこの関数を呼んだのと同じ回数だけ <a class="el" href="namespacenn_1_1time.html#a316a48243971bfac1dfcc1ea07466563">nn::time::Finalize</a> 関数を呼ぶ必要があります。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_time_calculate_user_system_clock_difference_8cpp-example.html#a2">TimeCalculateUserSystemClockDifference.cpp</a>, <a class="el" href="_time_claim_periodic_benefit_8cpp-example.html#a14">TimeClaimPeriodicBenefit.cpp</a>, <a class="el" href="_time_standard_steady_clock_8cpp-example.html#a2">TimeStandardSteadyClock.cpp</a>, <a class="el" href="_time_standard_user_system_clock_8cpp-example.html#a2">TimeStandardUserSystemClock.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="acd5d341f8b8024312cbb9ad67f205938"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::time::IsInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TIME ライブラリが初期化済みかを判定します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>ライブラリがすでに初期化されていれば true を、まだ初期化されていなければ false を返します。</dd></dl>
<p><b>詳細</b> <br />
</p>

</div>
</div>
<a class="anchor" id="a316a48243971bfac1dfcc1ea07466563"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::time::Finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TIME ライブラリの利用を終了します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。事前条件を満たしていない場合、以下に列挙されていない失敗が返ることがあります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000225">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。</dd></dl>
<p><b>詳細</b> <br />
 <a class="el" href="namespacenn_1_1time.html#af3d5226ce5093e581b3892fbb2fbc34c">nn::time::Initialize</a> 関数を複数回呼んでいる場合、TIME ライブラリの利用を完全に終了するには同じ回数だけこの関数を呼ぶ必要があります。<br />
 ライブラリの利用が完全に終了されると、システムで確保していたリソースが解放ます。<br />
 ライブラリが未初期化の状態でコールしても副作用はありません。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_time_calculate_user_system_clock_difference_8cpp-example.html#a15">TimeCalculateUserSystemClockDifference.cpp</a>, <a class="el" href="_time_claim_periodic_benefit_8cpp-example.html#a29">TimeClaimPeriodicBenefit.cpp</a>, <a class="el" href="_time_standard_steady_clock_8cpp-example.html#a11">TimeStandardSteadyClock.cpp</a>, <a class="el" href="_time_standard_user_system_clock_8cpp-example.html#a19">TimeStandardUserSystemClock.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a029976fde1c33e311557957f3fc57a6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">Result</a> nn::time::GetSpanBetween </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>pOutSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1time_1_1_steady_clock_time_point.html">SteadyClockTimePoint</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1time_1_1_steady_clock_time_point.html">SteadyClockTimePoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2つの <a class="el" href="structnn_1_1time_1_1_steady_clock_time_point.html" title="単調増加クロックが指し示す値を表す構造体です。 ">nn::time::SteadyClockTimePoint</a> 間の経過秒数を計算します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutSeconds</td><td>計算結果の秒数を格納するバッファへのポインタを指定します。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>起点となる時刻を指定します。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>終点となる時刻を指定します。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理の結果が返ります。事前条件を満たしていない場合、以下に列挙されていない失敗が返ることがあります。 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000226">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。 <br />
 </p>
<p><b><a class="el" href="classnn_1_1time_1_1_result_not_comparable.html" title="エラー Result (time: 与えられた2つの値に連続性がなく、比較・減算できません) を表すクラスです。 ...">ResultNotComparable</a></b> 与えられた2つの値に連続性がなく、比較・減算できません。 <br />
 </p>
<p class="enddd"><b><a class="el" href="classnn_1_1time_1_1_result_overflowed.html" title="エラー Result (time: オーバーフローまたはアンダーフローが発生しました) を表すクラスです。 ...">ResultOverflowed</a></b> 計算結果がオーバーフローもしくはアンダーフローしました。</p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>pOutSeconds != nullptr</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 終点が起点より過去を指していた場合、経過秒数として負の値が返ります。</p>
<p><a class="el" href="classnn_1_1time_1_1_standard_steady_clock.html">nn::time::StandardSteadyClock</a> はハードウェア的な改竄攻撃に対して強靭ではありません。 経過時間がマイナスなどの想定外の値になったとしても、アプリケーションにはまりや止まりがないように実装してください。</p>
<p>より多くのケースで経過時間の計算が可能な <a class="el" href="namespacenn_1_1time.html#a992889d77943f2f8f8d0c827ebd7eef1">nn::time::CalculateSpanBetween</a> 関数も参照してください。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_time_standard_steady_clock_8cpp-example.html#a9">TimeStandardSteadyClock.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a73a30636ce435336011030d45327e17d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::time::IsLeapYear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>year</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定した西暦がうるう年かどうかを判定します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">year</td><td>年</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>1 &lt;= year</li>
</ul>
</dd></dl>
<dl class="section return"><dt>戻り値</dt><dd>うるう年かどうか <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000227">戻り値一覧:</a></b></dt><dd><p class="startdd"><b>true</b> 指定した西暦がうるう年であった。 <br />
 </p>
<p class="enddd"><b>false</b> 指定した西暦がうるう年ではなかった。</p>
</dd></dl>
<p><b>詳細</b> <br />
</p>

</div>
</div>
<a class="anchor" id="abfd9bd6af9ce3c2302e8bbb7ac28fdc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::time::IsValidDate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>year</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>month</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>day</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定した年月日が有効かどうかをチェックします。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">year</td><td>年 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">month</td><td>月 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">day</td><td>日</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>指定した年月日が有効かどうか <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000228">戻り値一覧:</a></b></dt><dd><p class="startdd"><b>true</b> 有効な年月日であった。 <br />
 </p>
<p class="enddd"><b>false</b> 有効でない年月日であった。</p>
</dd></dl>
<p><b>詳細</b> <br />
 year が 0 以下の場合は必ず false が返ります。 </p>

</div>
</div>
<a class="anchor" id="a85c5cca1bcbbdff76aa6dedf156ef12a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::time::GetDaysInMonth </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>year</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>month</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>年月を指定してその月が何日あるかを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">year</td><td>年 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">month</td><td>月</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>1 &lt;= year</li>
<li>1 &lt;= month &lt;= 12</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>1 &lt;= 返り値 &lt;= 31</li>
</ul>
</dd></dl>
<dl class="section return"><dt>戻り値</dt><dd>指定した月の日数</dd></dl>
<p><b>詳細</b> <br />
</p>

</div>
</div>
<a class="anchor" id="aaf3ec0bb884c0797a5f593318e505fac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::time::DateToDays </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>year</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>month</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>day</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>年月日を 西暦1年1月1日 からの経過日数へ変換します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">year</td><td>年 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">month</td><td>月 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">day</td><td>日</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>1 &lt;= year</li>
<li>1 &lt;= month</li>
<li>1 &lt;= day</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>0 &lt;= 返り値</li>
</ul>
</dd></dl>
<dl class="section return"><dt>戻り値</dt><dd>西暦1年1月1日 からの経過日数</dd></dl>
<p><b>詳細</b> <br />
 指定年月日が何日目かではなく、経過日数を返すことに注意してください。 例えば 西暦1年1月1日 の場合は 0 が返ります。</p>
<p>有効でない日付を指定した場合には、有効な日付からの経過を考慮して日付が補正されます。 例えば有効でない 西暦2016年4月31日 を入力した場合、有効な 西暦2016年4月30日 から1日後の 西暦2016年5月1日 として扱われます。</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1time.html#a93a1933058acb7121d73b209dffc71e9" title="西暦1年1月1日 からの経過日数を年月日へ変換します。 ">DaysToDate()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a93a1933058acb7121d73b209dffc71e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::time::DaysToDate </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutYear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutMonth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutDay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>days</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>西暦1年1月1日 からの経過日数を年月日へ変換します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutYear</td><td>年が入るアドレスを指定してください </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutMonth</td><td>月が入るアドレスを指定してください </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutDay</td><td>日が入るアドレスを指定してください </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">days</td><td>西暦1年1月1日 からの経過日数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>0 &lt;= days</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>1 &lt;= *pOutYear</li>
<li>1 &lt;= *pOutMonth &lt;= 12</li>
<li>1 &lt;= *pOutDay &lt;= 31</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 days に指定するのは何日目かではなく、経過日数であることに注意してください。 例えば days に 0 を指定した場合は 西暦1年1月1日 が出力されます。</p>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="namespacenn_1_1time.html#aaf3ec0bb884c0797a5f593318e505fac" title="年月日を 西暦1年1月1日 からの経過日数へ変換します。 ">DateToDays()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a826bc69f7d326cda6bfbea67228fe0e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1time.html#a177bcc334d2637177f1b116a416b2c43">DayOfWeek</a> nn::time::GetDayOfWeek </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>year</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>month</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>day</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>年月日を指定して曜日を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">year</td><td>年 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">month</td><td>月 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">day</td><td>日</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>1 &lt;= year</li>
<li>1 &lt;= month</li>
<li>1 &lt;= day</li>
</ul>
</dd></dl>
<dl class="section return"><dt>戻り値</dt><dd>曜日</dd></dl>
<p><b>詳細</b> <br />
 有効でない日付を指定した場合には、有効な日付からの経過を考慮して日付が補正され、曜日が計算されます。 例えば有効でない 西暦2016年4月31日 を入力した場合、有効な 西暦2016年4月30日 から1日後の 西暦2016年5月1日 の曜日が返ります。 </p>

</div>
</div>
<a class="anchor" id="aa5e24f241a0806d6ac316075b655b3f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1time.html#abc313af281fff1f227bad03284e1c2ad">PeriodicBenefitClaimResult</a> nn::time::ClaimPeriodicBenefitWithUserSystemClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1time_1_1_periodic_benefit_claim_context.html">PeriodicBenefitClaimContext</a> *&#160;</td>
          <td class="paramname"><em>pHandover</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnn_1_1time_1_1_clock_snapshot.html">ClockSnapshot</a> &amp;&#160;</td>
          <td class="paramname"><em>currentSnapshot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> &amp;&#160;</td>
          <td class="paramname"><em>maxPenaltyTimeSpan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> &amp;&#160;</td>
          <td class="paramname"><em>acceptableOperationTimeSpan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnn_1_1time_1_1_check_calendar_time_callback.html">CheckCalendarTimeCallback</a> *&#160;</td>
          <td class="paramname"><em>pCheckCalendarTimeCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユーザー時計の操作を考慮した上で、定期的な利益を得られるかどうかを判定します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pHandover</td><td>前回の判定で得た pHandover<br />
 (関数実行後、次回の判定の pHandover として本関数の成否に関係なく引き継ぐ必要があります。<br />
 初回の判定では、コンストラクタで生成されたままの <a class="el" href="structnn_1_1time_1_1_periodic_benefit_claim_context.html" title="定期的な利益を得られるかどうかの判定に用いる情報を保持する構造体です。 ">PeriodicBenefitClaimContext</a> を指定してください。 このとき時計の操作がまったくないものとして判定します。)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">currentSnapshot</td><td>利益を得られるかどうかを判定する今現在の <a class="el" href="classnn_1_1time_1_1_clock_snapshot.html" title="時計の各種情報を保持するクラスです。 ">ClockSnapshot</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPenaltyTimeSpan</td><td>ペナルティ期間の最大値<br />
 (時計操作のないときに利益を得られる間隔以下の値を指定することを推奨します。 例えば日付が変わると新しく利益を得られるのであれば nn::TimeSpan::FromDays(1) 以下を指定します。)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acceptableOperationTimeSpan</td><td>未来へ進める方向への時計操作時に許容する時計の操作量<br />
 (この値を小さくすると、本来意図していたより短い間隔で利益を得ることを防ぐのには有効ですが、 ほんの少し時計を操作するだけで maxPenaltyTimeSpan 分のペナルティを受ける可能性が上がるので、 nn::TimeSpan::FromMinutes(10) 程度の値を指定することを推奨します。 ただし、利益を得られる間隔が短く、acceptableOperationTimeSpan が相対的に大きくなってしまう場合には値を小さくしてください。)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCheckCalendarTimeCallback</td><td>日時を確認するためのコールバッククラス<br />
 (詳細は <a class="el" href="classnn_1_1time_1_1_check_calendar_time_callback.html">CheckCalendarTimeCallback</a> クラスを参照してください)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>判定結果 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000229">戻り値一覧:</a></b></dt><dd><p class="startdd"><b><a class="el" href="namespacenn_1_1time.html#abc313af281fff1f227bad03284e1c2ada8a0603d107ba2cda011ae792b7cc3a39" title="利益を得ることができる ">nn::time::PeriodicBenefitClaimResult_Success</a></b> 利益を得ることができます。 <br />
 </p>
<p><b><a class="el" href="namespacenn_1_1time.html#abc313af281fff1f227bad03284e1c2ada38e1826e9ae5442c64a8dec9d2604af8" title="利益を得られるタイミングではない ">nn::time::PeriodicBenefitClaimResult_NotReceivableTiming</a></b> 新たに利益を得られるタイミングになっておらず、利益を得ることができません。 <br />
 </p>
<p class="enddd"><b><a class="el" href="namespacenn_1_1time.html#abc313af281fff1f227bad03284e1c2ada7d525d793c5f7200173a1f49355861cc" title="ペナルティによって利益を得られない ">nn::time::PeriodicBenefitClaimResult_Penalty</a></b> ペナルティ期間中であり、利益を得ることができません。 ペナルティ期間が過ぎてもその他の失敗を示す結果が返る可能性があります。 </p><dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>TIME ライブラリが初期化されている</li>
<li>currentSnapshot が <a class="el" href="classnn_1_1time_1_1_clock_snapshot.html#ab46c9996752e49c22634b140a99deee6" title="システムの最新時刻でオブジェクトを生成します。 ">nn::time::ClockSnapshot::CreateWithStandardSystemClock()</a> か <a class="el" href="classnn_1_1time_1_1_clock_snapshot.html#af42c23f50ba8df32b443cacf68516d3f" title="システムの最新時刻に任意のタイミングで追従できる時計を使ってオブジェクトを生成します。 ...">nn::time::ClockSnapshot::CreateWithAdjustableSystemClock()</a> で初期化されている</li>
<li>pHandover != nullptr</li>
<li>maxPenaltyTimeSpan &gt; <a class="el" href="classnn_1_1_time_span.html" title="時間の長さを表すクラスです。 ">nn::TimeSpan(0)</a></li>
<li>acceptableOperationTimeSpan &gt;= <a class="el" href="classnn_1_1_time_span.html" title="時間の長さを表すクラスです。 ">nn::TimeSpan(0)</a></li>
<li>pCheckCalendarTimeCallback != nullptr</li>
</ul>
</dd></dl>
</dd></dl>
<p><b>詳細</b> <br />
 本関数は、毎日日付が変わると利益を得られる、毎週特定の曜日にだけイベントが発生する、 といった日時を基準に定期的に発動するイベントを、ユーザー時計( <a class="el" href="classnn_1_1time_1_1_standard_user_system_clock.html">nn::time::StandardUserSystemClock</a> ) の時刻で管理するアプリケーション向けに用意されたユーティリティです。 ユーザーによる意図的な時計操作が行われたとしても、本来意図していたより短い間隔で利益を得たり、 また逆に、必要以上に利益の受け取りを制限したりすることがないような実装が可能です。</p>
<p>時計が操作されると、その操作内容に応じて利益を得られないペナルティ期間が設けられ、 この期間内は新たに利益が得られるはずの日時が来たとしても、利益を得ることができません。 ペナルティ期間は、時計を操作したタイミングからその期間が実時間で経過することによって自動的に解かれます。</p>
<h3>時計の操作量を判断できる場合</h3>
<p>ペナルティ期間は、過去の判定タイミングと currentSnapshot の2つの時点から求まるユーザーによる意図的な時計の操作量を使って以下のように決定されます。 なお、システムによる自動的な時刻補正がユーザー時計に影響してもペナルティとはなりません。<br />
</p><table class="doxtable">
<tr>
<th align="left">時計操作のケース </th><th align="left">ペナルティ期間のかかり方  </th></tr>
<tr>
<td align="left">時計がまったく操作されていない場合</td><td align="left">ペナルティ期間なし。 </td></tr>
<tr>
<td align="left">時計が未来へ進む方向へ操作された場合</td><td align="left">maxPenaltyTimeSpan がペナルティ期間となります。<br />
 ただし、時計の操作量が acceptableOperationTimeSpan 以下の場合、ペナルティ期間は発生しません。 </td></tr>
<tr>
<td align="left">時計が過去へ戻る方向へ操作された場合</td><td align="left">maxPenaltyTimeSpan を最大として、時計の操作量がそのままペナルティ期間となります。<br />
 ペナルティ期間が過ぎ去った後、新たに利益を得られるようになるタイミングが、前回利益を得たタイミングと同じになることがあります。<br />
 (日付が変わることで新たな利益を得られる仕様として、7月20日に利益を得て、その後24時間時計を巻き戻して24時間のペナルティ期間が発生した場合、ペナルティ期間が過ぎ去り新たな利益が得られるようになる日付は7月20日となります) </td></tr>
</table>
<h3>時計の操作量を判断できない場合</h3>
<p>上記はユーザー時計の操作量を正しく判断できる場合についてですが、 単調増加クロックの値同士に連続性がない場合には、時計の操作量を判断することができません (単調増加クロックのリセット発生時や、セーブデータの別デバイスへの移行時などが該当)。<br />
 このとき、pHandover が保持する前回利益を得たタイミングからの経過時間取得の成否によって、以下のようにペナルティ期間が決定されます。 経過時間の取得には <a class="el" href="namespacenn_1_1time.html#a992889d77943f2f8f8d0c827ebd7eef1">nn::time::CalculateSpanBetween()</a> を用いており、成否の条件はそちらを参照してください。<br />
</p><table class="doxtable">
<tr>
<th align="left">前回の利益受け取りから currentSnapshot までの経過時間の取得結果 </th><th align="left">ペナルティ期間のかかり方  </th></tr>
<tr>
<td align="left">利益を一度も受け取ったことがなく経過時間を取得できない</td><td align="left">ペナルティ期間なし。 </td></tr>
<tr>
<td align="left">経過時間の取得成功</td><td align="left">前回利益を受け取ったタイミングから maxPenaltyTimeSpan がペナルティ期間となります。<br />
すでにペナルティ期間が過ぎ去っていることもあります。 </td></tr>
<tr>
<td align="left">経過時間の取得失敗</td><td align="left">currentSnapshot から maxPenaltyTimeSpan がペナルティ期間となります。 </td></tr>
</table>
<p>ただし、 過去の判定タイミングの時点と currentSnapshot がそれぞれ 本体設定の「インターネットで時間をあわせる」がON、かつネットワーク時計が補正済の場合は、 ユーザー時計は未操作と判断できるのでペナルティはかかりません。<br />
 </p><h3>その他の事項</h3>
<ul>
<li>特に気を付けるハンドリングについて<br />
 pHandover は本関数の結果に関係なく次回の判定へ引き継ぐ必要があることに注意してください。</li>
<li>利益の受け取り結果の保存について<br />
 <a class="el" href="namespacenn_1_1time.html#abc313af281fff1f227bad03284e1c2ada8a0603d107ba2cda011ae792b7cc3a39">PeriodicBenefitClaimResult_Success</a> が返った場合、アプリケーション側で利益の受け取り処理を行ってください。 このとき、アプリケーションの終了やデバイスの電源断によるデータの不整合を防ぐため、 利益を受け取ったアプリケーション側の結果と pHandover とは、不可分にセーブデータに保存することを強く推奨します。</li>
<li>デバイスのタイムゾーン変更について<br />
 変更前後のタイムゾーンの時差の差分が、時計の操作量として加味されます。 ただし、夏時間などのデバイスのタイムゾーン変更を伴わない時差の変化は、時計の操作量としては扱われません。 例えば、UTC との時差が -3 から +1 に変更されると、時計を4時間進めたことと同等に扱われます。 タイムゾーン変更を伴わず夏時間の影響などで時間が1時間ずれたとしても、それは時計の操作量としては扱われません。 </li>
</ul>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_time_claim_periodic_benefit_8cpp-example.html#a22">TimeClaimPeriodicBenefit.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a7ebe8af7470bcbe489878e09cde9f3cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> nn::time::CalculateStandardUserSystemClockDifferenceByUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1time_1_1_clock_snapshot.html">ClockSnapshot</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnn_1_1time_1_1_clock_snapshot.html">ClockSnapshot</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユーザー時計がユーザーによって意図的に操作された量を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>操作検知の起点となるオブジェクト </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>操作検知の終点となるオブジェクト</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ユーザーによる意図的な時計の操作量</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>TIME ライブラリが初期化済である</li>
<li>from と to が <a class="el" href="classnn_1_1time_1_1_clock_snapshot.html#ab46c9996752e49c22634b140a99deee6" title="システムの最新時刻でオブジェクトを生成します。 ">nn::time::ClockSnapshot::CreateWithStandardSystemClock()</a> 同士、 もしくは <a class="el" href="classnn_1_1time_1_1_clock_snapshot.html#af42c23f50ba8df32b443cacf68516d3f" title="システムの最新時刻に任意のタイミングで追従できる時計を使ってオブジェクトを生成します。 ...">nn::time::ClockSnapshot::CreateWithAdjustableSystemClock()</a> 同士で初期化されている</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 from から to までの間に、 ユーザー時計( <a class="el" href="classnn_1_1time_1_1_standard_user_system_clock.html">nn::time::StandardUserSystemClock</a> )から得られる <a class="el" href="structnn_1_1time_1_1_posix_time.html" title="POSIX 標準の時刻を表す構造体です。 ">nn::time::PosixTime</a> が、 ユーザーによって意図的に操作された量を取得します。 未来の方向への操作であれば正の、過去の方向への操作であれば負の <a class="el" href="classnn_1_1_time_span.html" title="時間の長さを表すクラスです。 ">nn::TimeSpan</a> が返ります。</p>
<p><a class="el" href="classnn_1_1_time_span.html" title="時間の長さを表すクラスです。 ">nn::TimeSpan(0)</a> が返ったとしても、ユーザーによる意図的な操作がなかったことを示すだけであり、 ユーザー時計の <a class="el" href="structnn_1_1time_1_1_posix_time.html" title="POSIX 標準の時刻を表す構造体です。 ">nn::time::PosixTime</a> の巻き戻りや、実時間の経過以上の大きな進みがないことを保証するものではありません。</p>
<p>ユーザー時計の時刻を <a class="el" href="structnn_1_1time_1_1_calendar_time.html" title="カレンダー情報を扱う構造体です。 ">nn::time::CalendarTime</a> に変換した日時が操作されたかどうかを判定するものではないことに注意してください。 夏時間等の影響による時差変化や、ユーザーによって本体のタイムゾーンが変更されたとしても、 <a class="el" href="structnn_1_1time_1_1_posix_time.html" title="POSIX 標準の時刻を表す構造体です。 ">nn::time::PosixTime</a> 自体は操作されないため、本関数は <a class="el" href="classnn_1_1_time_span.html" title="時間の長さを表すクラスです。 ">nn::TimeSpan(0)</a> を返します。<br />
 本体のタイムゾーン変更の検知には、 from.GetLocationName() と to.GetLocationName() の比較が別途必要です。</p>
<p>from と to の間に以下のいずれかが発生していた場合、 ユーザーによって時計が操作されたと判断します。<br />
</p><ul>
<li>時計をユーザーが直接操作した(本体設定, DevMenu, DevMenuCommand などで操作可能)</li>
<li>本体設定の「インターネットで時間をあわせる」がユーザーによってOFFからONに切り替えられ、ユーザー時計の時刻が変わった</li>
</ul>
<p>一方で下記のいずれかが発生した場合、 <a class="el" href="structnn_1_1time_1_1_posix_time.html" title="POSIX 標準の時刻を表す構造体です。 ">nn::time::PosixTime</a> に変化があったとしても、ユーザーによる操作とは判断されません。<br />
</p><ul>
<li>本体設定の「インターネットで時間をあわせる」が常にONであり、システムによる時計の自動補正が行われた</li>
<li>単調増加クロックの電池切れによってユーザー時計の時刻が初期値に戻った</li>
<li>セーブデータが別デバイスへ移行された </li>
</ul>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_time_calculate_user_system_clock_difference_8cpp-example.html#a9">TimeCalculateUserSystemClockDifference.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a992889d77943f2f8f8d0c827ebd7eef1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::time::CalculateSpanBetween </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnn_1_1_time_span.html">nn::TimeSpan</a> *&#160;</td>
          <td class="paramname"><em>pOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnn_1_1time_1_1_clock_snapshot.html">ClockSnapshot</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnn_1_1time_1_1_clock_snapshot.html">ClockSnapshot</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2つの <a class="el" href="classnn_1_1time_1_1_clock_snapshot.html" title="時計の各種情報を保持するクラスです。 ">nn::time::ClockSnapshot</a> 間の実時間での経過時間を計算します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOut</td><td>経過時間を格納するバッファへのポインタ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>経過時間計算の起点となるオブジェクト </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>経過時間計算の終点となるオブジェクト</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>計算結果 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000233">戻り値一覧:</a></b></dt><dd><p class="startdd"><b>true</b> 成功 <br />
 </p>
<p class="enddd"><b>false</b> 失敗</p>
</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>TIME ライブラリが初期化済である</li>
<li>pOut != nullptr</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 終点が起点より過去を指していた場合、経過秒数として負の値が返ります。</p>
<p>セーブデータが別デバイスへ移行されたときや、単調増加クロックのリセット発生などにより、 起点と終点が保持する単調増加クロックの値同士に連続性がなくなった場合にも、 ネットワーク時計の時刻を利用して経過時間を計測可能です。<br />
 ただし、ネットワーク時計の時刻は単調増加が保証されないため、経過時間の計算に少なからず誤差が生じます。 それにより、特に短い期間の計測においては、実際には正の経過時間であっても 誤差によって負の経過時間が返されるなどの可能性があります。 誤差についての詳細は <a class="el" href="classnn_1_1time_1_1_standard_network_system_clock.html#network_clock_accuracy">ネットワーク時計の時刻精度について </a> を参照してください。</p>
<p>以下のすべてを満たす場合、経過時間の計算ができず false を返します。<br />
</p><ul>
<li>起点と終点が保持する単調増加クロックの値同士に連続性がない</li>
<li>起点と終点のどちらか一方でもネットワーク時計の時刻を保持していない </li>
</ul>

</div>
</div>
<a class="anchor" id="a8e7d7a0e92e652c83c9ec02fdd76d92f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::time::GetDeviceLocationName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1time_1_1_location_name.html">LocationName</a> *&#160;</td>
          <td class="paramname"><em>pOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>デバイスに設定されている地域名を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOut</td><td>地域名</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>TIME ライブラリが初期化されている</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 この関数で取得できる <a class="el" href="structnn_1_1time_1_1_location_name.html" title="地域名を扱う構造体です。 ">LocationName</a> はシステムの最新の値であり、 アプリケーション起動中であっても変更される可能性があります。 </p>

</div>
</div>
<a class="anchor" id="a44f1303ca25d1cb0625a6f1187b2b0f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::time::LoadTimeZoneRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1time_1_1_time_zone_rule.html">TimeZoneRule</a> *&#160;</td>
          <td class="paramname"><em>pOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1time_1_1_location_name.html">LocationName</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>地域名を指定してタイムゾーンルールを読み込みます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOut</td><td>タイムゾーンルール </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>地域名</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理結果 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000243">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>TIME ライブラリが初期化されている</li>
<li>pOut != nullptr</li>
<li>ライブラリが対応している地域名を指定している</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 本関数は最大数 msec ブロックする可能性があります。 </p>

</div>
</div>
<a class="anchor" id="a607660798bed9111b9157807fce0a413"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::time::ToCalendarTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1time_1_1_calendar_time.html">CalendarTime</a> *&#160;</td>
          <td class="paramname"><em>pOutCalendar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1time_1_1_calendar_additional_info.html">CalendarAdditionalInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutCalendarAdditionalInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1time_1_1_posix_time.html">PosixTime</a> &amp;&#160;</td>
          <td class="paramname"><em>posixTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1time_1_1_time_zone_rule.html">TimeZoneRule</a> &amp;&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>絶対時刻から現地時刻へ変換します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCalendar</td><td>現地時刻 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCalendarAdditionalInfo</td><td>現地時刻追加情報 ( 不要な場合は nullptr を入れてください ) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">posixTime</td><td>絶対時刻 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rule</td><td>タイムゾーンルール</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理結果 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000244">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>TIME ライブラリが初期化されている</li>
<li>pOutCalendar != nullptr</li>
<li><a class="el" href="namespacenn_1_1time.html#a41baeb3eba3afcee4baddbb8487ec827">InputPosixTimeMin</a> &lt;= posixTime &lt;= <a class="el" href="namespacenn_1_1time.html#add20d1747d5576dacf4a50fffd3d85e6">InputPosixTimeMax</a></li>
<li>タイムゾーンルールが読み込み済である</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 この関数に渡す <a class="el" href="structnn_1_1time_1_1_time_zone_rule.html" title="タイムゾーンルールを表す型です。 ">TimeZoneRule</a> の先頭アドレスを 4 KB アライメントにすることで、 Release ビルド時で数マイクロ秒の処理時間低減を行うことができます。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_time_standard_user_system_clock_8cpp-example.html#a8">TimeStandardUserSystemClock.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="acb7632c59223c9ffb9fcfb4d81e293ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::time::ToCalendarTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1time_1_1_calendar_time.html">CalendarTime</a> *&#160;</td>
          <td class="paramname"><em>pOutCalendar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1time_1_1_calendar_additional_info.html">CalendarAdditionalInfo</a> *&#160;</td>
          <td class="paramname"><em>pOutCalendarAdditionalInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1time_1_1_posix_time.html">PosixTime</a> &amp;&#160;</td>
          <td class="paramname"><em>posixTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>絶対時刻から現地時刻へ変換します。 デバイスの設定に従ったタイムゾーンルールが自動で利用されます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCalendar</td><td>現地時刻 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCalendarAdditionalInfo</td><td>現地時刻追加情報 ( 不要な場合は nullptr を入れてください ) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">posixTime</td><td>絶対時刻</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理結果 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000245">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>TIME ライブラリが初期化されている</li>
<li>pOutCalendar != nullptr</li>
<li><a class="el" href="namespacenn_1_1time.html#a41baeb3eba3afcee4baddbb8487ec827">InputPosixTimeMin</a> &lt;= posixTime &lt;= <a class="el" href="namespacenn_1_1time.html#add20d1747d5576dacf4a50fffd3d85e6">InputPosixTimeMax</a></li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 <a class="el" href="namespacenn_1_1time.html#a8e7d7a0e92e652c83c9ec02fdd76d92f">GetDeviceLocationName</a> 関数で得られる <a class="el" href="structnn_1_1time_1_1_location_name.html">LocationName</a> から生成した <a class="el" href="structnn_1_1time_1_1_time_zone_rule.html">TimeZoneRule</a> が自動的に利用されます。 </p>

</div>
</div>
<a class="anchor" id="a56a9d8766ae95d7336758e1531928c5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1time_1_1_calendar_time.html">CalendarTime</a> nn::time::ToCalendarTimeInUtc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1time_1_1_posix_time.html">PosixTime</a> &amp;&#160;</td>
          <td class="paramname"><em>posixTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>絶対時刻を協定世界時 (UTC) の日時へ変換します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">posixTime</td><td>絶対時刻 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>日時 (UTC)</dd></dl>
<p><b>詳細</b> <br />
 本関数で得られる <a class="el" href="structnn_1_1time_1_1_calendar_time.html" title="カレンダー情報を扱う構造体です。 ">CalendarTime</a> は協定世界時 (UTC) の時刻です。<br />
 デバイスに設定されているタイムゾーンルールは考慮されません。 </p>

</div>
</div>
<a class="anchor" id="a5dee0854e0a9f287e495129b37fcf2ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::time::ToPosixTime </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1time_1_1_posix_time.html">PosixTime</a> *&#160;</td>
          <td class="paramname"><em>pOutPosixTimeList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1time_1_1_calendar_time.html">CalendarTime</a> &amp;&#160;</td>
          <td class="paramname"><em>calendarTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1time_1_1_time_zone_rule.html">TimeZoneRule</a> &amp;&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>現地時刻から絶対時刻へ変換します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>pOutPosixTimeList に格納された要素数 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutPosixTimeList</td><td>絶対時刻 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>pOutPosixTimeList の要素数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">calendarTime</td><td>現地時刻 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rule</td><td>タイムゾーンルール</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理結果 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000246">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>TIME ライブラリが初期化されている</li>
<li>pOutCount != nullptr</li>
<li>pOutPosixTimeList != nullptr</li>
<li>count &gt; 0</li>
<li>2000 &lt;= calendarTime.year &lt;= 2100</li>
<li>1 &lt;= calendarTime.month &lt;= 12</li>
<li>1 &lt;= calendarTime.day &lt;= 31</li>
<li>0 &lt;= calendarTime.hour &lt;= 23</li>
<li>0 &lt;= calendarTime.minute &lt;= 59</li>
<li>0 &lt;= calendarTime.second &lt;= 59</li>
<li>タイムゾーンルールが読み込み済である</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>0 &lt;= *pOutCount &lt;= 2</li>
<li>*pOutCount == 2 の場合、 pOutPosixTimeList[0] &lt; pOutPosixTimeList[1]</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 <a class="el" href="namespacenn_1_1time.html#a8e7d7a0e92e652c83c9ec02fdd76d92f">GetDeviceLocationName</a> 関数で得られる <a class="el" href="structnn_1_1time_1_1_location_name.html">LocationName</a> から生成した <a class="el" href="structnn_1_1time_1_1_time_zone_rule.html">TimeZoneRule</a> が自動的に利用されます。</p>
<p>入力する現地時刻によって、本 API は次の通り 0 個から 2 個の絶対時刻を返します。 </p><table class="doxtable">
<tr>
<th align="left">入力の現地時刻のケース </th><th align="left">動作説明  </th></tr>
<tr>
<td align="left">1度だけ訪れる日時を指定した場合 </td><td align="left">*pOutCount == 1 になります。 </td></tr>
<tr>
<td align="left">時差の切り替わりによって時刻が巻き戻り、重複して2度訪れる日時を指定した場合 </td><td align="left">*pOutCount == 2 になります。 <br />
 pOutPosixTimeList[0] が時差の切り替わり前、 pOutPosixTimeList[1] が時差の切り替わり後の絶対時刻です。 </td></tr>
<tr>
<td align="left">時差の切り替わりによって時刻が進み、スキップされて存在しない日時を指定した場合や <br />
 2月31日など存在しない日付を指定した場合 </td><td align="left">*pOutCount == 0 になります。 </td></tr>
</table>
<p>時刻の重複・スキップは、地域に適用される時差の運用ルールが変わるタイミングで発生します。 <br />
 例えば夏時間の開始・終了がこれにあたりますが、 法律の改正によって時差の運用ルールが変更されるタイミングでも発生することがあります。</p>
<p>実装の簡略化のため、2個の絶対時刻が取得できた際に pOutPosixTimeList[0] か pOutPosixTimeList[1] の どちらか一方をアプリケーションで自動的に採用しても構いませんが、アプリケーションに仕様上の問題が起きないよう注意してください。</p>
<p>この関数に渡す <a class="el" href="structnn_1_1time_1_1_time_zone_rule.html" title="タイムゾーンルールを表す型です。 ">TimeZoneRule</a> の先頭アドレスを 4 KB アライメントにすることで、 Release ビルド時で数マイクロ秒の処理時間低減を行うことができます。 </p>

</div>
</div>
<a class="anchor" id="aff7759cf28be555a9a19d209173bb938"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnn_1_1_result.html">nn::Result</a> nn::time::ToPosixTime </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1time_1_1_posix_time.html">PosixTime</a> *&#160;</td>
          <td class="paramname"><em>pOutPosixTimeList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1time_1_1_calendar_time.html">CalendarTime</a> &amp;&#160;</td>
          <td class="paramname"><em>calendarTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>現地時刻から絶対時刻へ変換します。 デバイスの設定に従ったタイムゾーンルールが自動で利用されます。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutCount</td><td>pOutPosixTimeList に格納された要素数 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutPosixTimeList</td><td>絶対時刻 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>pOutPosixTimeList の要素数 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">calendarTime</td><td>現地時刻</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>処理結果 <br />
 </dd></dl>
<dl class="retval"><dt><b><a class="el" href="retval.html#_retval000247">戻り値一覧:</a></b></dt><dd><b><a class="el" href="classnn_1_1_result_success.html" title="Result の成功を表す型です。 ">ResultSuccess</a></b> 成功しました。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>TIME ライブラリが初期化されている</li>
<li>pOutCount != nullptr</li>
<li>pOutPosixTimeList != nullptr</li>
<li>count &gt; 0</li>
<li>2000 &lt;= calendarTime.year &lt;= 2100</li>
<li>1 &lt;= calendarTime.month &lt;= 12</li>
<li>1 &lt;= calendarTime.day &lt;= 31</li>
<li>0 &lt;= calendarTime.hour &lt;= 23</li>
<li>0 &lt;= calendarTime.minute &lt;= 59</li>
<li>0 &lt;= calendarTime.second &lt;= 59</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>0 &lt;= *pOutCount &lt;= 2</li>
<li>*pOutCount == 2 の場合、 pOutPosixTimeList[0] &lt; pOutPosixTimeList[1]</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 <a class="el" href="namespacenn_1_1time.html#a8e7d7a0e92e652c83c9ec02fdd76d92f">GetDeviceLocationName</a> 関数で得られる <a class="el" href="structnn_1_1time_1_1_location_name.html">LocationName</a> から生成した <a class="el" href="structnn_1_1time_1_1_time_zone_rule.html">TimeZoneRule</a> が自動的に利用されます。</p>
<p>入力する現地時刻によって、本 API は次の通り 0 個から 2 個の絶対時刻を返します。 </p><table class="doxtable">
<tr>
<th align="left">入力の現地時刻のケース </th><th align="left">動作説明  </th></tr>
<tr>
<td align="left">1度だけ訪れる日時を指定した場合 </td><td align="left">*pOutCount == 1 になります。 </td></tr>
<tr>
<td align="left">時差の切り替わりによって時刻が巻き戻り、重複して2度訪れる日時を指定した場合 </td><td align="left">*pOutCount == 2 になります。 <br />
 pOutPosixTimeList[0] が時差の切り替わり前、 pOutPosixTimeList[1] が時差の切り替わり後の絶対時刻です。 </td></tr>
<tr>
<td align="left">時差の切り替わりによって時刻が進み、スキップされて存在しない日時を指定した場合や <br />
 2月31日など存在しない日付を指定した場合 </td><td align="left">*pOutCount == 0 になります。 </td></tr>
</table>
<p>時刻の重複・スキップは、地域に適用される時差の運用ルールが変わるタイミングで発生します。 <br />
 例えば夏時間の開始・終了がこれにあたりますが、 法律の改正によって時差の運用ルールが変更されるタイミングでも発生することがあります。</p>
<p>実装の簡略化のため、2個の絶対時刻が取得できた際に pOutPosixTimeList[0] か pOutPosixTimeList[1] の どちらか一方をアプリケーションで自動的に採用しても構いませんが、アプリケーションに仕様上の問題が起きないよう注意してください。 </p>

</div>
</div>
<a class="anchor" id="ac22f757df13de784e8913f9e93a307a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1time_1_1_posix_time.html">PosixTime</a> nn::time::ToPosixTimeFromUtc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnn_1_1time_1_1_calendar_time.html">CalendarTime</a> &amp;&#160;</td>
          <td class="paramname"><em>calendarTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>協定世界時 (UTC) の日時を絶対時刻へ変換します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">calendarTime</td><td>日時 (UTC) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>絶対時刻</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li><a class="el" href="namespacenn_1_1time.html#abfd9bd6af9ce3c2302e8bbb7ac28fdc4" title="指定した年月日が有効かどうかをチェックします。 ">nn::time::IsValidDate</a>(calendarTime.year, calendarTime.month, calendarTime.day) == true</li>
<li>0 &lt;= calendarTime.hour &lt;= 23</li>
<li>0 &lt;= calendarTime.minute &lt;= 59</li>
<li>0 &lt;= calendarTime.second &lt;= 59</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
 入力の calendarTime が協定世界時 (UTC) での日時であるとして絶対時刻を計算します。<br />
 デバイスに設定されているタイムゾーンルールは考慮されません。 </p>

</div>
</div>
<h2 class="groupheader">変数詳解</h2>
<a class="anchor" id="a41baeb3eba3afcee4baddbb8487ec827"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structnn_1_1time_1_1_posix_time.html">PosixTime</a> nn::time::InputPosixTimeMin = { 946598400 }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacenn_1_1time.html#a607660798bed9111b9157807fce0a413">ToCalendarTime</a> 関数で動作保証している入力の最小値です。 </p>
<p><b>詳細</b> <br />
 協定世界時 (UTC) の1999年12月31日午前0時0分0秒を示す絶対時刻です。</p>
<p><a class="el" href="namespacenn_1_1time.html#about_time_zone_api">タイムゾーンを扱う API について </a> も併せて参照してください。 </p>

</div>
</div>
<a class="anchor" id="add20d1747d5576dacf4a50fffd3d85e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structnn_1_1time_1_1_posix_time.html">PosixTime</a> nn::time::InputPosixTimeMax = { 4102444800 }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacenn_1_1time.html#a607660798bed9111b9157807fce0a413">ToCalendarTime</a> 関数で動作保証している入力の最大値です。 </p>
<p><b>詳細</b> <br />
 協定世界時 (UTC) の2100年1月1日午前0時0分0秒を示す絶対時刻です。</p>
<p><a class="el" href="namespacenn_1_1time.html#about_time_zone_api">タイムゾーンを扱う API について </a> も併せて参照してください。 </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
