<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>NintendoSDK API Reference: IntermediateFileManager.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>総合概要</span></a></li>
      <li><a href="pages.html"><span>諸情報</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>名前空間</span></a></li>
      <li><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">IntermediateFileManager.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>ソースコードの説明は、<a class="el" href="_page_sample_nvn_tutorial02.html">NVN Tutorial 02: GPU Offline Build Tools</a> および <a class="el" href="_intermediate_file_manager_8cpp.html" title="This file defines a class that handles reading config text files, loading raw asset data...">IntermediateFileManager.cpp</a> を参照してください。</p>
<div class="fragment"><div class="line"><span class="comment">/*--------------------------------------------------------------------------------*</span></div>
<div class="line"><span class="comment">  Copyright (C)Nintendo All rights reserved.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  These coded instructions, statements, and computer programs contain proprietary</span></div>
<div class="line"><span class="comment">  information of Nintendo and/or its licensed developers and are protected by</span></div>
<div class="line"><span class="comment">  national and international copyright laws. They may not be disclosed to third</span></div>
<div class="line"><span class="comment">  parties or copied or duplicated in any form, in whole or in part, without the</span></div>
<div class="line"><span class="comment">  prior written consent of Nintendo.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  The content herein is highly confidential and should be handled accordingly.</span></div>
<div class="line"><span class="comment"> *--------------------------------------------------------------------------------*/</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_intermediate_file_manager_8h.html">IntermediateFileManager.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_texpkg___helper_8h.html">Texpkg_Helper.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_output_file_headers_8h.html">OutputFileHeaders.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;set&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">float</span> g_OutputFileVersion = 1.0f;</div>
<div class="line"></div>
<div class="line">IntermediateFileManager::IntermediateFileManager()</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::~IntermediateFileManager</span></div>
<div class="line"><span class="comment"> * -------------------------------------------------</span></div>
<div class="line"><span class="comment"> * Cleans up GLSLC and texpkg objects and frees any dynamically</span></div>
<div class="line"><span class="comment"> * allocated memory.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">IntermediateFileManager::~IntermediateFileManager()</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/* Finalize the glslc compile objects for each shader program. */</span></div>
<div class="line">    <span class="keywordflow">for</span>(std::unordered_map&lt;std::string, ShaderCompileData&gt;::iterator itr = m_ShaderPrograms.begin(); itr != m_ShaderPrograms.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        <a name="a0"></a><a class="code" href="nvn_tool___glslc_interface_8h.html#a05b2032c99f789df2a34ebf32271c320">glslcFinalize</a>(&amp;(itr-&gt;second.m_CompileObject));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Release the raw texture data. */</span></div>
<div class="line">    <span class="keywordflow">for</span>(std::vector&lt;TextureData&gt;::iterator itr = m_RawTextureData.begin(); itr != m_RawTextureData.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        itr-&gt;m_pRawImage-&gt;Release();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Release the converted texture data. */</span></div>
<div class="line">    <span class="keywordflow">for</span>(std::unordered_map&lt;std::string, nvnTool::texpkg::NVNHWTexture&gt;::iterator itr = m_ConvertedTextureData.begin(); itr != m_ConvertedTextureData.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        g_HwTextureExporter-&gt;<a name="a1"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image_hardware_texture_exporter.html#a3c17476b5aa35d3c7ef2b385dcd52871">ReleaseTextureData</a>(&amp;itr-&gt;second);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Frees the loaded model data. */</span></div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; m_RawModelData.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        free(m_RawModelData[i].m_IndexData.m_pData);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span>(uint32_t j = 0; j &lt; m_RawModelData[i].m_VertexAttributes.size(); ++j)</div>
<div class="line">        {</div>
<div class="line">            free(m_RawModelData[i].m_VertexAttributes[j].m_pData);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadShaderPrograms</span></div>
<div class="line"><span class="comment"> * -------------------------------------------</span></div>
<div class="line"><span class="comment"> * Loads the shader source needed for each stage of the shader program.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> IntermediateFileManager::LoadShaderPrograms(<span class="keyword">const</span> std::string&amp; path)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (std::unordered_map&lt;std::string, ShaderCompileData&gt;::iterator itr = m_ShaderPrograms.begin(); itr != m_ShaderPrograms.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        std::string* temp = <span class="keyword">reinterpret_cast&lt;</span>std::string*<span class="keyword">&gt;</span>(&amp;(itr-&gt;second));</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; 6; ++i)</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">/* If the shader stage exists for the program, load the source. */</span></div>
<div class="line">            <span class="keywordflow">if</span> (temp[i].size())</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">if</span> (!LoadShaderSource(temp[i], path))</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadShaderSource</span></div>
<div class="line"><span class="comment"> * -----------------------------------------</span></div>
<div class="line"><span class="comment"> * Loads the shader source specified by the given file name. If the source for</span></div>
<div class="line"><span class="comment"> * that file name has already been loaded, it just returns.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> IntermediateFileManager::LoadShaderSource(<span class="keyword">const</span> std::string&amp; filename, <span class="keyword">const</span> std::string&amp; path)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/* If the sour has been loaded already, return true. */</span></div>
<div class="line">    <span class="keywordflow">if</span> (m_RawShaderSource.find(filename) != m_RawShaderSource.end())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::ifstream shaderFile;</div>
<div class="line">    shaderFile.open(path + filename);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Return false if the file is not found. */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!shaderFile.is_open())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span>(!shaderFile.eof())</div>
<div class="line">    {</div>
<div class="line">        std::string temp;</div>
<div class="line">        std::getline(shaderFile, temp);</div>
<div class="line">        temp += <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        m_RawShaderSource[filename] += temp;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::CompileShaderPrograms</span></div>
<div class="line"><span class="comment"> * ----------------------------------------------</span></div>
<div class="line"><span class="comment"> * Compile the shader sources for each stage with a default set of</span></div>
<div class="line"><span class="comment"> * shader compile options.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> IntermediateFileManager::CompileShaderPrograms()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span>(std::unordered_map&lt;std::string, ShaderCompileData&gt;::iterator itr = m_ShaderPrograms.begin(); itr != m_ShaderPrograms.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        std::vector&lt;const char *&gt; shaderSources;</div>
<div class="line">        std::vector&lt;NVNshaderStage&gt; shaderStages;</div>
<div class="line"></div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * Checks each stage to see if there is shader source for it. If</span></div>
<div class="line"><span class="comment">             * there is, then the source and stage value are added to their</span></div>
<div class="line"><span class="comment">             * respective lists.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        <span class="keywordflow">if</span>(itr-&gt;second.m_Comp.size())</div>
<div class="line">        {</div>
<div class="line">            shaderSources.push_back(m_RawShaderSource.at(itr-&gt;second.m_Comp).c_str());</div>
<div class="line">            shaderStages.push_back(<a name="a2"></a><a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddae173bae8c554c2f196ff291335408395">NVNshaderStage::NVN_SHADER_STAGE_COMPUTE</a>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>(itr-&gt;second.m_Frag.size())</div>
<div class="line">        {</div>
<div class="line">            shaderSources.push_back(m_RawShaderSource.at(itr-&gt;second.m_Frag).c_str());</div>
<div class="line">            shaderStages.push_back(<a name="a3"></a><a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf979f751d1526164abb522c640c8eb06">NVNshaderStage::NVN_SHADER_STAGE_FRAGMENT</a>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>(itr-&gt;second.m_Geom.size())</div>
<div class="line">        {</div>
<div class="line">            shaderSources.push_back(m_RawShaderSource.at(itr-&gt;second.m_Geom).c_str());</div>
<div class="line">            shaderStages.push_back(<a name="a4"></a><a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf87149873f1b592524e771fdf82ab86f">NVNshaderStage::NVN_SHADER_STAGE_GEOMETRY</a>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>(itr-&gt;second.m_TessCont.size())</div>
<div class="line">        {</div>
<div class="line">            shaderSources.push_back(m_RawShaderSource.at(itr-&gt;second.m_TessCont).c_str());</div>
<div class="line">            shaderStages.push_back(<a name="a5"></a><a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddad8bedcc05b63478d7c2cdf772ddc8096">NVNshaderStage::NVN_SHADER_STAGE_TESS_CONTROL</a>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>(itr-&gt;second.m_TessEval.size())</div>
<div class="line">        {</div>
<div class="line">            shaderSources.push_back(m_RawShaderSource.at(itr-&gt;second.m_TessEval).c_str());</div>
<div class="line">            shaderStages.push_back(<a name="a6"></a><a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf732e2b4f5f5c1b5fca530f25146a8fb">NVNshaderStage::NVN_SHADER_STAGE_TESS_EVALUATION</a>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>(itr-&gt;second.m_Vert.size())</div>
<div class="line">        {</div>
<div class="line">            shaderSources.push_back(m_RawShaderSource.at(itr-&gt;second.m_Vert).c_str());</div>
<div class="line">            shaderStages.push_back(<a name="a7"></a><a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abdda5a6e5f69e0f338221cc5acf7882a21c7">NVNshaderStage::NVN_SHADER_STAGE_VERTEX</a>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * GLSLC Compile Object</span></div>
<div class="line"><span class="comment">             * --------------------</span></div>
<div class="line"><span class="comment">             * The GLSLCcompileObject holds the options used in the shader compile,</span></div>
<div class="line"><span class="comment">             * the output from the compile, the shader compile status/log, and shader</span></div>
<div class="line"><span class="comment">             * reflection data. The same compile object can be used for multiple compiles.</span></div>
<div class="line"><span class="comment">             * The lastCompiledResults pointer will be freed on subsequent compiles so</span></div>
<div class="line"><span class="comment">             * it is up to the application to copy the necessary data before using the</span></div>
<div class="line"><span class="comment">             * compile object again. The compile object needs to be initialize before</span></div>
<div class="line"><span class="comment">             * being used and should be finalized once the application is done with it.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        <span class="keywordflow">if</span> (!<a name="a8"></a><a class="code" href="nvn_tool___glslc_interface_8h.html#a648dfc0b503357a72dad03652fc31e57">glslcInitialize</a>(&amp;(itr-&gt;second.m_CompileObject)))</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to initialize glslc compile object.\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * GLSLC Options</span></div>
<div class="line"><span class="comment">             * -------------</span></div>
<div class="line"><span class="comment">             * The GLSLCoptions portion of the GLSLCcompile object has a</span></div>
<div class="line"><span class="comment">             * GLSLCoptionFlags struct that contains a number of options</span></div>
<div class="line"><span class="comment">             * that can be set for the next shader compile. Options:</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * glslSeparable                - Treat the GLSLC object as separable. Can be</span></div>
<div class="line"><span class="comment">             *                                used to compile singular shader stages.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * outputAssembly               - Include an assembly dump section in the</span></div>
<div class="line"><span class="comment">             *                                GLSLCoutput.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * outputGpuBinaries            - Output individual program binary sections</span></div>
<div class="line"><span class="comment">             *                                in the GLSLCoutput. Outputs one binary per</span></div>
<div class="line"><span class="comment">             *                                stage.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * outputPerfStats              - Output individual perf statistics for each</span></div>
<div class="line"><span class="comment">             *                                compiled binary.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * outputShaderReflection       - Output shader reflection data. Allows the</span></div>
<div class="line"><span class="comment">             *                                application to grab data about the shader like</span></div>
<div class="line"><span class="comment">             *                                uniform block sizes, names, locations, etc.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * language                     - Specify the language of the input shaders.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * outputDebugInfo              - Level of debug information to generate.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * spillControl                 - Control amount of spilling. Can be set to</span></div>
<div class="line"><span class="comment">             *                                DEFAULT_SPILL or NO_SPILL.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * outputThinGpuBinaries        - Controls whether the resulting output contains a</span></div>
<div class="line"><span class="comment">             *                                GPU program that is a thin binary (only contains</span></div>
<div class="line"><span class="comment">             *                                program code for NX platforms).</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * tessellationAndPassthroughGS - Compiles tessellation evaluation and passthrough</span></div>
<div class="line"><span class="comment">             *                                geometry shaders (NV_geometry_shader_passthrough)</span></div>
<div class="line"><span class="comment">             *                                to work together as a pair.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * These additional options are available in the GLSLCoptions struct proper:</span></div>
<div class="line"><span class="comment">             * includeInfo                  - Used to set include paths for shader headers.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * xfbVaryingInfo               - Used to specify transform feedback information.</span></div>
<div class="line"><span class="comment">             *</span></div>
<div class="line"><span class="comment">             * forceIncludeStdHeader        - Include standard header file. If this is NULL,</span></div>
<div class="line"><span class="comment">             *                                no standard header will be included.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        <a name="_a9"></a><a class="code" href="struct_g_l_s_l_coptions.html">GLSLCoptions</a> * options = &amp;(itr-&gt;second.m_CompileObject.options);</div>
<div class="line"></div>
<div class="line">        options-&gt;<a name="a10"></a><a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a11"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#ac0396d28c3ec928aaa280cb90e71f485">outputAssembly</a> = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// NOTE: This must be set to true for now.</span></div>
<div class="line">        options-&gt;<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a12"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#aec0779a250ad31f6deafe470820ffbb8">outputGpuBinaries</a> = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">        options-&gt;<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a13"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#af673dc6b82db05442d203619be5a022d">glslSeparable</a> = shaderStages.size() &lt; 2;</div>
<div class="line">        options-&gt;<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a14"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#ad57cedc549a410a87a8b5e667afd31b9">outputPerfStats</a> = <span class="keyword">true</span>;</div>
<div class="line">        options-&gt;<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a15"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#a723afb9e18cdf4c92bfe315c94e37c96">outputShaderReflection</a> = <span class="keyword">true</span>;</div>
<div class="line">        options-&gt;<a class="code" href="struct_g_l_s_l_coptions.html#a2b07e6d6a4984f7922cab3efbf8caf16">optionFlags</a>.<a name="a16"></a><a class="code" href="struct_g_l_s_l_coption_flags.html#af2b81192a389ab5093f074ced7ceea29">outputDebugInfo</a> = <a name="a17"></a><a class="code" href="nvn_tool___glslc_interface_8h.html#a238b82c174a58d9f9e2be6aa3e8a5bfea81704ec256f338d05d20e0d618decdef">GLSLC_DEBUG_LEVEL_G0</a>;</div>
<div class="line"></div>
<div class="line">            <span class="comment">/*</span></div>
<div class="line"><span class="comment">             * GLSLC Input</span></div>
<div class="line"><span class="comment">             * -------------</span></div>
<div class="line"><span class="comment">             * This structure defines the input data for the compilation.</span></div>
<div class="line"><span class="comment">             * The input is a list of pointers to shader source with a</span></div>
<div class="line"><span class="comment">             * corresponding list of NVNshaderStage values.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">        itr-&gt;second.m_CompileObject.input.sources = &amp;shaderSources[0];</div>
<div class="line">        itr-&gt;second.m_CompileObject.input.stages = &amp;shaderStages[0];</div>
<div class="line">        itr-&gt;second.m_CompileObject.input.count = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(shaderSources.size());</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* Compiles the shader program with the given input and options. */</span></div>
<div class="line">        <span class="keywordflow">if</span>(!<a name="a18"></a><a class="code" href="nvn_tool___glslc_interface_8h.html#ad0fd458cbbcd554a1dc81ac61fdcf7e3">glslcCompile</a>(&amp;(itr-&gt;second.m_CompileObject)))</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Compilation failed.  Info log:\n&quot;</span> &lt;&lt; itr-&gt;second.m_CompileObject.lastCompiledResults-&gt;compilationStatus-&gt;infoLog &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* Set these pointers to NULL before the things they point at go out of scope */</span></div>
<div class="line">        itr-&gt;second.m_CompileObject.input.sources = NULL;</div>
<div class="line">        itr-&gt;second.m_CompileObject.input.stages = NULL;</div>
<div class="line">        itr-&gt;second.m_CompileObject.input.count = 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Align</span></div>
<div class="line"><span class="comment"> * -----</span></div>
<div class="line"><span class="comment"> * Aligns a given value up to the given alignment</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">size_t</span> IntermediateFileManager::Align(<span class="keywordtype">size_t</span> size, <span class="keywordtype">size_t</span> alignment, <span class="keywordtype">size_t</span>&amp; bytesAlignedUp)</div>
<div class="line">{</div>
<div class="line">    bytesAlignedUp = (alignment - (size % alignment)) % alignment;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> bytesAlignedUp + size;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * PadFileBuffer</span></div>
<div class="line"><span class="comment"> * -------------</span></div>
<div class="line"><span class="comment"> * Inserts padding bytes into the file to maintain alignment of following</span></div>
<div class="line"><span class="comment"> * entries.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">size_t</span> IntermediateFileManager::PadFileBuffer(FILE* file, <span class="keywordtype">size_t</span> padSize)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (padSize == 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">static</span> std::vector&lt;char&gt; padBuffer;</div>
<div class="line">    <span class="keywordflow">if</span> (padSize &gt; padBuffer.size())</div>
<div class="line">    {</div>
<div class="line">        padBuffer.resize(padSize, 0);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> fwrite(&amp;padBuffer[0], <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), padSize, file);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::WriteOutputFile</span></div>
<div class="line"><span class="comment"> * ----------------------------------------</span></div>
<div class="line"><span class="comment"> * Takes the accumulated shader compile data, converted texture</span></div>
<div class="line"><span class="comment"> * data, and model data and writes it all out into one large</span></div>
<div class="line"><span class="comment"> * binary file. The general structure of the file is laid out</span></div>
<div class="line"><span class="comment"> * by the structs defined in OutputFileHeaders.h.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> IntermediateFileManager::WriteOutputFile(<span class="keyword">const</span> std::string&amp; outPath, <span class="keyword">const</span> std::string&amp; fileName, <span class="keywordtype">bool</span> outputDebugGlslcFiles)</div>
<div class="line">{</div>
<div class="line">    std::string filePath = outPath + fileName;</div>
<div class="line">    FILE* outputFile;</div>
<div class="line">    fopen_s(&amp;outputFile, filePath.c_str(), <span class="stringliteral">&quot;wb&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!outputFile)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    OutputFileHeader outputFileHeader;</div>
<div class="line"></div>
<div class="line">    ShaderBlockHeader shaderBlockHeader;</div>
<div class="line">    memset(&amp;shaderBlockHeader, 0, <span class="keyword">sizeof</span>(ShaderBlockHeader));</div>
<div class="line">    std::vector&lt;std::pair&lt;ShaderProgramHeader, std::vector&lt;ShaderStageHeader&gt; &gt; &gt; shaderProgramHeaders;</div>
<div class="line"></div>
<div class="line">    TextureBlockHeader textureBlockHeader;</div>
<div class="line">    memset(&amp;textureBlockHeader, 0, <span class="keyword">sizeof</span>(TextureBlockHeader));</div>
<div class="line">    std::vector&lt;TextureDataHeader&gt; textureDataHeaders;</div>
<div class="line"></div>
<div class="line">    ModelBlockHeader modelBlockHeader;</div>
<div class="line">    memset(&amp;modelBlockHeader, 0, <span class="keyword">sizeof</span>(ModelBlockHeader));</div>
<div class="line"></div>
<div class="line">    std::vector&lt;std::pair&lt;ModelHeader, std::pair&lt;std::vector&lt;VertexAttributeHeader&gt;, IndexBufferHeader&gt; &gt; &gt; modelHeaders;</div>
<div class="line"></div>
<div class="line">    outputFileHeader.m_Version = g_OutputFileVersion;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Keep track of the current offset. */</span></div>
<div class="line">    <span class="keywordtype">size_t</span> currentOffset = <span class="keyword">sizeof</span>(OutputFileHeader);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Keep track of instances of padding */</span></div>
<div class="line">    std::vector&lt;size_t&gt; padding;</div>
<div class="line">    <span class="keywordtype">size_t</span> currentPadding = 0;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Check for shader programs*/</span></div>
<div class="line">    <span class="keywordflow">if</span> (!m_ShaderPrograms.size())</div>
<div class="line">    {</div>
<div class="line">        outputFileHeader.m_ShaderBlockOffset = 0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        outputFileHeader.m_ShaderBlockOffset = <span class="keyword">sizeof</span>(OutputFileHeader);</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* Create directory along side assets that glslc debug output files will go in */</span></div>
<div class="line">        std::string glslcOutputDirectory(outPath + <span class="stringliteral">&quot;GlslcDbg\\&quot;</span>);</div>
<div class="line">        <span class="keywordtype">wchar_t</span> ws[256];</div>
<div class="line">        memset(ws, 0, 256 * <span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>));</div>
<div class="line">        swprintf(ws, glslcOutputDirectory.size(), L<span class="stringliteral">&quot;%hs&quot;</span>, glslcOutputDirectory.c_str());</div>
<div class="line">        <a name="a19"></a><a class="code" href="namespacenn_1_1fs.html#ad09dbc3816b9e95562081f9411711c4a">CreateDirectory</a>(ws, NULL);</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* Accumulates data about each shader program to be written out. */</span></div>
<div class="line">        <span class="keywordflow">for</span> (std::unordered_map&lt;std::string, ShaderCompileData&gt;::iterator itr = m_ShaderPrograms.begin(); itr != m_ShaderPrograms.end(); ++itr)</div>
<div class="line">        {</div>
<div class="line">            shaderProgramHeaders.push_back(std::pair&lt;ShaderProgramHeader, std::vector&lt;ShaderStageHeader&gt; &gt;());</div>
<div class="line"></div>
<div class="line">            ShaderProgramHeader&amp; programHeader = shaderProgramHeaders.back().first;</div>
<div class="line">            std::vector&lt;ShaderStageHeader&gt;&amp; stageHeaders = shaderProgramHeaders.back().second;</div>
<div class="line"></div>
<div class="line">            programHeader.m_pProgramName = itr-&gt;first.c_str();</div>
<div class="line">            programHeader.m_ProgramNameLength = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(itr-&gt;first.size());</div>
<div class="line">            programHeader.m_NumShaderStages = 0;</div>
<div class="line"></div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * GLSLCoutput</span></div>
<div class="line"><span class="comment">                 * -----------</span></div>
<div class="line"><span class="comment">                 * Holds the various sections output by the shader compile.</span></div>
<div class="line"><span class="comment">                 * Offsets to each section are from the beginning of the</span></div>
<div class="line"><span class="comment">                 * output struct. Offsets defined within a section are from</span></div>
<div class="line"><span class="comment">                 * the beginning of that section. These sections are:</span></div>
<div class="line"><span class="comment">                 *</span></div>
<div class="line"><span class="comment">                 * GLSLC_SECTION_TYPE_GPU_CODE   - Holds the compiled binary and</span></div>
<div class="line"><span class="comment">                 *                                 information for a shader stage.</span></div>
<div class="line"><span class="comment">                 *</span></div>
<div class="line"><span class="comment">                 * GLSLC_SECTION_TYPE_ASM_DUMP   - Holds the assembly dump for the</span></div>
<div class="line"><span class="comment">                 *                                 compiled shader stage.</span></div>
<div class="line"><span class="comment">                 *</span></div>
<div class="line"><span class="comment">                 * GLSLC_SECTION_TYPE_PERF_STATS - Holds the performance stats for</span></div>
<div class="line"><span class="comment">                 *                                 the shader stage.</span></div>
<div class="line"><span class="comment">                 *</span></div>
<div class="line"><span class="comment">                 * GLSLC_SECTION_TYPE_REFLECTION - Holds the shader reflection data</span></div>
<div class="line"><span class="comment">                 *                                 for the shader stage.</span></div>
<div class="line"><span class="comment">                 *</span></div>
<div class="line"><span class="comment">                 * GLSLC_SECTION_TYPE_DEBUG_INFO - Holds debug information for the</span></div>
<div class="line"><span class="comment">                 *                                 shader stage.</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">            <a name="_a20"></a><a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a>* compileOutput = itr-&gt;second.m_CompileObject.lastCompiledResults-&gt;glslcOutput;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span>(outputDebugGlslcFiles)</div>
<div class="line">            {</div>
<div class="line">                    <span class="comment">/*</span></div>
<div class="line"><span class="comment">                     * Write GLSLC output to file for NVN Graphics Debugger to use.</span></div>
<div class="line"><span class="comment">                     * To use these files, capture a frame in NVNGD, click on a</span></div>
<div class="line"><span class="comment">                     * draw event in the Events View window, go to one of the shader</span></div>
<div class="line"><span class="comment">                     * tabs in the API Inspector View, and click on the link to</span></div>
<div class="line"><span class="comment">                     * view shader source.  Set the folder below as the directory</span></div>
<div class="line"><span class="comment">                     * to look for the debug files in.</span></div>
<div class="line"><span class="comment">                     */</span></div>
<div class="line">                FILE* glslcOutputFileHandle = NULL;</div>
<div class="line"></div>
<div class="line">                std::string glslcOutputFileName(outPath + <span class="stringliteral">&quot;GlslcDbg\\&quot;</span> + fileName + <span class="stringliteral">&quot;.glslc&quot;</span>);</div>
<div class="line">                <span class="keywordflow">if</span>(fopen_s(&amp;glslcOutputFileHandle, glslcOutputFileName.c_str(), <span class="stringliteral">&quot;wb&quot;</span>) != 0)</div>
<div class="line">                {</div>
<div class="line">                    assert(<span class="keyword">false</span>);</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">if</span>(!glslcOutputFileHandle)</div>
<div class="line">                {</div>
<div class="line">                    assert(<span class="keyword">false</span>);</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                fwrite(reinterpret_cast&lt;char*&gt;(compileOutput), compileOutput-&gt;<a name="a21"></a><a class="code" href="struct_g_l_s_l_coutput.html#ac6e8159c6357796e5c51b6eb91f279b7">size</a>, 1, glslcOutputFileHandle);</div>
<div class="line">                fclose(glslcOutputFileHandle);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; compileOutput-&gt;<a name="a22"></a><a class="code" href="struct_g_l_s_l_coutput.html#a6cbb6ec5e8a4ff04512fd1c442aa3d92">numSections</a>; ++i)</div>
<div class="line">            {</div>
<div class="line">                <a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59">GLSLCsectionTypeEnum</a> type = compileOutput-&gt;<a name="a23"></a><a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].<a name="a24"></a>genericHeader.<a name="a25"></a>common.<a name="a26"></a><a class="code" href="struct_g_l_s_l_csection_header_common.html#a6a8aed7a5a7e82acff908d084fd85e4a">type</a>;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (type == <a name="a27"></a><a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59a332c55c4b44004865dda7d54c91df448">GLSLC_SECTION_TYPE_GPU_CODE</a>)</div>
<div class="line">                {</div>
<div class="line">                        <span class="comment">/*</span></div>
<div class="line"><span class="comment">                         * GLSLCgpuCodeHeader</span></div>
<div class="line"><span class="comment">                         * ------------------</span></div>
<div class="line"><span class="comment">                         * This structure is a section header that holds information used</span></div>
<div class="line"><span class="comment">                         * to access compiled shader code for an individual shader stage.</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * stage                      - Shader stage the gpu code correspons to.</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * controlOffset              - Offset in bytes to the control section</span></div>
<div class="line"><span class="comment">                         *                              from the start of the data section of the</span></div>
<div class="line"><span class="comment">                         *                              header.</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * controlSize                - Size of the control section in bytes.</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * dataOffset                 - Offset to the shader data section in bytes</span></div>
<div class="line"><span class="comment">                         *                              fom the start of the header&#39;s data section.</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * dataSize                   - Size of the shader data section.</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * scratchMemBytesPerWarp     - Amount of local memory required for the stage</span></div>
<div class="line"><span class="comment">                         *                              in bytes per warp.</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * scratchMemBytesRecommended - Recommended amount of local memory on the target.</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * asmDumpSectionIdx          - Index of the assembly dump section for this shader</span></div>
<div class="line"><span class="comment">                         *                              stage (if option was turned on).</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * perfStatsSectionNdx        - Index of the performance stats section for this</span></div>
<div class="line"><span class="comment">                         *                              shader stage (if option was turned on).</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * subroutineLinkageMapOffset - Offset to subroutine linkage map offset in data section</span></div>
<div class="line"><span class="comment">                         *</span></div>
<div class="line"><span class="comment">                         * subroutineLinkageMapSize   - Size of subroutine linkage map size</span></div>
<div class="line"><span class="comment">                         */</span></div>
<div class="line">                    <a name="_a28"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html">GLSLCgpuCodeHeader</a> * gpuHeader = &amp;(compileOutput-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].<a name="a29"></a>gpuCodeHeader);</div>
<div class="line"></div>
<div class="line">                        <span class="comment">/*</span></div>
<div class="line"><span class="comment">                         * Grab a pointer to the data section of the header. The control offset and</span></div>
<div class="line"><span class="comment">                         * data offset from the gpu code header are offsets from this pointer.</span></div>
<div class="line"><span class="comment">                         */</span></div>
<div class="line">                    <span class="keywordtype">void</span> * data = ((<span class="keywordtype">char</span>*)compileOutput) + gpuHeader-&gt;<a name="a30"></a>common.<a name="a31"></a><a class="code" href="struct_g_l_s_l_csection_header_common.html#abb6e96b70bad30c94477317328d384d5">dataOffset</a>;</div>
<div class="line"></div>
<div class="line">                    ShaderStageHeader stageHeader;</div>
<div class="line">                    stageHeader.m_ShaderStage = gpuHeader-&gt;<a name="a32"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#ab1e6be676a326a7281e18ad3a4607ced">stage</a>;</div>
<div class="line">                    stageHeader.m_ShaderControlSize = gpuHeader-&gt;<a name="a33"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#aff5295c90f2dc5eb969fb14660f31712">controlSize</a>;</div>
<div class="line">                    stageHeader.m_ShaderDataSize = gpuHeader-&gt;<a name="a34"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#a2617848640a161d41ed59f1a7c0ccb35">dataSize</a>;</div>
<div class="line">                    stageHeader.m_ShaderControlOffset = 0; <span class="comment">// Retrieve this offset later</span></div>
<div class="line">                    stageHeader.m_pShaderData = ((<span class="keywordtype">char</span>*)data + gpuHeader-&gt;<a name="a35"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#aafdececf784595d922fe1b95b06db976">dataOffset</a>);</div>
<div class="line">                    stageHeader.m_pShaderControl = ((<span class="keywordtype">char</span>*)data + gpuHeader-&gt;<a name="a36"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#a3b606fedf8582a1a47162d210e8a1448">controlOffset</a>);</div>
<div class="line"></div>
<div class="line">                    ++programHeader.m_NumShaderStages;</div>
<div class="line"></div>
<div class="line">                    stageHeaders.push_back(stageHeader);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            programHeader.m_pShaderStageOffsets = (uint64_t*)malloc(<span class="keyword">sizeof</span>(uint64_t) * programHeader.m_NumShaderStages);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        shaderBlockHeader.m_NumShaderPrograms = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(shaderProgramHeaders.size());</div>
<div class="line">        uint32_t shaderProgramOffsetsSize = <span class="keyword">sizeof</span>(uint64_t) * shaderBlockHeader.m_NumShaderPrograms;</div>
<div class="line">        shaderBlockHeader.m_pShaderProgramOffsets = (uint64_t*)malloc(shaderProgramOffsetsSize);</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* Based on the accumulated data the currentOffset is updated. */</span></div>
<div class="line">        currentOffset += <span class="keyword">sizeof</span>(ShaderBlockHeader);</div>
<div class="line">        currentOffset -= <span class="keyword">sizeof</span>(shaderBlockHeader.m_pShaderProgramOffsets);</div>
<div class="line">        currentOffset += shaderProgramOffsetsSize;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; shaderProgramHeaders.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * Align shader program header struct to account for</span></div>
<div class="line"><span class="comment">                 * variable length of shader name</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">            currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">            padding.push_back(currentPadding);</div>
<div class="line">            shaderBlockHeader.m_pShaderProgramOffsets[i] = currentOffset;</div>
<div class="line"></div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(ShaderProgramHeader);</div>
<div class="line">            currentOffset -= <span class="keyword">sizeof</span>(shaderProgramHeaders[i].first.m_pShaderStageOffsets);</div>
<div class="line">            currentOffset -= <span class="keyword">sizeof</span>(shaderProgramHeaders[i].first.m_pProgramName);</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(char) * shaderProgramHeaders[i].first.m_ProgramNameLength;</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(uint64_t) * shaderProgramHeaders[i].first.m_NumShaderStages;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; shaderProgramHeaders[i].first.m_NumShaderStages; ++j)</div>
<div class="line">            {</div>
<div class="line">                    <span class="comment">/*</span></div>
<div class="line"><span class="comment">                     * Align shader stage header struct to account for</span></div>
<div class="line"><span class="comment">                     * variable length of shader and control data</span></div>
<div class="line"><span class="comment">                     */</span></div>
<div class="line">                currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">                padding.push_back(currentPadding);</div>
<div class="line">                shaderProgramHeaders[i].first.m_pShaderStageOffsets[j] = currentOffset;</div>
<div class="line"></div>
<div class="line">                currentOffset += <span class="keyword">sizeof</span>(ShaderStageHeader);</div>
<div class="line">                currentOffset -= <span class="keyword">sizeof</span>(shaderProgramHeaders[i].second[j].m_pShaderData);</div>
<div class="line">                currentOffset -= <span class="keyword">sizeof</span>(shaderProgramHeaders[i].second[j].m_pShaderControl);</div>
<div class="line">                currentOffset += shaderProgramHeaders[i].second[j].m_ShaderDataSize;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">/*</span></div>
<div class="line"><span class="comment">                     * Offset of control data is set now to account for the variable</span></div>
<div class="line"><span class="comment">                     * size of the shader data</span></div>
<div class="line"><span class="comment">                     */</span></div>
<div class="line">                currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">                padding.push_back(currentPadding);</div>
<div class="line">                shaderProgramHeaders[i].second[j].m_ShaderControlOffset = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(currentOffset);</div>
<div class="line"></div>
<div class="line">                currentOffset += shaderProgramHeaders[i].second[j].m_ShaderControlSize;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Check for textures */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!m_ConvertedTextureData.size())</div>
<div class="line">    {</div>
<div class="line">        outputFileHeader.m_TextureBlockOffset = 0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">        padding.push_back(currentPadding);</div>
<div class="line">        outputFileHeader.m_TextureBlockOffset = currentOffset;</div>
<div class="line"></div>
<div class="line">        textureBlockHeader.m_NumTextures = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(m_ConvertedTextureData.size());</div>
<div class="line">        textureBlockHeader.m_pTextureOffsets = (uint64_t*)malloc(<span class="keyword">sizeof</span>(uint64_t) * textureBlockHeader.m_NumTextures);</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* Accumulate data to be written out for the textures. */</span></div>
<div class="line">        <span class="keywordflow">for</span> (std::unordered_map&lt;std::string, nvnTool::texpkg::NVNHWTexture&gt;::iterator itr = m_ConvertedTextureData.begin(); itr != m_ConvertedTextureData.end(); ++itr)</div>
<div class="line">        {</div>
<div class="line">            textureDataHeaders.push_back(TextureDataHeader());</div>
<div class="line"></div>
<div class="line">            TextureDataHeader&amp; header = textureDataHeaders.back();</div>
<div class="line"></div>
<div class="line">            header.m_TextureDataSize = itr-&gt;second.header.dataSize;</div>
<div class="line">            header.m_GpuVersion = 0;</div>
<div class="line">            header.m_Alignment = itr-&gt;second.header.align;</div>
<div class="line">            header.m_Width = itr-&gt;second.header.width;</div>
<div class="line">            header.m_Height = itr-&gt;second.header.height;</div>
<div class="line">            header.m_Depth = itr-&gt;second.header.depth;</div>
<div class="line">            header.m_NvnTextureTarget = itr-&gt;second.header.target;</div>
<div class="line">            header.m_NvnFormat = itr-&gt;second.header.format;</div>
<div class="line">            header.m_MipLevels = itr-&gt;second.header.mipmapLevels;</div>
<div class="line">            header.m_TextureNameLength = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(itr-&gt;first.size());</div>
<div class="line">            header.m_TextureDataOffset = 0; <span class="comment">// Retrieve offset later</span></div>
<div class="line">            header.m_pTextureName = itr-&gt;first.c_str();</div>
<div class="line">            header.m_pTextureData = itr-&gt;second.data;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* Update currentOffset */</span></div>
<div class="line">        currentOffset += <span class="keyword">sizeof</span>(TextureBlockHeader);</div>
<div class="line">        currentOffset -= <span class="keyword">sizeof</span>(textureBlockHeader.m_pTextureOffsets);</div>
<div class="line">        currentOffset += <span class="keyword">sizeof</span>(uint64_t) * textureBlockHeader.m_NumTextures;</div>
<div class="line"></div>
<div class="line">        for (uint32_t i = 0; i &lt; textureBlockHeader.m_NumTextures; ++i)</div>
<div class="line">        {</div>
<div class="line">            currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">            padding.push_back(currentPadding);</div>
<div class="line">            textureBlockHeader.m_pTextureOffsets[i] = currentOffset;</div>
<div class="line"></div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(TextureDataHeader);</div>
<div class="line">            currentOffset -= <span class="keyword">sizeof</span>(textureDataHeaders[i].m_pTextureData);</div>
<div class="line">            currentOffset -= <span class="keyword">sizeof</span>(textureDataHeaders[i].m_pTextureName);</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(char) * textureDataHeaders[i].m_TextureNameLength;</div>
<div class="line"></div>
<div class="line">                <span class="comment">/*</span></div>
<div class="line"><span class="comment">                 * Offset of texture data is set now to account for the variable</span></div>
<div class="line"><span class="comment">                 * size of the texture name</span></div>
<div class="line"><span class="comment">                 */</span></div>
<div class="line">            currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">            padding.push_back(currentPadding);</div>
<div class="line">            textureDataHeaders[i].m_TextureDataOffset = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(currentOffset);</div>
<div class="line"></div>
<div class="line">            currentOffset += <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(textureDataHeaders[i].m_TextureDataSize);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Check for models. */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!m_RawModelData.size())</div>
<div class="line">    {</div>
<div class="line">        outputFileHeader.m_ModelBlockOffset = 0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">        padding.push_back(currentPadding);</div>
<div class="line">        outputFileHeader.m_ModelBlockOffset = currentOffset;</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* Accumulate model data in the header structs. */</span></div>
<div class="line">        <span class="keywordflow">for</span> (std::vector&lt;Model&gt;::iterator itr = m_RawModelData.begin(); itr != m_RawModelData.end(); ++itr)</div>
<div class="line">        {</div>
<div class="line">            modelHeaders.push_back(std::pair&lt;ModelHeader, std::pair&lt;std::vector&lt;VertexAttributeHeader&gt;, IndexBufferHeader&gt; &gt;());</div>
<div class="line"></div>
<div class="line">            ModelHeader&amp; modelHeader = modelHeaders.back().first;</div>
<div class="line">            std::vector&lt;VertexAttributeHeader&gt;&amp; vertexBufferHeader = modelHeaders.back().second.first;</div>
<div class="line">            IndexBufferHeader&amp; indexBufferHeader = modelHeaders.back().second.second;</div>
<div class="line"></div>
<div class="line">            modelHeader.m_NumPrimitives = itr-&gt;m_NumPrimitives;</div>
<div class="line">            modelHeader.m_NvnDrawPrimitiveType = itr-&gt;m_NvnDrawPrimitiveType;</div>
<div class="line">            modelHeader.m_NumVertexAttributes = itr-&gt;m_NumVertexAttributes;</div>
<div class="line">            modelHeader.m_ModelNameLength = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(itr-&gt;m_Name.size());</div>
<div class="line">            modelHeader.m_IndexBufferOffset = 0; <span class="comment">// Retrieve offset later</span></div>
<div class="line">            modelHeader.m_pModelName = itr-&gt;m_Name.c_str();</div>
<div class="line"></div>
<div class="line">            indexBufferHeader.m_NumIndices = itr-&gt;m_IndexData.m_DataSize / itr-&gt;m_IndexData.m_Stride;</div>
<div class="line">            indexBufferHeader.m_IndexBufferSize = itr-&gt;m_IndexData.m_DataSize;</div>
<div class="line">            indexBufferHeader.m_pIndexData = itr-&gt;m_IndexData.m_pData;</div>
<div class="line">            indexBufferHeader.m_IndexType = itr-&gt;m_IndexData.m_IndexType;</div>
<div class="line">            indexBufferHeader.m_MagicPadding = 0;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; itr-&gt;m_VertexAttributes.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                VertexAttributeHeader attributeHeader;</div>
<div class="line">                attributeHeader.m_AttributeStride = itr-&gt;m_VertexAttributes[i].m_Stride;</div>
<div class="line">                attributeHeader.m_NvnFormat = itr-&gt;m_VertexAttributes[i].m_NvnFormat;</div>
<div class="line">                attributeHeader.m_AttributeDataSize = itr-&gt;m_VertexAttributes[i].m_DataSize;</div>
<div class="line">                attributeHeader.m_AttributeNameLength = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(itr-&gt;m_VertexAttributes[i].m_Name.size());</div>
<div class="line">                attributeHeader.m_AttributeDataOffset = 0; <span class="comment">// Retrieve offset later</span></div>
<div class="line">                attributeHeader.m_MagicPadding = 0;</div>
<div class="line">                attributeHeader.m_pAttributeName = itr-&gt;m_VertexAttributes[i].m_Name.c_str();</div>
<div class="line">                attributeHeader.m_AttributeData = itr-&gt;m_VertexAttributes[i].m_pData;</div>
<div class="line"></div>
<div class="line">                vertexBufferHeader.push_back(attributeHeader);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        modelBlockHeader.m_NumModels = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(m_RawModelData.size());</div>
<div class="line">        modelBlockHeader.m_pModelOffsets = (uint64_t*)malloc(<span class="keyword">sizeof</span>(uint64_t) * modelBlockHeader.m_NumModels);</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* Update currentOffset. */</span></div>
<div class="line">        currentOffset += <span class="keyword">sizeof</span>(ModelBlockHeader);</div>
<div class="line">        currentOffset -= <span class="keyword">sizeof</span>(modelBlockHeader.m_pModelOffsets);</div>
<div class="line">        currentOffset += <span class="keyword">sizeof</span>(uint64_t) * modelBlockHeader.m_NumModels;</div>
<div class="line"></div>
<div class="line">        for (uint32_t i = 0; i &lt; modelHeaders.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">            padding.push_back(currentPadding);</div>
<div class="line">            modelBlockHeader.m_pModelOffsets[i] = currentOffset;</div>
<div class="line"></div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(ModelHeader);</div>
<div class="line">            currentOffset -= <span class="keyword">sizeof</span>(modelHeaders[i].first.m_pVertexAttributeOffsets);</div>
<div class="line">            currentOffset -= <span class="keyword">sizeof</span>(modelHeaders[i].first.m_pModelName);</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(uint64_t) * modelHeaders[i].second.first.size();</div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(char) * modelHeaders[i].first.m_ModelNameLength;</div>
<div class="line"></div>
<div class="line">            modelHeaders[i].first.m_pVertexAttributeOffsets = (uint64_t*)malloc(<span class="keyword">sizeof</span>(uint64_t) * modelHeaders[i].second.first.size());</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; modelHeaders[i].second.first.size(); ++j)</div>
<div class="line">            {</div>
<div class="line">                currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">                padding.push_back(currentPadding);</div>
<div class="line">                modelHeaders[i].first.m_pVertexAttributeOffsets[j] = currentOffset;</div>
<div class="line"></div>
<div class="line">                currentOffset += <span class="keyword">sizeof</span>(VertexAttributeHeader);</div>
<div class="line">                currentOffset -= <span class="keyword">sizeof</span>(modelHeaders[i].second.first[j].m_pAttributeName);</div>
<div class="line">                currentOffset -= <span class="keyword">sizeof</span>(modelHeaders[i].second.first[j].m_AttributeData);</div>
<div class="line">                currentOffset += <span class="keyword">sizeof</span>(char) * modelHeaders[i].second.first[j].m_AttributeNameLength;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">/*</span></div>
<div class="line"><span class="comment">                     * Offset of vertex attribute data is set now to account for the variable</span></div>
<div class="line"><span class="comment">                     * size of the attribute&#39;s name</span></div>
<div class="line"><span class="comment">                     */</span></div>
<div class="line">                currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">                padding.push_back(currentPadding);</div>
<div class="line">                modelHeaders[i].second.first[j].m_AttributeDataOffset = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(currentOffset);</div>
<div class="line"></div>
<div class="line">                currentOffset += modelHeaders[i].second.first[j].m_AttributeDataSize;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            currentOffset = Align(currentOffset, 8, currentPadding);</div>
<div class="line">            padding.push_back(currentPadding);</div>
<div class="line">            modelHeaders[i].first.m_IndexBufferOffset = currentOffset;</div>
<div class="line"></div>
<div class="line">            currentOffset += <span class="keyword">sizeof</span>(IndexBufferHeader);</div>
<div class="line">            currentOffset -= <span class="keyword">sizeof</span>(modelHeaders[i].second.second.m_pIndexData);</div>
<div class="line">            currentOffset += modelHeaders[i].second.second.m_IndexBufferSize;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Write the output file based on the setup file section headers. */</span></div>
<div class="line">    uint64_t writtenBytes = 0;</div>
<div class="line">    uint32_t magicPadding = 0;</div>
<div class="line">    uint32_t currentPaddingIndex = 0;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// File Header</span></div>
<div class="line">    fwrite(&amp;outputFileHeader, <span class="keyword">sizeof</span>(outputFileHeader), 1, outputFile);</div>
<div class="line">    writtenBytes += <span class="keyword">sizeof</span>(outputFileHeader);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (outputFileHeader.m_ShaderBlockOffset)</div>
<div class="line">    {</div>
<div class="line">            <span class="comment">// Shader Block Header</span></div>
<div class="line">        fwrite(&amp;shaderBlockHeader.m_NumShaderPrograms, <span class="keyword">sizeof</span>(shaderBlockHeader.m_NumShaderPrograms), 1, outputFile);</div>
<div class="line">        writtenBytes += <span class="keyword">sizeof</span>(shaderBlockHeader.m_NumShaderPrograms);</div>
<div class="line"></div>
<div class="line">        fwrite(&amp;magicPadding, <span class="keyword">sizeof</span>(uint32_t), 1, outputFile);</div>
<div class="line">        writtenBytes += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line"></div>
<div class="line">        fwrite(shaderBlockHeader.m_pShaderProgramOffsets, <span class="keyword">sizeof</span>(shaderBlockHeader.m_pShaderProgramOffsets[0]), shaderBlockHeader.m_NumShaderPrograms, outputFile);</div>
<div class="line">        writtenBytes += <span class="keyword">sizeof</span>(shaderBlockHeader.m_pShaderProgramOffsets[0]);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Shader Program Headers</span></div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; shaderProgramHeaders.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">// Insert padding</span></div>
<div class="line">            writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;shaderProgramHeaders[i].first.m_NumShaderStages, <span class="keyword">sizeof</span>(shaderProgramHeaders[i].first.m_NumShaderStages), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(shaderProgramHeaders[i].first.m_NumShaderStages);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;shaderProgramHeaders[i].first.m_ProgramNameLength, <span class="keyword">sizeof</span>(shaderProgramHeaders[i].first.m_ProgramNameLength), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(shaderProgramHeaders[i].first.m_ProgramNameLength);</div>
<div class="line"></div>
<div class="line">            fwrite(shaderProgramHeaders[i].first.m_pShaderStageOffsets, <span class="keyword">sizeof</span>(uint64_t), shaderProgramHeaders[i].first.m_NumShaderStages, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(uint64_t) * shaderProgramHeaders[i].first.m_NumShaderStages;</div>
<div class="line"></div>
<div class="line">            fwrite(shaderProgramHeaders[i].first.m_pProgramName, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), shaderProgramHeaders[i].first.m_ProgramNameLength, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(char) * shaderProgramHeaders[i].first.m_ProgramNameLength;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Shader Stage Headers/Data</span></div>
<div class="line">            for (uint32_t j = 0; j &lt; shaderProgramHeaders[i].first.m_NumShaderStages; ++j)</div>
<div class="line">            {</div>
<div class="line">                    <span class="comment">// Insert padding</span></div>
<div class="line">                writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"></div>
<div class="line">                fwrite(&amp;shaderProgramHeaders[i].second[j].m_ShaderStage, <span class="keyword">sizeof</span>(shaderProgramHeaders[i].second[j].m_ShaderStage), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(shaderProgramHeaders[i].second[j].m_ShaderStage);</div>
<div class="line"></div>
<div class="line">                fwrite(&amp;shaderProgramHeaders[i].second[j].m_ShaderDataSize, <span class="keyword">sizeof</span>(shaderProgramHeaders[i].second[j].m_ShaderDataSize), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(shaderProgramHeaders[i].second[j].m_ShaderDataSize);</div>
<div class="line"></div>
<div class="line">                fwrite(&amp;shaderProgramHeaders[i].second[j].m_ShaderControlSize, <span class="keyword">sizeof</span>(shaderProgramHeaders[i].second[j].m_ShaderControlSize), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(shaderProgramHeaders[i].second[j].m_ShaderControlSize);</div>
<div class="line"></div>
<div class="line">                fwrite(&amp;shaderProgramHeaders[i].second[j].m_ShaderControlOffset, <span class="keyword">sizeof</span>(shaderProgramHeaders[i].second[j].m_ShaderControlOffset), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(shaderProgramHeaders[i].second[j].m_ShaderControlOffset);</div>
<div class="line"></div>
<div class="line">                fwrite(shaderProgramHeaders[i].second[j].m_pShaderData, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), shaderProgramHeaders[i].second[j].m_ShaderDataSize, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(char) * shaderProgramHeaders[i].second[j].m_ShaderDataSize;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Insert padding</span></div>
<div class="line">                writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"></div>
<div class="line">                fwrite(shaderProgramHeaders[i].second[j].m_pShaderControl, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), shaderProgramHeaders[i].second[j].m_ShaderControlSize, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(char) * shaderProgramHeaders[i].second[j].m_ShaderControlSize;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (outputFileHeader.m_TextureBlockOffset)</div>
<div class="line">    {</div>
<div class="line">            <span class="comment">// Insert padding</span></div>
<div class="line">        writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Texture Block Header</span></div>
<div class="line">        fwrite(&amp;textureBlockHeader.m_NumTextures, <span class="keyword">sizeof</span>(textureBlockHeader.m_NumTextures), 1, outputFile);</div>
<div class="line">        writtenBytes += <span class="keyword">sizeof</span>(textureBlockHeader.m_NumTextures);</div>
<div class="line"></div>
<div class="line">        fwrite(&amp;textureBlockHeader.m_MagicPadding, <span class="keyword">sizeof</span>(textureBlockHeader.m_MagicPadding), 1, outputFile);</div>
<div class="line">        writtenBytes += <span class="keyword">sizeof</span>(textureBlockHeader.m_MagicPadding);</div>
<div class="line"></div>
<div class="line">        fwrite(textureBlockHeader.m_pTextureOffsets, <span class="keyword">sizeof</span>(uint64_t), textureBlockHeader.m_NumTextures, outputFile);</div>
<div class="line">        writtenBytes += <span class="keyword">sizeof</span>(uint64_t) * textureBlockHeader.m_NumTextures;</div>
<div class="line"></div>
<div class="line">        for (uint32_t i = 0; i &lt; textureDataHeaders.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">// Insert padding</span></div>
<div class="line">            writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;textureDataHeaders[i].m_TextureDataSize, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_TextureDataSize), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_TextureDataSize);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;textureDataHeaders[i].m_GpuVersion, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_GpuVersion), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_GpuVersion);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;textureDataHeaders[i].m_Alignment, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_Alignment), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_Alignment);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;textureDataHeaders[i].m_Width, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_Width), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_Width);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;textureDataHeaders[i].m_Height, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_Height), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_Height);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;textureDataHeaders[i].m_Depth, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_Depth), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_Depth);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;textureDataHeaders[i].m_NvnTextureTarget, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_NvnTextureTarget), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_NvnTextureTarget);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;textureDataHeaders[i].m_NvnFormat, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_NvnFormat), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_NvnFormat);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;textureDataHeaders[i].m_MipLevels, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_MipLevels), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_MipLevels);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;textureDataHeaders[i].m_TextureNameLength, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_TextureNameLength), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_TextureNameLength);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;textureDataHeaders[i].m_TextureDataOffset, <span class="keyword">sizeof</span>(textureDataHeaders[i].m_TextureDataOffset), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(textureDataHeaders[i].m_TextureDataOffset);</div>
<div class="line"></div>
<div class="line">            fwrite(textureDataHeaders[i].m_pTextureName, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), textureDataHeaders[i].m_TextureNameLength, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(char) * textureDataHeaders[i].m_TextureNameLength;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Insert padding</span></div>
<div class="line">            writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"></div>
<div class="line">            fwrite(textureDataHeaders[i].m_pTextureData, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), static_cast&lt;size_t&gt;(textureDataHeaders[i].m_TextureDataSize), outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(char) * textureDataHeaders[i].m_TextureDataSize;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (outputFileHeader.m_ModelBlockOffset)</div>
<div class="line">    {</div>
<div class="line">            <span class="comment">// Insert padding</span></div>
<div class="line">        writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Model Block Header</span></div>
<div class="line">        fwrite(&amp;modelBlockHeader.m_NumModels, <span class="keyword">sizeof</span>(modelBlockHeader.m_NumModels), 1, outputFile);</div>
<div class="line">        writtenBytes += <span class="keyword">sizeof</span>(modelBlockHeader.m_NumModels);</div>
<div class="line"></div>
<div class="line">        fwrite(&amp;modelBlockHeader.m_MagicPadding, <span class="keyword">sizeof</span>(modelBlockHeader.m_MagicPadding), 1, outputFile);</div>
<div class="line">        writtenBytes += <span class="keyword">sizeof</span>(modelBlockHeader.m_MagicPadding);</div>
<div class="line"></div>
<div class="line">        fwrite(modelBlockHeader.m_pModelOffsets, <span class="keyword">sizeof</span>(uint64_t), modelBlockHeader.m_NumModels, outputFile);</div>
<div class="line">        writtenBytes += <span class="keyword">sizeof</span>(uint64_t) * modelBlockHeader.m_NumModels;</div>
<div class="line"></div>
<div class="line">        for (uint32_t i = 0; i &lt; modelHeaders.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">// Insert padding</span></div>
<div class="line">            writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Model Header</span></div>
<div class="line">            fwrite(&amp;modelHeaders[i].first.m_NumPrimitives, <span class="keyword">sizeof</span>(modelHeaders[i].first.m_NumPrimitives), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(modelHeaders[i].first.m_NumPrimitives);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;modelHeaders[i].first.m_NvnDrawPrimitiveType, <span class="keyword">sizeof</span>(modelHeaders[i].first.m_NvnDrawPrimitiveType), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(modelHeaders[i].first.m_NvnDrawPrimitiveType);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;modelHeaders[i].first.m_NumVertexAttributes, <span class="keyword">sizeof</span>(modelHeaders[i].first.m_NumVertexAttributes), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(modelHeaders[i].first.m_NumVertexAttributes);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;modelHeaders[i].first.m_ModelNameLength, <span class="keyword">sizeof</span>(modelHeaders[i].first.m_ModelNameLength), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(modelHeaders[i].first.m_ModelNameLength);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;modelHeaders[i].first.m_IndexBufferOffset, <span class="keyword">sizeof</span>(modelHeaders[i].first.m_IndexBufferOffset), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(modelHeaders[i].first.m_IndexBufferOffset);</div>
<div class="line"></div>
<div class="line">            fwrite(modelHeaders[i].first.m_pVertexAttributeOffsets, <span class="keyword">sizeof</span>(uint64_t), modelHeaders[i].first.m_NumVertexAttributes, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(uint64_t) * modelHeaders[i].first.m_NumVertexAttributes;</div>
<div class="line"></div>
<div class="line">            fwrite(modelHeaders[i].first.m_pModelName, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), modelHeaders[i].first.m_ModelNameLength, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(char) * modelHeaders[i].first.m_ModelNameLength;</div>
<div class="line"></div>
<div class="line">            std::vector&lt;VertexAttributeHeader&gt;&amp; vertexAttributes = modelHeaders[i].second.first;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Vertex Attributes</span></div>
<div class="line">            for (uint32_t j = 0; j &lt; vertexAttributes.size(); ++j)</div>
<div class="line">            {</div>
<div class="line">                    <span class="comment">// Insert padding</span></div>
<div class="line">                writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"></div>
<div class="line">                fwrite(&amp;vertexAttributes[j].m_AttributeStride, <span class="keyword">sizeof</span>(vertexAttributes[j].m_AttributeStride), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(vertexAttributes[j].m_AttributeStride);</div>
<div class="line"></div>
<div class="line">                fwrite(&amp;vertexAttributes[j].m_NvnFormat, <span class="keyword">sizeof</span>(vertexAttributes[j].m_NvnFormat), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(vertexAttributes[j].m_NvnFormat);</div>
<div class="line"></div>
<div class="line">                fwrite(&amp;vertexAttributes[j].m_AttributeDataSize, <span class="keyword">sizeof</span>(vertexAttributes[j].m_AttributeDataSize), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(vertexAttributes[j].m_AttributeDataSize);</div>
<div class="line"></div>
<div class="line">                fwrite(&amp;vertexAttributes[j].m_AttributeNameLength, <span class="keyword">sizeof</span>(vertexAttributes[j].m_AttributeNameLength), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(vertexAttributes[j].m_AttributeNameLength);</div>
<div class="line"></div>
<div class="line">                fwrite(&amp;vertexAttributes[j].m_AttributeDataOffset, <span class="keyword">sizeof</span>(vertexAttributes[j].m_AttributeDataOffset), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(vertexAttributes[j].m_AttributeDataOffset);</div>
<div class="line"></div>
<div class="line">                fwrite(&amp;vertexAttributes[j].m_MagicPadding, <span class="keyword">sizeof</span>(vertexAttributes[j].m_MagicPadding), 1, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(vertexAttributes[j].m_MagicPadding);</div>
<div class="line"></div>
<div class="line">                fwrite(vertexAttributes[j].m_pAttributeName, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), vertexAttributes[j].m_AttributeNameLength, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(char) * vertexAttributes[j].m_AttributeNameLength;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Insert padding</span></div>
<div class="line">                writtenBytes += PadFileBuffer(outputFile, padding[currentPaddingIndex++]);</div>
<div class="line"></div>
<div class="line">                fwrite(vertexAttributes[j].m_AttributeData, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), vertexAttributes[j].m_AttributeDataSize, outputFile);</div>
<div class="line">                writtenBytes += <span class="keyword">sizeof</span>(char) * vertexAttributes[j].m_AttributeDataSize;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Index Buffer Header/Data</span></div>
<div class="line">            fwrite(&amp;modelHeaders[i].second.second.m_IndexBufferSize, <span class="keyword">sizeof</span>(modelHeaders[i].second.second.m_IndexBufferSize), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(modelHeaders[i].second.second.m_IndexBufferSize);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;modelHeaders[i].second.second.m_NumIndices, <span class="keyword">sizeof</span>(modelHeaders[i].second.second.m_NumIndices), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(modelHeaders[i].second.second.m_NumIndices);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;modelHeaders[i].second.second.m_IndexType, <span class="keyword">sizeof</span>(modelHeaders[i].second.second.m_IndexType), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(modelHeaders[i].second.second.m_IndexType);</div>
<div class="line"></div>
<div class="line">            fwrite(&amp;modelHeaders[i].second.second.m_MagicPadding, <span class="keyword">sizeof</span>(modelHeaders[i].second.second.m_MagicPadding), 1, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(modelHeaders[i].second.second.m_MagicPadding);</div>
<div class="line"></div>
<div class="line">            fwrite(modelHeaders[i].second.second.m_pIndexData, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), modelHeaders[i].second.second.m_IndexBufferSize, outputFile);</div>
<div class="line">            writtenBytes += <span class="keyword">sizeof</span>(char) * modelHeaders[i].second.second.m_IndexBufferSize;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Check if number of bytes written to file does not match size of data generated</span></div>
<div class="line">    assert(writtenBytes == currentOffset);</div>
<div class="line"></div>
<div class="line">    fclose(outputFile);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (outputFileHeader.m_ShaderBlockOffset)</div>
<div class="line">    {</div>
<div class="line">        free(shaderBlockHeader.m_pShaderProgramOffsets);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; shaderProgramHeaders.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            free(shaderProgramHeaders[i].first.m_pShaderStageOffsets);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (outputFileHeader.m_TextureBlockOffset)</div>
<div class="line">    {</div>
<div class="line">        free(textureBlockHeader.m_pTextureOffsets);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (outputFileHeader.m_ModelBlockOffset)</div>
<div class="line">    {</div>
<div class="line">        free(modelBlockHeader.m_pModelOffsets);</div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; modelHeaders.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            free(modelHeaders[i].first.m_pVertexAttributeOffsets);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}<span class="comment">//NOLINT(impl/function_size)</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::OutputUniformBlockHeaderFiles</span></div>
<div class="line"><span class="comment"> * ------------------------------------------------------</span></div>
<div class="line"><span class="comment"> * This function takes the shader reflection data and the shader performance</span></div>
<div class="line"><span class="comment"> * data from the GLSLC compile object and outputs a C++ header/source file pair.</span></div>
<div class="line"><span class="comment"> * These files define some classes and static data for the vertex attributes</span></div>
<div class="line"><span class="comment"> * and uniform blocks to help with setting up the data to be passed to the</span></div>
<div class="line"><span class="comment"> * shader and keeps track of the location for the data in the shader per stage.</span></div>
<div class="line"><span class="comment"> * The uniform block classes have helper functions to set individual members at</span></div>
<div class="line"><span class="comment"> * the correct offset in the block. The shader performance data is output at the</span></div>
<div class="line"><span class="comment"> * top of the header file in a comment for each stage.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> IntermediateFileManager::OutputUniformBlockHeaderFiles(<span class="keyword">const</span> std::string&amp; path)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span>(std::unordered_map&lt;std::string, ShaderCompileData&gt;::iterator itr = m_ShaderPrograms.begin(); itr != m_ShaderPrograms.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        std::ofstream file;</div>
<div class="line">        file.open(path + (itr-&gt;first + <span class="stringliteral">&quot;DataHelper.h&quot;</span>), std::fstream::out);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>(!file.is_open())</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to create output header file for &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; path &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;DataHelper.h\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;/*--------------------------------------------------------------------------------*\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;Copyright (C)Nintendo All rights reserved.\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;These coded instructions, statements, and computer programs contain proprietary\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;information of Nintendo and/or its licensed developers and are protected by\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;national and international copyright laws. They may not be disclosed to third\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;parties or copied or duplicated in any form, in whole or in part, without the\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;prior written consent of Nintendo.\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;The content herein is highly confidential and should be handled accordingly.\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;*--------------------------------------------------------------------------------*/\n\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;/*\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; * &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;DataHelper.h\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; * -------------------------------------------------\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; * This is a generated file from GLSLC shader\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; * compile reflection information. Do not edit.\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; * -------------------------------------------------\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; */\n\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;/*\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; * Shader Program: &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;\n * \n&quot;</span>;</div>
<div class="line"></div>
<div class="line">        <a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a>* compileOutput = itr-&gt;second.m_CompileObject.lastCompiledResults-&gt;glslcOutput;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; compileOutput-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a6cbb6ec5e8a4ff04512fd1c442aa3d92">numSections</a>; ++i)</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59">GLSLCsectionTypeEnum</a> type = compileOutput-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].genericHeader.common.<a class="code" href="struct_g_l_s_l_csection_header_common.html#a6a8aed7a5a7e82acff908d084fd85e4a">type</a>;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (type == <a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59a332c55c4b44004865dda7d54c91df448">GLSLC_SECTION_TYPE_GPU_CODE</a>)</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_cgpu_code_header.html">GLSLCgpuCodeHeader</a> * gpuHeader = &amp;(compileOutput-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].gpuCodeHeader);</div>
<div class="line">                <span class="keywordtype">int</span> perfStatsNdx = gpuHeader-&gt;<a name="a37"></a><a class="code" href="struct_g_l_s_l_cgpu_code_header.html#a210237850b30911ca52acf10d628bc0e">perfStatsSectionNdx</a>;</div>
<div class="line"></div>
<div class="line">                <span class="keyword">const</span> <a name="_a38"></a><a class="code" href="struct_g_l_s_l_cperf_stats_header.html">GLSLCperfStatsHeader</a> * perfStatsHeader = &amp;(compileOutput-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[perfStatsNdx].<a name="a39"></a>perfStatsHeader);</div>
<div class="line"></div>
<div class="line">                    <span class="comment">/*</span></div>
<div class="line"><span class="comment">                     * GLSLCperfStatsData</span></div>
<div class="line"><span class="comment">                     * ------------------</span></div>
<div class="line"><span class="comment">                     * The GLSLCperfStatsData structure holds the performance data</span></div>
<div class="line"><span class="comment">                     * information for a specific shader stage. This information is</span></div>
<div class="line"><span class="comment">                     * present in the option was set in the GLSLCoptions structure</span></div>
<div class="line"><span class="comment">                     * before the last compile.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * magic                - Indicates the presence of perf stats data for</span></div>
<div class="line"><span class="comment">                     *                        sanity checking. This should be equal to the</span></div>
<div class="line"><span class="comment">                     *                        define GLSLC_PERF_STATS_SECTION_MAGIC_NUMBER.</span></div>
<div class="line"><span class="comment">                     * spillMem             - Spill memory data. (lmem and smem)</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * nonSpillLMem         - Non-spill memory.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * throughputLimiter    - Throughput limiter information. Values are in terms</span></div>
<div class="line"><span class="comment">                     *                        of warps per cycle.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * loopData             - Loop unroll information. Contains number of partially</span></div>
<div class="line"><span class="comment">                     *                        unrolled loops and number of not unrolled loops.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * latency              - Cycles per pixel.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * occupancy            - Ratio of active warps to maximum number of warps</span></div>
<div class="line"><span class="comment">                     *                        supported.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * numDivergentBranches - Number of divergent branches.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * attributeMemUsage    - Attribute memory usage in bytes.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * programSize          - Program size in bytes.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     */</span></div>
<div class="line">                <span class="keyword">const</span> <a name="_a40"></a><a class="code" href="struct_g_l_s_l_cperf_stats_data.html">GLSLCperfStatsData</a> * perfStatsData = (<span class="keyword">const</span> <a class="code" href="struct_g_l_s_l_cperf_stats_data.html">GLSLCperfStatsData</a> *)(((<span class="keyword">const</span> <span class="keywordtype">char</span>*)(compileOutput)) + perfStatsHeader-&gt;<a name="a41"></a>common.<a class="code" href="struct_g_l_s_l_csection_header_common.html#abb6e96b70bad30c94477317328d384d5">dataOffset</a>);</div>
<div class="line"></div>
<div class="line">                std::string stage;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">switch</span>(gpuHeader-&gt;<a class="code" href="struct_g_l_s_l_cgpu_code_header.html#ab1e6be676a326a7281e18ad3a4607ced">stage</a>)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordflow">case</span> <a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abdda5a6e5f69e0f338221cc5acf7882a21c7">NVNshaderStage::NVN_SHADER_STAGE_VERTEX</a>:</div>
<div class="line">                        stage = <span class="stringliteral">&quot;Vertex&quot;</span>;</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> <a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf979f751d1526164abb522c640c8eb06">NVNshaderStage::NVN_SHADER_STAGE_FRAGMENT</a>:</div>
<div class="line">                        stage = <span class="stringliteral">&quot;Fragment&quot;</span>;</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> <a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf87149873f1b592524e771fdf82ab86f">NVNshaderStage::NVN_SHADER_STAGE_GEOMETRY</a>:</div>
<div class="line">                        stage = <span class="stringliteral">&quot;Geometry&quot;</span>;</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> <a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddad8bedcc05b63478d7c2cdf772ddc8096">NVNshaderStage::NVN_SHADER_STAGE_TESS_CONTROL</a>:</div>
<div class="line">                        stage = <span class="stringliteral">&quot;Tesselation Control&quot;</span>;</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> <a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddaf732e2b4f5f5c1b5fca530f25146a8fb">NVNshaderStage::NVN_SHADER_STAGE_TESS_EVALUATION</a>:</div>
<div class="line">                        stage = <span class="stringliteral">&quot;Tesselation Evaluation&quot;</span>;</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> <a class="code" href="group__nvn__c__enum.html#ggac99deb2b11df8b0358f73a92e2a2abddae173bae8c554c2f196ff291335408395">NVNshaderStage::NVN_SHADER_STAGE_COMPUTE</a>:</div>
<div class="line">                        stage = <span class="stringliteral">&quot;Compute&quot;</span>;</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">default</span>:</div>
<div class="line">                        assert(<span class="keyword">false</span>);</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Perf Statistics - Stage: &quot;</span>           &lt;&lt; stage &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * -------------------------------------------------------------&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Latency:                           &quot;</span> &lt;&lt; perfStatsData-&gt;<a name="a42"></a><a class="code" href="struct_g_l_s_l_cperf_stats_data.html#aeba2f57d7a5786cfac325cd5ea99250c">latency</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Number of lmem spill bytes:        &quot;</span> &lt;&lt; perfStatsData-&gt;<a name="a43"></a><a class="code" href="struct_g_l_s_l_cperf_stats_data.html#ae368ee8152d78e81cd42094c5d7f08a4">spillMem</a>.<a name="a44"></a><a class="code" href="struct_g_l_s_l_cspill_l_mem.html#ad224d4137a67b9e8009302ce36351305">numLmemSpillBytes</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Number of lmem refill bytes:       &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#ae368ee8152d78e81cd42094c5d7f08a4">spillMem</a>.<a name="a45"></a><a class="code" href="struct_g_l_s_l_cspill_l_mem.html#af6b39e00e63c8a8e0f7e0b6873221e1a">numLmemRefillBytes</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Number of smem spill bytes:        &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#ae368ee8152d78e81cd42094c5d7f08a4">spillMem</a>.<a name="a46"></a><a class="code" href="struct_g_l_s_l_cspill_l_mem.html#ad2e83c16dc5264df509f512c3807705b">numSmemSpillBytes</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Number of smem refill bytes:       &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#ae368ee8152d78e81cd42094c5d7f08a4">spillMem</a>.<a name="a47"></a><a class="code" href="struct_g_l_s_l_cspill_l_mem.html#a41a1bf5449af1806420a1160482adb1e">numSmemRefillBytes</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Lmem Spill Size:                   &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#ae368ee8152d78e81cd42094c5d7f08a4">spillMem</a>.<a name="a48"></a><a class="code" href="struct_g_l_s_l_cspill_l_mem.html#a6cfdf0aeb653422164babeffc41b4b68">size</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Local Memory Non-spill Loads:      &quot;</span> &lt;&lt; perfStatsData-&gt;<a name="a49"></a><a class="code" href="struct_g_l_s_l_cperf_stats_data.html#a9adc6910a33636f8688ad1231d0ad293">nonSpillLMem</a>.<a name="a50"></a><a class="code" href="struct_g_l_s_l_cnon_spill_l_mem.html#a27760cf751240260637a72447d127bb6">loadBytes</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Local Memory Non-spill Stores:     &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#a9adc6910a33636f8688ad1231d0ad293">nonSpillLMem</a>.<a name="a51"></a><a class="code" href="struct_g_l_s_l_cnon_spill_l_mem.html#a9e9f1b81107865e233a351231841e6f6">storeBytes</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Non-spill Local Memory Size:       &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#a9adc6910a33636f8688ad1231d0ad293">nonSpillLMem</a>.<a name="a52"></a><a class="code" href="struct_g_l_s_l_cnon_spill_l_mem.html#a76ddc6e0aedfd37e36aa7d7d5d96a909">size</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Occupancy:                         &quot;</span> &lt;&lt; perfStatsData-&gt;<a name="a53"></a><a class="code" href="struct_g_l_s_l_cperf_stats_data.html#ad91e1581425b17e18ef6603d9f1fde22">occupancy</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Number of Divergent Branches:      &quot;</span> &lt;&lt; perfStatsData-&gt;<a name="a54"></a><a class="code" href="struct_g_l_s_l_cperf_stats_data.html#ad66aa359d1cadbb6680fe56c8084c48b">numDivergentBranches</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Attribute Memory Usage:            &quot;</span> &lt;&lt; perfStatsData-&gt;<a name="a55"></a><a class="code" href="struct_g_l_s_l_cperf_stats_data.html#a169e086f11fc356a04df91af96b31d08">attributeMemUsage</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Program Size:                      &quot;</span> &lt;&lt; perfStatsData-&gt;<a name="a56"></a><a class="code" href="struct_g_l_s_l_cperf_stats_data.html#abe4198110a02135c0941513d8493017f">programSize</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Issue Ltd Throughput:              &quot;</span> &lt;&lt; perfStatsData-&gt;<a name="a57"></a><a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a58"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#a80471483a98d5aa2b56f3d091c6f66c3">issue</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * FP Ltd Throughput:                 &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a59"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#afe5545973adf22ed4001a0784348efda">fp</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Half Ltd Throughput:               &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a60"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#a77999a2646e730fb536abb4263f9cd19">half</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Trancedental Ltd Throughput:       &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a61"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#a53a2616c9cc95e2656c12cfa10266485">trancedental</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * IPA Ltd Throughput:                &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a62"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#a374b65adbd7ae380a465089bbbc29bab">ipa</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Shared Ltd Throughput:             &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a63"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#aaa1a970a3f023d8b399e4323d0354276">shared</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * ControlFlow Ltd Throughput:        &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a64"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#a82a4ac305863d2195e79c945b8188d65">controlFlow</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Texture/Load/Store Ltd Throughput: &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a65"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#a681850c900eb4aacb11bce98483831c7">texLoadStore</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Reg Ltd Throughput:                &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a66"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#ab3d12b78f87486d981e166d317122466">reg</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot; * Warp Ltd Throughput:               &quot;</span> &lt;&lt; perfStatsData-&gt;<a class="code" href="struct_g_l_s_l_cperf_stats_data.html#af787142790d854a42032ec6998ed5658">throughputLimiter</a>.<a name="a67"></a><a class="code" href="struct_g_l_s_l_cthroughput_limiter.html#aedddd315e155a83318fc9a79723c15b2">warp</a> &lt;&lt; <span class="stringliteral">&quot;\n * \n&quot;</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot; */\n\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;#pragma once\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;#include &lt;cstdint&gt;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;#include &lt;string&gt;\n\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;namespace &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;{\n\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">        std::vector&lt;UniformBlockData&gt; uniformBlocks;</div>
<div class="line">        std::vector&lt;UniformData&gt; uniforms;</div>
<div class="line">        std::vector&lt;VertexAttributeData&gt; vertexAttributes;</div>
<div class="line"></div>
<div class="line">        <a class="code" href="struct_g_l_s_l_coutput.html">GLSLCoutput</a> * output = itr-&gt;second.m_CompileObject.lastCompiledResults-&gt;glslcOutput;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; output-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a6cbb6ec5e8a4ff04512fd1c442aa3d92">numSections</a>; ++i)</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59">GLSLCsectionTypeEnum</a> type = output-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].genericHeader.common.<a class="code" href="struct_g_l_s_l_csection_header_common.html#a6a8aed7a5a7e82acff908d084fd85e4a">type</a>;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span>(type == <a name="a68"></a><a class="code" href="nvn_tool___glslc_interface_8h.html#aab53ab9845cc7be41102195446759a59a9af0dfcdde630017c24029fa35ed8849">GLSLC_SECTION_TYPE_REFLECTION</a>)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordtype">void</span> * data = ((<span class="keywordtype">char</span> *)output) + (output-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].genericHeader.common.<a class="code" href="struct_g_l_s_l_csection_header_common.html#abb6e96b70bad30c94477317328d384d5">dataOffset</a>);</div>
<div class="line"></div>
<div class="line">                <span class="keyword">const</span> <a name="_a69"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html">GLSLCprogramReflectionHeader</a> * reflectionHeader = &amp;(output-&gt;<a class="code" href="struct_g_l_s_l_coutput.html#a69ff5a7c06d39592caacec94be810995">headers</a>[i].<a name="a70"></a>programReflectionHeader);</div>
<div class="line"></div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">char</span> *stringPool = (<span class="keyword">const</span> <span class="keywordtype">char</span>*)data + reflectionHeader-&gt;<a name="a71"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a23a3fcd75086c2b537f992e212661622">stringPoolOffset</a>;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">/*</span></div>
<div class="line"><span class="comment">                     * GLSLCuniformBlockInfo</span></div>
<div class="line"><span class="comment">                     * ---------------------</span></div>
<div class="line"><span class="comment">                     * This structures holds information about a uniform block in</span></div>
<div class="line"><span class="comment">                     * the shader program.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * nameInfo           - Contains the length of the block&#39;s name</span></div>
<div class="line"><span class="comment">                     *                      and the offset to the name in the reflection</span></div>
<div class="line"><span class="comment">                     *                      header&#39;s string pool.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * size               - Size in bytes of the uniform block.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * numActiveVariables - Number of active variables defined in the block.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * stagesReferencedIn - Mask that represents what stages the block is</span></div>
<div class="line"><span class="comment">                     *                      used in.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * bindings           - Per stage bindings for the uniform block. The</span></div>
<div class="line"><span class="comment">                     *                      array index corresponds to the NVNshaderStage</span></div>
<div class="line"><span class="comment">                     *                      that the binding is for. If the binding value</span></div>
<div class="line"><span class="comment">                     *                      is -1, that means he block is not used in that</span></div>
<div class="line"><span class="comment">                     *                      stage.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     */</span></div>
<div class="line">                <span class="keyword">const</span> <a name="_a72"></a><a class="code" href="struct_g_l_s_l_cuniform_block_info.html">GLSLCuniformBlockInfo</a> * uniformBlock = (<a class="code" href="struct_g_l_s_l_cuniform_block_info.html">GLSLCuniformBlockInfo</a> *)((<span class="keywordtype">char</span> *)data + reflectionHeader-&gt;<a name="a73"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#ab7239cf2349bda4632d8382ffddcde85">uniformBlockOffset</a>);</div>
<div class="line">                <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; reflectionHeader-&gt;<a name="a74"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a006944206bfbf2bbfb56c1dfb9dc7f96">numUniformBlocks</a>; ++j)</div>
<div class="line">                {</div>
<div class="line">                    UniformBlockData uniformBlockData;</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">for</span>(uint32_t k = 0; k &lt; 6; ++k)</div>
<div class="line">                        uniformBlockData.m_Bindings[k] = uniformBlock-&gt;<a name="a75"></a><a class="code" href="struct_g_l_s_l_cuniform_block_info.html#a3089f78f6431b069fca45643190b8f88">bindings</a>[k];</div>
<div class="line"></div>
<div class="line">                    uniformBlockData.m_Name               = stringPool + uniformBlock-&gt;nameInfo.nameOffset;</div>
<div class="line">                    uniformBlockData.m_Size               = uniformBlock-&gt;size;</div>
<div class="line">                    uniformBlockData.m_NumActiveVariables = uniformBlock-&gt;numActiveVariables;</div>
<div class="line">                    uniformBlockData.m_StagesReferencedIn = static_cast&lt;uint8_t&gt;(uniformBlock-&gt;stagesReferencedIn);</div>
<div class="line"></div>
<div class="line">                    uniformBlocks.push_back(uniformBlockData);</div>
<div class="line"></div>
<div class="line">                    ++uniformBlock;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                    <span class="comment">/*</span></div>
<div class="line"><span class="comment">                     * GLSLCuniformInfo</span></div>
<div class="line"><span class="comment">                     * ---------------------</span></div>
<div class="line"><span class="comment">                     * This structure holds information about individual</span></div>
<div class="line"><span class="comment">                     * uniforms in the sader program. This includes uniforms</span></div>
<div class="line"><span class="comment">                     * that are part of uniform blocks as well sampler/image</span></div>
<div class="line"><span class="comment">                     * type uniforms.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * nameInfo           - Contains the length of the block&#39;s name</span></div>
<div class="line"><span class="comment">                     *                      and the offset to the name in the reflection</span></div>
<div class="line"><span class="comment">                     *                      header&#39;s string pool.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * type               - Data type of the uniform.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * blockNdx           - Index of the uniform in it&#39;s uniform block.</span></div>
<div class="line"><span class="comment">                     *                      (-1 if not a part of a block)</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * blockOffset        - Byte offset into the uniform block.</span></div>
<div class="line"><span class="comment">                     *                      (-1 if not a part of a block)</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * sizeOfArray        - Number of elements, if an array, 1 if not.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * arrayStride        - Stride between array elements.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * matrixStride       - Specifies stride between columns/rows of matrix</span></div>
<div class="line"><span class="comment">                     *                      depending on isRowMajor.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * isRowMajor         - Specifies row major vs column major.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * stagesReferencedIn - Mask that represents what stages the block is</span></div>
<div class="line"><span class="comment">                     *                      used in.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * bindings           - Per stage bindings for the uniform block. The</span></div>
<div class="line"><span class="comment">                     *                      array index corresponds to the NVNshaderStage</span></div>
<div class="line"><span class="comment">                     *                      that the binding is for. If the binding value</span></div>
<div class="line"><span class="comment">                     *                      is -1, that means he block is not used in that</span></div>
<div class="line"><span class="comment">                     *                      stage.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * kind               - Specifies between image, smapler, or normal uniform.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * isInUBO            - 1 if this uniform is in a uniform block, 0 otherwise.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * isArray            - 1 if this uniform is an array, 0 if otherwise.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     */</span></div>
<div class="line">                <a name="_a76"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html">GLSLCuniformInfo</a> * uniform = (<a class="code" href="struct_g_l_s_l_cuniform_info.html">GLSLCuniformInfo</a> *)((<span class="keywordtype">char</span> *)data + reflectionHeader-&gt;<a name="a77"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a7116c27cf2638894a145fcdbb7d05568">uniformOffset</a>);</div>
<div class="line">                <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; reflectionHeader-&gt;<a name="a78"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a0bf19ae5c6027329eec9480f13c71d3c">numUniforms</a>; ++j)</div>
<div class="line">                {</div>
<div class="line">                    UniformData uniformData;</div>
<div class="line"></div>
<div class="line">                    uniformData.m_Name               = stringPool + uniform-&gt;<a name="a79"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#af3c2cf0a643a810defd8f1964ee5347c">nameInfo</a>.<a name="a80"></a><a class="code" href="struct_g_l_s_l_cpiq_name.html#a95cb55a78c99bc13a5442a4ec038fe64">nameOffset</a>;</div>
<div class="line">                    uniformData.m_Type               = uniform-&gt;<a name="a81"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#aba31e5a44352d4b9e067ded0f87e8059">type</a>;</div>
<div class="line">                    uniformData.m_BlockNdx           = uniform-&gt;<a name="a82"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#adc5be9a9b1526b2ec101a374f4d7fe1a">blockNdx</a>;</div>
<div class="line">                    uniformData.m_BlockOffset        = uniform-&gt;<a name="a83"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#a2f72999cec8d93607ffc6c9488c8bd6e">blockOffset</a>;</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">for</span> (uint32_t k = 0; k &lt; 6; ++k)</div>
<div class="line">                    {</div>
<div class="line">                        uniformData.m_Bindings[k] = uniform-&gt;<a name="a84"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#af5982205cf060f75098ac393b9d47536">bindings</a>[k];</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    uniformData.m_IsArray            = uniform-&gt;<a name="a85"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#a6b7862e3e1a42c7e95f6041b210c3124">isArray</a>;</div>
<div class="line">                    uniformData.m_SizeOfArray        = uniform-&gt;<a name="a86"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#aaa27c23127bba5e365da8b927b344570">sizeOfArray</a>;</div>
<div class="line">                    uniformData.m_ArrayStride        = uniform-&gt;<a name="a87"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#a0cbf82d02d29d69ca87d00d575a11d9d">arrayStride</a>;</div>
<div class="line">                    uniformData.m_MatrixStride       = uniform-&gt;<a name="a88"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#a540f5953a7f10b489754374639222af5">matrixStride</a>;</div>
<div class="line">                    uniformData.m_IsRowMajor         = uniform-&gt;<a name="a89"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#ade0fa25b5b9ead9c2101826d6b445f74">isRowMajor</a>;</div>
<div class="line">                    uniformData.m_StagesReferencedIn = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(uniform-&gt;<a name="a90"></a><a class="code" href="struct_g_l_s_l_cuniform_info.html#a062aec36dd8b1203f67b1a8bd12948ee">stagesReferencedIn</a>);</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span>(uniformData.m_BlockNdx != -1)</div>
<div class="line">                    {</div>
<div class="line">                        uniformBlocks[uniformData.m_BlockNdx].m_Uniforms.push_back(uniformData);</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span></div>
<div class="line">                    {</div>
<div class="line">                        uniforms.push_back(uniformData);</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    ++uniform;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                    <span class="comment">/*</span></div>
<div class="line"><span class="comment">                     * GLSLCprogramInputInfo</span></div>
<div class="line"><span class="comment">                     * ---------------------</span></div>
<div class="line"><span class="comment">                     * This structure holds information about attributes</span></div>
<div class="line"><span class="comment">                     * used by the shader program.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * nameInfo           - Contains the length of the block&#39;s name</span></div>
<div class="line"><span class="comment">                     *                      and the offset to the name in the reflection</span></div>
<div class="line"><span class="comment">                     *                      header&#39;s string pool.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * type               - Data type of the uniform.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * sizeOfArray        - Number of elements, if an array, 1 if not.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * location           - Location this input is assigned to.</span></div>
<div class="line"><span class="comment">                     *                      (-1 if not a vert/frag program)</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * stagesReferencedIn - Per stage bindings for the uniform block. The</span></div>
<div class="line"><span class="comment">                     *                      array index corresponds to the NVNshaderStage</span></div>
<div class="line"><span class="comment">                     *                      that the binding is for. If the binding value</span></div>
<div class="line"><span class="comment">                     *                      is -1, that means he block is not used in that</span></div>
<div class="line"><span class="comment">                     *                      stage.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * isArray            - 1 if this input is an array, 0 if otherwise.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     * isPerPatch         - 1 if this input is per patch, 0 if otherwise.</span></div>
<div class="line"><span class="comment">                     *</span></div>
<div class="line"><span class="comment">                     */</span></div>
<div class="line">                <a name="_a91"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html">GLSLCprogramInputInfo</a> * programInput = (<a class="code" href="struct_g_l_s_l_cprogram_input_info.html">GLSLCprogramInputInfo</a> *)((<span class="keywordtype">char</span> *)data + reflectionHeader-&gt;<a name="a92"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#a9f264ef95c68193971b360b4df2f259d">programInputsOffset</a>);</div>
<div class="line">                <span class="keywordflow">for</span>(uint32_t j = 0; j &lt; reflectionHeader-&gt;<a name="a93"></a><a class="code" href="struct_g_l_s_l_cprogram_reflection_header.html#aca10eea8e482a030016556875aec0a7f">numProgramInputs</a>; ++j)</div>
<div class="line">                {</div>
<div class="line">                    VertexAttributeData vertexAttributeData;</div>
<div class="line">                    vertexAttributeData.m_Name               = stringPool + programInput-&gt;<a name="a94"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#a30e2dc0f471667ac41cdde8329d71e25">nameInfo</a>.<a class="code" href="struct_g_l_s_l_cpiq_name.html#a95cb55a78c99bc13a5442a4ec038fe64">nameOffset</a>;</div>
<div class="line">                    vertexAttributeData.m_Type               = programInput-&gt;<a name="a95"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#af409a6a5d837178521fd638d0e19140f">type</a>;</div>
<div class="line">                    vertexAttributeData.m_IsArray            = programInput-&gt;<a name="a96"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#af5f932dc8d34d953489986516b2aa632">isArray</a>;</div>
<div class="line">                    vertexAttributeData.m_SizeOfArray        = programInput-&gt;<a name="a97"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#ade21acdb8e7f5d6fb2023f96a0770e84">sizeOfArray</a>;</div>
<div class="line">                    vertexAttributeData.m_Location           = programInput-&gt;<a name="a98"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#ac0100c9580f95e97b101ae505680bef0">location</a>;</div>
<div class="line">                    vertexAttributeData.m_IsPerPatch         = programInput-&gt;<a name="a99"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#a0924d76ca260a63649cc6409a5084541">isPerPatch</a>;</div>
<div class="line">                    vertexAttributeData.m_StagesReferencedIn = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(programInput-&gt;<a name="a100"></a><a class="code" href="struct_g_l_s_l_cprogram_input_info.html#aa850abcd72ca572b118cea86cc858af7">stagesReferencedIn</a>);</div>
<div class="line"></div>
<div class="line">                    vertexAttributes.push_back(vertexAttributeData);</div>
<div class="line"></div>
<div class="line">                    ++programInput;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;    // Holds a list of attribute data and provides binding information for each attribute\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;class Attributes\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;{\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;    public:\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            // Holds information describing a given attribute\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            // Data fields are filled with data from the GLSLC compile output\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        struct AttributeData\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            AttributeData(const std::string&amp; name = \&quot;\&quot;,\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;                          int32_t location = -1,\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;                          uint8_t stagesReferencedIn = 0) : m_Name(name),\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;                                                            m_Location(location),\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;                                                            m_StagesReferencedIn(stagesReferencedIn)\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            {\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            }\n\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            std::string m_Name;              // Name of the attribute in the shader\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            int32_t m_Location;              // Binding location\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            uint8_t m_StagesReferencedIn;    // Bit flag of stages that the attribute is referenced in, of type NVNshaderStageBits\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        };\n\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            // Get the binding location for the attribute with the given name\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        static int32_t GetAttributeLocation(const std::string&amp; name)\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            for(uint32_t i = 0; i &lt; m_NumAttributes; ++i)\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            {\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;                if(m_Attributes[i].m_Name == name)\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;                    return m_Attributes[i].m_Location;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            }\n\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            return -1;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            // Get the number of vertex attributes in the shader program\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        static uint32_t GetNumAttributes()\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            return m_NumAttributes;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            // Get the stages the attribute is referenced in\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        static uint8_t GetStagesReferencedIn(const std::string&amp; name)\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            for(uint32_t i = 0; i &lt; m_NumAttributes; ++i)\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            {\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;                if(m_Attributes[i].m_Name == name)\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;                    return m_Attributes[i].m_StagesReferencedIn;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            }\n\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            return 0;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        static const AttributeData* GetAttributeList()\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;            return m_Attributes;\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;    private:\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        const static uint32_t m_NumAttributes = &quot;</span> &lt;&lt; vertexAttributes.size() &lt;&lt; <span class="stringliteral">&quot;;     // Total number of attributes\n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;        const static AttributeData m_Attributes[&quot;</span> &lt;&lt; vertexAttributes.size() &lt;&lt; <span class="stringliteral">&quot;];    // Static array of attribute data \n&quot;</span>;</div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;};\n\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; uniforms.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;    // Helper class for the &quot;</span> &lt;&lt; uniforms[i].m_Name &lt;&lt; <span class="stringliteral">&quot;uniform\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;class &quot;</span> &lt;&lt; uniforms[i].m_Name &lt;&lt; <span class="stringliteral">&quot;UniformData\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;{\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;    public:\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        static const char name[] = \&quot;&quot;</span> &lt;&lt; uniforms[i].m_Name &lt;&lt; <span class="stringliteral">&quot;\&quot;;    // Name of the uniform\n\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            // Binding locations for the uniform\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        static const int32_t m_Bindings[6];\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        static const uint8_t m_StagesReferencedIn = &quot;</span> &lt;&lt; (uint32_t)uniforms[i].m_StagesReferencedIn &lt;&lt; <span class="stringliteral">&quot;;    // Stages that the uniform is referenced in, of type NVNshaderStageBits\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;};\n\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;const int32_t &quot;</span> &lt;&lt; uniforms[i].m_Name &lt;&lt; <span class="stringliteral">&quot;UniformData::m_Bindings[6] = { &quot;</span> &lt;&lt; uniforms[i].m_Bindings[0];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span>(uint32_t j = 1; j &lt; 6; ++j)</div>
<div class="line">            {</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; uniforms[i].m_Bindings[j];</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot; };\n\n&quot;</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; uniformBlocks.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;    // Helper class for the &quot;</span> &lt;&lt; uniformBlocks[i].m_Name &lt;&lt; <span class="stringliteral">&quot; uniform block\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;class &quot;</span> &lt;&lt; uniformBlocks[i].m_Name &lt;&lt; <span class="stringliteral">&quot;UniformBlockData\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;{\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;    public:\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span>(uint32_t j = 0; j &lt; uniformBlocks[i].m_Uniforms.size(); ++j)</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">const</span> UniformData&amp; uniform = uniformBlocks[i].m_Uniforms[j];</div>
<div class="line">                std::string typeName = GetReferenceTypeName(uniform.m_Type, <span class="stringliteral">&quot;uniformData&quot;</span>);</div>
<div class="line"></div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot;            // Sets the data at the appropriate offset for the uniform block member: &quot;</span> &lt;&lt; uniform.m_Name &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot;        void SetUniform_&quot;</span> &lt;&lt; uniform.m_Name &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; typeName &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot;            memcpy(&amp;m_BlockData[&quot;</span> &lt;&lt; uniform.m_BlockOffset &lt;&lt; <span class="stringliteral">&quot;], &amp;uniformData, sizeof(uniformData));\n&quot;</span>;</div>
<div class="line">                file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            // Get the binding location for the uniform block\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            // shaderStage is of type NVNshaderStage\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        static uint32_t GetBinding(uint32_t shaderStage)\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            return m_Bindings[shaderStage];\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            // Get the stages the uniform block is referenced in\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        static uint8_t GetStagesReferencedIn()\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        {\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            return m_StagesReferencedIn;\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        }\n\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;    private:\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        char m_BlockData[&quot;</span> &lt;&lt; uniformBlocks[i].m_Size &lt;&lt; <span class="stringliteral">&quot;];    // Block of data representing the uniform block\n\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;            // Binding location of the uniform block\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        static const int32_t m_Bindings[6];\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;        static const uint8_t m_StagesReferencedIn = &quot;</span> &lt;&lt; (uint32_t)uniformBlocks[i].m_StagesReferencedIn &lt;&lt; <span class="stringliteral">&quot;;    // Bit flag of stages that the attribute is referenced in, of type NVNshaderStageBits\n&quot;</span>;</div>
<div class="line">            file &lt;&lt; <span class="stringliteral">&quot;};\n\n&quot;</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        file &lt;&lt; <span class="stringliteral">&quot;}\n\n&quot;</span>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">            <span class="comment">// Source file for static member initilization</span></div>
<div class="line">        std::ofstream sourceFile;</div>
<div class="line">        sourceFile.open(path + (itr-&gt;first + <span class="stringliteral">&quot;DataHelper.cpp&quot;</span>), std::fstream::out);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>(!sourceFile.is_open())</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to create output source file for &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; path &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;DataHelper.cpp\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;/*--------------------------------------------------------------------------------*\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;Copyright (C)Nintendo All rights reserved.\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;These coded instructions, statements, and computer programs contain proprietary\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;information of Nintendo and/or its licensed developers and are protected by\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;national and international copyright laws. They may not be disclosed to third\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;parties or copied or duplicated in any form, in whole or in part, without the\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;prior written consent of Nintendo.\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;The content herein is highly confidential and should be handled accordingly.\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;*--------------------------------------------------------------------------------*/\n\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;/*\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot; * &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;DataHelper.cpp\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot; * -------------------------------------------------\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot; * This is a generated file from GLSLC shader\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot; * compile reflection information. Do not edit.\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot; * -------------------------------------------------\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot; */\n\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;#include \&quot;&quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;DataHelper.h\&quot;\n\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">        sourceFile &lt;&lt;<span class="stringliteral">&quot;    // The AttributeData array is filled with values from the GLSLC shader compile output\n&quot;</span>;</div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot;const &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;::Attributes::AttributeData &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;::Attributes::m_Attributes[&quot;</span> &lt;&lt; vertexAttributes.size() &lt;&lt; <span class="stringliteral">&quot;] = { &quot;</span>;</div>
<div class="line">        <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; vertexAttributes.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            sourceFile &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;::Attributes::AttributeData(\&quot;&quot;</span> &lt;&lt; vertexAttributes[i].m_Name &lt;&lt; <span class="stringliteral">&quot;\&quot;, &quot;</span> &lt;&lt; vertexAttributes[i].m_Location &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; (uint32_t)vertexAttributes[i].m_StagesReferencedIn &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (i + 1 &lt; vertexAttributes.size())</div>
<div class="line">            {</div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        sourceFile &lt;&lt; <span class="stringliteral">&quot; };\n\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; uniformBlocks.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            sourceFile &lt;&lt; <span class="stringliteral">&quot;const int32_t &quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="stringliteral">&quot;::&quot;</span> &lt;&lt; uniformBlocks[i].m_Name &lt;&lt; <span class="stringliteral">&quot;UniformBlockData::m_Bindings[6] = { &quot;</span> &lt;&lt; uniformBlocks[i].m_Bindings[0];</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span>(uint32_t j = 1; j &lt; 6; ++j)</div>
<div class="line">            {</div>
<div class="line">                sourceFile &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; uniformBlocks[i].m_Bindings[j];</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            sourceFile &lt;&lt; <span class="stringliteral">&quot; };\n\n&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}<span class="comment">//NOLINT(impl/function_size)</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::GetReferenceTypeName</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------</span></div>
<div class="line"><span class="comment"> * Helper function that converts a given type enum and variable name</span></div>
<div class="line"><span class="comment"> * into a string to be used by the shader header/source helper file</span></div>
<div class="line"><span class="comment"> * output. The list of types here is not complete and is simply the</span></div>
<div class="line"><span class="comment"> * types that are used by the shaders in these tutorials.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">std::string IntermediateFileManager::GetReferenceTypeName(<a class="code" href="nvn_tool___glslc_interface_8h.html#a71450a1e5f331c7e5a19404cbf63974a">GLSLCpiqTypeEnum</a> type, <span class="keyword">const</span> std::string&amp; variableName)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span>(type)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_UINT:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const uint32_t&amp; &quot;</span> + variableName;</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_UINT64:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const uint64_t&amp; &quot;</span> + variableName;</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_FLOAT:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const float&amp; &quot;</span> + variableName;</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_FLOAT_VEC2:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const float (&amp;&quot;</span> + variableName + <span class="stringliteral">&quot;)[2]&quot;</span>;</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_FLOAT_VEC3:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const float (&amp;&quot;</span> + variableName + <span class="stringliteral">&quot;)[3]&quot;</span>;</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_FLOAT_VEC4:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const float (&amp;&quot;</span> + variableName + <span class="stringliteral">&quot;)[4]&quot;</span>;</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_MAT3:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const float (&amp;&quot;</span> + variableName + <span class="stringliteral">&quot;)[9]&quot;</span>;</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_MAT4X3:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const float (&amp;&quot;</span> + variableName + <span class="stringliteral">&quot;)[12]&quot;</span>;</div>
<div class="line">        <span class="keywordflow">case</span> GLSLC_PIQ_TYPE_MAT4:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;const float (&amp;&quot;</span> + variableName + <span class="stringliteral">&quot;)[16]&quot;</span>;</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Unlisted variable type, case needs to be added.\n&quot;</span>;</div>
<div class="line">            assert(<span class="stringliteral">&quot;Unlisted variable type, case needs to be added.&quot;</span> &amp;&amp; 0);</div>
<div class="line">            <span class="keywordflow">return</span> std::string();</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadTextureData</span></div>
<div class="line"><span class="comment"> * ----------------------------------------</span></div>
<div class="line"><span class="comment"> * Uses the NVN image library to load the raw texture data</span></div>
<div class="line"><span class="comment"> * from the files specified by the config text file. The raw</span></div>
<div class="line"><span class="comment"> * texture data is stored in the nvnTool::texpkg::RawImage class.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> IntermediateFileManager::LoadTextureData(<span class="keyword">const</span> std::string&amp; path)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * Texpkg Raw Image</span></div>
<div class="line"><span class="comment">         * ----------------</span></div>
<div class="line"><span class="comment">         * The RawImage structure is a wrapper around a generic pitch-linear</span></div>
<div class="line"><span class="comment">         * image with member functions to get information about the texture.</span></div>
<div class="line"><span class="comment">         * A RawImage can be created with specific settings with the Create</span></div>
<div class="line"><span class="comment">         * function. An image created through the image loader will be setup</span></div>
<div class="line"><span class="comment">         * based on the texture file that is loaded.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Textures */</span></div>
<div class="line">    <span class="keywordflow">for</span>(std::vector&lt;TextureData&gt;::iterator itr = m_RawTextureData.begin(); itr != m_RawTextureData.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">            <span class="comment">/* Create a RawImage struct for the base texture to be loaded. */</span></div>
<div class="line">        <a name="_a101"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html">nvnTool::texpkg::RawImage</a>* temp = g_NvnImageLib.<a name="a102"></a>createRawImage();</div>
<div class="line"></div>
<div class="line">        std::string tempFile = path + itr-&gt;m_FileName;</div>
<div class="line">        std::wstring filename(tempFile.begin(), tempFile.end());</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* Load the texture in from file into the RawImage. */</span></div>
<div class="line">        TPError err = g_ImageLoader-&gt;<a name="a103"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image_format_manager.html#a8dc4204e239067cf09595b493588eb68">Load</a>(filename.c_str(), temp);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>(err != TP_OK)</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to load image: &quot;</span> &lt;&lt; tempFile.c_str() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* If the texture has mip maps that need to be loaded in... */</span></div>
<div class="line">        <span class="keywordflow">if</span>(itr-&gt;m_MipMaps.size())</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html">nvnTool::texpkg::RawImage</a>* image = g_NvnImageLib.createRawImage();</div>
<div class="line"></div>
<div class="line">                <span class="comment">/* Create a new RawImage that has the appropriate number of mip maps. */</span></div>
<div class="line">            TPError create = image-&gt;<a name="a104"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html#ac10c025febba178c2f547be67db50c45">Create</a>(temp-&gt;<a name="a105"></a>Target(), temp-&gt;<a name="a106"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html#a5f7b454a84ad0511ba340383d75bdafe">Width</a>(), temp-&gt;<a name="a107"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html#a284d305b9c72ec9081b5137e42491f5a">Height</a>(), temp-&gt;<a name="a108"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html#afb6099eb30a13967d0abf2a1a4560ac3">Depth</a>(), temp-&gt;<a name="a109"></a>Format(), <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(itr-&gt;m_MipMaps.size()) + 1);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span>(create != TP_OK)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to created image: &quot;</span> &lt;&lt; tempFile.c_str() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">                <span class="comment">/* Grab a pointer to the base level texture data and copy the loaded texture data into it. */</span></div>
<div class="line">            <a name="_a110"></a><a class="code" href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html">nvnTool::texpkg::RawMipMapLevel</a>* base = image-&gt;<a name="a111"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html#a0d0ff82a41c39b616dabb7b73b13f9dd">MipMapLevel</a>(0);</div>
<div class="line">            memcpy(base-&gt;<a name="a112"></a><a class="code" href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html#a7a5c91011253054539257bf5e58f8dfc">data</a>, temp-&gt;<a name="a113"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html#a82824e08861efe2123da72fec40ef788">GetData</a>(), base-&gt;<a name="a114"></a><a class="code" href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html#a9966eb3a43d2a4232b85136c9cb3ca58">dataSize</a>);</div>
<div class="line"></div>
<div class="line">                <span class="comment">/* For each mip level... */</span></div>
<div class="line">            <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; itr-&gt;m_MipMaps.size(); ++i)</div>
<div class="line">            {</div>
<div class="line">                    <span class="comment">/* Create a RawImage and load the texture file for the mip level. */</span></div>
<div class="line">                <a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html">nvnTool::texpkg::RawImage</a>* tempMip = g_NvnImageLib.createRawImage();</div>
<div class="line">                std::string tempFileMip = path + itr-&gt;m_MipMaps[i].m_FileName;</div>
<div class="line">                err = g_ImageLoader-&gt;<a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image_format_manager.html#a8dc4204e239067cf09595b493588eb68">Load</a>(std::wstring(tempFileMip.begin(), tempFileMip.end()).c_str(), tempMip);</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span>(err != TP_OK)</div>
<div class="line">                {</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to load image: &quot;</span> &lt;&lt; tempFileMip.c_str() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                    <span class="comment">/* Grab a poiner to the mip level data and copy the loaded data into it. */</span></div>
<div class="line">                <a class="code" href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html">nvnTool::texpkg::RawMipMapLevel</a>* mipMap = image-&gt;<a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html#a0d0ff82a41c39b616dabb7b73b13f9dd">MipMapLevel</a>(itr-&gt;m_MipMaps[i].m_Level);</div>
<div class="line">                memcpy(mipMap-&gt;<a class="code" href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html#a7a5c91011253054539257bf5e58f8dfc">data</a>, tempMip-&gt;<a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html#a82824e08861efe2123da72fec40ef788">GetData</a>(), mipMap-&gt;<a class="code" href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html#a9966eb3a43d2a4232b85136c9cb3ca58">dataSize</a>);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            itr-&gt;m_pRawImage = image;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            itr-&gt;m_pRawImage = temp;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Cube maps */</span></div>
<div class="line">    <span class="keywordflow">for</span>(std::vector&lt;CubeMapData&gt;::iterator itr = m_RawCubeMapData.begin(); itr != m_RawCubeMapData.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        std::vector&lt;nvnTool::texpkg::RawImage*&gt; faces;</div>
<div class="line">        faces.resize(itr-&gt;m_Faces.size(), NULL);</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* For each face... */</span></div>
<div class="line">        <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; itr-&gt;m_Faces.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">/* Load in the cube map face from file and create a RawImage for it. */</span></div>
<div class="line">            faces[i] = g_NvnImageLib.createRawImage();</div>
<div class="line"></div>
<div class="line">            std::string tempFile = path + itr-&gt;m_Faces[i];</div>
<div class="line">            std::wstring filename(tempFile.begin(), tempFile.end());</div>
<div class="line"></div>
<div class="line">            TPError err = g_ImageLoader-&gt;<a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image_format_manager.html#a8dc4204e239067cf09595b493588eb68">Load</a>(filename.c_str(), faces[i]);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span>(err != TP_OK)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to load image: &quot;</span> &lt;&lt; itr-&gt;m_Faces[i].c_str() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* Create a RawImage for the full cube map with the appropriate parameters. */</span></div>
<div class="line">        <a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html">nvnTool::texpkg::RawImage</a>* cubeImage = g_NvnImageLib.createRawImage();</div>
<div class="line"></div>
<div class="line">        TPError create = cubeImage-&gt;<a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html#ac10c025febba178c2f547be67db50c45">Create</a>(<a name="a115"></a><a class="code" href="group__nvn__c__enum.html#gga7f247010f53480c7dd1f3b2ad638c431a3566aaaa3f937694d6321407ff4af7c2">NVNtextureTarget::NVN_TEXTURE_TARGET_CUBEMAP</a>, faces[0]-&gt;Width(), faces[0]-&gt;Height(), faces[0]-&gt;Depth(), faces[0]-&gt;Format(), 1, 6);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>(create != TP_OK)</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to created image: &quot;</span> &lt;&lt; itr-&gt;m_Name.c_str() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* Set the cube face mask to all to denote that all cube map faces are being used. */</span></div>
<div class="line">        cubeImage-&gt;<a name="a116"></a>SetCubeFaceMask(<a name="a117"></a><a class="code" href="namespacenvn_tool_1_1texpkg.html#a552cb0de2b3e44d1ec796f7c4997fe11a83372e89ffcb28e22577609d44b26b7c">nvnTool::texpkg::RawTextureCubeFace::CUBE_FACE_All</a>);</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* Copy the data for each face at the appropriate subimage. */</span></div>
<div class="line">        <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; itr-&gt;m_Faces.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html">nvnTool::texpkg::RawMipMapLevel</a>* mipMap = cubeImage-&gt;<a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image.html#a0d0ff82a41c39b616dabb7b73b13f9dd">MipMapLevel</a>(0, i);</div>
<div class="line"></div>
<div class="line">            memcpy(mipMap-&gt;<a class="code" href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html#a7a5c91011253054539257bf5e58f8dfc">data</a>, faces[i]-&gt;GetData(), mipMap-&gt;<a class="code" href="structnvn_tool_1_1texpkg_1_1_raw_mip_map_level.html#a9966eb3a43d2a4232b85136c9cb3ca58">dataSize</a>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        itr-&gt;m_pRawImage = cubeImage;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::ConvertTextures</span></div>
<div class="line"><span class="comment"> * ----------------------------------------</span></div>
<div class="line"><span class="comment"> * Takes the raw texture data that was loaded in and runs</span></div>
<div class="line"><span class="comment"> * it through the texpkg libraries conversion process. This</span></div>
<div class="line"><span class="comment"> * results in the texture being converted to a format that</span></div>
<div class="line"><span class="comment"> * allows the target harware to use it directly.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> IntermediateFileManager::ConvertTextures()</div>
<div class="line">{</div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * NVNHWTexture</span></div>
<div class="line"><span class="comment">         * ------------</span></div>
<div class="line"><span class="comment">         * The NVNHWTexture hold the texture data from a RawImage after</span></div>
<div class="line"><span class="comment">         * it has been converted to the hardware optimized format. This</span></div>
<div class="line"><span class="comment">         * converted format can also be used on Windows if it is given</span></div>
<div class="line"><span class="comment">         * to the texture builder through the SetPackagedTextureData function.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Convert the list of textures. */</span></div>
<div class="line">    <span class="keywordflow">for</span> (std::vector&lt;TextureData&gt;::iterator itr = m_RawTextureData.begin(); itr != m_RawTextureData.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        TPError err = g_HwTextureExporter-&gt;<a name="a118"></a><a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image_hardware_texture_exporter.html#afd984b313aa67240995f06d92a8e9ef3">Convert</a>(itr-&gt;m_pRawImage, &amp;m_ConvertedTextureData[itr-&gt;m_FileName]);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>(err != TP_OK)</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to convert texture: &quot;</span> &lt;&lt; itr-&gt;m_FileName.c_str() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Convert the cube maps. */</span></div>
<div class="line">    <span class="keywordflow">for</span>(std::vector&lt;CubeMapData&gt;::iterator itr = m_RawCubeMapData.begin(); itr != m_RawCubeMapData.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        TPError err = g_HwTextureExporter-&gt;<a class="code" href="classnvn_tool_1_1texpkg_1_1_raw_image_hardware_texture_exporter.html#afd984b313aa67240995f06d92a8e9ef3">Convert</a>(itr-&gt;m_pRawImage, &amp;m_ConvertedTextureData[itr-&gt;m_Name]);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>(err != TP_OK)</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to convert texture: &quot;</span> &lt;&lt; itr-&gt;m_Name.c_str() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadShaderConfig</span></div>
<div class="line"><span class="comment"> * -----------------------------------------</span></div>
<div class="line"><span class="comment"> * Load the shader section of the config file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> IntermediateFileManager::LoadShaderConfig(std::ifstream&amp; configFile)</div>
<div class="line">{</div>
<div class="line">    std::string text, programName;</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;Name:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        configFile &gt;&gt; programName;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Shader Program Name\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Shader Program Name\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> loop = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">while</span> (loop)</div>
<div class="line">    {</div>
<div class="line">        configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;VertexShader:&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line">            m_ShaderPrograms[programName].m_Vert = text;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;FragmentShader:&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line">            m_ShaderPrograms[programName].m_Frag = text;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;ComputeShader:&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line">            m_ShaderPrograms[programName].m_Comp = text;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;TessEvalShader:&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line">            m_ShaderPrograms[programName].m_TessEval = text;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;TessContShader:&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line">            m_ShaderPrograms[programName].m_TessCont = text;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;GeometryShader:&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line">            m_ShaderPrograms[programName].m_Geom = text;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            loop = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadTextureConfig</span></div>
<div class="line"><span class="comment"> * ------------------------------------------</span></div>
<div class="line"><span class="comment"> * Load the texture section of the config file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> IntermediateFileManager::LoadTextureConfig(std::ifstream&amp; configFile)</div>
<div class="line">{</div>
<div class="line">    std::string text, textureName;</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;Name:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        configFile &gt;&gt; textureName;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Texture File Name\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Texture File Name\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    m_RawTextureData.push_back(TextureData());</div>
<div class="line"></div>
<div class="line">    m_RawTextureData.back().m_FileName = textureName;</div>
<div class="line">    m_RawTextureData.back().m_pRawImage = NULL;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> loop = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">while</span> (loop)</div>
<div class="line">    {</div>
<div class="line">        configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            loop = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;MipmapBegin&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            m_RawTextureData.back().m_MipMaps.push_back(MipMapData());</div>
<div class="line"></div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;Name:&quot;</span>)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Mipmap File Name\n&quot;</span>;</div>
<div class="line">                assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Mipmap File Name\n&quot;</span>);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            configFile &gt;&gt; m_RawTextureData.back().m_MipMaps.back().m_FileName;</div>
<div class="line"></div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;Level:&quot;</span>)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Mipmap Level\n&quot;</span>;</div>
<div class="line">                assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Mipmap Level\n&quot;</span>);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            configFile &gt;&gt; m_RawTextureData.back().m_MipMaps.back().m_Level;</div>
<div class="line"></div>
<div class="line">            configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Mipmap End\n&quot;</span>;</div>
<div class="line">                assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Mipmap End\n&quot;</span>);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadCubeMapConfig</span></div>
<div class="line"><span class="comment"> * ------------------------------------------</span></div>
<div class="line"><span class="comment"> * Load the cube map section of the config file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> IntermediateFileManager::LoadCubeMapConfig(std::ifstream&amp; configFile)</div>
<div class="line">{</div>
<div class="line">    std::string text;</div>
<div class="line"></div>
<div class="line">    m_RawCubeMapData.push_back(CubeMapData());</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;Name:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Cube Map Name\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Cube Map Name\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; m_RawCubeMapData.back().m_Name;</div>
<div class="line">    m_RawCubeMapData.back().m_pRawImage = NULL;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> loop = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">while</span> (loop)</div>
<div class="line">    {</div>
<div class="line">        configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            loop = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;Face:&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            m_RawCubeMapData.back().m_Faces.push_back(std::string());</div>
<div class="line">            configFile &gt;&gt; m_RawCubeMapData.back().m_Faces.back();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Unknown Cube Map Element: &quot;</span> &lt;&lt; text &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            assert(0 &amp;&amp; <span class="stringliteral">&quot;Unknown Cube Map Element\n&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (m_RawCubeMapData.back().m_Faces.size() != 6)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cube map with less than 6 faces: &quot;</span> &lt;&lt; m_RawCubeMapData.back().m_Name.c_str() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        assert(<span class="stringliteral">&quot;Cube map with less than 6 faces&quot;</span> &amp;&amp; 0);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadModelConfig</span></div>
<div class="line"><span class="comment"> * ----------------------------------------</span></div>
<div class="line"><span class="comment"> * Load the model section of the config file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> IntermediateFileManager::LoadModelConfig(std::ifstream&amp; configFile)</div>
<div class="line">{</div>
<div class="line">    Model model;</div>
<div class="line"></div>
<div class="line">    std::string text;</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;Name:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Model Name\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Model Name\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; model.m_Name;</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;NumAttributes:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing NumAttributes\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing NumAttributes\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; model.m_NumVertexAttributes;</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;NumPrimitives:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing NumPrimitives\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing NumPrimitives\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; model.m_NumPrimitives;</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;nvnDrawPrimitiveType:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing nvnDrawPrimitiveType\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing nvnDrawPrimitiveType\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; model.m_NvnDrawPrimitiveType;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> loop = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">while</span> (loop)</div>
<div class="line">    {</div>
<div class="line">        configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;VertexAttributeBegin&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            LoadVertexAttributeConfig(configFile, model);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;IndicesBegin&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            LoadIndices(configFile, model);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            loop = <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    m_RawModelData.push_back(model);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadVertexAttributeConfig</span></div>
<div class="line"><span class="comment"> * --------------------------------------------------</span></div>
<div class="line"><span class="comment"> * Load the vertex attribute section of the config file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> IntermediateFileManager::LoadVertexAttributeConfig(std::ifstream&amp; configFile, Model&amp; model)</div>
<div class="line">{</div>
<div class="line">    std::string text;</div>
<div class="line">    VertexAttribute vertexAttribute;</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;Name:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Attribute Name\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Attribute Name\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; vertexAttribute.m_Name;</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;DataSize:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Attribute DataSize\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Attribute DataSize\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; vertexAttribute.m_DataSize;</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;ElementSize:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Attribute ElementSize\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Attribute ElementSize\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; vertexAttribute.m_ElementSize;</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;Stride:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Attribute Stride\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Attribute Stride\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; vertexAttribute.m_Stride;</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;nvnFormat:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Attribute nvnFormat\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Attribute nvnFormat\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; vertexAttribute.m_NvnFormat;</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;DataBegin&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Attribute Data\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Attribute Data\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    vertexAttribute.m_pData = malloc(vertexAttribute.m_DataSize);</div>
<div class="line">    <span class="keywordtype">void</span>* temp = vertexAttribute.m_pData;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> loop = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">while</span> (loop)</div>
<div class="line">    {</div>
<div class="line">        configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            loop = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (vertexAttribute.m_ElementSize == <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>))</div>
<div class="line">        {</div>
<div class="line">            *(<span class="keywordtype">float</span>*)temp = (<span class="keywordtype">float</span>)std::atof(text.c_str());</div>
<div class="line">            temp = (<span class="keywordtype">float</span>*)temp + 1;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vertexAttribute.m_ElementSize == <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>))</div>
<div class="line">        {</div>
<div class="line">            *(<span class="keywordtype">short</span>*)temp = static_cast&lt;short&gt;(std::atoi(text.c_str()));</div>
<div class="line">            temp = (<span class="keywordtype">short</span>*)temp + 1;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vertexAttribute.m_ElementSize == <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>))</div>
<div class="line">        {</div>
<div class="line">            *(<span class="keywordtype">char</span>*)temp = static_cast&lt;char&gt;(std::atoi(text.c_str()));</div>
<div class="line">            temp = (<span class="keywordtype">char</span>*)temp + 1;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Attribute End\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Attribute End\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    model.m_VertexAttributes.push_back(vertexAttribute);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadIndices</span></div>
<div class="line"><span class="comment"> * ------------------------------------</span></div>
<div class="line"><span class="comment"> * Load the index section of the config file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> IntermediateFileManager::LoadIndices(std::ifstream&amp; configFile, Model&amp; model)</div>
<div class="line">{</div>
<div class="line">    std::string text;</div>
<div class="line">    IndexData&amp; indexData = model.m_IndexData;</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;nvnType:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Indices NVN Type\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Indices NVN Type\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; indexData.m_IndexType;</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;DataSize:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Indices DataSize\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Indices DataSize\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; indexData.m_DataSize;</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;Stride:&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Indices Stride\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Indices Stride\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; indexData.m_Stride;</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;DataBegin&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Indices Data\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Indices Data\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    indexData.m_pData = malloc(indexData.m_DataSize);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span>* temp = indexData.m_pData;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> loop = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">while</span> (loop)</div>
<div class="line">    {</div>
<div class="line">        configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            loop = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (indexData.m_Stride == <span class="keyword">sizeof</span>(uint32_t))</div>
<div class="line">        {</div>
<div class="line">            *(uint32_t*)temp = std::atoi(text.c_str());</div>
<div class="line">            temp = (uint32_t*)temp + 1;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (indexData.m_Stride == <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>))</div>
<div class="line">        {</div>
<div class="line">            *(<span class="keywordtype">short</span>*)temp = static_cast&lt;short&gt;(std::atoi(text.c_str()));</div>
<div class="line">            temp = (<span class="keywordtype">short</span>*)temp + 1;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (indexData.m_Stride == <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>))</div>
<div class="line">        {</div>
<div class="line">            *(<span class="keywordtype">char</span>*)temp = static_cast&lt;char&gt;(std::atoi(text.c_str()));</div>
<div class="line">            temp = (<span class="keywordtype">char</span>*)temp + 1;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    configFile &gt;&gt; text;</div>
<div class="line">    <span class="keywordflow">if</span> (text != <span class="stringliteral">&quot;End&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Missing Indices End\n&quot;</span>;</div>
<div class="line">        assert(0 &amp;&amp; <span class="stringliteral">&quot;Missing Indices End\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * IntermediateFileManager::LoadConfigFile</span></div>
<div class="line"><span class="comment"> * ---------------------------------------</span></div>
<div class="line"><span class="comment"> * Load the config file.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">bool</span> IntermediateFileManager::LoadConfigFile(std::string fileName)</div>
<div class="line">{</div>
<div class="line">    std::ifstream configFile;</div>
<div class="line">    configFile.open(fileName);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!configFile.is_open())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> (!configFile.eof())</div>
<div class="line">    {</div>
<div class="line">        std::string text;</div>
<div class="line">        configFile &gt;&gt; text;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;ShaderProgramBegin&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            LoadShaderConfig(configFile);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;TextureBegin&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            LoadTextureConfig(configFile);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;CubeMapBegin&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            LoadCubeMapConfig(configFile);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (text == <span class="stringliteral">&quot;ModelBegin&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            LoadModelConfig(configFile);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
