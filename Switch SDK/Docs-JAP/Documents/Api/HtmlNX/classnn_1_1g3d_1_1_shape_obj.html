<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>NintendoSDK API Reference: nn::g3d::ShapeObj クラス</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>総合概要</span></a></li>
      <li><a href="pages.html"><span>諸情報</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>名前空間</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>クラス一覧</span></a></li>
      <li><a href="classes.html"><span>クラス索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>クラスメンバ</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenn.html">nn</a></li><li class="navelem"><a class="el" href="namespacenn_1_1g3d.html">g3d</a></li><li class="navelem"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html">ShapeObj</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">クラス</a> &#124;
<a href="#pub-types">公開型</a> &#124;
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="#pro-types">限定公開型</a> &#124;
<a href="classnn_1_1g3d_1_1_shape_obj-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">nn::g3d::ShapeObj クラス</div>  </div>
</div><!--header-->
<div class="contents">

<p>シェイプインスタンスです。  
 <a href="classnn_1_1g3d_1_1_shape_obj.html#details">[詳解]</a></p>

<p><code>#include &lt;nn/g3d/g3d_ShapeObj.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
クラス</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj_1_1_builder.html">Builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html" title="シェイプインスタンスです。 ">ShapeObj</a> の構築を行うクラスです。  <a href="classnn_1_1g3d_1_1_shape_obj_1_1_builder.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj_1_1_initialize_argument.html">InitializeArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>内部用機能のため使用禁止です。</b> <a class="el" href="namespacenn_1_1htcs.html#a7eab72b8843a2a9ff763f52b78da680e" title="ホスト・ターゲット間ソケット通信を初期化します。  nn::htcs::GetWorkingMemorySize(nn::htcs::SocketCoun...">ShapeObj::Initialize()</a> に渡して初期化を行うパラメータです。  <a href="classnn_1_1g3d_1_1_shape_obj_1_1_initialize_argument.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
公開型</h2></td></tr>
<tr class="memitem:a324377c158258439ceb8d5c2573d8bb8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a324377c158258439ceb8d5c2573d8bb8">Alignment</a> { <a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a324377c158258439ceb8d5c2573d8bb8a6083dd58eaffe3866fecd81fb437a0b9">Alignment_Buffer</a> = MatrixVectorAlignment
 }<tr class="memdesc:a324377c158258439ceb8d5c2573d8bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">インスタンスの構築時に渡すバッファーの必要アライメントサイズです。  <a href="classnn_1_1g3d_1_1_shape_obj.html#a324377c158258439ceb8d5c2573d8bb8">[詳解]</a><br /></td></tr>
<tr class="separator:a324377c158258439ceb8d5c2573d8bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:a49dd09490b1b087accb0df529831c20e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a49dd09490b1b087accb0df529831c20e">GetShapeBlockArray</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a49dd09490b1b087accb0df529831c20e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>内部用機能のため使用禁止です。</b> ユニフォームブロックのバッファー配列を取得します。  <a href="#a49dd09490b1b087accb0df529831c20e">[詳解]</a><br /></td></tr>
<tr class="separator:a49dd09490b1b087accb0df529831c20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6be9b6a4067792ff55b9665a5660a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a2e6be9b6a4067792ff55b9665a5660a7">SetShapeBlockArray</a> (<a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a> *pBlockArray) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2e6be9b6a4067792ff55b9665a5660a7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>内部用機能のため使用禁止です。</b> ユニフォームブロックのバッファー配列を設定します。  <a href="#a2e6be9b6a4067792ff55b9665a5660a7">[詳解]</a><br /></td></tr>
<tr class="separator:a2e6be9b6a4067792ff55b9665a5660a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">構築/破棄</div></td></tr>
<tr class="memitem:af6d03e27a48f193a0aaafa2380c13919"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#af6d03e27a48f193a0aaafa2380c13919">ShapeObj</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af6d03e27a48f193a0aaafa2380c13919"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンストラクタです。  <a href="#af6d03e27a48f193a0aaafa2380c13919">[詳解]</a><br /></td></tr>
<tr class="separator:af6d03e27a48f193a0aaafa2380c13919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba82136231db018f912733940a36dc4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a0ba82136231db018f912733940a36dc4">CalculateBlockBufferSize</a> (<a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *pDevice) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0ba82136231db018f912733940a36dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユニフォームブロックのサイズを計算します。  <a href="#a0ba82136231db018f912733940a36dc4">[詳解]</a><br /></td></tr>
<tr class="separator:a0ba82136231db018f912733940a36dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cabdabea5964ffbfb204dd0e4bd5bf1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a7cabdabea5964ffbfb204dd0e4bd5bf1">SetupBlockBuffer</a> (<a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *pDevice, <a class="el" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">nn::gfx::MemoryPool</a> *pMemoryPool, ptrdiff_t offset, size_t memoryPoolSize) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7cabdabea5964ffbfb204dd0e4bd5bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">メモリプールを渡して、ユニフォームブロックを構築します。  <a href="#a7cabdabea5964ffbfb204dd0e4bd5bf1">[詳解]</a><br /></td></tr>
<tr class="separator:a7cabdabea5964ffbfb204dd0e4bd5bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62907045e2b301d7f347752106eec7af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a62907045e2b301d7f347752106eec7af">CleanupBlockBuffer</a> (<a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *pDevice) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a62907045e2b301d7f347752106eec7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユニフォームブロックを破棄します。  <a href="#a62907045e2b301d7f347752106eec7af">[詳解]</a><br /></td></tr>
<tr class="separator:a62907045e2b301d7f347752106eec7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">更新</div></td></tr>
<tr class="memitem:afa580dfcb0fac318789e05bf22ab949c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#afa580dfcb0fac318789e05bf22ab949c">CalculateBounding</a> (const <a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html">SkeletonObj</a> *pSkeleton) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afa580dfcb0fac318789e05bf22ab949c"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッシュ0 のバウンディング球を計算します。  <a href="#afa580dfcb0fac318789e05bf22ab949c">[詳解]</a><br /></td></tr>
<tr class="separator:afa580dfcb0fac318789e05bf22ab949c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1a0c59dab38304e64db8d6831ce75d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a3e1a0c59dab38304e64db8d6831ce75d">CalculateBounding</a> (const <a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html">SkeletonObj</a> *pSkeleton, int meshIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3e1a0c59dab38304e64db8d6831ce75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定したメッシュのバウンディング球を計算します。  <a href="#a3e1a0c59dab38304e64db8d6831ce75d">[詳解]</a><br /></td></tr>
<tr class="separator:a3e1a0c59dab38304e64db8d6831ce75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3875fc401453548f6e5fdf3928abdee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ad3875fc401453548f6e5fdf3928abdee">CalculateSubMeshBounding</a> (const <a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html">SkeletonObj</a> *pSkeleton) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad3875fc401453548f6e5fdf3928abdee"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッシュ 0 のサブメッシュのバウンディングボックスを計算します。  <a href="#ad3875fc401453548f6e5fdf3928abdee">[詳解]</a><br /></td></tr>
<tr class="separator:ad3875fc401453548f6e5fdf3928abdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4ed8a8cbc3c3e702b1f1b20d2a5536"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a5d4ed8a8cbc3c3e702b1f1b20d2a5536">CalculateSubMeshBounding</a> (const <a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html">SkeletonObj</a> *pSkeleton, int meshIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5d4ed8a8cbc3c3e702b1f1b20d2a5536"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定したメッシュのサブメッシュのバウンディングボックスを計算します。  <a href="#a5d4ed8a8cbc3c3e702b1f1b20d2a5536">[詳解]</a><br /></td></tr>
<tr class="separator:a5d4ed8a8cbc3c3e702b1f1b20d2a5536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b2fc3bb7e76ccac3700abfa9bd5ab8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ac9b2fc3bb7e76ccac3700abfa9bd5ab8">CalculateShape</a> (int viewIndex, const <a class="el" href="namespacenn_1_1util.html#afb360b0e9579454c6af5804cc476c101">nn::util::Matrix4x3fType</a> &amp;worldMtx, int bufferIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac9b2fc3bb7e76ccac3700abfa9bd5ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">シェイプに関する描画リソースを計算します。  <a href="#ac9b2fc3bb7e76ccac3700abfa9bd5ab8">[詳解]</a><br /></td></tr>
<tr class="separator:ac9b2fc3bb7e76ccac3700abfa9bd5ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">取得/設定</div></td></tr>
<tr class="memitem:a8f7bc2a51ba63d4488ff2d6d7d5e0937"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a8f7bc2a51ba63d4488ff2d6d7d5e0937">GetBlockBufferAlignment</a> (<a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *pDevice) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8f7bc2a51ba63d4488ff2d6d7d5e0937"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユニフォームブロックが要求するアライメントを取得します。  <a href="#a8f7bc2a51ba63d4488ff2d6d7d5e0937">[詳解]</a><br /></td></tr>
<tr class="separator:a8f7bc2a51ba63d4488ff2d6d7d5e0937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877f7c0f4f853151966321c4b969c45b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_shape.html">ResShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a877f7c0f4f853151966321c4b969c45b">GetResource</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a877f7c0f4f853151966321c4b969c45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">リソースを取得します。  <a href="#a877f7c0f4f853151966321c4b969c45b">[詳解]</a><br /></td></tr>
<tr class="separator:a877f7c0f4f853151966321c4b969c45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160c8f620f415ad2c3fcfcc0da86ea4f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a160c8f620f415ad2c3fcfcc0da86ea4f">GetBufferPtr</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a160c8f620f415ad2c3fcfcc0da86ea4f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1g3d_1_1_shape_obj_1_1_builder.html" title="ShapeObj の構築を行うクラスです。 ">Builder</a> でBuild() 時に渡されたバッファーを取得します。  <a href="#a160c8f620f415ad2c3fcfcc0da86ea4f">[詳解]</a><br /></td></tr>
<tr class="separator:a160c8f620f415ad2c3fcfcc0da86ea4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ca4b89b13c955925424be0dfeb79d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">nn::gfx::MemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ad1ca4b89b13c955925424be0dfeb79d5">GetMemoryPoolPtr</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad1ca4b89b13c955925424be0dfeb79d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a7cabdabea5964ffbfb204dd0e4bd5bf1" title="メモリプールを渡して、ユニフォームブロックを構築します。 ">SetupBlockBuffer()</a> 時に渡されたメモリプールのポインターを取得します。  <a href="#ad1ca4b89b13c955925424be0dfeb79d5">[詳解]</a><br /></td></tr>
<tr class="separator:ad1ca4b89b13c955925424be0dfeb79d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad133182bc588fb9fc2285cadd3423de0"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ad133182bc588fb9fc2285cadd3423de0">GetMemoryPoolOffset</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad133182bc588fb9fc2285cadd3423de0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a7cabdabea5964ffbfb204dd0e4bd5bf1" title="メモリプールを渡して、ユニフォームブロックを構築します。 ">SetupBlockBuffer()</a> 時に渡されたメモリプールのオフセットを取得します。  <a href="#ad133182bc588fb9fc2285cadd3423de0">[詳解]</a><br /></td></tr>
<tr class="separator:ad133182bc588fb9fc2285cadd3423de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e08f29f39bbbfc84101739e7a23c02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a96e08f29f39bbbfc84101739e7a23c02">IsBlockBufferValid</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a96e08f29f39bbbfc84101739e7a23c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユニフォームブロックが構築済みであるかどうかを取得します。  <a href="#a96e08f29f39bbbfc84101739e7a23c02">[詳解]</a><br /></td></tr>
<tr class="separator:a96e08f29f39bbbfc84101739e7a23c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40ab5352dfd30bc5e42f9aff17a70dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#af40ab5352dfd30bc5e42f9aff17a70dc">GetMaterialIndex</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af40ab5352dfd30bc5e42f9aff17a70dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">参照する <a class="el" href="classnn_1_1g3d_1_1_res_material.html" title="マテリアルのリソースです。 ">ResMaterial</a> へのインデックスを取得します。  <a href="#af40ab5352dfd30bc5e42f9aff17a70dc">[詳解]</a><br /></td></tr>
<tr class="separator:af40ab5352dfd30bc5e42f9aff17a70dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2779416450c45a319b2c7bc2abfa5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a4e2779416450c45a319b2c7bc2abfa5a">GetBoneIndex</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4e2779416450c45a319b2c7bc2abfa5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">参照する <a class="el" href="classnn_1_1g3d_1_1_res_bone.html" title="ボーンのリソースです。 ">ResBone</a> へのインデックスを取得します。  <a href="#a4e2779416450c45a319b2c7bc2abfa5a">[詳解]</a><br /></td></tr>
<tr class="separator:a4e2779416450c45a319b2c7bc2abfa5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff949952a39b416c12e09018666f555"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a9ff949952a39b416c12e09018666f555">GetVertexIndex</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9ff949952a39b416c12e09018666f555"><td class="mdescLeft">&#160;</td><td class="mdescRight">参照する <a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="頂点情報のリソースです。 ">ResVertex</a> へのインデックスを取得します。  <a href="#a9ff949952a39b416c12e09018666f555">[詳解]</a><br /></td></tr>
<tr class="separator:a9ff949952a39b416c12e09018666f555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75f67b6366474039749b9e4106780ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ac75f67b6366474039749b9e4106780ba">GetVertexSkinCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac75f67b6366474039749b9e4106780ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">スムーススキニングに必要なボーン数を取得します。  <a href="#ac75f67b6366474039749b9e4106780ba">[詳解]</a><br /></td></tr>
<tr class="separator:ac75f67b6366474039749b9e4106780ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94497b52f362ce706ce19d95e83621e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a94497b52f362ce706ce19d95e83621e6">IsRigidBody</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a94497b52f362ce706ce19d95e83621e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">剛体のシェイプかどうかを取得します。  <a href="#a94497b52f362ce706ce19d95e83621e6">[詳解]</a><br /></td></tr>
<tr class="separator:a94497b52f362ce706ce19d95e83621e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7df9878fca8f101db113b28eed9b272"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ab7df9878fca8f101db113b28eed9b272">IsRigidSkinning</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab7df9878fca8f101db113b28eed9b272"><td class="mdescLeft">&#160;</td><td class="mdescRight">リジッドスキニングのシェイプかどうかを取得します。  <a href="#ab7df9878fca8f101db113b28eed9b272">[詳解]</a><br /></td></tr>
<tr class="separator:ab7df9878fca8f101db113b28eed9b272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca46c9cc157f944073e1a20cb720f99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a0ca46c9cc157f944073e1a20cb720f99">IsSmoothSkinning</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0ca46c9cc157f944073e1a20cb720f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">スムーススキニングのシェイプかどうかを取得します。  <a href="#a0ca46c9cc157f944073e1a20cb720f99">[詳解]</a><br /></td></tr>
<tr class="separator:a0ca46c9cc157f944073e1a20cb720f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4250dd1621b8717ab126aa3d43a18fa8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_mesh.html">ResMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a4250dd1621b8717ab126aa3d43a18fa8">GetResMesh</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a4250dd1621b8717ab126aa3d43a18fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッシュを取得します。  <a href="#a4250dd1621b8717ab126aa3d43a18fa8">[詳解]</a><br /></td></tr>
<tr class="separator:a4250dd1621b8717ab126aa3d43a18fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193348f627beda4bfa8a47cc2980f12d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_mesh.html">ResMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a193348f627beda4bfa8a47cc2980f12d">GetResMesh</a> (int meshIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a193348f627beda4bfa8a47cc2980f12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッシュを取得します。  <a href="#a193348f627beda4bfa8a47cc2980f12d">[詳解]</a><br /></td></tr>
<tr class="separator:a193348f627beda4bfa8a47cc2980f12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3880bc46da44ec036bedb940b5b3d5d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#af3880bc46da44ec036bedb940b5b3d5d">GetMeshCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af3880bc46da44ec036bedb940b5b3d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッシュの数を取得します。  <a href="#af3880bc46da44ec036bedb940b5b3d5d">[詳解]</a><br /></td></tr>
<tr class="separator:af3880bc46da44ec036bedb940b5b3d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9932dc0d155a493eaa6d4abd18970fa0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a9932dc0d155a493eaa6d4abd18970fa0">GetViewCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9932dc0d155a493eaa6d4abd18970fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">ビューの数を取得します。  <a href="#a9932dc0d155a493eaa6d4abd18970fa0">[詳解]</a><br /></td></tr>
<tr class="separator:a9932dc0d155a493eaa6d4abd18970fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07131b7bd1633a73acff2b021ebd45a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a07131b7bd1633a73acff2b021ebd45a7">GetSubMeshCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a07131b7bd1633a73acff2b021ebd45a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">サブメッシュの数を取得します。  <a href="#a07131b7bd1633a73acff2b021ebd45a7">[詳解]</a><br /></td></tr>
<tr class="separator:a07131b7bd1633a73acff2b021ebd45a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6072233b7f32e07f3fdbeda866258c40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a6072233b7f32e07f3fdbeda866258c40">GetSubMeshCount</a> (int meshIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6072233b7f32e07f3fdbeda866258c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定したメッシュのサブメッシュの数を取得します。  <a href="#a6072233b7f32e07f3fdbeda866258c40">[詳解]</a><br /></td></tr>
<tr class="separator:a6072233b7f32e07f3fdbeda866258c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db7c7b7e7b3be79c4a06722bf2c7bcd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a5db7c7b7e7b3be79c4a06722bf2c7bcd">IsViewDependent</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5db7c7b7e7b3be79c4a06722bf2c7bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">シェイプがビューに依存するかどうかを取得します。  <a href="#a5db7c7b7e7b3be79c4a06722bf2c7bcd">[詳解]</a><br /></td></tr>
<tr class="separator:a5db7c7b7e7b3be79c4a06722bf2c7bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962fd9c318f3763a92bf3549a2396c4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a962fd9c318f3763a92bf3549a2396c4e">GetShapeBlockCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a962fd9c318f3763a92bf3549a2396c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">シェイプ単位のユニフォームブロックの数を取得します。  <a href="#a962fd9c318f3763a92bf3549a2396c4e">[詳解]</a><br /></td></tr>
<tr class="separator:a962fd9c318f3763a92bf3549a2396c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90eb0caf66948a4bab1ab07bc0eae384"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a90eb0caf66948a4bab1ab07bc0eae384">GetShapeBlock</a> (int viewIndex, int bufferIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a90eb0caf66948a4bab1ab07bc0eae384"><td class="mdescLeft">&#160;</td><td class="mdescRight">シェイプ単位のユニフォームブロックのバッファーを取得します。  <a href="#a90eb0caf66948a4bab1ab07bc0eae384">[詳解]</a><br /></td></tr>
<tr class="separator:a90eb0caf66948a4bab1ab07bc0eae384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f887028ec44b37b074a8ead5256c298"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a0f887028ec44b37b074a8ead5256c298">GetShapeBlock</a> (int viewIndex, int bufferIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a0f887028ec44b37b074a8ead5256c298"><td class="mdescLeft">&#160;</td><td class="mdescRight">シェイプ単位のユニフォームブロックのバッファーを取得します。  <a href="#a0f887028ec44b37b074a8ead5256c298">[詳解]</a><br /></td></tr>
<tr class="separator:a0f887028ec44b37b074a8ead5256c298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661802cb989edfb1f765e53a9ada92f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a661802cb989edfb1f765e53a9ada92f1">GetBufferingCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a661802cb989edfb1f765e53a9ada92f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユニフォームブロックのバッファーリング数を取得します。  <a href="#a661802cb989edfb1f765e53a9ada92f1">[詳解]</a><br /></td></tr>
<tr class="separator:a661802cb989edfb1f765e53a9ada92f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a96b326ce84b4dc7867b09a3c2fad1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a59a96b326ce84b4dc7867b09a3c2fad1">IsBlockSwapEnabled</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a59a96b326ce84b4dc7867b09a3c2fad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユニフォームブロックのエンディアンスワップを行うかどうかを取得します。  <a href="#a59a96b326ce84b4dc7867b09a3c2fad1">[詳解]</a><br /></td></tr>
<tr class="separator:a59a96b326ce84b4dc7867b09a3c2fad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035541674c664057eb66b958c3d763cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a035541674c664057eb66b958c3d763cf">SetUserPtr</a> (void *pUserPtr) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a035541674c664057eb66b958c3d763cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザーポインターを設定します。  <a href="#a035541674c664057eb66b958c3d763cf">[詳解]</a><br /></td></tr>
<tr class="separator:a035541674c664057eb66b958c3d763cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53aeee059d9dc6b38482bb4f4cc2eb9a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a53aeee059d9dc6b38482bb4f4cc2eb9a">GetUserPtr</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a53aeee059d9dc6b38482bb4f4cc2eb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザーポインターを取得します。  <a href="#a53aeee059d9dc6b38482bb4f4cc2eb9a">[詳解]</a><br /></td></tr>
<tr class="separator:a53aeee059d9dc6b38482bb4f4cc2eb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205405441aa99765f735d51f82e0d205"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a205405441aa99765f735d51f82e0d205">GetUserPtr</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a205405441aa99765f735d51f82e0d205"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザーポインターを取得します。  <a href="#a205405441aa99765f735d51f82e0d205">[詳解]</a><br /></td></tr>
<tr class="separator:a205405441aa99765f735d51f82e0d205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81206653da41f37c6b924f4f3fcd2bb5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a81206653da41f37c6b924f4f3fcd2bb5"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a81206653da41f37c6b924f4f3fcd2bb5">GetUserPtr</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a81206653da41f37c6b924f4f3fcd2bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザーポインターを取得します。  <a href="#a81206653da41f37c6b924f4f3fcd2bb5">[詳解]</a><br /></td></tr>
<tr class="separator:a81206653da41f37c6b924f4f3fcd2bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1680667038c121f969470d162d933af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1680667038c121f969470d162d933af"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#af1680667038c121f969470d162d933af">GetUserPtr</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af1680667038c121f969470d162d933af"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザーポインターを取得します。  <a href="#af1680667038c121f969470d162d933af">[詳解]</a><br /></td></tr>
<tr class="separator:af1680667038c121f969470d162d933af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cbc2ed0a34709b6ec841559e92abb0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a13cbc2ed0a34709b6ec841559e92abb0">GetName</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a13cbc2ed0a34709b6ec841559e92abb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">シェイプ名を取得します。  <a href="#a13cbc2ed0a34709b6ec841559e92abb0">[詳解]</a><br /></td></tr>
<tr class="separator:a13cbc2ed0a34709b6ec841559e92abb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366192ea48975363a42b6793469b484c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a366192ea48975363a42b6793469b484c">GetUserArea</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a366192ea48975363a42b6793469b484c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザーエリアへのポインターを取得します。  <a href="#a366192ea48975363a42b6793469b484c">[詳解]</a><br /></td></tr>
<tr class="separator:a366192ea48975363a42b6793469b484c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af057a8b378cb6d7ee94a8b95c545fcb4"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#af057a8b378cb6d7ee94a8b95c545fcb4">GetUserArea</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af057a8b378cb6d7ee94a8b95c545fcb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザーエリアへのポインターを取得します。  <a href="#af057a8b378cb6d7ee94a8b95c545fcb4">[詳解]</a><br /></td></tr>
<tr class="separator:af057a8b378cb6d7ee94a8b95c545fcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadace6bf4ef3fd23b28664052981a336"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aadace6bf4ef3fd23b28664052981a336"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#aadace6bf4ef3fd23b28664052981a336">GetUserArea</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aadace6bf4ef3fd23b28664052981a336"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザーエリアへのポインターを取得します。  <a href="#aadace6bf4ef3fd23b28664052981a336">[詳解]</a><br /></td></tr>
<tr class="separator:aadace6bf4ef3fd23b28664052981a336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5d31af5f0d71847aaca41377ba1212"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc5d31af5f0d71847aaca41377ba1212"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#acc5d31af5f0d71847aaca41377ba1212">GetUserArea</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acc5d31af5f0d71847aaca41377ba1212"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザーエリアへのポインターを取得します。  <a href="#acc5d31af5f0d71847aaca41377ba1212">[詳解]</a><br /></td></tr>
<tr class="separator:acc5d31af5f0d71847aaca41377ba1212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67c5f9f13e2158953143b56433cae26"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ab67c5f9f13e2158953143b56433cae26">GetUserAreaSize</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab67c5f9f13e2158953143b56433cae26"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユーザーエリアのサイズを取得します。  <a href="#ab67c5f9f13e2158953143b56433cae26">[詳解]</a><br /></td></tr>
<tr class="separator:ab67c5f9f13e2158953143b56433cae26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">頂点情報</div></td></tr>
<tr class="memitem:acd76605a682a3ca3676ab91d6fe62c24"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_vertex.html">ResVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#acd76605a682a3ca3676ab91d6fe62c24">GetResVertex</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:acd76605a682a3ca3676ab91d6fe62c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">参照する <a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="頂点情報のリソースです。 ">ResVertex</a> を取得します。  <a href="#acd76605a682a3ca3676ab91d6fe62c24">[詳解]</a><br /></td></tr>
<tr class="separator:acd76605a682a3ca3676ab91d6fe62c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987abf75f6288206255df95bbd891cde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a987abf75f6288206255df95bbd891cde">GetVertexAttrCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a987abf75f6288206255df95bbd891cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">参照する <a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="頂点情報のリソースです。 ">ResVertex</a> の頂点属性の数を取得します。  <a href="#a987abf75f6288206255df95bbd891cde">[詳解]</a><br /></td></tr>
<tr class="separator:a987abf75f6288206255df95bbd891cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae44347c36040e406258524943d95d40"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_vertex_attr.html">ResVertexAttr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#aae44347c36040e406258524943d95d40">GetResVertexAttr</a> (int attrIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aae44347c36040e406258524943d95d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">インデックス引きで頂点属性を取得します。  <a href="#aae44347c36040e406258524943d95d40">[詳解]</a><br /></td></tr>
<tr class="separator:aae44347c36040e406258524943d95d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7115a44dc383289e8887b4c20c00313"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_vertex_attr.html">ResVertexAttr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#aa7115a44dc383289e8887b4c20c00313">FindResVertexAttr</a> (const char *name) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa7115a44dc383289e8887b4c20c00313"><td class="mdescLeft">&#160;</td><td class="mdescRight">名前引きで頂点属性を取得します。  <a href="#aa7115a44dc383289e8887b4c20c00313">[詳解]</a><br /></td></tr>
<tr class="separator:aa7115a44dc383289e8887b4c20c00313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065d7bd66a8484c0a818e6fa6dac7b8f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a065d7bd66a8484c0a818e6fa6dac7b8f">GetVertexAttrName</a> (int attribIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a065d7bd66a8484c0a818e6fa6dac7b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">インデックスから頂点属性名を取得します。  <a href="#a065d7bd66a8484c0a818e6fa6dac7b8f">[詳解]</a><br /></td></tr>
<tr class="separator:a065d7bd66a8484c0a818e6fa6dac7b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d864c5b51adbbe0f8ac2568c1052240"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a2d864c5b51adbbe0f8ac2568c1052240">FindVertexAttrIndex</a> (const char *name) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2d864c5b51adbbe0f8ac2568c1052240"><td class="mdescLeft">&#160;</td><td class="mdescRight">頂点属性名からインデックスを取得します。  <a href="#a2d864c5b51adbbe0f8ac2568c1052240">[詳解]</a><br /></td></tr>
<tr class="separator:a2d864c5b51adbbe0f8ac2568c1052240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bfb2f1f02e9f47bf4a8796194c08e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a38bfb2f1f02e9f47bf4a8796194c08e8">GetVertexBufferCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a38bfb2f1f02e9f47bf4a8796194c08e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">参照する <a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="頂点情報のリソースです。 ">ResVertex</a> の頂点バッファーの数を取得します。  <a href="#a38bfb2f1f02e9f47bf4a8796194c08e8">[詳解]</a><br /></td></tr>
<tr class="separator:a38bfb2f1f02e9f47bf4a8796194c08e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c79150775d457e82c04d5ba635ef7c5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a1c79150775d457e82c04d5ba635ef7c5">GetVertexBuffer</a> (int bufferIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1c79150775d457e82c04d5ba635ef7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">インデックスから頂点バッファーを取得します。  <a href="#a1c79150775d457e82c04d5ba635ef7c5">[詳解]</a><br /></td></tr>
<tr class="separator:a1c79150775d457e82c04d5ba635ef7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">バウンディング</div></td></tr>
<tr class="memitem:a311a863e4d0810ddffa988344af47974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1g3d_1_1_sphere.html">Sphere</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a311a863e4d0810ddffa988344af47974">GetBounding</a> () <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a311a863e4d0810ddffa988344af47974"><td class="mdescLeft">&#160;</td><td class="mdescRight">ワールド座標系におけるシェイプのバウンディング球を取得します。  <a href="#a311a863e4d0810ddffa988344af47974">[詳解]</a><br /></td></tr>
<tr class="separator:a311a863e4d0810ddffa988344af47974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2ab901b61469513d334f5a6d29d535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnn_1_1g3d_1_1_sphere.html">Sphere</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a1b2ab901b61469513d334f5a6d29d535">GetBounding</a> (int meshIndex) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1b2ab901b61469513d334f5a6d29d535"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定したメッシュのワールド座標系におけるバウンディング球を取得します。  <a href="#a1b2ab901b61469513d334f5a6d29d535">[詳解]</a><br /></td></tr>
<tr class="separator:a1b2ab901b61469513d334f5a6d29d535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35c8f2e29190cfc6012aad9c671edf3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structnn_1_1g3d_1_1_sphere.html">Sphere</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ad35c8f2e29190cfc6012aad9c671edf3">GetBounding</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad35c8f2e29190cfc6012aad9c671edf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">ワールド座標系におけるシェイプのバウンディング球を取得します。  <a href="#ad35c8f2e29190cfc6012aad9c671edf3">[詳解]</a><br /></td></tr>
<tr class="separator:ad35c8f2e29190cfc6012aad9c671edf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d123d46ed75284aec03f721b9d7b45"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structnn_1_1g3d_1_1_sphere.html">Sphere</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#aa7d123d46ed75284aec03f721b9d7b45">GetBounding</a> (int meshIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa7d123d46ed75284aec03f721b9d7b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定したメッシュのワールド座標系におけるバウンディング球を取得します。  <a href="#aa7d123d46ed75284aec03f721b9d7b45">[詳解]</a><br /></td></tr>
<tr class="separator:aa7d123d46ed75284aec03f721b9d7b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584937fcde20904ba97d7df31366f0d0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structnn_1_1g3d_1_1_aabb.html">Aabb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a584937fcde20904ba97d7df31366f0d0">GetSubMeshBoundingArray</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a584937fcde20904ba97d7df31366f0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">ワールド座標系におけるサブメッシュの AABB 配列を取得します。  <a href="#a584937fcde20904ba97d7df31366f0d0">[詳解]</a><br /></td></tr>
<tr class="separator:a584937fcde20904ba97d7df31366f0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309a21916d5b1921a5106bce6c872b9f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structnn_1_1g3d_1_1_aabb.html">Aabb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a309a21916d5b1921a5106bce6c872b9f">GetSubMeshBoundingArray</a> (int meshIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a309a21916d5b1921a5106bce6c872b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ワールド座標系における指定したメッシュのサブメッシュの AABB 配列を取得します。  <a href="#a309a21916d5b1921a5106bce6c872b9f">[詳解]</a><br /></td></tr>
<tr class="separator:a309a21916d5b1921a5106bce6c872b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c0526e70aef8f5ac9512196c1f5d14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a25c0526e70aef8f5ac9512196c1f5d14">TestSubMeshIntersection</a> (<a class="el" href="structnn_1_1g3d_1_1_culling_context.html">CullingContext</a> *pCtx, const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;volume) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a25c0526e70aef8f5ac9512196c1f5d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">ビューボリュームと交差する連続したサブメッシュを取得します。  <a href="#a25c0526e70aef8f5ac9512196c1f5d14">[詳解]</a><br /></td></tr>
<tr class="separator:a25c0526e70aef8f5ac9512196c1f5d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc539bbe698f6a400f2e9f4fb1daeaea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#afc539bbe698f6a400f2e9f4fb1daeaea">TestSubMeshIntersection</a> (<a class="el" href="structnn_1_1g3d_1_1_culling_context.html">CullingContext</a> *pCtx, const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;volume, int meshIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:afc539bbe698f6a400f2e9f4fb1daeaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定したメッシュにおけるビューボリュームと交差する連続したサブメッシュを取得します。  <a href="#afc539bbe698f6a400f2e9f4fb1daeaea">[詳解]</a><br /></td></tr>
<tr class="separator:afc539bbe698f6a400f2e9f4fb1daeaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64775081aa11a283658bfef401c7694"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ab64775081aa11a283658bfef401c7694">TestSubMeshLodIntersection</a> (<a class="el" href="structnn_1_1g3d_1_1_culling_context.html">CullingContext</a> *pCtx, const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;volume, <a class="el" href="structnn_1_1g3d_1_1_i_calculate_lod_level_functor.html">ICalculateLodLevelFunctor</a> &amp;calcLodFunctor) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab64775081aa11a283658bfef401c7694"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>内部用機能のため使用禁止です。</b> ビューボリュームと交差する LOD レベルの等しい連続したサブメッシュを取得します。  <a href="#ab64775081aa11a283658bfef401c7694">[詳解]</a><br /></td></tr>
<tr class="separator:ab64775081aa11a283658bfef401c7694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7a151dcaf87f835b29b9e09404c21c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a2c7a151dcaf87f835b29b9e09404c21c">MakeSubMeshRange</a> (<a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html">SubMeshRange</a> *pRangeArray, const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;volume) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a2c7a151dcaf87f835b29b9e09404c21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ビューボリュームと交差する連続したサブメッシュの範囲配列を取得します。  <a href="#a2c7a151dcaf87f835b29b9e09404c21c">[詳解]</a><br /></td></tr>
<tr class="separator:a2c7a151dcaf87f835b29b9e09404c21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9151525ed04761e24e47ac9370c8db96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a9151525ed04761e24e47ac9370c8db96">MakeSubMeshRange</a> (<a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html">SubMeshRange</a> *pRangeArray, const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;volume, int meshIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9151525ed04761e24e47ac9370c8db96"><td class="mdescLeft">&#160;</td><td class="mdescRight">メッシュのインデックスを指定して、ビューボリュームと交差する連続したサブメッシュの範囲配列を取得します。  <a href="#a9151525ed04761e24e47ac9370c8db96">[詳解]</a><br /></td></tr>
<tr class="separator:a9151525ed04761e24e47ac9370c8db96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc83b0a0933cef444306411994a2720b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#adc83b0a0933cef444306411994a2720b">MakeSubMeshLodRange</a> (<a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html">SubMeshRange</a> *pRangeArray, const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;volume, <a class="el" href="structnn_1_1g3d_1_1_i_calculate_lod_level_functor.html">ICalculateLodLevelFunctor</a> &amp;calcLodFunctor) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:adc83b0a0933cef444306411994a2720b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>内部用機能のため使用禁止です。</b> ビューボリュームと交差する LOD レベルの等しい連続したサブメッシュの範囲配列を取得します。  <a href="#adc83b0a0933cef444306411994a2720b">[詳解]</a><br /></td></tr>
<tr class="separator:adc83b0a0933cef444306411994a2720b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">キーシェイプ</div></td></tr>
<tr class="memitem:a7b0e8fd440a0a3a99cf4fc71793f9484"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a7b0e8fd440a0a3a99cf4fc71793f9484">GetKeyShapeCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a7b0e8fd440a0a3a99cf4fc71793f9484"><td class="mdescLeft">&#160;</td><td class="mdescRight">キーシェイプの数を取得します。  <a href="#a7b0e8fd440a0a3a99cf4fc71793f9484">[詳解]</a><br /></td></tr>
<tr class="separator:a7b0e8fd440a0a3a99cf4fc71793f9484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae682c5ed1aee0a94d64c85aae80daf0f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_key_shape.html">ResKeyShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ae682c5ed1aee0a94d64c85aae80daf0f">GetResKeyShape</a> (int keyShapeIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae682c5ed1aee0a94d64c85aae80daf0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">インデックス引きでキーシェイプを取得します。  <a href="#ae682c5ed1aee0a94d64c85aae80daf0f">[詳解]</a><br /></td></tr>
<tr class="separator:ae682c5ed1aee0a94d64c85aae80daf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d6937bdfdb9d9374bcb8b48cccd07f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnn_1_1g3d_1_1_res_key_shape.html">ResKeyShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ac7d6937bdfdb9d9374bcb8b48cccd07f">FindResKeyShape</a> (const char *name) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac7d6937bdfdb9d9374bcb8b48cccd07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">名前引きでキーシェイプを取得します。  <a href="#ac7d6937bdfdb9d9374bcb8b48cccd07f">[詳解]</a><br /></td></tr>
<tr class="separator:ac7d6937bdfdb9d9374bcb8b48cccd07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89891c755056ab332f0b1cdcf6bb3190"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a89891c755056ab332f0b1cdcf6bb3190">GetKeyShapeName</a> (int keyShapeIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a89891c755056ab332f0b1cdcf6bb3190"><td class="mdescLeft">&#160;</td><td class="mdescRight">インデックスからキーシェイプ名を取得します。  <a href="#a89891c755056ab332f0b1cdcf6bb3190">[詳解]</a><br /></td></tr>
<tr class="separator:a89891c755056ab332f0b1cdcf6bb3190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850c286d793fca69dea82b4d15612fca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a850c286d793fca69dea82b4d15612fca">FindKeyShapeIndex</a> (const char *name) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a850c286d793fca69dea82b4d15612fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">キーシェイプの名前からインデックスを取得します。  <a href="#a850c286d793fca69dea82b4d15612fca">[詳解]</a><br /></td></tr>
<tr class="separator:a850c286d793fca69dea82b4d15612fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30fa8adfe8b77687b7f416d9026757e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ac30fa8adfe8b77687b7f416d9026757e">GetTargetAttribCount</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac30fa8adfe8b77687b7f416d9026757e"><td class="mdescLeft">&#160;</td><td class="mdescRight">キーシェイプが持つ頂点属性の数を取得します。  <a href="#ac30fa8adfe8b77687b7f416d9026757e">[詳解]</a><br /></td></tr>
<tr class="separator:ac30fa8adfe8b77687b7f416d9026757e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37b9ec279a4bf687b512dde43670b95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab37b9ec279a4bf687b512dde43670b95"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ab37b9ec279a4bf687b512dde43670b95">ClearBlendWeights</a> ()</td></tr>
<tr class="memdesc:ab37b9ec279a4bf687b512dde43670b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">キーシェイプのブレンドウェイトを初期化します。 <br /></td></tr>
<tr class="separator:ab37b9ec279a4bf687b512dde43670b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69625ebe1a4a5920e0cc48cf02be2d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ab69625ebe1a4a5920e0cc48cf02be2d7">HasValidBlendWeight</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab69625ebe1a4a5920e0cc48cf02be2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">有効なキーシェイプのブレンドウェイトをもつかどうかを取得します。  <a href="#ab69625ebe1a4a5920e0cc48cf02be2d7">[詳解]</a><br /></td></tr>
<tr class="separator:ab69625ebe1a4a5920e0cc48cf02be2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0aadad1cc0cc4ed59b0777886932936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#af0aadad1cc0cc4ed59b0777886932936">SetBlendWeight</a> (int keyShapeIndex, float weight) <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af0aadad1cc0cc4ed59b0777886932936"><td class="mdescLeft">&#160;</td><td class="mdescRight">キーシェイプのブレンドウェイトを設定します。  <a href="#af0aadad1cc0cc4ed59b0777886932936">[詳解]</a><br /></td></tr>
<tr class="separator:af0aadad1cc0cc4ed59b0777886932936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e4e6ea528f00f34f5c6a2913a435d9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a60e4e6ea528f00f34f5c6a2913a435d9">GetBlendWeight</a> (int keyShapeIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a60e4e6ea528f00f34f5c6a2913a435d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">キーシェイプのブレンドウェイトを取得します。  <a href="#a60e4e6ea528f00f34f5c6a2913a435d9">[詳解]</a><br /></td></tr>
<tr class="separator:a60e4e6ea528f00f34f5c6a2913a435d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f338c38b6c82c09d6aa85edc5b47d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#af0f338c38b6c82c09d6aa85edc5b47d2">IsBlendWeightValid</a> (int keyShapeIndex) const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:af0f338c38b6c82c09d6aa85edc5b47d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">キーシェイプのブレンドウェイトが有効かどうかを取得します。  <a href="#af0f338c38b6c82c09d6aa85edc5b47d2">[詳解]</a><br /></td></tr>
<tr class="separator:af0f338c38b6c82c09d6aa85edc5b47d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622d803b4f893d861e563fa1ef70f2ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a622d803b4f893d861e563fa1ef70f2ff">CountValidBlendWeight</a> () const <a class="el" href="nn___macro_8h.html#a0e31cc4dc24d85253a31e48b1a85ab33">NN_NOEXCEPT</a></td></tr>
<tr class="memdesc:a622d803b4f893d861e563fa1ef70f2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">有効なキーシェイプのブレンドウェイトを数えます。  <a href="#a622d803b4f893d861e563fa1ef70f2ff">[詳解]</a><br /></td></tr>
<tr class="separator:a622d803b4f893d861e563fa1ef70f2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
限定公開型</h2></td></tr>
<tr class="memitem:ade842941f47fbbe74a09e389491a4089"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ade842941f47fbbe74a09e389491a4089">Flag</a> { <br />
&#160;&#160;<a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ade842941f47fbbe74a09e389491a4089aa030233056f81a0e7a8d7d6b20f4eb34">Flag_BlockBufferValid</a> = 0x1 &lt;&lt; 0, 
<br />
&#160;&#160;<a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ade842941f47fbbe74a09e389491a4089ac2c408f15f62b0af48bb38c5054ab1b6">Flag_BlendWeightValid</a> = 0x1 &lt;&lt; 1
<br />
 }<tr class="memdesc:ade842941f47fbbe74a09e389491a4089"><td class="mdescLeft">&#160;</td><td class="mdescRight">シェイプの状態を表すフラグです。  <a href="classnn_1_1g3d_1_1_shape_obj.html#ade842941f47fbbe74a09e389491a4089">[詳解]</a><br /></td></tr>
<tr class="separator:ade842941f47fbbe74a09e389491a4089"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p>シェイプインスタンスです。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_shape_animation_8cpp-example.html#_a6">ShapeAnimation.cpp</a>, <a class="el" href="_town_8cpp-example.html#_a78">Town.cpp</a>.</dd>
</dl></div><h2 class="groupheader">列挙型メンバ詳解</h2>
<a class="anchor" id="a324377c158258439ceb8d5c2573d8bb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a324377c158258439ceb8d5c2573d8bb8">nn::g3d::ShapeObj::Alignment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>インスタンスの構築時に渡すバッファーの必要アライメントサイズです。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="a324377c158258439ceb8d5c2573d8bb8a6083dd58eaffe3866fecd81fb437a0b9"></a>Alignment_Buffer&#160;</td><td class="fielddoc">
<p><a class="el" href="classnn_1_1g3d_1_1_shape_obj_1_1_builder.html" title="ShapeObj の構築を行うクラスです。 ">Builder</a> に渡すバッファーの必要アライメントサイズです。 </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ade842941f47fbbe74a09e389491a4089"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ade842941f47fbbe74a09e389491a4089">nn::g3d::ShapeObj::Flag</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>シェイプの状態を表すフラグです。 </p>
<table class="fieldtable">
<tr><th colspan="2">列挙値</th></tr><tr><td class="fieldname"><a class="anchor" id="ade842941f47fbbe74a09e389491a4089aa030233056f81a0e7a8d7d6b20f4eb34"></a>Flag_BlockBufferValid&#160;</td><td class="fielddoc">
<p><b>内部用機能のため使用禁止です。</b> ユニフォームブロックが構築済みであるかどうかを表すフラグです。 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ade842941f47fbbe74a09e389491a4089ac2c408f15f62b0af48bb38c5054ab1b6"></a>Flag_BlendWeightValid&#160;</td><td class="fielddoc">
<p><b>内部用機能のため使用禁止です。</b> キーシェイプのブレンドウェイトが変更されたかどうかを表すフラグです。 </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">構築子と解体子</h2>
<a class="anchor" id="af6d03e27a48f193a0aaafa2380c13919"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nn::g3d::ShapeObj::ShapeObj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンストラクタです。 </p>
<p>実際の構築処理は <a class="el" href="classnn_1_1g3d_1_1_shape_obj_1_1_builder.html" title="ShapeObj の構築を行うクラスです。 ">Builder</a> で行います。 </p>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a class="anchor" id="a0ba82136231db018f912733940a36dc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::g3d::ShapeObj::CalculateBlockBufferSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユニフォームブロックのサイズを計算します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>計算したバッファーサイズを返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a7cabdabea5964ffbfb204dd0e4bd5bf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::SetupBlockBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">nn::gfx::MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pMemoryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memoryPoolSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メモリプールを渡して、ユニフォームブロックを構築します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDevice</td><td>デバイスへのポインター。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMemoryPool</td><td>メモリプールへのポインター。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>メモリプールの使用する領域へのオフセット。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memoryPoolSize</td><td>offset以降で使用可能なメモリプールのサイズ。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>構築に成功した場合は true、失敗した場合は false を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>pDevice が初期化されている。</li>
<li>pMemoryPool が初期化されている。</li>
<li>offset で指されたメモリプールの位置が <a class="el" href="classnn_1_1gfx_1_1_t_buffer.html#a99b1cd500e55e26460655d68eee13842" title="バッファーに要求されるアライメントを取得します。 ">nn::gfx::Buffer::GetBufferAlignment()</a> のアラインメント上にある。</li>
<li>memoryPoolSize は <a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a0ba82136231db018f912733940a36dc4" title="ユニフォームブロックのサイズを計算します。 ">CalculateBlockBufferSize()</a> 以上である。</li>
<li>ユニフォームブロックが未構築である。</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>ユニフォームブロックが構築されている </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a62907045e2b301d7f347752106eec7af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::CleanupBlockBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユニフォームブロックを破棄します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDevice</td><td>デバイスへのポインター</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>pDevice が初期化されている。</li>
<li>ユニフォームブロックが構築済みである。</li>
</ul>
</dd></dl>
<dl class="section post"><dt>事後条件</dt><dd><ul>
<li>ユニフォームブロックが破棄されている。 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="afa580dfcb0fac318789e05bf22ab949c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::CalculateBounding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html">SkeletonObj</a> *&#160;</td>
          <td class="paramname"><em>pSkeleton</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッシュ0 のバウンディング球を計算します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSkeleton</td><td>SkeletonObjへのポインター。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>構築時にバウンディング計算を有効にしている。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
前提条件を満たさない場合、この関数は何も行いません。 </p>

</div>
</div>
<a class="anchor" id="a3e1a0c59dab38304e64db8d6831ce75d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::CalculateBounding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html">SkeletonObj</a> *&#160;</td>
          <td class="paramname"><em>pSkeleton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定したメッシュのバウンディング球を計算します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSkeleton</td><td>SkeletonObjへのポインター。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshIndex</td><td>メッシュのインデックス。 LOD レベルを指定します。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>構築時にバウンディング計算を有効にしている。</li>
<li>インデックスはメッシュの数の範囲内。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
前提条件を満たさない場合、この関数は何も行いません。 </p>

</div>
</div>
<a class="anchor" id="ad3875fc401453548f6e5fdf3928abdee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::CalculateSubMeshBounding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html">SkeletonObj</a> *&#160;</td>
          <td class="paramname"><em>pSkeleton</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッシュ 0 のサブメッシュのバウンディングボックスを計算します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSkeleton</td><td>SkeletonObjへのポインター。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>構築時にバウンディング計算を有効にしている。</li>
<li>剛体である。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
前提条件を満たさない場合、この関数は何も行いません。 </p>

</div>
</div>
<a class="anchor" id="a5d4ed8a8cbc3c3e702b1f1b20d2a5536"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::CalculateSubMeshBounding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnn_1_1g3d_1_1_skeleton_obj.html">SkeletonObj</a> *&#160;</td>
          <td class="paramname"><em>pSkeleton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定したメッシュのサブメッシュのバウンディングボックスを計算します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSkeleton</td><td>SkeletonObjへのポインター。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshIndex</td><td>メッシュのインデックス。 LOD レベルを指定します。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>構築時にバウンディング計算を有効にしている。</li>
<li>剛体である。</li>
<li>インデックスはメッシュの数の範囲内。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
前提条件を満たさない場合、この関数は何も行いません。 </p>

</div>
</div>
<a class="anchor" id="ac9b2fc3bb7e76ccac3700abfa9bd5ab8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::CalculateShape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenn_1_1util.html#afb360b0e9579454c6af5804cc476c101">nn::util::Matrix4x3fType</a> &amp;&#160;</td>
          <td class="paramname"><em>worldMtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>シェイプに関する描画リソースを計算します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">viewIndex</td><td>計算を反映させるビューのインデックス。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">worldMtx</td><td>ワールド変換行列。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferIndex</td><td>計算を反映させるユニフォームブロックのインデックス。</td></tr>
  </table>
  </dd>
</dl>
<p><b>詳細</b> <br />
GPU から参照されるバッファーを書き換えるため、 前回の描画で GPU が参照し終わった後に呼ぶ必要があります。 構築時のオプションでダブルバッファー化するか、 フレームバッファーのコピーアウト中などに呼ぶことを想定しています。 </p>

</div>
</div>
<a class="anchor" id="a8f7bc2a51ba63d4488ff2d6d7d5e0937"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::g3d::ShapeObj::GetBlockBufferAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a911efa3d8dce04d59a39b97d97079cd7">nn::gfx::Device</a> *&#160;</td>
          <td class="paramname"><em>pDevice</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユニフォームブロックが要求するアライメントを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>ユニフォームブロックが要求するアライメントを返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a877f7c0f4f853151966321c4b969c45b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_shape.html">ResShape</a>* nn::g3d::ShapeObj::GetResource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>リソースを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="classnn_1_1g3d_1_1_res_shape.html" title="シェイプのリソースです。 ">ResShape</a> へのポインターを返します。 </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_shape_animation_8cpp-example.html#a9">ShapeAnimation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a160c8f620f415ad2c3fcfcc0da86ea4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::g3d::ShapeObj::GetBufferPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classnn_1_1g3d_1_1_shape_obj_1_1_builder.html" title="ShapeObj の構築を行うクラスです。 ">Builder</a> でBuild() 時に渡されたバッファーを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="classnn_1_1g3d_1_1_shape_obj_1_1_builder.html" title="ShapeObj の構築を行うクラスです。 ">Builder</a> でBuild() 時に渡されたバッファーへのポインターを返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="ad1ca4b89b13c955925424be0dfeb79d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1gfx.html#ad620d8208dd309eb7c4dd5973a6aeee5">nn::gfx::MemoryPool</a>* nn::g3d::ShapeObj::GetMemoryPoolPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a7cabdabea5964ffbfb204dd0e4bd5bf1" title="メモリプールを渡して、ユニフォームブロックを構築します。 ">SetupBlockBuffer()</a> 時に渡されたメモリプールのポインターを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>メモリプールへのポインターを返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="ad133182bc588fb9fc2285cadd3423de0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t nn::g3d::ShapeObj::GetMemoryPoolOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a7cabdabea5964ffbfb204dd0e4bd5bf1" title="メモリプールを渡して、ユニフォームブロックを構築します。 ">SetupBlockBuffer()</a> 時に渡されたメモリプールのオフセットを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>メモリプールのオフセットを返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a96e08f29f39bbbfc84101739e7a23c02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::IsBlockBufferValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユニフォームブロックが構築済みであるかどうかを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>構築済みの場合は true、未構築の場合は false を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="af40ab5352dfd30bc5e42f9aff17a70dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetMaterialIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>参照する <a class="el" href="classnn_1_1g3d_1_1_res_material.html" title="マテリアルのリソースです。 ">ResMaterial</a> へのインデックスを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>参照する <a class="el" href="classnn_1_1g3d_1_1_res_material.html" title="マテリアルのリソースです。 ">ResMaterial</a> へのインデックスを返します。 </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_edit_8cpp-example.html#a65">Edit.cpp</a>, <a class="el" href="_town_8cpp-example.html#a171">Town.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a4e2779416450c45a319b2c7bc2abfa5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetBoneIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>参照する <a class="el" href="classnn_1_1g3d_1_1_res_bone.html" title="ボーンのリソースです。 ">ResBone</a> へのインデックスを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>参照する <a class="el" href="classnn_1_1g3d_1_1_res_bone.html" title="ボーンのリソースです。 ">ResBone</a> へのインデックスを返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a9ff949952a39b416c12e09018666f555"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetVertexIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>参照する <a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="頂点情報のリソースです。 ">ResVertex</a> へのインデックスを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>参照する <a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="頂点情報のリソースです。 ">ResVertex</a> へのインデックスを返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="ac75f67b6366474039749b9e4106780ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetVertexSkinCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>スムーススキニングに必要なボーン数を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>スムーススキニングに必要なボーン数を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a94497b52f362ce706ce19d95e83621e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::IsRigidBody </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>剛体のシェイプかどうかを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>剛体の場合は true、それ以外の場合は false を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="ab7df9878fca8f101db113b28eed9b272"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::IsRigidSkinning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>リジッドスキニングのシェイプかどうかを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>ジッドスキニングのシェイプの場合は true、それ以外の場合は false を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a0ca46c9cc157f944073e1a20cb720f99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::IsSmoothSkinning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>スムーススキニングのシェイプかどうかを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>スムーススキニングのシェイプの場合は true、それ以外の場合は false を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a4250dd1621b8717ab126aa3d43a18fa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_mesh.html">ResMesh</a>* nn::g3d::ShapeObj::GetResMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッシュを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="classnn_1_1g3d_1_1_res_mesh.html" title="メッシュのリソースです。インデックスバッファーを持ちます。 ">ResMesh</a> へのポインターを返します。 </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_town_8cpp-example.html#a81">Town.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a193348f627beda4bfa8a47cc2980f12d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_mesh.html">ResMesh</a>* nn::g3d::ShapeObj::GetResMesh </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッシュを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshIndex</td><td>メッシュのインデックス。 LOD レベルを指定します。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="classnn_1_1g3d_1_1_res_mesh.html" title="メッシュのリソースです。インデックスバッファーを持ちます。 ">ResMesh</a> のポインターを返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="af3880bc46da44ec036bedb940b5b3d5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetMeshCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッシュの数を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>メッシュの数を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a9932dc0d155a493eaa6d4abd18970fa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetViewCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ビューの数を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>ビューの数を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a07131b7bd1633a73acff2b021ebd45a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetSubMeshCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>サブメッシュの数を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>サブメッシュの数を返します。 </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_town_8cpp-example.html#a223">Town.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6072233b7f32e07f3fdbeda866258c40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetSubMeshCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定したメッシュのサブメッシュの数を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshIndex</td><td>メッシュのインデックス。 LOD レベルを指定します。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>サブメッシュの数を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a5db7c7b7e7b3be79c4a06722bf2c7bcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::IsViewDependent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>シェイプがビューに依存するかどうかを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>シェイプがビューに依存する場合は true、依存しない場合は false を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a962fd9c318f3763a92bf3549a2396c4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetShapeBlockCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>シェイプ単位のユニフォームブロックの数を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>シェイプ単位のユニフォームブロックの数を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a90eb0caf66948a4bab1ab07bc0eae384"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a>* nn::g3d::ShapeObj::GetShapeBlock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>シェイプ単位のユニフォームブロックのバッファーを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">viewIndex</td><td>ビューのインデックス。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferIndex</td><td>ユニフォームブロックのインデックス。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>nn::gfx::BufferView へのポインターを返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>viewIndex はマテリアルが持つビュー数の範囲内。</li>
<li>bufferIndex はマテリアルが持つバッファー数の範囲内。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
ビューごとに Build() 時に指定したバッファー数のユニフォームブロック用バッファーを持ちます。 ユニフォームブロックが未構築の場合、NULL を返します。 </p>

</div>
</div>
<a class="anchor" id="a0f887028ec44b37b074a8ead5256c298"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a>* nn::g3d::ShapeObj::GetShapeBlock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>シェイプ単位のユニフォームブロックのバッファーを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">viewIndex</td><td>ビューのインデックス。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferIndex</td><td>ユニフォームブロックのインデックス。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>nn::gfx::BufferView へのポインターを返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>viewIndex はマテリアルが持つビュー数の範囲内。</li>
<li>bufferIndex はマテリアルが持つバッファー数の範囲内。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
ビューごとに Build() 時に指定したバッファー数のユニフォームブロック用バッファーを持ちます。 ユニフォームブロックが未構築の場合、NULL を返します。 </p>

</div>
</div>
<a class="anchor" id="a661802cb989edfb1f765e53a9ada92f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetBufferingCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユニフォームブロックのバッファーリング数を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>ユニフォームブロックのバッファーリング数を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a59a96b326ce84b4dc7867b09a3c2fad1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::IsBlockSwapEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユニフォームブロックのエンディアンスワップを行うかどうかを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>ユニフォームブロックをスワップする場合は true、しない場合は false を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a035541674c664057eb66b958c3d763cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::SetUserPtr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユーザーポインターを設定します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUserPtr</td><td>ポインターを返します。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53aeee059d9dc6b38482bb4f4cc2eb9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::g3d::ShapeObj::GetUserPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユーザーポインターを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a035541674c664057eb66b958c3d763cf" title="ユーザーポインターを設定します。 ">SetUserPtr()</a> で設定したポインターを返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a205405441aa99765f735d51f82e0d205"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* nn::g3d::ShapeObj::GetUserPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユーザーポインターを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a035541674c664057eb66b958c3d763cf" title="ユーザーポインターを設定します。 ">SetUserPtr()</a> で設定したポインターを返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a81206653da41f37c6b924f4f3fcd2bb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* nn::g3d::ShapeObj::GetUserPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユーザーポインターを取得します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>ポインターを受けとる際の型。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a035541674c664057eb66b958c3d763cf" title="ユーザーポインターを設定します。 ">SetUserPtr()</a> で設定したポインターを返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="af1680667038c121f969470d162d933af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* nn::g3d::ShapeObj::GetUserPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユーザーポインターを取得します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>ポインターを受けとる際の型。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a035541674c664057eb66b958c3d763cf" title="ユーザーポインターを設定します。 ">SetUserPtr()</a> で設定したポインターを返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a13cbc2ed0a34709b6ec841559e92abb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::g3d::ShapeObj::GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>シェイプ名を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="classnn_1_1g3d_1_1_res_shape.html" title="シェイプのリソースです。 ">ResShape</a> のシェイプ名へのポインターを返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a366192ea48975363a42b6793469b484c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nn::g3d::ShapeObj::GetUserArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユーザーエリアへのポインターを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>ユーザーエリアへのポインターを返します。 </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_town_8cpp-example.html#a82">Town.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af057a8b378cb6d7ee94a8b95c545fcb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* nn::g3d::ShapeObj::GetUserArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユーザーエリアへのポインターを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>ユーザーエリアへのポインターを返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="aadace6bf4ef3fd23b28664052981a336"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* nn::g3d::ShapeObj::GetUserArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユーザーエリアへのポインターを取得します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>ポインターを受けとる際の型。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ユーザーエリアへのポインターを返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="acc5d31af5f0d71847aaca41377ba1212"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* nn::g3d::ShapeObj::GetUserArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユーザーエリアへのポインターを取得します。 </p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>ポインターを受けとる際の型。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ユーザーエリアへのポインターを返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="ab67c5f9f13e2158953143b56433cae26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nn::g3d::ShapeObj::GetUserAreaSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユーザーエリアのサイズを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>ユーザーエリアのサイズを返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="acd76605a682a3ca3676ab91d6fe62c24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_vertex.html">ResVertex</a>* nn::g3d::ShapeObj::GetResVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>参照する <a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="頂点情報のリソースです。 ">ResVertex</a> を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="頂点情報のリソースです。 ">ResVertex</a> へのポインターを返します。 </dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_mii_g3d_headwear_8cpp-example.html#a220">MiiG3dHeadwear.cpp</a>, <a class="el" href="_shape_animation_8cpp-example.html#a11">ShapeAnimation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a987abf75f6288206255df95bbd891cde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetVertexAttrCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>参照する <a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="頂点情報のリソースです。 ">ResVertex</a> の頂点属性の数を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>参照する <a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="頂点情報のリソースです。 ">ResVertex</a> の頂点属性の数を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="aae44347c36040e406258524943d95d40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_vertex_attr.html">ResVertexAttr</a>* nn::g3d::ShapeObj::GetResVertexAttr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attrIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>インデックス引きで頂点属性を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attrIndex</td><td>頂点属性のインデックス。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="classnn_1_1g3d_1_1_res_vertex_attr.html" title="頂点属性のリソースです。 ">ResVertexAttr</a> へのポインターを返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>インデックスはシェイプが持つ頂点属性数の範囲内。 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa7115a44dc383289e8887b4c20c00313"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_vertex_attr.html">ResVertexAttr</a>* nn::g3d::ShapeObj::FindResVertexAttr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>名前引きで頂点属性を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>頂点属性名へのポインター。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="classnn_1_1g3d_1_1_res_vertex_attr.html" title="頂点属性のリソースです。 ">ResVertexAttr</a> へのポインターを返します。</dd></dl>
<p><b>詳細</b> <br />
指定した名前の頂点属性が存在しない場合は NULL を返します。</p>
<p>名前引きよりインデックス引きほうが高速に動作します。インデックスを 取得後、記録しておき、通常はインデックス引きを使用することを推奨します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_shape_animation_8cpp-example.html#a31">ShapeAnimation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a065d7bd66a8484c0a818e6fa6dac7b8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::g3d::ShapeObj::GetVertexAttrName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>インデックスから頂点属性名を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attribIndex</td><td>頂点属性のインデックス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>頂点属性名へのポインターを返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>インデックスはシェイプが持つ頂点属性数の範囲内。 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a2d864c5b51adbbe0f8ac2568c1052240"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::FindVertexAttrIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>頂点属性名からインデックスを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>頂点属性名へのポインター。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>頂点属性のインデックスを返します。</dd></dl>
<p><b>詳細</b> <br />
指定した名前の頂点属性が存在しない場合は <a class="el" href="classnn_1_1util_1_1_res_dic.html#a825d9c73f03e6d02e9f8d0050b0e11a6" title="無効なインデックスです。 ">nn::util::ResDic::Npos</a> を返します。 </p>

</div>
</div>
<a class="anchor" id="a38bfb2f1f02e9f47bf4a8796194c08e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetVertexBufferCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>参照する <a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="頂点情報のリソースです。 ">ResVertex</a> の頂点バッファーの数を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>参照する <a class="el" href="classnn_1_1g3d_1_1_res_vertex.html" title="頂点情報のリソースです。 ">ResVertex</a> の頂点バッファーの数を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a1c79150775d457e82c04d5ba635ef7c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a>* nn::g3d::ShapeObj::GetVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>インデックスから頂点バッファーを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferIndex</td><td>頂点属性のインデックス。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85" title="バッファーを表す型定義です。 ">nn::gfx::Buffer</a> へのポインターを返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>インデックスはシェイプが持つ頂点バッファー数の範囲内。 </li>
</ul>
</dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_shape_animation_8cpp-example.html#a34">ShapeAnimation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a311a863e4d0810ddffa988344af47974"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1g3d_1_1_sphere.html">Sphere</a>* nn::g3d::ShapeObj::GetBounding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ワールド座標系におけるシェイプのバウンディング球を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>ワールド座標系におけるシェイプのバウンディング球へのポインターを返します。</dd></dl>
<p><b>詳細</b> <br />
構築時にバウンディングを無効に指定した場合は NULL を返します。 </p>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_town_8cpp-example.html#a150">Town.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1b2ab901b61469513d334f5a6d29d535"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnn_1_1g3d_1_1_sphere.html">Sphere</a>* nn::g3d::ShapeObj::GetBounding </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定したメッシュのワールド座標系におけるバウンディング球を取得します。 </p>
<p>param[in] meshIndex メッシュのインデックス。</p>
<dl class="section return"><dt>戻り値</dt><dd>指定したメッシュのワールド座標系におけるバウンディング球へのポインターを返します。</dd></dl>
<p><b>詳細</b> <br />
構築時にバウンディングを無効に指定した場合は NULL を返します。 </p>

</div>
</div>
<a class="anchor" id="ad35c8f2e29190cfc6012aad9c671edf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structnn_1_1g3d_1_1_sphere.html">Sphere</a>* nn::g3d::ShapeObj::GetBounding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ワールド座標系におけるシェイプのバウンディング球を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>ワールド座標系におけるシェイプのバウンディング球へのポインターを返します。</dd></dl>
<p><b>詳細</b> <br />
構築時にバウンディングを無効に指定した場合は NULL を返します。 </p>

</div>
</div>
<a class="anchor" id="aa7d123d46ed75284aec03f721b9d7b45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structnn_1_1g3d_1_1_sphere.html">Sphere</a>* nn::g3d::ShapeObj::GetBounding </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定したメッシュのワールド座標系におけるバウンディング球を取得します。 </p>
<p>param[in] meshIndex メッシュのインデックス。</p>
<dl class="section return"><dt>戻り値</dt><dd>指定したメッシュのワールド座標系におけるバウンディング球へのポインターを返します。</dd></dl>
<p><b>詳細</b> <br />
構築時にバウンディングを無効に指定した場合は NULL を返します。 </p>

</div>
</div>
<a class="anchor" id="a584937fcde20904ba97d7df31366f0d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structnn_1_1g3d_1_1_aabb.html">Aabb</a>* nn::g3d::ShapeObj::GetSubMeshBoundingArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ワールド座標系におけるサブメッシュの AABB 配列を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>ワールド座標系におけるサブメッシュの AABB 配列へのポインターを返します。</dd></dl>
<p><b>詳細</b> <br />
構築時にバウンディングを無効に指定した場合は NULL を返します。 </p>

</div>
</div>
<a class="anchor" id="a309a21916d5b1921a5106bce6c872b9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structnn_1_1g3d_1_1_aabb.html">Aabb</a>* nn::g3d::ShapeObj::GetSubMeshBoundingArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ワールド座標系における指定したメッシュのサブメッシュの AABB 配列を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshIndex</td><td>メッシュのインデックス。 LOD レベルを指定します。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ワールド座標系におけるサブメッシュの AABB 配列へのポインターを返します。</dd></dl>
<p><b>詳細</b> <br />
構築時にバウンディングを無効に指定した場合は NULL を返します。 </p>

</div>
</div>
<a class="anchor" id="a25c0526e70aef8f5ac9512196c1f5d14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::TestSubMeshIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1g3d_1_1_culling_context.html">CullingContext</a> *&#160;</td>
          <td class="paramname"><em>pCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;&#160;</td>
          <td class="paramname"><em>volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ビューボリュームと交差する連続したサブメッシュを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>サブメッシュ列を保持するコンテクストへのポインター。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>ビューボリュームへの参照。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>交差または包含されるサブメッシュが存在する場合はtrue、存在しない場合は false を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>構築時にバウンディング計算を有効にしている。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
コンテクストが保持するサブメッシュ列から探索し、次に交差または包含される 連続したサブメッシュをコンテクストに書き込みます。 <a class="el" href="structnn_1_1g3d_1_1_culling_context.html#a973c9d256f0663513a820b28baa9e1e8" title="サブメッシュのインデックス。 ">CullingContext::submeshIndex</a> にビューボリューム内に入る 開始サブメッシュインデックス、 <a class="el" href="structnn_1_1g3d_1_1_culling_context.html#a8c2aec7a1d20d20c7fed1b3bf037cd3a" title="サブメッシュ数。 ">CullingContext::submeshCount</a> に開始サブメッシュインデックス からビューボリューム内に入る連続するサブメッシュ数が格納されます。</p>
<p>探索は最後のサブメッシュに到達するか、ビューボリューム内に入るサブメッシュを見つけた後に続くサブメッシュを 探索し、ビューボリューム内に入らないものを見つけた場合に終了し、結果を返します。pCtxのデータを保持し、続けて この関数を呼び出すことによって、ビューボリューム内に入るすべてのサブメッシュを知ることができます。</p>
<p>得られた <a class="el" href="structnn_1_1g3d_1_1_culling_context.html" title="カリングに用いるコンテクストです。 ">CullingContext</a> を元に <a class="el" href="classnn_1_1g3d_1_1_res_mesh.html#a81aeebb2ad882470c6be182f018c209b" title="指定した範囲のサブメッシュを描画します。 ">nn::g3d::ResMesh::DrawSubMesh()</a> を呼び出し、 これを <a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a25c0526e70aef8f5ac9512196c1f5d14" title="ビューボリュームと交差する連続したサブメッシュを取得します。 ">TestSubMeshIntersection()</a> が false を返すまで繰り返すことによって、サブメッシュカリングを実現できます。 </p>

</div>
</div>
<a class="anchor" id="afc539bbe698f6a400f2e9f4fb1daeaea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::TestSubMeshIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1g3d_1_1_culling_context.html">CullingContext</a> *&#160;</td>
          <td class="paramname"><em>pCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定したメッシュにおけるビューボリュームと交差する連続したサブメッシュを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>サブメッシュ列を保持するコンテクストへのポインター。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>ビューボリュームへの参照。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshIndex</td><td>メッシュのインデックス。 LOD レベルを指定します。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>交差または包含されるサブメッシュが存在する場合はtrue、存在しない場合は false を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>構築時にバウンディング計算を有効にしている。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
コンテクストが保持するサブメッシュ列から探索し、次に交差または包含される 連続したサブメッシュをコンテクストに書き込みます。 <a class="el" href="structnn_1_1g3d_1_1_culling_context.html#a973c9d256f0663513a820b28baa9e1e8" title="サブメッシュのインデックス。 ">CullingContext::submeshIndex</a> にビューボリューム内に入る 開始サブメッシュインデックス、 <a class="el" href="structnn_1_1g3d_1_1_culling_context.html#a8c2aec7a1d20d20c7fed1b3bf037cd3a" title="サブメッシュ数。 ">CullingContext::submeshCount</a> に開始サブメッシュインデックス からビューボリューム内に入る連続するサブメッシュ数が格納されます。</p>
<p>探索は最後のサブメッシュに到達するか、ビューボリューム内に入るサブメッシュを見つけた後に続くサブメッシュを 探索し、ビューボリューム内に入らないものを見つけた場合に終了し、結果を返します。pCtxのデータを保持し、続けて この関数を呼び出すことによって、ビューボリューム内に入るすべてのサブメッシュを知ることができます。</p>
<p>得られた <a class="el" href="structnn_1_1g3d_1_1_culling_context.html" title="カリングに用いるコンテクストです。 ">CullingContext</a> を元に <a class="el" href="classnn_1_1g3d_1_1_res_mesh.html#a81aeebb2ad882470c6be182f018c209b" title="指定した範囲のサブメッシュを描画します。 ">nn::g3d::ResMesh::DrawSubMesh()</a> を呼び出し、 これを <a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a25c0526e70aef8f5ac9512196c1f5d14" title="ビューボリュームと交差する連続したサブメッシュを取得します。 ">TestSubMeshIntersection()</a> が false を返すまで繰り返すことによって、サブメッシュカリングを実現できます。</p>
<p>meshIndex に <a class="el" href="classnn_1_1g3d_1_1_shape_obj.html" title="シェイプインスタンスです。 ">ShapeObj</a> が保持するメッシュの数よりも大きな値が設定された場合には、 コンテクストには何も書き込まず、早期に false を返します。 </p>

</div>
</div>
<a class="anchor" id="ab64775081aa11a283658bfef401c7694"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::TestSubMeshLodIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1g3d_1_1_culling_context.html">CullingContext</a> *&#160;</td>
          <td class="paramname"><em>pCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1g3d_1_1_i_calculate_lod_level_functor.html">ICalculateLodLevelFunctor</a> &amp;&#160;</td>
          <td class="paramname"><em>calcLodFunctor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>内部用機能のため使用禁止です。</b> ビューボリュームと交差する LOD レベルの等しい連続したサブメッシュを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pCtx</td><td>サブメッシュ列を保持するコンテクストへのポインター。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>ビューボリュームへの参照。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">calcLodFunctor</td><td>LOD レベルの判定に用いる関数オブジェクトへの参照。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>交差または包含されるサブメッシュが存在する場合は true、存在しない場合は false を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>構築時にバウンディング計算を有効にしている。</li>
</ul>
</dd></dl>
<p><b>詳細</b> <br />
コンテクストが保持するサブメッシュ列から探索し、次に交差または包含される LOD レベルの等しい連続したサブメッシュをコンテクストに書き込みます。 <a class="el" href="structnn_1_1g3d_1_1_culling_context.html#a973c9d256f0663513a820b28baa9e1e8" title="サブメッシュのインデックス。 ">CullingContext::submeshIndex</a> にビューボリューム内に入る 開始サブメッシュインデックス、 <a class="el" href="structnn_1_1g3d_1_1_culling_context.html#a8c2aec7a1d20d20c7fed1b3bf037cd3a" title="サブメッシュ数。 ">CullingContext::submeshCount</a> に開始サブメッシュインデックス からビューボリューム内に入る連続するサブメッシュ数、CullingContex::submeshLodLevel にはLODレベルが格納されます。</p>
<p>探索は最後のサブメッシュに到達するか、ビューボリューム内に入るサブメッシュを見つけた後に続くサブメッシュを 探索し、ビューボリューム内に入らないものを見つけた場合に終了し、結果を返します。pCtxのデータを保持し、続けて この関数を呼び出すことによって、ビューボリューム内に入るすべてのサブメッシュを知ることができます。</p>
<p>得られた <a class="el" href="structnn_1_1g3d_1_1_culling_context.html" title="カリングに用いるコンテクストです。 ">CullingContext</a> を元に <a class="el" href="classnn_1_1g3d_1_1_res_mesh.html#a81aeebb2ad882470c6be182f018c209b" title="指定した範囲のサブメッシュを描画します。 ">nn::g3d::ResMesh::DrawSubMesh()</a> を呼び出し、 これを <a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#a25c0526e70aef8f5ac9512196c1f5d14" title="ビューボリュームと交差する連続したサブメッシュを取得します。 ">TestSubMeshIntersection()</a> が false を返すまで繰り返すことによって、サブメッシュカリングを実現できます。</p>
<p>この関数は LOD レベル 0 のバウンディング情報を使用し、計算を行います。 各 LOD モデルのバウンディングが LOD レベル 0 のものと大きく異なる場合に期待した結果にならない場合があります。 </p>

</div>
</div>
<a class="anchor" id="a2c7a151dcaf87f835b29b9e09404c21c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::MakeSubMeshRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html">SubMeshRange</a> *&#160;</td>
          <td class="paramname"><em>pRangeArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;&#160;</td>
          <td class="paramname"><em>volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ビューボリュームと交差する連続したサブメッシュの範囲配列を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pRangeArray</td><td><a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html" title="サブメッシュの範囲です。 ">SubMeshRange</a> 配列へのポインター。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>ビューボリュームへの参照。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ビューボリュームと交差するサブメッシュの数を返します。</dd></dl>
<p><b>詳細</b> <br />
pRangeArray は index と count と lodLevel がそれぞれ 0 の <a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html" title="サブメッシュの範囲です。 ">SubMeshRange</a> で終端され、 終端を含まないサブメッシュの個数が戻り値として返されます。 シェイプのサブメッシュ数を N とすると <a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html" title="サブメッシュの範囲です。 ">SubMeshRange</a> の最大数は (N+1)/2 です。（終端を除く） </p>

</div>
</div>
<a class="anchor" id="a9151525ed04761e24e47ac9370c8db96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::MakeSubMeshRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html">SubMeshRange</a> *&#160;</td>
          <td class="paramname"><em>pRangeArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>メッシュのインデックスを指定して、ビューボリュームと交差する連続したサブメッシュの範囲配列を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pRangeArray</td><td><a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html" title="サブメッシュの範囲です。 ">SubMeshRange</a> 配列へのポインター。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>ビューボリュームへの参照。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshIndex</td><td>メッシュのインデックス。 LOD レベルを指定します。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ビューボリュームと交差するサブメッシュの数を返します。</dd></dl>
<p><b>詳細</b> <br />
pRangeArray は index と count と lodLevel がそれぞれ 0 の <a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html" title="サブメッシュの範囲です。 ">SubMeshRange</a> で終端され、 終端を含まないサブメッシュの個数が戻り値として返されます。 シェイプのサブメッシュ数を N とすると <a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html" title="サブメッシュの範囲です。 ">SubMeshRange</a> の最大数は (N+1)/2 です。（終端を除く） </p>

</div>
</div>
<a class="anchor" id="adc83b0a0933cef444306411994a2720b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::MakeSubMeshLodRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html">SubMeshRange</a> *&#160;</td>
          <td class="paramname"><em>pRangeArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnn_1_1g3d_1_1_view_volume.html">ViewVolume</a> &amp;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnn_1_1g3d_1_1_i_calculate_lod_level_functor.html">ICalculateLodLevelFunctor</a> &amp;&#160;</td>
          <td class="paramname"><em>calcLodFunctor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>内部用機能のため使用禁止です。</b> ビューボリュームと交差する LOD レベルの等しい連続したサブメッシュの範囲配列を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pRangeArray</td><td><a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html" title="サブメッシュの範囲です。 ">SubMeshRange</a> 配列へのポインター。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">volume</td><td>ビューボリュームへの参照。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">calcLodFunctor</td><td>LOD レベルの判定に用いる関数オブジェクトへの参照。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ビューボリュームと交差するサブメッシュの数を返します。</dd></dl>
<p><b>詳細</b> <br />
pRangeArray は index と count と lodLevel がそれぞれ 0 の <a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html" title="サブメッシュの範囲です。 ">SubMeshRange</a> で終端され、 終端を含まないサブメッシュの個数が戻り値として返されます。 シェイプのサブメッシュ数を N とすると <a class="el" href="structnn_1_1g3d_1_1_sub_mesh_range.html" title="サブメッシュの範囲です。 ">SubMeshRange</a> の最大数は N です。（終端を除く） </p>

</div>
</div>
<a class="anchor" id="a7b0e8fd440a0a3a99cf4fc71793f9484"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetKeyShapeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>キーシェイプの数を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>キーシェイプの数。 </dd></dl>

</div>
</div>
<a class="anchor" id="ae682c5ed1aee0a94d64c85aae80daf0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_key_shape.html">ResKeyShape</a>* nn::g3d::ShapeObj::GetResKeyShape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyShapeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>インデックス引きでキーシェイプを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyShapeIndex</td><td>キーシェイプのインデックス。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="classnn_1_1g3d_1_1_res_key_shape.html" title="キーシェイプのリソースです。 ">ResKeyShape</a> へのポインターを返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd>インデックスはシェイプが持つキーシェイプ数の範囲内。 </dd></dl>

</div>
</div>
<a class="anchor" id="ac7d6937bdfdb9d9374bcb8b48cccd07f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnn_1_1g3d_1_1_res_key_shape.html">ResKeyShape</a>* nn::g3d::ShapeObj::FindResKeyShape </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>名前引きでキーシェイプを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>キーシェイプ名へのポインター。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="classnn_1_1g3d_1_1_res_key_shape.html" title="キーシェイプのリソースです。 ">ResKeyShape</a> へのポインターを返します。</dd></dl>
<p><b>詳細</b> <br />
指定した名前のキーシェイプが存在しない場合は NULL を返します。</p>
<p>名前引きよりインデックス引きほうが高速に動作します。インデックスを 取得後、記録しておき、通常はインデックス引きを使用することを推奨します。 </p>

</div>
</div>
<a class="anchor" id="a89891c755056ab332f0b1cdcf6bb3190"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* nn::g3d::ShapeObj::GetKeyShapeName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyShapeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>インデックスからキーシェイプ名を取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyShapeIndex</td><td>キーシェイプのインデックス。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>キーシェイプ名へのポインター。</dd></dl>
<p><b>詳細</b> <br />
インデックスはシェイプが持つキーシェイプ数の範囲内。 </p>

</div>
</div>
<a class="anchor" id="a850c286d793fca69dea82b4d15612fca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::FindKeyShapeIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>キーシェイプの名前からインデックスを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>キーシェイプ名へのポインター。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>キーシェイプのインデックス。</dd></dl>
<p><b>詳細</b> <br />
指定した名前のキーシェイプが存在しない場合は <a class="el" href="classnn_1_1util_1_1_res_dic.html#a825d9c73f03e6d02e9f8d0050b0e11a6" title="無効なインデックスです。 ">nn::util::ResDic::Npos</a> を返します。 </p>

</div>
</div>
<a class="anchor" id="ac30fa8adfe8b77687b7f416d9026757e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::GetTargetAttribCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>キーシェイプが持つ頂点属性の数を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>キーシェイプが持つ頂点属性の数。 </dd></dl>

</div>
</div>
<a class="anchor" id="ab69625ebe1a4a5920e0cc48cf02be2d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::HasValidBlendWeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>有効なキーシェイプのブレンドウェイトをもつかどうかを取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ab37b9ec279a4bf687b512dde43670b95" title="キーシェイプのブレンドウェイトを初期化します。 ">ClearBlendWeights()</a> 呼び出し後に <a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#af0aadad1cc0cc4ed59b0777886932936" title="キーシェイプのブレンドウェイトを設定します。 ">SetBlendWeight()</a> を呼んでいた場合に true、そうでないならfalse。 </dd></dl>

</div>
</div>
<a class="anchor" id="af0aadad1cc0cc4ed59b0777886932936"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::SetBlendWeight </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyShapeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>キーシェイプのブレンドウェイトを設定します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyShapeIndex</td><td>キーシェイプのインデックス。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>ブレンドウェイト。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>keyShapeIndex はシェイプが持つキーシェイプ数の範囲内。 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a60e4e6ea528f00f34f5c6a2913a435d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float nn::g3d::ShapeObj::GetBlendWeight </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyShapeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>キーシェイプのブレンドウェイトを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyShapeIndex</td><td>キーシェイプのインデックス。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ブレンドウェイトを返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>keyShapeIndexはシェイプが持つキーシェイプ数の範囲内。 </li>
</ul>
</dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_shape_animation_8cpp-example.html#a77">ShapeAnimation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af0f338c38b6c82c09d6aa85edc5b47d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nn::g3d::ShapeObj::IsBlendWeightValid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyShapeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>キーシェイプのブレンドウェイトが有効かどうかを取得します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyShapeIndex</td><td>キーシェイプのインデックス。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><a class="el" href="classnn_1_1g3d_1_1_shape_obj.html#ab37b9ec279a4bf687b512dde43670b95" title="キーシェイプのブレンドウェイトを初期化します。 ">ClearBlendWeights()</a> 呼び出し後に SetBlendWeight(keyShapeIndex) を呼んでいた場合は true、それ以外の場合は false を返します。</dd></dl>
<dl class="section pre"><dt>事前条件</dt><dd><ul>
<li>keyShapeIndex はシェイプが持つキーシェイプ数の範囲内 </li>
</ul>
</dd></dl>
<dl><dt><b>各種例: </b></dt><dd><a class="el" href="_shape_animation_8cpp-example.html#a76">ShapeAnimation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a622d803b4f893d861e563fa1ef70f2ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nn::g3d::ShapeObj::CountValidBlendWeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>有効なキーシェイプのブレンドウェイトを数えます。 </p>
<dl class="section return"><dt>戻り値</dt><dd>有効なキーシェイプのブレンドウェイトの数を返します。 </dd></dl>

</div>
</div>
<a class="anchor" id="a2e6be9b6a4067792ff55b9665a5660a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nn::g3d::ShapeObj::SetShapeBlockArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a> *&#160;</td>
          <td class="paramname"><em>pBlockArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>内部用機能のため使用禁止です。</b> ユニフォームブロックのバッファー配列を設定します。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBlockArray</td><td>バッファー配列へのポインター。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49dd09490b1b087accb0df529831c20e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenn_1_1gfx.html#a8721c66f238e6505cbf9ca0eb71d3e85">nn::gfx::Buffer</a>* nn::g3d::ShapeObj::GetShapeBlockArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>内部用機能のため使用禁止です。</b> ユニフォームブロックのバッファー配列を取得します。 </p>
<dl class="section return"><dt>戻り値</dt><dd>バッファー配列へのポインターを返します。 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
