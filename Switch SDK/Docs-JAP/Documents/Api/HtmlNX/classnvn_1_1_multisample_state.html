<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>NintendoSDK API Reference: nvn::MultisampleState クラス</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="openclose.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NintendoSDK API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>総合概要</span></a></li>
      <li><a href="pages.html"><span>諸情報</span></a></li>
      <li><a href="modules.html"><span>モジュール</span></a></li>
      <li><a href="namespaces.html"><span>名前空間</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>クラス一覧</span></a></li>
      <li><a href="classes.html"><span>クラス索引</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>クラスメンバ</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenvn.html">nvn</a></li><li class="navelem"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="classnvn_1_1_multisample_state-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">nvn::MultisampleState クラス<div class="ingroups"><a class="el" href="group__nvn__cpp__interface.html">NVN C++ API Bindings</a> &raquo; <a class="el" href="group__nvn__cpp__apiclasses.html">API Classes</a> &#124; <a class="el" href="group__nvn__cpp__interface.html">NVN C++ API Bindings</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>API state object controlling multisample rasterization and sample processing.  
 <a href="classnvn_1_1_multisample_state.html#details">[詳解]</a></p>

<p><code>#include &lt;nvn/nvn_Cpp.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:a8185a93167e39775dcc1458998392576"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8185a93167e39775dcc1458998392576"></a>
NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#a8185a93167e39775dcc1458998392576">GetAlphaToCoverageDither</a> () const </td></tr>
<tr class="memdesc:a8185a93167e39775dcc1458998392576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the alpha-to-coverage dithering enable. <br /></td></tr>
<tr class="separator:a8185a93167e39775dcc1458998392576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedab3b6ae1a97af5292be378167ba2cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedab3b6ae1a97af5292be378167ba2cb"></a>
NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#aedab3b6ae1a97af5292be378167ba2cb">GetAlphaToCoverageEnable</a> () const </td></tr>
<tr class="memdesc:aedab3b6ae1a97af5292be378167ba2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the alpha-to-coverage enable. <br /></td></tr>
<tr class="separator:aedab3b6ae1a97af5292be378167ba2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33fb68762b6ac8ffa24711670a5149a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnvn_1_1_coverage_modulation_mode.html">CoverageModulationMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#ae33fb68762b6ac8ffa24711670a5149a">GetCoverageModulationMode</a> () const </td></tr>
<tr class="memdesc:ae33fb68762b6ac8ffa24711670a5149a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the coverage modulation mode for target-independent rasterization.  <a href="#ae33fb68762b6ac8ffa24711670a5149a">[詳解]</a><br /></td></tr>
<tr class="separator:ae33fb68762b6ac8ffa24711670a5149a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c52a6d3d1b97ac11c8b904158428778"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c52a6d3d1b97ac11c8b904158428778"></a>
NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#a1c52a6d3d1b97ac11c8b904158428778">GetCoverageToColorEnable</a> () const </td></tr>
<tr class="memdesc:a1c52a6d3d1b97ac11c8b904158428778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the enable for the fragment coverage-to-color feature. <br /></td></tr>
<tr class="separator:a1c52a6d3d1b97ac11c8b904158428778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476f59adab874d75e18d944831bfc106"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#a476f59adab874d75e18d944831bfc106">GetCoverageToColorOutput</a> () const </td></tr>
<tr class="memdesc:a476f59adab874d75e18d944831bfc106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the color output updated by the fragment coverage-to-color feature.  <a href="#a476f59adab874d75e18d944831bfc106">[詳解]</a><br /></td></tr>
<tr class="separator:a476f59adab874d75e18d944831bfc106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1313faf16197063a63270ccecf21786f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1313faf16197063a63270ccecf21786f"></a>
NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#a1313faf16197063a63270ccecf21786f">GetMultisampleEnable</a> () const </td></tr>
<tr class="memdesc:a1313faf16197063a63270ccecf21786f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the multisample rasterization enable. <br /></td></tr>
<tr class="separator:a1313faf16197063a63270ccecf21786f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f92d01666c70612dc6d2c4a53e3e5cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#a8f92d01666c70612dc6d2c4a53e3e5cd">GetRasterSamples</a> ()</td></tr>
<tr class="memdesc:a8f92d01666c70612dc6d2c4a53e3e5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the raster sample count for target-independent rasterization.  <a href="#a8f92d01666c70612dc6d2c4a53e3e5cd">[詳解]</a><br /></td></tr>
<tr class="separator:a8f92d01666c70612dc6d2c4a53e3e5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de5a0093df188f1a082e65993fe4fe3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4de5a0093df188f1a082e65993fe4fe3"></a>
NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#a4de5a0093df188f1a082e65993fe4fe3">GetSampleLocationsEnable</a> () const </td></tr>
<tr class="memdesc:a4de5a0093df188f1a082e65993fe4fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the programmable sample locations enable. <br /></td></tr>
<tr class="separator:a4de5a0093df188f1a082e65993fe4fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f53817de7e5705af51acf0c74f4520"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#ae6f53817de7e5705af51acf0c74f4520">GetSampleLocationsGrid</a> (int *width, int *height)</td></tr>
<tr class="memdesc:ae6f53817de7e5705af51acf0c74f4520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the size of a pixel grid used for programmable sample locations.  <a href="#ae6f53817de7e5705af51acf0c74f4520">[詳解]</a><br /></td></tr>
<tr class="separator:ae6f53817de7e5705af51acf0c74f4520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665b47a217b8492807120746efd3ffb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a665b47a217b8492807120746efd3ffb0"></a>
NVNboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#a665b47a217b8492807120746efd3ffb0">GetSampleLocationsGridEnable</a> () const </td></tr>
<tr class="memdesc:a665b47a217b8492807120746efd3ffb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the programmable sample locations grid enable. <br /></td></tr>
<tr class="separator:a665b47a217b8492807120746efd3ffb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f87a5c5ba4b222fd41e00cce3f0a517"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f87a5c5ba4b222fd41e00cce3f0a517"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#a6f87a5c5ba4b222fd41e00cce3f0a517">GetSamples</a> () const </td></tr>
<tr class="memdesc:a6f87a5c5ba4b222fd41e00cce3f0a517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of samples in a <a class="el" href="classnvn_1_1_multisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">MultisampleState</a> object. <br /></td></tr>
<tr class="separator:a6f87a5c5ba4b222fd41e00cce3f0a517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202f114e6e48f7adc4916494c4451977"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#a202f114e6e48f7adc4916494c4451977">SetAlphaToCoverageDither</a> (NVNboolean dither)</td></tr>
<tr class="memdesc:a202f114e6e48f7adc4916494c4451977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable dithering in the alpha-to-coverage operation.  <a href="#a202f114e6e48f7adc4916494c4451977">[詳解]</a><br /></td></tr>
<tr class="separator:a202f114e6e48f7adc4916494c4451977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d18e24578866a64c9d74a4abbd25df9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#a7d18e24578866a64c9d74a4abbd25df9">SetAlphaToCoverageEnable</a> (NVNboolean enable)</td></tr>
<tr class="memdesc:a7d18e24578866a64c9d74a4abbd25df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable alpha-to-coverage operation.  <a href="#a7d18e24578866a64c9d74a4abbd25df9">[詳解]</a><br /></td></tr>
<tr class="separator:a7d18e24578866a64c9d74a4abbd25df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70c6c171586265cafedf41af820f68a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#af70c6c171586265cafedf41af820f68a">SetCoverageModulationMode</a> (<a class="el" href="structnvn_1_1_coverage_modulation_mode.html">CoverageModulationMode</a> mode)</td></tr>
<tr class="memdesc:af70c6c171586265cafedf41af820f68a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the coverage modulation mode for target-independent rasterization.  <a href="#af70c6c171586265cafedf41af820f68a">[詳解]</a><br /></td></tr>
<tr class="separator:af70c6c171586265cafedf41af820f68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095f794f39df5a3ef790b787ce0c17e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#a095f794f39df5a3ef790b787ce0c17e6">SetCoverageToColorEnable</a> (NVNboolean enable)</td></tr>
<tr class="memdesc:a095f794f39df5a3ef790b787ce0c17e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the fragment coverage-to-color feature.  <a href="#a095f794f39df5a3ef790b787ce0c17e6">[詳解]</a><br /></td></tr>
<tr class="separator:a095f794f39df5a3ef790b787ce0c17e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621d450196e564ae64d6a33ed1bde5b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#a621d450196e564ae64d6a33ed1bde5b8">SetCoverageToColorOutput</a> (int color)</td></tr>
<tr class="memdesc:a621d450196e564ae64d6a33ed1bde5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the color output updated by the fragment coverage-to-color feature.  <a href="#a621d450196e564ae64d6a33ed1bde5b8">[詳解]</a><br /></td></tr>
<tr class="separator:a621d450196e564ae64d6a33ed1bde5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7079f05341d242850bab400784858fde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#a7079f05341d242850bab400784858fde">SetDefaults</a> ()</td></tr>
<tr class="memdesc:a7079f05341d242850bab400784858fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default state for the <a class="el" href="classnvn_1_1_multisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">MultisampleState</a> object.  <a href="#a7079f05341d242850bab400784858fde">[詳解]</a><br /></td></tr>
<tr class="separator:a7079f05341d242850bab400784858fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703b817993977fd7e5f01771d0a7b0c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#a703b817993977fd7e5f01771d0a7b0c1">SetMultisampleEnable</a> (NVNboolean enable)</td></tr>
<tr class="memdesc:a703b817993977fd7e5f01771d0a7b0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable multisample rasterization.  <a href="#a703b817993977fd7e5f01771d0a7b0c1">[詳解]</a><br /></td></tr>
<tr class="separator:a703b817993977fd7e5f01771d0a7b0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4ca475a2fca7835b9a516b3195f140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#adb4ca475a2fca7835b9a516b3195f140">SetRasterSamples</a> (int rasterSamples)</td></tr>
<tr class="memdesc:adb4ca475a2fca7835b9a516b3195f140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the raster sample count for target-independent rasterization.  <a href="#adb4ca475a2fca7835b9a516b3195f140">[詳解]</a><br /></td></tr>
<tr class="separator:adb4ca475a2fca7835b9a516b3195f140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fc9ae077d2a7d0594850c077566258"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#a89fc9ae077d2a7d0594850c077566258">SetSampleLocations</a> (int start, int count, const float *values)</td></tr>
<tr class="memdesc:a89fc9ae077d2a7d0594850c077566258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies programmable sample locations for rasterization.  <a href="#a89fc9ae077d2a7d0594850c077566258">[詳解]</a><br /></td></tr>
<tr class="separator:a89fc9ae077d2a7d0594850c077566258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebe4fe4e01912a3cebc7bf5ad768cf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#acebe4fe4e01912a3cebc7bf5ad768cf6">SetSampleLocationsEnable</a> (NVNboolean enable)</td></tr>
<tr class="memdesc:acebe4fe4e01912a3cebc7bf5ad768cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable programmable sample locations.  <a href="#acebe4fe4e01912a3cebc7bf5ad768cf6">[詳解]</a><br /></td></tr>
<tr class="separator:acebe4fe4e01912a3cebc7bf5ad768cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d819818314c0091f6c571f17b442c4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#a5d819818314c0091f6c571f17b442c4f">SetSampleLocationsGridEnable</a> (NVNboolean enable)</td></tr>
<tr class="memdesc:a5d819818314c0091f6c571f17b442c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the programmable sample locations grid enable.  <a href="#a5d819818314c0091f6c571f17b442c4f">[詳解]</a><br /></td></tr>
<tr class="separator:a5d819818314c0091f6c571f17b442c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166d9ef3f583a7901a5046e1169204b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvn_1_1_multisample_state.html#a166d9ef3f583a7901a5046e1169204b0">SetSamples</a> (int samples)</td></tr>
<tr class="memdesc:a166d9ef3f583a7901a5046e1169204b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the number of samples in the framebuffer.  <a href="#a166d9ef3f583a7901a5046e1169204b0">[詳解]</a><br /></td></tr>
<tr class="separator:a166d9ef3f583a7901a5046e1169204b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p>API state object controlling multisample rasterization and sample processing. </p>
</div><h2 class="groupheader">関数詳解</h2>
<a class="anchor" id="a7079f05341d242850bab400784858fde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp; nvn::MultisampleState::SetDefaults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default state for the <a class="el" href="classnvn_1_1_multisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">MultisampleState</a> object. </p>
<dl class="section note"><dt>覚え書き</dt><dd>This is semantically equivalent to calling</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classnvn_1_1_multisample_state.html#a703b817993977fd7e5f01771d0a7b0c1">MultisampleState::SetMultisampleEnable</a>(<a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>);</div>
<div class="line"><a class="code" href="classnvn_1_1_multisample_state.html#a7d18e24578866a64c9d74a4abbd25df9">MultisampleState::SetAlphaToCoverageEnable</a>(<a class="code" href="group__nvn__c__defines.html#gad12fb86930f09043843be6b39c78bb1b">NVN_FALSE</a>);</div>
<div class="line"><a class="code" href="classnvn_1_1_multisample_state.html#a202f114e6e48f7adc4916494c4451977">MultisampleState::SetAlphaToCoverageDither</a>(<a class="code" href="group__nvn__c__defines.html#ga48151b7e768a13685d77d1a4c464a33b">NVN_TRUE</a>);</div>
<div class="line"><a class="code" href="classnvn_1_1_multisample_state.html#a166d9ef3f583a7901a5046e1169204b0">MultisampleState::SetSamples</a>(0);</div>
<div class="line"><a class="code" href="classnvn_1_1_multisample_state.html#adb4ca475a2fca7835b9a516b3195f140">MultisampleState::SetRasterSamples</a>(0);</div>
<div class="line"><a class="code" href="classnvn_1_1_multisample_state.html#af70c6c171586265cafedf41af820f68a">MultisampleState::SetCoverageModulationMode</a>(<a class="code" href="structnvn_1_1_coverage_modulation_mode.html#aac050f81ede81ac3d2b4ec9e6521615aa4351ccac9d7c975fa977c62a37e4ad6d">CoverageModulationMode::NONE</a>);</div>
<div class="line"><a class="code" href="classnvn_1_1_multisample_state.html#a095f794f39df5a3ef790b787ce0c17e6">MultisampleState::SetCoverageToColorEnable</a>(<a class="code" href="group__nvn__c__defines.html#gad12fb86930f09043843be6b39c78bb1b">NVN_FALSE</a>);</div>
<div class="line"><a class="code" href="classnvn_1_1_multisample_state.html#a621d450196e564ae64d6a33ed1bde5b8">MultisampleState::SetCoverageToColorOutput</a>(0);</div>
<div class="line"><a class="code" href="classnvn_1_1_multisample_state.html#acebe4fe4e01912a3cebc7bf5ad768cf6">MultisampleState::SetSampleLocationsEnable</a>(<a class="code" href="group__nvn__c__defines.html#gad12fb86930f09043843be6b39c78bb1b">NVN_FALSE</a>);</div>
<div class="line"><a class="code" href="classnvn_1_1_multisample_state.html#a5d819818314c0091f6c571f17b442c4f">MultisampleState::SetSampleLocationsGridEnable</a>(<a class="code" href="group__nvn__c__defines.html#gad12fb86930f09043843be6b39c78bb1b">NVN_FALSE</a>);</div>
</div><!-- fragment --><p> All sample locations in the <a class="el" href="classnvn_1_1_multisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">MultisampleState</a> object are initialized to pixel centers (0.5). </p>

</div>
</div>
<a class="anchor" id="a703b817993977fd7e5f01771d0a7b0c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp; nvn::MultisampleState::SetMultisampleEnable </td>
          <td>(</td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable multisample rasterization. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) multisample rasterization. When multisample rasterization is enabled, separate coverage information is computed for every sample in a pixel. When multisample rasterization is disabled, a single coverage value is used for all samples in a pixel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a166d9ef3f583a7901a5046e1169204b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp; nvn::MultisampleState::SetSamples </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the number of samples in the framebuffer. </p>
<dl class="section warning"><dt>警告</dt><dd>If the sample count in the <a class="el" href="classnvn_1_1_multisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">MultisampleState</a> object and the textures in the framebuffer don't match, the results of rendering are undefined.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td>Specifies the number of samples in the framebuffer. If non-multisample framebuffers are used, the value should be specified as 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d18e24578866a64c9d74a4abbd25df9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp; nvn::MultisampleState::SetAlphaToCoverageEnable </td>
          <td>(</td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable alpha-to-coverage operation. </p>
<p>When alpha-to-coverage operations are enabled, the fourth (A) component of fragment color zero is used to produce a sample mask that is combined with raster coverage to produce an updated sample mask. An alpha value of 0.0 disables all samples; an alpha value of 1.0 enables all samples.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Enable (TRUE) or disable (FALSE) the alpha-to-coverage operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a202f114e6e48f7adc4916494c4451977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp; nvn::MultisampleState::SetAlphaToCoverageDither </td>
          <td>(</td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>dither</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable dithering in the alpha-to-coverage operation. </p>
<p>When alpha-to-coverage operations are enabled via MultisampleState::SetAlphaToCoverage, the fourth (A) component of fragment color zero is used to produce a sample mask that is combined with raster coverage to produce an updated sample mask. An alpha value of 0.0 disables all samples; an alpha value of 1.0 enables all samples. If alpha-to-coverage dithering is enabled by this command, the same alpha value will produce different sample masks for different pixels. If dithering is disabled, the same alpha value will produce the same sample mask in all pixels. Dithering will allow for more effective levels of transparency, but may result in more visible noise. Dithering has no effect if alpha-to-coverage is disabled.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">dither</td><td>Enable (TRUE) or disable (FALSE) the alpha-to-coverage dithering operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb4ca475a2fca7835b9a516b3195f140"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp; nvn::MultisampleState::SetRasterSamples </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rasterSamples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the raster sample count for target-independent rasterization. </p>
<p>When using a non-zero value (supported: 2, 4, 8, and 16), this command enables target-independent rasterization, where the rasterizer evaluates sample coverage using the specified number of sample locations. This raster sample count may differ from the number of stored samples in the framebuffer. When using a zero value (default), the command disables target-independent rasterization and has the rasterizer evaluate sample coverage based on the stored samples in the framebuffer.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">rasterSamples</td><td>Raster sample count. If depth or stencil tests are performed with target-independent rasterization, the raster sample count must be equal to the number of samples in the depth/stencil render target. If non-zero, the raster sample count must be greater than or equal to the color sample count set by <a class="el" href="classnvn_1_1_multisample_state.html#a166d9ef3f583a7901a5046e1169204b0" title="Specify the number of samples in the framebuffer. ">MultisampleState::SetSamples</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f92d01666c70612dc6d2c4a53e3e5cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvn::MultisampleState::GetRasterSamples </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the raster sample count for target-independent rasterization. </p>

</div>
</div>
<a class="anchor" id="af70c6c171586265cafedf41af820f68a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp; nvn::MultisampleState::SetCoverageModulationMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvn_1_1_coverage_modulation_mode.html">CoverageModulationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the coverage modulation mode for target-independent rasterization. </p>
<p>When target-independent rasterization is enabled, pixel or sample color values in the framebuffer are updated whenever any of the associated raster samples are covered by a primitive. Applications can enable coverage modulation to account for partial coverage, where color (RGB) or alpha components are multiplied by a factor that reflects the fraction of raster samples that are covered. This modulation mode allows applications to specify that some, all, or none of the color components are multiplied by this factor.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Specifies the set of color channels to multiply by the coverage modulation factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae33fb68762b6ac8ffa24711670a5149a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvn_1_1_coverage_modulation_mode.html">CoverageModulationMode</a> nvn::MultisampleState::GetCoverageModulationMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the coverage modulation mode for target-independent rasterization. </p>

</div>
</div>
<a class="anchor" id="a095f794f39df5a3ef790b787ce0c17e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp; nvn::MultisampleState::SetCoverageToColorEnable </td>
          <td>(</td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the fragment coverage-to-color feature. </p>
<p>When enabled using <a class="el" href="classnvn_1_1_multisample_state.html#a095f794f39df5a3ef790b787ce0c17e6" title="Enable or disable the fragment coverage-to-color feature. ">MultisampleState::SetCoverageToColorEnable</a>, the fragment coverage-to-color feature writes a coverage mask for each fragment into the red component of the fragment color for one color output. The color output number recieving the coverage mask is specified by <a class="el" href="classnvn_1_1_multisample_state.html#a621d450196e564ae64d6a33ed1bde5b8" title="Specify the color output updated by the fragment coverage-to-color feature. ">MultisampleState::SetCoverageToColorOutput</a>.</p>
<p>The coverage mask used for coverage-to-color reflects not only raster sample coverage, but also the results of per-fragment operations including other sample masks, alpha to coverage, alpha test, and the depth bounds, depth, and stencil tests.</p>
<dl class="section warning"><dt>警告</dt><dd>When coverage-to-color is enabled, the color target receiving the coverage mask must have a one-component format with signed or unsigned integer components (e.g., R8I, R32UI). Coverage-to-color has no effect if other color target formats are used.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Fragment coverage-to-color enable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a621d450196e564ae64d6a33ed1bde5b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp; nvn::MultisampleState::SetCoverageToColorOutput </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the color output updated by the fragment coverage-to-color feature. </p>
<p>When enabled using <a class="el" href="classnvn_1_1_multisample_state.html#a095f794f39df5a3ef790b787ce0c17e6" title="Enable or disable the fragment coverage-to-color feature. ">MultisampleState::SetCoverageToColorEnable</a>, the fragment coverage-to-color feature writes a coverage mask for each fragment into the red component of the fragment color for one color output. The color output number recieving the coverage mask is specified by <a class="el" href="classnvn_1_1_multisample_state.html#a621d450196e564ae64d6a33ed1bde5b8" title="Specify the color output updated by the fragment coverage-to-color feature. ">MultisampleState::SetCoverageToColorOutput</a>.</p>
<p>The coverage mask used for coverage-to-color reflects not only raster sample coverage, but also the results of per-fragment operations including other sample masks, alpha to coverage, alpha test, and the depth bounds, depth, and stencil tests.</p>
<dl class="section warning"><dt>警告</dt><dd>When coverage-to-color is enabled, the color target receiving the coverage mask must have a one-component format with signed or unsigned integer components (e.g., R8I, R32UI). Coverage-to-color has no effect if other color target formats are used.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Color output number updated by the fragment coverage-to-color feature. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a476f59adab874d75e18d944831bfc106"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nvn::MultisampleState::GetCoverageToColorOutput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the color output updated by the fragment coverage-to-color feature. </p>

</div>
</div>
<a class="anchor" id="acebe4fe4e01912a3cebc7bf5ad768cf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp; nvn::MultisampleState::SetSampleLocationsEnable </td>
          <td>(</td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable programmable sample locations. </p>
<p>By default, rasterization in NVN uses a set of fixed sample locations based on the total number of raster samples. When programmable sample locations are enabled, rasterization instead uses a set of locations from the <a class="el" href="classnvn_1_1_multisample_state.html" title="API state object controlling multisample rasterization and sample processing. ">MultisampleState</a> object programmed using <a class="el" href="classnvn_1_1_multisample_state.html#a89fc9ae077d2a7d0594850c077566258" title="Specifies programmable sample locations for rasterization. ">MultisampleState::SetSampleLocations</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Enable/disable programmble sample locations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6f53817de7e5705af51acf0c74f4520"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvn::MultisampleState::GetSampleLocationsGrid </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the size of a pixel grid used for programmable sample locations. </p>
<p>When programmable sample locations are enabled, the rasterizer can use the same set of locations for each pixel, or use a different set of locations for each pixel in a small fixed-size grid, based on the enable set by <a class="el" href="classnvn_1_1_multisample_state.html#a5d819818314c0091f6c571f17b442c4f" title="Set the programmable sample locations grid enable. ">MultisampleState::SetSampleLocationsGridEnable</a>. This function returns the width and height of the fixed-size grid used when enabled. The grid will have a total of 16/N pixels, where N is the total number of raster samples in the multisample state object. Please refer to the documentation of <a class="el" href="classnvn_1_1_multisample_state.html#a89fc9ae077d2a7d0594850c077566258" title="Specifies programmable sample locations for rasterization. ">MultisampleState::SetSampleLocations</a> for more details.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">width</td><td>Returns the width (in pixels) of the sample location pixel grid.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">height</td><td>Returns the height (in pixels) of the sample location pixel grid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d819818314c0091f6c571f17b442c4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp; nvn::MultisampleState::SetSampleLocationsGridEnable </td>
          <td>(</td>
          <td class="paramtype">NVNboolean&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the programmable sample locations grid enable. </p>
<p>When programmable sample locations are enabled, the rasterizer can use the same set of locations for each pixel (disabled), or use a different set of locations for each pixel in a small fixed-size grid.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Enable or disable the programmble sample locations grid. If set to NVN_TRUE, different sample locations are used for each pixel in a fixed-size grid. If set to NVN_FALSE, the same locations are used for all pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89fc9ae077d2a7d0594850c077566258"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnvn_1_1_multisample_state.html">MultisampleState</a> &amp; nvn::MultisampleState::SetSampleLocations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies programmable sample locations for rasterization. </p>
<p>When programmable sample locations are enabled using <a class="el" href="classnvn_1_1_multisample_state.html#acebe4fe4e01912a3cebc7bf5ad768cf6" title="Enable or disable programmable sample locations. ">MultisampleState::SetSampleLocationsEnable</a>, rasterization uses a set of sample locations programmed in the multisample state object using this command. Each sample location is a pair of (x,y) values identifying the location of a sample within its pixel.</p>
<p>The rasterizer may use the same sample locations for each pixel or varying sample locations within a repeating pixel grid, depending on state set using <a class="el" href="classnvn_1_1_multisample_state.html#a5d819818314c0091f6c571f17b442c4f" title="Set the programmable sample locations grid enable. ">MultisampleState::SetSampleLocationsGridEnable</a>. If the pixel grid is disabled, a sample with index <em>s</em> in the pixel with coordinates (x,y) always uses entry <em>s</em> in the array of sample locations. If the pixel grid is enabled and the grid has a width and height of <em>gw</em> and <em>gh</em>, respectively, sample <em>s</em> in pixel (x,y) uses entry <em>s</em> + (<em>y</em> % <em>gh</em>) * <em>gw</em> + (<em>x</em> % <em>gw</em>).</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Index of the first sample location to update.</td></tr>
    <tr><td class="paramname">count</td><td>Number of sample locations to update.</td></tr>
    <tr><td class="paramname">values</td><td>Array of sample location value pairs. <em>values</em> is an array of 2 * <em>count</em> floating-point values, where each sample (x,y) location is specified using two values in the range [0.0, 1.0). The pair (0.5, 0.5) identifies the center of a pixel. Sample locations are converted to fixed-point values when the multisample state object is updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</body>
</html>
