<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<script type="text/javascript" src="../template/js/jquery/jquery.js"></script>
<script type="text/javascript" src="../template/js/common/manualLib.js"></script>
<script type="text/javascript" src="../tocData.js"></script>
<link rel="stylesheet" type="text/css" href="../template/css/template.css" />
<title>stdlib ファイル i/o</title>
</head>
<body data-reassemble="autoindex=no,forceNoLabel=yes">
<div id="autoindex_content">
<div class="body_content">
<noscript>
<div style="border: 4px double black; margin: 4px; padding: 2px; font-weight: bold; background-color: #FFFFCC;">
<p>お使いのブラウザは JavaScript が使用できないため、本ドキュメントの一部機能が無効になっています。</p><p>JavaScript が無効の環境では目次を使用することができません。<br />JavaScriptの実行が許可された状態で閲覧してください。<br /><br /></p>
</div>
</noscript>
<div class="page_navigation_top">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
</table>
</div>
<div class="breadcrumb"></div>

<!-- stdlib ファイル i/o -->
<div class="pagetitle" id="PageId_106358756">stdlib ファイル i/o</div>
<div class="text_separate">
<p>
  <ul class="macro_toc">
    <li>
      <a href="#Anchor_106358756_h1_1">posix 関数インターフェース</a>
    </li>
    <ul>
      <ul>
        <ul>
          <li>
            <a href="#Anchor_106358756_h4_1">open()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_2">creat()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_3">read()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_4">write()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_5">lseek()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_6">pread()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_7">pwrite()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_8">close()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_9">ftruncate()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_10">fstat()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_11">access()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_12">rename()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_13">remove()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_14">mkdir()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_15">rmdir()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_16">opendir()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_17">readdir() および readdir_r()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_18">rewinddir()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_19">telldir()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_20">dirfd()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_21">closedir()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_22">open_memstream() and open_wmemstream()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_23">fmemopen()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_24">fdopendir()</a>
          </li>
          <li>
            <a href="#Anchor_106358756_h4_25">flockfile()、ftrylockfile()、および funlockfile()</a>
          </li>
        </ul>
      </ul>
    </ul>
    <li>
      <a href="#Anchor_106358756_h1_2">現在実装されていない関数</a>
    </li>
    <li>
      <a href="#Anchor_106358756_h1_3">NintendoSDK FS API への低レベルインターフェース</a>
    </li>
  </ul>
</p>
<p> </p>
<div class="section">
  <h1 id="Anchor_106358756_h1_1">posix 関数インターフェース</h1>
</div>
<div class="section">
  <p> </p>
  <div class="info_new">
    <div class="info_new_left">参考：</div>
    <div class="info_new_right">
      <p>「Errno」セクションには、関数ごとに標準で定義しているすべての errno を挙げています。NX では、黒色表示の errno のみをサポートしており、グレー表示の errno はサポート対象外です。</p>
    </div>
  </div>
  <table class="table">
    <tbody>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_1">open()</h4>
          <p>
            <br />
          </p>
          <p>Int <strong>open</strong>(const char *pathname, int flags, &hellip;)</p>
        </td>
        <td>
          <div class="section">
            <strong>
              <u>説明</u>
            </strong>
          </div>
          <div class="section">ファイルのパス名である <em>pathname</em> を受け取った <strong>open</strong>() はファイルディスクリプタを返します。ファイルディスクリプタは、負数ではない小さい整数値であり、以降のシステム呼び出し（<em><strong><a href="http://linux.die.net/man/2/read">read</a></strong>(2)</em>、<em><strong><a href="http://linux.die.net/man/2/write">write</a></strong>(2)</em>、<em><strong><a href="http://linux.die.net/man/2/lseek">lseek</a></strong>(2)</em>、<em><strong><a href="http://linux.die.net/man/2/fcntl">fcntl</a></strong>(2)</em> など）で使用できます。 正常な呼び出しで返されるファイルディスクリプタは、現在のプロセスで開いていないファイルディスクリプタのうち、最小の値です。</div>
          <div class="section">
            <em>flags</em> 引数に<em>アクセスモード</em>として  <strong>O_RDONLY</strong>、<strong>O_WRONLY</strong>、または <strong>O_RDWR</strong> のいずれかを記述する必要があります。 これらの要求に従って、読み取り専用、書き込み専用、読み取り/書き込みのいずれかのモードでファイルが開きます。</div>
          <div class="section"> <p><u><strong>ANSI C</strong></u></p><p>ANSI C 関数である <strong>fopen</strong>() は <strong>open</strong>() を呼び出します。</p></div>
          <div class="section">
            <br />
          </div>
          <div class="section">
            <u>
              <strong>NX 固有の扱い</strong>
            </u>
          </div>
          <div class="section">O_RONLY、O_WRONLY、O_RDWR、O_APPEND、O_CREAT、O_EXCL、および O_TRUNC の各フラグのみが有効です。</div>
          <div class="section">現時点では、256 個のファイルディスクリプタを同時に使用できます。</div>
          <div class="section">
            <p> </p>
            <div class="info_new">
              <div class="info_new_left">参考：</div>
              <div class="info_new_right">
                <p>NX では、既に開いているファイルを開くことはできません。開いているファイルを開こうとすると、errno として EBUSY が返されます。 そのようなファイルを O_RDONLY モードで開いている場合はエラーが返されません。</p>
              </div>
            </div>
            <p> </p>
          </div>
          <div class="section">
            <u>
              <u>
                <strong> </strong>
              </u>
            </u>
            <!--Remove-->
            <u>
              <strong>
                <br />
              </strong>
            </u>
          </div>
          <div class="section">
            <u>
              <strong>Errno</strong>
            </u> </div>
          <div class="section">
            <p>次の条件下では、<em>open</em>() 関数が必ず失敗します。</p>
            <p>
              <strong>EEXIST</strong>：O_CREAT と O_EXCL を設定していて、指定したファイルが存在している場合。</p>
            <p>
              <strong>ENAMETOOLONG</strong>：old 引数または new 引数の長さが {PATH_MAX} を超えているか、パス名の部分が {NAME_MAX} より長い場合。</p>
            <p>
              <strong>ENFILE</strong>：使用可能な最大数のファイルが現時点で既に開いている場合。</p>
            <p>
              <strong>ENOENT</strong>：O_CREAT を設定していない状態で指定のファイルが存在しない場合。または O_CREAT を設定していても、指定したパス接頭辞が存在しないか、指定した path 引数が空の文字列を指している場合。</p>
            <p>
              <strong>EOVERFLOW</strong>：指定したファイルが通常のファイルであり、そのサイズを off_t 型のオブジェクトでは正しく表現できない場合。</p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>
                  <span style="color: rgb(153,153,153);">EACCES</span>
                </strong>
                <span style="color: rgb(153,153,153);">
                  <span style="color: rgb(153,153,153);">：パス接頭辞の構成要素に対する検索許可が拒否された場合、ファイルが存在していて、oflag で指定した許可が拒否された場合、ファイルが存在せず、作成対象であるファイルの親ディレクトリに対する書き込み許可が拒否された場合、または O_TRUNC を指定していて書き込み許可が拒否された場合。</span>
                </span>
              </span>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>
                  <span style="color: rgb(153,153,153);">EISDIR</span>
                </strong>
                <span style="color: rgb(153,153,153);">：指定したファイル名がディレクトリ名であり、oflag に O_WRONLY または O_RDWR が指定されている場合。</span>
              </span>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <span style="color: rgb(153,153,153);">
                  <strong>EMFILE</strong>
                  <span style="color: rgb(153,153,153);">：ファイルディスクリプタ {OPEN_MAX} で指定したファイルが、呼び出し側のプロセスで現在開いている場合。</span>
                </span>
              </span>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>ENOSR</strong>：STREAMS に基づいたファイルを path 引数に指定していて、システムで STREAM を割り当てることができない場合。</span>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>ENOSPC</strong>：新しいファイルの格納先であるディレクトリまたはファイルシステムを拡張できない状況で、指定のファイルが存在せず、O_CREAT を指定している場合。</span>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>ENOTDIR</strong>
                <span style="color: rgb(153,153,153);">：パス接頭辞にディレクトリが指定されていない場合。</span>
              </span>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>ENXIO</strong>：O_NONBLOCK を設定していて、指定したファイルが FIFO であり、O_WRONLY を設定していて、読み取るファイルを開いているプロセスが存在しない場合。</span>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>ENXIO</strong>：指定したファイルが文字またはブロックの特殊なファイルであり、この特殊なファイルに関連付けられたデバイスが存在しない場合。</span>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>ELOOP</strong>：path 引数を解決するときにシンボリックリンクにループが検出された場合。</span>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EROFS</strong>：指定したファイルが読み取り専用のファイルシステムに存在していて、oflag 引数に O_WRONLY、O_RDWR、O_CREAT（ファイルが存在しない場合）、または O_TRUNC を設定している場合。</span>
            </p>
            <p> </p>
            <p>次の条件下では、<em>open</em>() 関数が失敗する可能性があります。</p>
            <p>
              <strong>EINVAL</strong>：oflag 引数の値が有効ではない場合。</p>
            <p>
              <strong>ENOMEM</strong>：path 引数に STREAMS ファイルを指定していて、システム側でリソースを割り当てることができない場合。</p>
            <p> </p>
          </div>
          <div class="section">
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EAGAIN</strong>
                <span style="color: rgb(153,153,153);">：ロックされている疑似端末デバイスのスレーブ側を path 引数で指定している場合。</span>
              </span>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EINTR</strong>：実行時にシグナルが検出された場合。</span>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：このファイルに同期する I/O を実装側でサポートしていない場合。</span>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EIO</strong>：path 引数に STREAMS ファイルを指定している状態で、open() の実行中にハングアップまたはエラーが発生した場合。</span>
            </p>
            <div class="section">
              <p>
                <span style="color: rgb(153,153,153);">
                  <strong>ELOOP</strong>
                </span>
                <span style="color: rgb(153,153,153);">：path 引数の解決で {SYMLOOP_MAX} 個を超えるシンボリックリンクが検出された場合。</span> </p>
              <p>
                <span style="color: rgb(153,153,153);">
                  <strong>ENAMETOOLONG</strong>
                  <span style="color: rgb(153,153,153);">：path 引数の解決でシンボリックリンクを検出した結果、代入されたパス名文字列の長さが {PATH_MAX} を超えた場合。</span>
                </span>
              </p>
              <p>
                <span style="color: rgb(153,153,153);">
                  <strong>ETXTBSY</strong>
                </span>
                <span style="color: rgb(153,153,153);">：指定したファイルがプロシージャ（共有テキスト）のみを記述したファイルであって、現在実行中であり、oflag に O_WRONLY または O_RDWR を指定している場合。</span>
              </p>
              <div>
                <span style="color: rgb(153,153,153);">
                  <br />
                </span>
              </div>
            </div>
            <div class="section">NX には、以下の errno 情報が別途用意されています。</div>
            <div class="section">
              <strong>EBUSY</strong>：リソースがビジー状態で、書き込み先として使用できません。</div>
            <div class="section">
              <strong>ENOMEM</strong> ：この操作に必要なシステムメモリが不足しています。</div>
            <div class="section">
              <strong>ENOSPC</strong>：この操作に必要な領域が不足しています。</div>
            <div class="section">
              <strong>EPERM</strong>：不定なエラーです。</div>
            <div>
              <span style="color: rgb(153,153,153);">
                <br />
              </span>
            </div>
          </div>
          <div class="section">
            <u>
              <strong>詳細情報</strong>
            </u>
          </div>
          <div class="section">
            <a href="http://linux.die.net/man/2/open">http://linux.die.net/man/2/open</a>
          </div>
          <div class="section">
            <br />
          </div>
          <div class="warn_new">
            <div class="warn_new_left">警告：</div>
            <div class="warn_new_right">
              <p>O_CREAT フラグを設定すると、Unix の各モードでファイル許可を</p>
              <p>設定するオプションが open の 3 番目のオプションになります。</p>
              <p>（666 = ワールドの読み書き、グループの読み書き、ユーザの読み書き）。</p>
              <p>現在のところ、この関数ではこのパラメータをサポートしていません。</p>
            </div>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_2">creat()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>creat </strong>(const char *path, mode_t mode)</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>open</strong>(path, O_CREAT|O_TRUNC|O_WRONLY, t_mode) を呼び出します。</p>
          <p>この関数は、上記のフラグ指定で open を呼び出します。</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>前述の open() を参照してください。</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/2/creat">http://linux.die.net/man/2/creat</a>
          </p>
          <p> </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_3">read()</h4>
          <p> </p>
          <p>ssize_t <strong>read</strong>(int fd, void *buf, size_t count);</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>read</strong>() は、ファイルディスクリプタ <em>fd</em> で指定されたファイルから最大で <em>count</em> バイトを、<em>buf</em> から始まるバッファに読み取ります。</p>
          <p>シークが可能なファイルの場合、この読み取り操作は現在のファイルオフセット位置から始まり、読み取ったバイト数の分だけ、ファイルオフセットが増加します。現在のファイルオフセットがファイルの末尾にある場合またはファイルの末尾を超えている場合、バイトは読み取られず、<strong>read</strong>() によってゼロが返されます。</p>
          <p>
            <em>count</em> がゼロの場合、<strong>read</strong>() によって下記のエラーが検出される<em>可能性があります</em>。エラーが発生していない場合または <strong>read</strong>() でエラーの発生をチェックしていない場合、<strong>count</strong> に 0 を指定した <em>read</em>() ではゼロが返され、ほかには何も実行されません。</p>
          <p> </p>
          <p>
            <u>
              <strong>ANSI C</strong>
            </u>
          </p>
          <p>ANSI C 関数である <strong>fdopen</strong>()、<strong>fread</strong>()、<strong>freopen</strong>()、<strong>fscanf</strong>()、<strong>vsscanf</strong>()、<strong>vswscanf</strong>()、<strong>wcstox</strong>()、および <strong>wcstoxl</strong>() は <strong>read</strong>().を呼び出します。</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>NX 固有の扱い</strong>
            </u>
          </p>
          <p>ファイルディスクリプタによって NX ファイルであることが示されれば、そのファイルが読み取られます。</p>
          <p>ファイルディスクリプタによってコンソール（&quot;STDIN_FILENO&quot;）であることが示された場合、この関数からは -1 が返されます。NintendoSDK ではコンソールの読み取りをサポートしていないからです。</p>
          <p>ファイルディスクリプタが上記のどれにも一致しない場合、EBADF が設定され、-1 が返されます。</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>次の条件下では、<em>read</em>() 関数と <em>pread</em>() 関数が必ず失敗します。</p>
          <p>
            <strong>EBADF</strong>：fildes 引数が、読み取り対象として開いているファイルの有効なファイルディスクリプタではない場合。</p>
          <p>
            <strong>EISDIR</strong>：fildes 引数がディレクトリを参照して、現在の実装では、そのディレクトリを read() でも pread() でも読み取ることができない場合。代わりに readdir() 関数を使用してください。</p>
          <p>
            <strong>EOVERFLOW</strong>：指定したファイルが通常のファイルであること、nbyte に 0 より大きい値を指定していること、および開始位置がファイル末尾よりも前ではあるが、fildes に関連付けられて開いているファイルの記述で指定している最大オフセット以上であることがすべて成立している場合。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EAGAIN</strong>
              <span style="color: rgb(153,153,153);">：ファイルディスクリプタに O_NONBLOCK フラグを設定していて、プロセスが遅延する場合。</span>
            </span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EBADMSG</strong>：control-normal モードに設定した STREAM ファイルを指定していて、読み取り待ちのメッセージに制御部が存在する場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EINTR</strong>：シグナルを受信したために読み取り操作が終了し、データが転送されなかった場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EINVAL</strong>：fildes が参照する STREAM またはマルチプレクサが、マルチプレクサの下流で（直接であるかどうかに関係なく）リンクされている場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EIO</strong>：目的のプロセスがその制御端末から読み取ろうとするバックグランドプロセスに属している場合、目的のプロセスで SIGTTIN シグナルが無視されるかブロックされる場合、または目的のプロセスグループが孤立している場合。 このエラーは、実装側で定義している理由で発生することもあります。</span>
          </p>
          <p> </p>
          <p>次の条件下では、<em>read</em>() 関数が必ず失敗します。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EAGAIN</strong> または <strong>EWOULDBLOCK</strong>：ファイルディスクリプタがソケットを示していて O_NONBLOCK として指定され、受信待ちのデータが存在しない場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ECONNRESET</strong>：ソケットを読み取ろうとしたため、ピア側で接続を強制的に閉じた場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENOTCONN</strong>：接続していないソケットから読み取ろうとした場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ETIMEDOUT</strong>：ソケットから読み取ろうとして、送信がタイムアウトに達した場合。</span>
          </p>
          <p> </p>
          <p>次の条件下では、<em>read</em>() と <em>pread</em>() 関数が失敗する可能性があります。</p>
          <p>
            <strong>ENOMEM</strong>：要求を処理するためのメモリが不足していた場合。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EIO</strong>：物理的な I/O エラーが発生した場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENOBUFS</strong>：操作を実行するうえで十分なシステムリソースがなかった場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENXIO</strong>：存在しないデバイスに要求を発行した場合またはデバイスの機能を超える要求を発行した場合。</span>
          </p>
          <p> </p>
          <p>次の条件下では、<em>pread</em>() 関数が必ず失敗し、ファイルポインタは変更されません。</p>
          <p>
            <strong>EINVAL</strong>：offset 引数が無効である場合。負数が指定されています。</p>
          <p>
            <strong>EOVERFLOW</strong>：指定したファイルが通常のファイルで、そのファイルに関連付けた最大オフセット位置またはそれを超えた位置から読み取ろうとした場合。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENXIO</strong>：デバイスの機能を超える要求を発行した場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ESPIPE</strong>：fildes がパイプまたは FIFO に関連付けられている場合。</span>
          </p>
          <p>
            <br />
          </p>
          <div class="section">NX には、以下の errno 情報が別途用意されています。</div>
          <div class="section">
            <strong>ENOSPC</strong>：この操作に必要な領域が不足しています。</div>
          <div class="section">
            <strong>EPERM</strong>：不定なエラーです。</div>
          <p>
            <u>
              <strong>
                <br />
              </strong>
            </u>
          </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/2/read">http://linux.die.net/man/2/read</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_4">write()</h4>
          <p>
            <br />
          </p>
          <p>ssize_t <strong>write</strong>(int fd, const void *buf, size_t count)</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>write() は、<em>buf</em> で指定されているバッファから最大で <em>count</em> バイトを、ファイルディスクリプタ <em>fd</em> で参照しているファイルに書き込みます。</p>
          <p> </p>
          <p>
            <u>
              <strong>ANSI C</strong>
            </u>
          </p>
          <p>ANSI C 関数である <strong>fdopen</strong>()、<strong>fflush</strong>()、<strong>freopen</strong>()、<strong>fseek</strong>()、<strong>fwrite</strong>()、<strong>printf</strong>()、<strong>vdprintf</strong>()、<strong>vfprintf</strong>()、<strong>vsnprintf</strong>()、および <strong>vswprintf</strong>() は <strong>write</strong>() を呼び出します。</p>
          <p> </p>
          <p>
            <u>
              <strong>NX 固有の扱い</strong>
            </u>
          </p>
          <p>ファイルディスクリプタによって NX ファイルであることが示されれば、そのファイルに書き込まれます。ファイルディスクリプタによってコンソールであることが示されれば、コンソールに書き込まれます。それ以外の場合は、エラーになります。</p>
          <p>この関数では、必ず <strong><span class="ApiLink_nn__fs__WriteFile">nn::fs::WriteFile</span></strong>() に <strong><span class="ApiLink_nn__fs__WriteOptionFlag_Flush">nn::fs::WriteOptionFlag_Flush</span></strong> が渡されます。</p>
          <p>この関数では、現在のファイル位置を追跡する必要があります。</p>
          <div class="warn_new">
            <div class="warn_new_left">警告：</div>
            <div class="warn_new_right">
              <p>OS による書き込みの終了を待機している間、低レベルの <strong>write</strong>() インターフェースではロックが保持されないので、<strong>write</strong>() が終了した後でファイル位置を更新する処理はスレッドセーフではありません。</p>
              <p> </p>
              <p>高レベルのインターフェース <strong>fwrite</strong>() ではロック（ミューテックス）が保持されるので安全です。</p>
            </div>
          </div>
          <p>ファイルの末尾を超えて読み取ろうとすると、エラーではなくカウントゼロが返されます。</p>
          <p> </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>次の条件下では、<em>write</em>() と <em>pwrite</em>() 関数が必ず失敗します。</p>
          <p>
            <strong>EBADF</strong>：fildes 引数が、書き込み対象として開いているファイルの有効なファイルディスクリプタではない場合。<span style="color: rgb(153,153,153);"> </span></p>
          <p>
            <strong>ENOSPC</strong>：ファイルの格納先であるデバイスに空き領域がない場合。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EAGAIN</strong>：ファイルディスクリプタに O_NONBLOCK フラグを設定していて、write() 操作でスレッドが遅延する場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);"> </span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EFBIG</strong>：実装で定義している最大ファイルサイズまたはプロセスのファイルサイズ制限を超えるサイズのファイルを書き込もうとして、書き込み先の空き領域を使い果たした場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);"> </span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EFBIG</strong>：指定したファイルが通常のファイルであること、nbyte に 0 より大きい値を指定していること、および fildes に関連付けられて開いているファイルの記述で指定している最大オフセット以上の位置に開始位置があることがすべて成立している場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EINTR</strong>：シグナルを受信したために書き込み操作が終了し、データが転送されなかった場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EIO</strong>：目的のプロセスがその制御端末に書き込もうとするバックグランドプロセスグループに属していること、TOSTOP を設定していること、そのプロセスでは SIGTTOU を無視もブロックもしないこと、およびそのプロセスのプロセスグループが孤立していることがすべて成立している場合。 このエラーは、実装側で定義している条件下で返されることもあります。</span>
          </p>
          <p>
            <strong>EPIPE</strong>
            <span style="color: rgb(153,153,153);">：どのようなプロセスでも読み取るために開くことが許可されていないパイプまたは FIFO あるいは一方の端のみが開いているパイプまたは FIFO に書き込もうとした場合。 スレッドには SIGPIPE シグナルも送信されます。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ERANGE</strong>
            </span>
            <span style="color: rgb(153,153,153);">：fildes に関連付けた STREAMS ファイルでサポートされている範囲を超えるサイズの転送要求を発行した場合。</span> </p>
          <p> </p>
          <p>次の条件下では、<em>write</em>() 関数が必ず失敗します。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EAGAIN</strong> または <strong>EWOULDBLOCK</strong>：ファイルディスクリプタがソケットを示していて O_NONBLOCK として指定され、書き込みがブロックされる場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ECONNRESETA</strong>：接続していないソケットに書き込もうとした場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EPIPEA</strong>：書き込みをシャットダウンしているソケットまたは接続を解除されたソケットに書き込もうとした場合。 ソケットの接続が解除されている場合、ソケットが SOCK_STREAM タイプであれば、呼び出し元プロセスに SIGPIPE シグナルが送信されます。</span>
          </p>
          <p> </p>
          <p>次の条件下では、<em>write</em>() と <em>pwrite</em>() 関数が失敗する可能性があります。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EINVAL</strong>：fildes が参照する STREAM またはマルチプレクサが、マルチプレクサの下流で（直接であるかどうかに関係なく）リンクされている場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EIOA</strong>：物理的な I/O エラーが発生した場合。ENOBUFS：操作を実行するうえで十分なシステムリソースがなかった場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENXIOA</strong>：存在しないデバイスに要求を発行した場合またはデバイスの機能を超える要求を発行した場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENXIOA</strong>：書き込み先の STREAM でハングアップが発生した場合。</span>
          </p>
          <p>
            <br />
          </p>
          <div class="section">NX には、以下の errno 情報が別途用意されています。</div>
          <div class="section">
            <strong>ENOMEM</strong> ：この操作に必要なシステムメモリが不足しています。</div>
          <div class="section">
            <strong>EPERM</strong>：不定なエラーです。</div>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/2/write">http://linux.die.net/man/2/write</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_5">lseek()</h4>
          <p>
            <br />
          </p>
          <p>off_t <strong>lseek </strong>(int fd, off_t offset, int whence)</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>lseek</strong>() 関数は、ファイルディスクリプタ <em>fd</em> に関連付けられて開いているファイルのオフセットを、<em>whence</em> ディレクティブに基づいて、次のように引数 <em>offset</em> で指定された位置に再設定します。</p>
          <ul>
            <li>SEEK_SET：オフセットは、offset で指定されたバイト数に設定されます。</li>
            <li>SEEK_CUR： オフセットは、offset で指定されたバイト数を現在の位置に加算した値に設定されます。</li>
            <li>SEEK_END：オフセットは、offset で指定されたバイト数をファイルサイズに加算した値に設定されます。</li>
          </ul>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>ANSI C</strong>
            </u>
          </p>
          <p>ANSI C 関数である <strong>rewinddir</strong>() と <strong>seekdir</strong>() は <strong>lseek</strong>() を呼び出します。</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>NX 固有の扱い</strong>
            </u>
          </p>
          <p>ファイルディスクリプタによって NX ファイルであることが示されれば、ファイルの位置が設定されます。 ファイルディスクリプタによって NX ディレクトリであることが示されると、内部関数が呼び出されます。</p>
          <p> </p>
          <!--Remove-->
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <div class="info_new">
            <div class="info_new_left">参考：</div>
            <div class="info_new_right">
              <p>OS にはシークの概念がないので、ライブラリに位置が記録されます。</p>
              <p>ファイルの末尾を基準としてシークする場合、shim では内部関数を使用して</p>
              <p>そのシークを実行します。</p>
              <p> </p>
            </div>
          </div>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>次の条件下では、<em>lseek</em>() 関数が必ず失敗します。</p>
          <p>
            <strong>EBADF</strong>：fildes 引数が、開いているファイルのファイルディスクリプタではない場合。</p>
          <p>
            <strong>EOVERFLOW</strong>：得られたファイルのオフセットが off_t 型のオブジェクトでは正しく表現できない値である場合。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EINVAL</strong>
              <span style="color: rgb(153,153,153);">：whence 引数が適切な値ではない場合、あるいは通常のファイル、ブロックの特殊ファイル、またはディレクトリに対して得られたファイルのオフセットが負数の場合。</span>
            </span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ESPIPE</strong>：fildes 引数がパイプ、FIFO、またはソケット に関連付けられている場合。</span>
          </p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <div class="section">NX には、以下の errno 情報が別途用意されています。</div>
          <div class="section">
            <strong>ENOMEM</strong> ：この操作に必要なシステムメモリが不足しています。</div>
          <div class="section">
            <strong>ENOSPC</strong>：この操作に必要な領域が不足しています。</div>
          <div class="section">
            <strong>EPERM</strong>：不定なエラーです。</div>
          <p> </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/2/lseek">http://linux.die.net/man/2/lseek</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_6">pread()</h4>
          <p> </p>
          <p>ssize_t <strong>pread</strong>(int fd, void *buf, size_t count, off_t offset);</p>
          <p> </p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>pread</strong>
            <span style="color: rgb(68,68,68);">() は、ディスクリプタ </span>
            <em>ｆｄ</em>
            <span style="color: rgb(68,68,68);"> で指定されたファイルからデータを読み取ります。読み取り開始位置は、ファイルの先頭から </span>
            <em>offset</em>
            <span style="color: rgb(68,68,68);"> で指定された値だけオフセットした位置です。読み取るデータの量は、</span>
            <em>count</em>
            <span style="color: rgb(68,68,68);"> で指定されたバイト数を最大サイズとします。データの読み取り先は、</span>
            <em>buf</em>
            <span style="color: rgb(68,68,68);"> を先頭アドレスとするバッファです。 このファイルの offset は変更されません。</span>
          </p>
          <p> </p>
          <p>
            <u>
              <strong>NX 固有の扱い</strong>
            </u>
          </p>
          <p>ファイルディスクリプタによって NX ファイルであることが示されれば、そのファイルが読み取られます。それ以外の場合は、エラーになります。</p>
          <p> </p>
          <!--Remove-->
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>次の条件下では、<em>read</em>() 関数と <em>pread</em>() 関数が必ず失敗します。</p>
          <p>
            <strong>EBADF</strong>：fildes 引数が、読み取り対象として開いているファイルの有効なファイルディスクリプタではない場合。</p>
          <p>
            <strong>EISDIR</strong>：fildes 引数がディレクトリを参照して、現在の実装では、そのディレクトリを read() でも pread() でも読み取ることができない場合。代わりに readdir() 関数を使用してください。</p>
          <p>
            <strong>EOVERFLOW</strong>：指定したファイルが通常のファイルであること、nbyte に 0 より大きい値を指定していること、および開始位置がファイル末尾よりも前ではあるが、fildes に関連付けられて開いているファイルの記述で指定している最大オフセット以上であることがすべて成立している場合。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EAGAIN</strong>：ファイルディスクリプタに O_NONBLOCK フラグを設定していて、プロセスが遅延する場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EBADMSG</strong>：control-normal モードに設定した STREAM ファイルを指定していて、読み取り待ちのメッセージに制御部が存在する場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EINTR</strong>：シグナルを受信したために読み取り操作が終了し、データが転送されなかった場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EINVAL</strong>：fildes が参照する STREAM またはマルチプレクサが、マルチプレクサの下流で（直接であるかどうかに関係なく）リンクされている場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EIO</strong>：目的のプロセスがその制御端末から読み取ろうとするバックグランドプロセスに属している場合、目的のプロセスで SIGTTIN シグナルが無視されるかブロックされる場合、または目的のプロセスグループが孤立している場合。 このエラーは、実装側で定義している理由で発生することもあります。</span>
          </p>
          <p> </p>
          <p>次の条件下では、<em>read</em>() 関数が必ず失敗します。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EAGAIN</strong> または <strong>EWOULDBLOCK</strong>：ファイルディスクリプタがソケットを示していて O_NONBLOCK として指定され、受信待ちのデータが存在しない場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ECONNRESET</strong>：ソケットを読み取ろうとしたため、ピア側で接続を強制的に閉じた場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENOTCONN</strong>：接続していないソケットから読み取ろうとした場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ETIMEDOUT</strong>：ソケットから読み取ろうとして、送信がタイムアウトに達した場合。</span>
          </p>
          <p> </p>
          <p>次の条件下では、<em>read</em>() と <em>pread</em>() 関数が失敗する可能性があります。</p>
          <p>
            <strong>ENOMEM</strong>：要求を処理するためのメモリが不足していた場合。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EIO</strong>：物理的な I/O エラーが発生した場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENOBUFS</strong>：操作を実行するうえで十分なシステムリソースがなかった場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENXIO</strong>：存在しないデバイスに要求を発行した場合またはデバイスの機能を超える要求を発行した場合。</span>
          </p>
          <p> </p>
          <p>次の条件下では、<em>pread</em>() 関数が必ず失敗し、ファイルポインタは変更されません。</p>
          <p>
            <strong>EINVAL</strong>：offset 引数が無効である場合。負数が指定されています。</p>
          <p>
            <strong>EOVERFLOW</strong>：指定したファイルが通常のファイルで、そのファイルに関連付けた最大オフセット位置またはそれを超えた位置から読み取ろうとした場合。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENXIO</strong>：デバイスの機能を超える要求を発行した場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ESPIPE</strong>：fildes がパイプまたは FIFO に関連付けられている場合。</span>
          </p>
          <p> </p>
          <div class="section">NX には、以下の errno 情報が別途用意されています。</div>
          <div class="section">
            <strong>ENOSPC</strong>：この操作に必要な領域が不足しています。</div>
          <div class="section">
            <strong>EPERM</strong>：不定なエラーです。</div>
          <p>
            <u>
              <strong>
                <br />
              </strong>
            </u>
          </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="https://linux.die.net/man/2/pwrite">https://linux.die.net/man/2/pwrite</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_7">pwrite()</h4>
          <p> </p>
          <p>ssize_t <strong>pwrite</strong>(int fd, const void *buf, size_t count, off_t offset);</p>
          <p> </p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>pwrite</strong>() は、ディスクリプタ <em>fd</em> で指定されたファイルにデータを書き込みます。書き込み開始位置は、<em>offset</em> で指定されたオフセット位置です。書き込むデータは、<em>buf</em> を先頭アドレスとするバッファから取得します。書き込むデータの量は、<em>count</em> で指定されたバイト数を最大サイズとします。このファイルの offset は変更されません。</p>
          <p>
            <em>fd</em> で参照するファイルはシーク可能であることが必要です。</p>
          <p> </p>
          <p>
            <u>
              <strong>NX 固有の扱い</strong>
            </u>
          </p>
          <p>ファイルディスクリプタによって NX ファイルであることが示されれば、そのファイルに書き込まれます。それ以外の場合は、エラーになります。</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>この関数では、必ず <strong><span class="ApiLink_nn__fs__WriteFile">nn::fs::WriteFile</span></strong>() に <strong><span class="ApiLink_nn__fs__WriteOptionFlag_Flush">nn::fs::WriteOptionFlag_Flush</span></strong> が渡されます。</p>
          <p> </p>
          <p>ファイルの末尾を超えて読み取ろうとすると、エラーではなくカウントゼロが返されます。</p>
          <p> </p>
          <!--Remove-->
          <p> </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>次の条件下では、<em>write</em>() と <em>pwrite</em>() 関数が必ず失敗します。</p>
          <p>
            <strong>EBADF</strong>：fildes 引数が、書き込み対象として開いているファイルの有効なファイルディスクリプタではない場合。<span style="color: rgb(153,153,153);"> </span></p>
          <p>
            <strong>ENOSPC</strong>：ファイルの格納先であるデバイスに空き領域がない場合。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EAGAIN</strong>：ファイルディスクリプタに O_NONBLOCK フラグを設定していて、write() 操作でスレッドが遅延する場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);"> </span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EFBIG</strong>：実装で定義している最大ファイルサイズまたはプロセスのファイルサイズ制限を超えるサイズのファイルを書き込もうとして、書き込み先の空き領域を使い果たした場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);"> </span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EFBIG</strong>：指定したファイルが通常のファイルであること、nbyte に 0 より大きい値を指定していること、および fildes に関連付けられて開いているファイルの記述で指定している最大オフセット以上の位置に開始位置があることがすべて成立している場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EINTR</strong>：シグナルを受信したために書き込み操作が終了し、データが転送されなかった場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EIO</strong>：目的のプロセスがその制御端末に書き込もうとするバックグランドプロセスグループに属していること、TOSTOP を設定していること、そのプロセスでは SIGTTOU を無視もブロックもしないこと、およびそのプロセスのプロセスグループが孤立していることがすべて成立している場合。 このエラーは、実装側で定義している条件下で返されることもあります。</span>
          </p>
          <p>
            <strong>EPIPE</strong>
            <span style="color: rgb(153,153,153);">：どのようなプロセスでも読み取るために開くことが許可されていないパイプまたは FIFO あるいは一方の端のみが開いているパイプまたは FIFO に書き込もうとした場合。 スレッドには SIGPIPE シグナルも送信されます。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ERANGE</strong>
            </span>
            <span style="color: rgb(153,153,153);">：fildes に関連付けた STREAMS ファイルでサポートされている範囲を超えるサイズの転送要求を発行した場合。</span>
          </p>
          <p> </p>
          <p>次の条件下では、<em>write</em>() 関数が必ず失敗します。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EAGAIN</strong> または <strong>EWOULDBLOCK</strong>：ファイルディスクリプタがソケットを示していて O_NONBLOCK として指定され、書き込みがブロックされる場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ECONNRESETA</strong>：接続していないソケットに書き込もうとした場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EPIPEA</strong>：書き込みをシャットダウンしているソケットまたは接続を解除されたソケットに書き込もうとした場合。 ソケットの接続が解除されている場合、ソケットが SOCK_STREAM タイプであれば、呼び出し元プロセスに SIGPIPE シグナルが送信されます。</span>
          </p>
          <p> </p>
          <p>次の条件下では、<em>write</em>() と <em>pwrite</em>() 関数が失敗する可能性があります。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EINVAL</strong>：fildes が参照する STREAM またはマルチプレクサが、マルチプレクサの下流で（直接であるかどうかに関係なく）リンクされている場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EIOA</strong>：物理的な I/O エラーが発生した場合。ENOBUFS：操作を実行するうえで十分なシステムリソースがなかった場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENXIOA</strong>：存在しないデバイスに要求を発行した場合またはデバイスの機能を超える要求を発行した場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENXIOA</strong>：書き込み先の STREAM でハングアップが発生した場合。</span>
          </p>
          <p> </p>
          <div class="section">NX には、以下の errno 情報が別途用意されています。</div>
          <div class="section">
            <strong>ENOMEM</strong> ：この操作に必要なシステムメモリが不足しています。</div>
          <div class="section">
            <strong>EPERM</strong>：不定なエラーです。</div>
          <p> </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="https://linux.die.net/man/2/pwrite">https://linux.die.net/man/2/pwrite</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_8">close()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>close</strong> (int files)</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>close</strong>() はファイルディスクリプタを閉じます。そのファイルディスクリプタは、どのファイルも参照しなくなるので再利用できるようになります。</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>ANSI C</strong>
            </u>
          </p>
          <p>ANSI C 関数である <strong>closedir</strong>()、<strong>fopen</strong>()、<strong>fclose</strong>()、<strong>fdopen</strong>()、<strong>fscanf</strong>()、および <strong>freopen</strong>() は <strong>close</strong>() を呼び出します。</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>NX 固有の扱い</u>
            </strong>
          </p>
          <ul>
            <li>ファイルディスクリプタによって NX ファイルであることが示されれば、そのファイルが閉じられます。 ファイルディスクリプタによって NX ディレクトリであることが示されると、内部関数が呼び出されます。<br /></li>
            <li>NX ファイルが書き込み可能であれば、そのファイルはフラッシュされます。</li>
          </ul>
          <div class="warn_new">
            <div class="warn_new_left">警告：</div>
            <div class="warn_new_right">
              <p>この関数はフラッシュ機能を呼び出しません。posix インターフェースでは Nintendo SDK の <strong>FlushWrite</strong>() をサポートしていません。posix インターフェースは、出力をフラッシュするフラグをすべての <strong>WriteFile</strong>() 呼び出しに渡します。</p>
            </div>
          </div>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>次の条件下では、<em>close</em>() 関数が必ず失敗します。</p>
          <p>
            <strong>EBADF</strong>：fildes 引数が有効なファイルディスクリプタではない場合。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EINTR</strong>：close() 関数がシグナルによって中断された場合。</span>
          </p>
          <p> </p>
          <p>次の条件下では、<em>close</em>() 関数が失敗する可能性があります。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EIO</strong>：ファイルシステムとの読み取りまたは書き込みで I/O エラーが発生した場合。</span>
          </p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/2/close">http://linux.die.net/man/2/close</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_9">ftruncate()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>ftruncate</strong> (int fd, off_t length)</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>truncate</strong>() 関数および <strong>ftruncate</strong>() 関数を使用すると、<em>path</em> で指定した通常のファイルまたは <em>fd</em> で参照する通常のファイルが正確に <em>length</em> バイトのサイズに切り詰められます。</p>
          <p>ファイルがこのサイズよりも長い場合は、そのサイズを超える分のデータが失われます。ファイルのサイズがこのサイズよりも短い場合は、このサイズまで拡張されます。拡張された部分は NULL バイト（'\0'）として読み取られます。</p>
          <p> </p>
          <p>
            <u>
              <strong>NX 固有の扱い</strong>
            </u>
          </p>
          <p>なし</p>
          <!--Remove-->
          <p>
            <u>
              <strong>
                <br />
              </strong>
            </u>
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>次の条件下では、<em>ftruncate</em>() 関数が必ず失敗します。</p>
          <p>
            <strong>EFBIG</strong>
            <span style="color: rgb(153,153,153);"> または </span>
            <strong>
              <span style="color: rgb(153,153,153);">EINVAL</span>
            </strong>：length 引数が最大ファイルサイズを超える値である場合。</p>
          <p>
            <strong>EFBIG</strong>：目的のファイルが通常のファイルであり、fildes に関連付けられて開いているファイルの記述で設定した最大オフセット値よりも length が大きい場合。</p>
          <p>
            <strong>EBADF</strong>
            <span style="color: rgb(153,153,153);"> または </span>
            <strong>
              <span style="color: rgb(153,153,153);">EINVAL</span>
            </strong>：fildes 引数が、書き込み先として開いているファイルのファイルディスクリプタではない場合。</p>
          <p>
            <strong>EINVAL</strong>：書き込み許可なしで開いたファイルを fildes 引数で参照している場合。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EINVAL </strong>
              <span style="color: rgb(153,153,153);">：length 引数が 0 未満である場合。</span>
            </span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EINTR</strong>：実行時にシグナルが検出された場合。</span>
            <span style="color: rgb(153,153,153);"> </span>
          </p>
          <div>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EIO</strong>：ファイルシステムとの読み取りまたは書き込みで I/O エラーが発生した場合。</span>
            </p>
          </div>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EROFS</strong>：指定したファイルが読み取り専用のファイルシステムに置かれている場合。</span>
          </p>
          <p>
            <br />
          </p>
          <div class="section">NX には、以下の errno 情報が別途用意されています。</div>
          <div class="section">
            <strong>ENOENT</strong>：目的のファイルが存在しません。</div>
          <div class="section">
            <strong>ENOMEM</strong> ：この操作に必要なシステムメモリが不足しています。</div>
          <div class="section">
            <strong>EOVERFLOW </strong>：得られたファイルが範囲外です。</div>
          <div class="section">
            <strong>ENOSPC</strong>：この操作に必要な領域が不足しています。</div>
          <div class="section">
            <strong>EPERM</strong>：不定なエラーです。</div>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/2/ftruncate">http://linux.die.net/man/2/ftruncate</a>
          </p>
          <p>
            <br />
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_10">fstat()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>fstat</strong>(int fd, struct stat *buf)</p>
        </td>
        <td>
          <p>
            <strong>
              <u>説明</u>
            </strong>
          </p>
          <p>これらの関数は、ファイルに関する情報を返します。</p>
          <p>
            <strong>stat</strong>() は、<em>path</em> が指しているファイルに関する情報を取得し、<em>buf</em> に入力します。</p>
          <p>
            <strong>lstat</strong>() は <strong>stat</strong>() と同じですが、<em>path</em>がシンボリックリンクの場合は、そのリンクが参照しているファイルの情報ではなく、リンクそのものに関する情報を取得する点が異なります。</p>
          <p>
            <strong>fstat</strong>() は <strong>stat</strong>() と同じですが、情報の取得元とするファイルをファイルディスクリプタ <em>fd</em> で指定する点が異なります。</p>
          <p> </p>
          <p>
            <u>
              <strong>ANSI C</strong>
            </u>
          </p>
          <p>ANSI C 関数である <strong>fdopendir</strong>() は <strong>fstat</strong>() を呼び出します。</p>
          <p> </p>
          <p>
            <strong>
              <u>NX 固有の扱い</u>
            </strong>
          </p>
          <p>NX ファイルのサイズのみを取得します。その他のフィールドには次の固定値が設定されます。</p>
          <p>st-&gt;st_dev = 0<br />st-&gt;st_ino = 0<br />st-&gt;st_mode = 0666<br />st-&gt;st_nlink = 1<br />st-&gt;st_uid = 99<br />st-&gt;st_gid = -1<br />st-&gt;st_rdev = 0<br />st-&gt;st_atime = 0<br />st-&gt;st_mtime = 0<br />st-&gt;st_ctime = 0</p>
          <p>
            <strong>
              <u>
                <br />
              </u>
            </strong>
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Errno</u>
            </strong>
          </p>
          <p>次の条件下では、<em>fstat</em>() 関数が必ず失敗します。</p>
          <p>
            <strong>EBADF</strong>：fildes 引数が有効なファイルディスクリプタではない場合。</p>
          <p>
            <strong>EOVERFLOW</strong>：バイト単位のファイルサイズ、ファイルに割り当てられたブロック数、ファイルのシリアル番号のいずれも、buf が指す構造体で正しく表現できない場合。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EIO</strong>：ファイルシステムからの読み取りで I/O エラーが発生した場合。</span>
          </p>
          <p>次の条件下では、<em>fstat</em>() 関数が失敗する可能性があります。</p>
          <p>
            <strong>EOVERFLOW</strong> ：buf 引数が指している構造体に格納できないサイズの値がある場合。</p>
          <p>
            <br />
          </p>
          <div class="section">NX には、以下の errno 情報が別途用意されています。</div>
          <div class="section">
            <strong>ENOENT</strong>：目的のファイルが存在しません。</div>
          <div class="section">
            <strong>ENOMEM</strong> ：この操作に必要なシステムメモリが不足しています。</div>
          <div class="section">
            <strong>ENOSPC</strong>：この操作に必要な領域が不足しています。</div>
          <div class="section">
            <strong>EPERM</strong>：不定なエラーです。</div>
          <p> </p>
          <p>
            <strong>
              <u>詳細情報</u>
            </strong>
          </p>
          <p>
            <a href="http://linux.die.net/man/2/fstat">http://linux.die.net/man/2/fstat</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_11">access()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>access</strong> (const char *path, int amode)</p>
        </td>
        <td>
          <p>
            <strong>説明</strong>
          </p>
          <p>ファイルに対するユーザの許可をチェックします。 </p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>NX 固有の扱い</u>
            </strong>
          </p>
          <p>なし</p>
          <div class="info_new">
            <div class="info_new_left">参考：</div>
            <div class="info_new_right">
              <p>NX では、既に開いているファイルを開くことはできません。開いているファイルを開こうとすると、errno として EBUSY が返されます。そのようなファイルを O_RDONLY モードで開いている場合はエラーが返されません。</p>
            </div>
          </div>
          <p>
            <strong>
              <u>
                <br />
              </u>
            </strong>
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>次の条件下では、<em>access() </em>関数が必ず失敗します。<span style="color: rgb(153,153,153);"> </span></p>
          <p>
            <strong>ENOENT</strong>：pathname のディレクトリ部分が存在しないか、参照先を失ったシンボリックリンクである場合。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EACCES</strong>
              <span style="color: rgb(153,153,153);">：要求したアクセスがファイルで拒否された場合または pathname のパス接頭辞が示すディレクトリのいずれかで検索許可が拒否された場合 （path_resolution(7) も参照）。</span>
            </span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENAMETOOLONG</strong>
              <span style="color: rgb(153,153,153);">：pathname が長すぎる場合。</span>
            </span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENOTDIR</strong>：pathname でディレクトリとして使用している構成要素が実際にはディレクトリではない場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ELOOP</strong>：pathname の解決時に検出されたシンボリックリンクの数が多すぎる場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EROFS</strong>：読み取り専用のファイルシステムにあるファイルに対して書き込み許可を要求した場合。</span>
          </p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>次の条件下では、<em>access()</em> 関数が失敗する可能性があります。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENOMEM</strong>：カーネルメモリ量が不足している場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EFAULT</strong>：pathname が、アクセス可能なアドレス空間の外部を指している場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EINVAL</strong>：正しくないモードを指定した場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EIO</strong>：I/O エラーが発生した場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ETXTBSY</strong>：実行中の実行可能ファイルに書き込みアクセスを要求した場合。</span>
          </p>
          <p>
            <br />
          </p>
          <div class="section">NX には、以下の errno 情報が別途用意されています。</div>
          <div class="section">
            <strong>EBUSY</strong>：リソースがビジー状態で、書き込み先として使用できません。</div>
          <div class="section">
            <strong>ENOMEM</strong> ：この操作に必要なシステムメモリが不足しています。</div>
          <div class="section">
            <strong>ENOSPC</strong>：この操作に必要な領域が不足しています。</div>
          <div class="section">
            <strong>EPERM</strong>：不定なエラーです。</div>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>詳細情報</u>
            </strong>
          </p>
          <p>
            <a href="http://linux.die.net/man/2/access" style="text-decoration: underline;">http://linux.die.net/man/2/access</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_12">rename()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>rename</strong> (const char *old, const char *new)</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>rename</strong>() はファイルの名前を変更し、そのファイルを必要に応じて別のディレクトリに移動します。 ファイルに対するその他のハードリンク（<em><a href="http://linux.die.net/man/2/link">link</a>(2)</em> を使用して作成したリンク）は影響を受けません。 <em>oldpath</em></p>
          <p> </p>
          <p>
            <strong>
              <u>NX 固有の扱い</u>
            </strong>
          </p>
          <p>NX では、既存ファイルと同じ名前に変更することはできません。 既存のファイル名が <em>new</em> に設定されると、errno EPERM が返されます。</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Errno</u>
            </strong>
          </p>
          <p>次の条件下では、<em>rename</em>() 関数が必ず失敗します。</p>
          <p>
            <strong>EACCES</strong>：いずれか一方のパス接頭辞の構成要素で検索許可が拒否された場合、old 引数または new 引数をパス名に持つディレクトリで書き込み許可が拒否された場合、あるいは書き込み許可が必要な状況で、old 引数または new 引数が指しているディレクトリでその許可が拒否された場合。</p>
          <p>
            <strong>EBUSY</strong>
            <span style="color: rgb(0,51,102);">：old または new で指定されているディレクトリがシステムまたは別のプロセスで現在使用されているために、この操作が実装側でエラーと見なされる場合。</span>
          </p>
          <p>
            <strong>EEXIST</strong> または <strong>ENOTEMPTY</strong>：new で指定したリンク先が空のディレクトリではない場合。</p>
          <p>
            <strong>EINVAL</strong>：new で指定したディレクトリのパス名に、old で指定したディレクトリを指定する接頭辞が使用されている場合。</p>
          <p>
            <strong>EMLINK</strong>：old で指定したファイルがディレクトリであり、new で指定したディレクトリの親ディレクトリへのリンク数が {LINK_MAX} を超えている場合。</p>
          <p>
            <strong>ENAMETOOLONG</strong>：old 引数または new 引数の長さが {PATH_MAX} を超えているか、パス名の部分が {NAME_MAX} より長い場合。</p>
          <p>
            <strong>ENOENT</strong>：old で指定されたリンクが既存のファイルを指定していないか、old または new が空の文字列を指している場合。</p>
          <p>
            <strong>ENOTDIR</strong>：いずれか一方のパス接頭辞の構成要素がディレクトリではない場合、または old 引数がディレクトリを指定し、new 引数がディレクトリではないファイルを指定している場合。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EIO</strong>：物理的な I/O エラーが発生した場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EISDIR</strong>：new 引数がディレクトリを指し、old 引数がディレクトリではないファイルを指している場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ELOOP</strong>：path 引数を解決するときにシンボリックリンクにループが検出された場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENOSPC</strong>：new 引数で指定されたパスにあるディレクトリを展開できない場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EPERM</strong> または <strong>EACCES</strong>：old が参照するファイルを格納したディレクトリに対して S_ISVTX フラグが設定されていて、呼び出し元がそのファイルの所有者でもそのディレクトリの所有者でもなく、適切な権限も持っていない場合、または new が既存のファイルを参照し、そのファイルを格納しているディレクトリに対して S_ISVTX フラグが設定されていて、呼び出し側がそのファイルの所有者でもそのディレクトリの所有者でもなく、適切な権限も持っていない場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EROFS</strong>：読み取り専用のファイルシステム上にあるディレクトリで、目的の操作が書き込みを要求している場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EXDEV</strong>：new および old で指定されたリンクが互いに別々のファイルシステム上にあり、これらのファイルシステム間のリンクが実装でサポートされていない場合。</span>
          </p>
          <p> </p>
          <p>次の条件下では、<em>rename</em>() 関数が失敗する可能性があります。</p>
          <p>
            <strong>ENAMETOOLONG</strong>：path 引数の解決でシンボリックリンクを検出した結果、代入されたパス名文字列の長さが {PATH_MAX} を超えた場合。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EBUSY</strong>：old 引数または new 引数で指定したファイルが名前付き STREAM である場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ELOOP</strong>：path 引数の解決で {SYMLOOP_MAX} 個を超えるシンボリックリンクが検出された場合。</span>
          </p>
          <p>
            <strong>ETXTBSY</strong>
            <span style="color: rgb(153,153,153);">：名前変更の対象とするファイルが、プロシージャ（共有テキスト）のみを記述した実行中のファイルである場合。</span>
          </p>
          <p>
            <u>
              <strong>
                <br />
              </strong>
            </u>
          </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/rename">http://linux.die.net/man/3/rename</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_13">remove()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>remove </strong>(const char *filename)</p>
        </td>
        <td>
          <p>
            <strong>
              <u>説明</u>
            </strong>
          </p>
          <p>
            <strong>remove</strong>() は、ファイルシステムから名前を削除します。 ファイルに対しては <em><a href="http://linux.die.net/man/2/unlink">unlink</a>(2)</em> が呼び出され、ディレクトリに対しては <em><a href="http://linux.die.net/man/2/rmdir">rmdir</a>(2)</em> が呼び出されます。</p>
          <p>
            <strong>
              <u>
                <br />
              </u>
            </strong>
          </p>
          <p>
            <strong>
              <u>NX 固有の扱い</u>
            </strong>
          </p>
          <p>なし</p>
          <p>
            <strong>
              <u>
                <br />
              </u>
            </strong>
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>Errno</u>
            </strong>
          </p>
          <p>
            <strong>EBUSY</strong>：ファイルの <em>pathname</em> がシステムまたは別のプロセスで使用されているため、このパス名へのリンクを解除できない場合。例えば、このパス名がマウントポイントである場合や、本来は名前のない inode であるノードをアクティブにするために NFS クライアントソフトウェアで作成され、NFS で不適切に名前変更されたパス名である場合が考えられます。</p>
          <p>
            <strong>EINVAL</strong>：<em>pathname</em> 末尾の構成要素が <em>.</em>（ピリオド）である場合。</p>
          <p>
            <strong>ENOENT</strong>：<em>pathname</em> の構成要素が存在しないか参照先を失ったシンボリックリンクである場合、または <em>pathname</em> が空白である場合。</p>
          <p>
            <strong>ENOMEM</strong>：カーネルメモリ量が不足している場合。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EACCES</strong>
              <span style="color: rgb(153,153,153);">：</span>
              <em>pathname</em>
              <span style="color: rgb(153,153,153);"> をパス名に持つディレクトリへの書き込みアクセスがプロセスの実効 UID で許可されていないか、</span>
              <em>pathname</em>
              <span style="color: rgb(153,153,153);"> で指定されているディレクトリのいずれかで検索が許可されていない場合。 （</span>
              <em>
                <a href="http://linux.die.net/man/7/path_resolution">
                  <span style="color: rgb(153,153,153);">path_resolution</span>
                </a>(7)</em>
              <span style="color: rgb(153,153,153);"> も参照）。</span>
            </span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EFAULT</strong>：<em>pathname</em> が、アクセス可能なアドレス空間の外部を指している場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EIO</strong>：I/O エラーが発生した場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EISDIR</strong>：<em>pathname</em><span style="color: rgb(153,153,153);"> がディレクトリを参照している場合 （これは、Linux 2.1.132 以降で返される POSIX ではない値です）。</span></span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ELOOP</strong>：<em>pathname</em> の変換時に検出されたシンボリックリンクの数が多すぎる場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENAMETOOLONG</strong>：<em>pathname</em><span style="color: rgb(153,153,153);"> が長すぎる場合。</span></span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENOTDIR</strong>：<em>pathname</em> でディレクトリとして使用している構成要素が実際にはディレクトリではない場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENOTEMPTY</strong>：<em>pathname</em> に <em>.</em> でも <em>..</em> でもないエントリがある場合、または <em>pathname</em> の最後の部分に <em>..</em> が使用されている場合。 POSIX.1-2001 では、この条件下でも <strong>EEXIST</strong> を使用できます。</span>
          </p>
          <p>
            <strong>EPERM</strong>
            <span style="color: rgb(153,153,153);">：ディレクトリのリンク解除がシステムで許可されていないか、呼び出し側のプロセスが持っていない権限がディレクトリのリンク解除で必要な場合 （これは、上記のとおり、POSIX に規定されたエラーの戻り値です。この場合、Linux からは </span>
            <strong>EISDIR</strong>
            <span style="color: rgb(153,153,153);"> が返されます）。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EPERM</strong>：（Linux のみ）ファイルのリンク解除がファイルシステムで許可されていない場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EPERM</strong> または <strong>EACCES</strong>：<em>pathname</em> をパス名に持つディレクトリにスティッキービット（<strong>S_ISVTX</strong>）が設定されていること、プロセスの実効 UID が削除対象ファイルの UID ではなく、そのファイルを格納しているディレクトリの UID でもないこと、およびプロセスに何の権限も与えられていないことがすべて成立している場合（Linux では <strong>CAP_FOWNER</strong> の機能がありません）。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EROFS</strong>：<em>pathname</em> が読み取り専用ファイルシステムのファイルを参照している場合。</span>
          </p>
          <p>
            <br />
          </p>
          <div class="section">NX には、以下の errno 情報が別途用意されています。</div>
          <div class="section">
            <strong>ENOSPC</strong>：この操作に必要な領域が不足しています。</div>
          <div class="section">
            <strong>EPERM</strong>：不定なエラーです。</div>
          <p>
            <strong>
              <u>
                <br />
              </u>
            </strong>
          </p>
          <p>
            <strong>
              <u>詳細情報</u>
            </strong>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/remove">http://linux.die.net/man/3/remove</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_14">mkdir()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>mkdir </strong>(const char *path, mode_t mode)</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
            <br />
            <strong>mkdir</strong>（） 関数は、<em>path</em> を名前とする新規ディレクトリを作成します。</p>
          <p>
            <u>
              <br />
            </u>
          </p>
          <p>
            <strong>
              <u>NX 固有の扱い</u>
            </strong>
          </p>
          <p>なし</p>
          <p> </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <strong>EEXIST</strong>：<em>pathname</em> が既に存在している場合（ディレクトリではなくても同様）。 <em>pathname</em> がシンボリックリンクである場合も、その参照先があるかどうかに関係なく、同じ扱いとなります。</p>
          <p>
            <strong>EFAULT</strong>：<em>pathname</em> が、アクセス可能なアドレス空間の外部を指している場合。</p>
          <p>
            <strong>EMLINK</strong>：親ディレクトリへのリンク数が <strong>LINK_MAX</strong> を超える場合。</p>
          <p>
            <strong>ENAMETOOLONG</strong>：<em>pathname</em> が長すぎる場合。</p>
          <p>
            <strong>ENOENT</strong>：<em>pathname</em> のディレクトリ部分が存在しないか、参照先を失ったシンボリックリンクである場合。</p>
          <p>
            <strong>ENOMEM</strong>：カーネルメモリ量が不足している場合。</p>
          <p>
            <strong>ENOSPC</strong>：<em>pathname</em> をパス名に持つデバイスに、新しいディレクトリを作成するための空き領域がない場合。</p>
          <p>
            <strong>ENOSPC</strong>：ユーザのディスククォータを使い切ったため、新しいディレクトリを作成できない場合。</p>
          <p>
            <strong>ENOTDIR</strong>：<em>pathname</em> でディレクトリとして使用している構成要素が実際にはディレクトリではない場合。</p>
          <p>
            <span style="color: rgb(153,153,153);"> </span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EACCES</strong>：プロセスによる書き込みが親ディレクトリで許可されていないか、<em>pathname</em> で指定されているディレクトリのいずれかで検索が許可されていない場合 （<em><strong><a href="http://linux.die.net/man/7/path_resolution"><span style="color: rgb(153,153,153);">path_resolution</span></a></strong>(7)</em> も参照）。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);"> </span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EDQUOT</strong>：ディスクブロックにあるユーザのクォータまたはファイルシステムにある inode を使い切った場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);"> </span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ELOOP</strong>：<em>pathname</em> の解決時に検出されたシンボリックリンクの数が多すぎる場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EPERM</strong>：<em>pathname</em> を格納しているファイルシステムでディレクトリの作成がサポートされていない場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EROFS</strong>：<em>pathname</em> が読み取り専用ファイルシステムのファイルを参照している場合。</span>
          </p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>詳細情報</u>
            </strong>
          </p>
          <p>
            <a href="http://linux.die.net/man/2/mkdir">http://linux.die.net/man/2/mkdir</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_15">rmdir()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>rmdir </strong>(const char *path)</p>
        </td>
        <td>
          <p>
            <strong>
              <u>説明</u>
            </strong>
          </p>
          <p>
            <strong>rmdir</strong>() 関数は、<em>path</em> で指定された名前のディレクトリを削除します。 指定したディレクトリは、空である場合にのみ削除されます。</p>
          <p>
            <strong>
              <u>
                <br />
              </u>
            </strong>
          </p>
          <p>
            <strong>
              <u>NX 固有の扱い</u>
            </strong>
          </p>
          <p>なし<strong><br /></strong></p>
          <p> </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EFAULT</strong>：<em>pathname</em> が、アクセス可能なアドレス空間の外部を指している場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EINVAL</strong>：<em>pathname</em> 末尾の構成要素が <em>.</em>（ピリオド）である場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENAMETOOLONG</strong>：<em>pathname</em> が長すぎる場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENOENT</strong>：<em>pathname</em> のディレクトリ部分が存在しないか、参照先を失ったシンボリックリンクである場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENOMEM</strong>：カーネルメモリ量が不足している場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENOTDIR</strong>：<em>pathname</em> または <em>pathname</em> でディレクトリとして使用されている構成要素が実際にはディレクトリではない場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENOTEMPTY</strong>：<em>pathname</em> に <em>.</em> でも <em>..</em> でもないエントリがある場合、または <em>pathname</em> の最後の部分に <em>..</em> が使用されている場合。 POSIX.1-2001 では、この条件下でも <strong>EEXIST</strong> を使用できます。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EACCES</strong>：<em>pathname</em> をパス名に持つディレクトリへの書き込みアクセスが許可されていないか、<em>pathname</em> のパス接頭辞で指定されているディレクトリのいずれかで検索が許可されていない場合 （<em><strong><a href="http://linux.die.net/man/7/path_resolution"><span style="color: rgb(153,153,153);">path_resolution</span></a></strong>(7)</em> も参照）。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EBUSY</strong>：現在 <em>pathname</em> がシステムで使用されているか、そのパスが削除されないようにしている何らかのプロセスで使用されている場合。 Linux の場合、<em>pathname</em> が現在マウントポイントとして使用されているか、呼び出し元プロセスのルートディレクトリであることを意味します</span>。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ELOOP</strong>：<em>pathname</em> の解決時に検出されたシンボリックリンクの数が多すぎる場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EPERM</strong>：<em>pathname</em> をパス名に持つディレクトリにスティッキービット（<strong>S_ISVTX</strong>）が設定されていること、プロセスの実効ユーザ ID が削除対象ファイルのユーザ ID ではなく、そのファイルを格納しているディレクトリのユーザ ID でもないこと、およびプロセスに何の権限も与えられていないことがすべて成立している場合（Linuxでは <strong>CAP_FOWNER</strong> の機能がありません）。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EPERM</strong>：<em>pathname</em> を格納しているファイルシステムでディレクトリの削除がサポートされていない場合。</span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EROFS</strong>：<em>pathname</em> が読み取り専用ファイルシステムのディレクトリを参照している場合。</span>
          </p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>詳細情報</u>
            </strong>
          </p>
          <p>
            <a href="http://linux.die.net/man/2/rmdir">http://linux.die.net/man/2/rmdir</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_16">opendir()</h4>
          <p>
            <br />
          </p>
          <p>DIR *<strong>opendir </strong>(const char *name)</p>
        </td>
        <td>
          <p>
            <strong>
              <u>説明</u>
            </strong>
          </p>
          <p>
            <strong>opendir</strong>() 関数は、ディレクトリ <em>name</em> に対応するディレクトリストリームを開き、そのディレクトリストリームへのポインタを返します。 このストリームは、ディレクトリの先頭エントリに配置されます。</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>NX 固有の扱い</strong>
            </u>
          </p>
          <ul>
            <li>opendir() は、Linux では open() を呼び出すだけですが、NintendoSDK API では別の<br />ルーチンを呼び出す必要があります。</li>
            <li>この関数に対する制限が scandir() の動作に影響することがあります。<ul><li>int scandir(const char *, struct dirent ***, int (*)(const struct dirent *), int (*)(const struct dirent **, const struct dirent **));</li><li><a href="http://linux.die.net/man/3/scandir">http://linux.die.net/man/3/scandir</a><br /><br /></li></ul></li>
          </ul>
          <div class="warn_new">
            <div class="warn_new_left">警告：</div>
            <div class="warn_new_right">
              <p>
                <strong>opendir</strong>() は、calloc() を使用して DIR * 構造体を割り当てます。</p>
            </div>
          </div>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <strong>EBADF</strong>：<em>fd</em> が、読み取り元として開いているファイルの有効なファイルディスクリプタではない場合。</p>
          <div>
            <p>
              <strong>EMFILE</strong>：プロセスで使用しているファイルディスクリプタの数が多すぎる場合。</p>
          </div>
          <div>
            <p>
              <strong>ENFILE</strong>：システムで現在開いているファイルの数が多すぎる場合。</p>
          </div>
          <div>
            <p>
              <strong>ENOENT</strong>：ディレクトリが存在しないか、<em>name</em> が空の文字列である場合。</p>
          </div>
          <div>
            <p>
              <strong>ENOMEM</strong>：処理を完了するためのメモリが不足している場合。</p>
          </div>
          <p>
            <strong>ENOTDIR</strong>：<em>name</em> がディレクトリではない場合。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EACCES</strong>：許可が拒否された場合。</span>
          </p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/opendir">http://linux.die.net/man/3/opendir</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_17">readdir() および readdir_r()</h4>
          <p>
            <br />
          </p>
          <p>struct dirent *<strong>readdir</strong>(DIR *dirp)</p>
          <p>
            <br />
          </p>
          <p>int <strong>readdir_r</strong>(DIR *restrict dirp, struct dirent *restrict entry, struct dirent **restrict result)</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>readdir</strong>() 関数は、<em>dirent</em> 構造体へのポインタを返します。この構造体は、<em>dirp</em> が指すディレクトリストリームの中で次の順番にあるディレクトリエントリを表します。 ディレクトリストリームの末尾に達した場合またはエラーが発生した場合は NULL を返します。</p>
          <p>
            <strong>readdir_r</strong>() 関数は、<strong>readdir</strong>() の再入可能なバージョンです。 ディレクトリストリーム <em>dirp</em> から次の順番にあるディレクトリエントリを読み取り、<em>entry</em> が指している呼び出し元割り当てバッファに返します。</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>注意</strong>
            </u>
          </p>
          <p>readdir() は、dir-&gt;buf を次のように構造体 dirent * のパラメータとして渡します。</p>
          <table class="codeblock">
            <tbody>
              <tr>
                <td class="code">
                  <div class="codeblock"><pre>struct dirent *readdir(DIR *dir)
{
&nbsp;&nbsp;&nbsp;&nbsp;int result = __nnmusl_FileReaddir(dir-&gt;fd,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(struct dirent *) dir-&gt;buf);
&nbsp;&nbsp;&nbsp;&nbsp;if (result == 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (struct dirent *) dir-&gt;buf;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return NULL;
}</pre></div>
                </td>
              </tr>
            </tbody>
          </table>
          <p>
            <br />
          </p>
          <p>
            <strong>readdir</strong>() と異なり、<strong>readdir_r</strong>() では、次のようにバッファに渡す必要があります。</p>
          <table class="codeblock">
            <tbody>
              <tr>
                <td class="code">
                  <div class="codeblock"><pre>int readdir_r(DIR *restrict dir,
&nbsp;&nbsp;&nbsp;&nbsp;struct dirent *restrict buf,
&nbsp;&nbsp;&nbsp;&nbsp;struct dirent **restrict result)
{
&nbsp;&nbsp;&nbsp;&nbsp;int error = __nnmusl_FileReaddir(dir-&gt;fd, buf);
&nbsp;&nbsp;&nbsp;&nbsp;if (error == 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*result = buf;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return error;
}</pre></div>
                </td>
              </tr>
            </tbody>
          </table>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>NX 固有の扱い</strong>
            </u>
          </p>
          <p>buf（現在のサイズは 2048）に <strong>dirent</strong> 構造体の全体を保持できるようにする必要があります。</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p> </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <strong>EBADF</strong>：ディレクトリストリームのディスクリプタ <em>dirp</em> が無効です。</p>
          <p>
            <br />
          </p>
          <p>
            <strong>
              <u>詳細情報</u>
            </strong>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/readdir">http://linux.die.net/man/3/readdir</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_18">rewinddir()</h4>
          <p>
            <br />
          </p>
          <p>void <strong>rewinddir</strong>(DIR *dirp)</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>rewinddir</strong>() 関数は、ディレクトリストリーム <em>dirp</em> の位置をディレクトリの先頭にリセットします。</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>注意</strong>
            </u>
          </p>
          <div class="note_new">
            <div class="note_new_left">注意：</div>
            <div class="note_new_right">
              <p>NX の場合、オフセットには <strong>sizeof</strong>(<strong>nn::fs::DirectoryEntry</strong>) の倍数を指定する必要があります。</p>
              <p> </p>
              <p>
                <strong>lseek</strong>() と同様、NintendoSDK API には同等の関数がありません。</p>
              <p> </p>
              <p>nnmsl は所定の場所を記録した後、その値を <strong>sizeof</strong>(<strong>nn::fs::DirectoryEntry</strong>) で除算し、ReadDirectory に渡すインデックスを決定します。</p>
              <p> </p>
              <p>
                <strong>sizeof(nn::fs::DirectoryEntry)</strong> に基づいてオフセットを生成しないようにする必要があります。<strong>telldir()</strong> で返されるオフセットを使用してください。</p>
              <p> </p>
            </div>
          </div>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>NX 固有の扱い</strong>
            </u>
          </p>
          <p>なし</p>
          <p>
            <br />
          </p>
          <!--Remove-->
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>なし</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/rewinddir">http://linux.die.net/man/3/rewinddir</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_19">telldir()</h4>
          <p>
            <br />
          </p>
          <p>long <strong>telldir</strong>(DIR *dirp)</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>telldir</strong>() 関数は、ディレクトリストリーム <em>dirp</em> に関連付けられた現在の場所を返します。</p>
          <p>
            <em>
              <br />
            </em>
          </p>
          <p>
            <u>
              <strong>NX 固有の扱い</strong>
            </u>
          </p>
          <p>なし</p>
          <p> </p>
          <p>
            <u>
              <strong>インターフェース関数</strong>
            </u>
          </p>
          <p>
            <strong>dir</strong>-&gt;<strong>tell</strong>の値をそのまま返します。</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>なし</p>
          <p> </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/telldir">http://linux.die.net/man/3/telldir</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_20">dirfd()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>dirfd</strong>(DIR *dirp)</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>dirfd</strong>() 関数は、ディレクトリストリーム <em>dirp</em> に関連付けられたファイルディスクリプタを返します。</p>
          <p>
            <em>
              <br />
            </em>
          </p>
          <p>
            <u>
              <strong>NX 固有の扱い</strong>
            </u>
          </p>
          <p>なし</p>
          <p> </p>
          <p>
            <u>
              <strong>インターフェース関数</strong>
            </u>
          </p>
          <p>
            <strong>dir</strong>-&gt;<strong>fd</strong>の値をそのまま返します。</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>なし</p>
          <p> </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/dirfd">http://linux.die.net/man/3/dirfd</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_21">closedir()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>closedir </strong>(DIR *dirp)</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>closedir</strong>() 関数は、<em>dirp</em> に関連付けられたディレクトリストリームを閉じます。</p>
          <p>
            <em>
              <br />
            </em>
          </p>
          <p>
            <u>
              <strong>NX 固有の扱い</strong>
            </u>
          </p>
          <p>なし</p>
          <p> </p>
          <!--Remove-->
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <strong>EBADF</strong>：ディレクトリストリームのディスクリプタ <em>dirp</em> が無効な場合。</p>
          <p> </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/closedir">http://linux.die.net/man/3/closedir</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_22">open_memstream() and open_wmemstream()</h4>
          <p> </p>
          <p>FILE *<strong>open_memstream</strong>(char **bufp, size_t *sizep);</p>
          <p> </p>
          <p>FILE *<strong>open_wmemstream</strong>(wchar_t **bufp, size_t *sizep)</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>open_memstream</strong>（） 関数および <strong>open_wmemstream</strong>（） 関数は、動的に割り当てられたメモリバッファに関連付けた I/O ストリームを作成します。 このストリームは、書き込み先として開くことおよびシーク可能であることが必要です。</p>
          <p>設計上、この関数で作成するのは読み取り元ストリームではなく、書き込み先ストリームです。 したがって、この関数が返すストリームでは読み取りがサポートされていません。</p>
          <div class="note_new">
            <div class="note_new_left">注意：</div>
            <div class="note_new_right">
              <p>Clang for NX 1.2.4 の時点では、これらの関数は sizeof char* を別途割り当てています。これは、開いたストリームを何の書き込みもせずに閉じた場合でも 'bufp' が必ず有効になるバグの修正を目的としたものです。</p>
              <p>このバグによって、アロケータでプール全体（4096 Byte）が割り当てられることがあり、メモリが少ない環境で問題が発生する原因となります。</p>
            </div>
          </div>
          <p> </p>
          <p>
            <u>
              <strong>NX 固有の扱い</strong>
            </u>
          </p>
          <p>なし</p>
          <p> </p>
          <p>
            <u>
              <strong>インターフェース関数</strong>
            </u>
          </p>
          <p>なし</p>
          <p>
            <u>
              <strong>
                <br />Errno</strong>
            </u>
          </p>
          <p>
            <strong>EMFILE </strong>：現在、呼び出し元プロセスで開いているストリームの量が <em>'FOPEN_MAX'</em> になっています。</p>
          <p>
            <strong>ENOMEM</strong>：ストリームまたはバッファで使用するメモリを割り当てることができませんでした。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EINVAL</strong>：<em>bufp</em> または <em>sizep</em> が NULL です。</span>
          </p>
          <div class="note_new">
            <div class="note_new_left">注意：</div>
            <div class="note_new_right">
              <p>
                <strong>open_memstream</strong>() および <strong>open_wmemstream</strong>() の実装では、<em>bufp</em> パラメータまたは <em>sizep</em> パラメータを NULL として渡すと、errno が EINVAL に設定されません。</p>
              <p>いずれかの引数を NULL として渡すと、ストリームに書き込んだときにプログラムがクラッシュします。</p>
            </div>
          </div>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/open_memstream">http://linux.die.net/man/3/open_memstream</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_23">fmemopen()</h4>
          <p> </p>
          <p>FILE *<strong>fmemopen</strong>(void *restrict buf, size_t size, const char *restrict mode)</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>fmemopen</strong>() 関数は、<em>mode</em> で指定されたモードでのアクセスが許可されているストリームを開きます。 このストリームでは、<em>buf</em> が指す文字列バッファまたはメモリ バッファに対する I/O が可能です。 このバッファは、<em>size</em> で指定されたバイト数以上の長さとする必要があります。</p>
          <p> </p>
          <p>
            <u>
              <strong>NX 固有の扱い</strong>
            </u>
          </p>
          <p>なし</p>
          <p> </p>
          <p>
            <u>
              <strong>インターフェース関数</strong>
            </u>
          </p>
          <p>なし</p>
          <p>
            <u>
              <strong>
                <br />Errno</strong>
            </u>
          </p>
          <p>
            <strong>EINVAL</strong>：size 引数でバッファのサイズにゼロが指定されています。</p>
          <p>
            <strong>EINVAL</strong>：mode 引数の値が有効ではありません。</p>
          <p>
            <strong>ENOMEM</strong>：buf 引数が NULL ポインタであり、サイズが length であるバッファのアロケーションに失敗しました。</p>
          <p>
            <strong>EMFILE</strong>： 現在、呼び出し元で <em>'FOPEN_MAX'</em> 個のストリームが開いています。</p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EINVAL</strong>：<em>buf</em> 引数が NULL ポインタですが、mode 引数に '+' 文字が使用されていません。</span>
          </p>
          <div class="note_new">
            <div class="note_new_left">注意：</div>
            <div class="note_new_right">
              <p>
                <strong>fmemopen</strong>() の実装では、<em>mode</em> を NULL として渡すとクラッシュが発生します。</p>
              <p> </p>
              <p>NULL を <em>buf</em> 引数に渡すことはできますが（EINVAL は返されません）、<em>mode</em> 文字列に '+' 文字を使用しないと意味がありません。&quot;r&quot; モードではデータをバッファに書き込む方法がなく、&quot;w&quot; モードまたは &quot;a&quot; モードではバッファからデータを読み取る方法がないからです。'+' 形式（&quot;r+&quot;、&quot;w+&quot;、&quot;a+&quot;）で指定した場合にのみ、読み取りと書き込みが可能です。</p>
            </div>
          </div>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/fmemopen">http://linux.die.net/man/3/fmemopen</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_24">fdopendir()</h4>
          <p> </p>
          <p>DIR *<strong>fdopendir</strong>(int);</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>fdopendir</strong>() 関数は <strong>opendir</strong>() 関数に似ていますが、開いているファイルのディスクリプタ <em>fd</em> で参照しているディレクトリのディレクトリストリームを返す点が異なります。</p>
          <p> </p>
          <p>
            <u>
              <strong>NX 固有の扱い</strong>
            </u>
          </p>
          <div class="warn_new">
            <div class="warn_new_left">警告：</div>
            <div class="warn_new_right">
              <p>この関数は実装されていないので NULL を返すだけです。</p>
            </div>
          </div>
          <p> </p>
          <p>
            <u>
              <strong>インターフェース関数</strong>
            </u>
          </p>
          <p>なし</p>
          <p>
            <u>
              <strong>
                <br />Errno</strong>
            </u>
          </p>
          <p>該当なし</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/fdopendir">http://linux.die.net/man/3/fdopendir</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_106358756_h4_25">flockfile()、ftrylockfile()、および funlockfile()</h4>
          <p> </p>
          <p>void <strong>flockfile</strong>(FILE *filehandle);<br />int <strong>ftrylockfile</strong>(FILE *filehandle);<br />void <strong>funlockfile</strong>(FILE *filehandle);</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p> </p>
          <p>
            <strong>flockfile</strong>() 関数は、<em>*filehandle</em> が現在のスレッド以外のスレッドでロックされていない状態になるまで待機したうえで、現在のスレッドを <em>*filehandle</em> の所有者として、</p>
          <p>ロックカウントをインクリメントします。</p>
          <p> </p>
          <p>
            <strong>funlockfile</strong>() 関数はロックカウントをデクリメントします。</p>
          <p> </p>
          <p>
            <strong>ftrylockfile</strong>() 関数は <strong>flockfile</strong>() の非ブロッキング型です。現在のスレッド以外のスレッドが <em>*filehandle</em> を所有していない場合、この関数は何も実行しません。</p>
          <p>それ以外の場合は、所有権を取得してロックカウントをインクリメントします。</p>
          <p> </p>
          <p>
            <u>
              <strong>NX 固有の扱い</strong>
            </u>
          </p>
          <ul>
            <li>なし</li>
          </ul>
          <p> </p>
          <!--Remove-->
          <p>
            <u>
              <strong>
                <br />Errno</strong>
            </u>
          </p>
          <p>該当なし</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/flockfile">http://linux.die.net/man/3/flockfile</a>
            <br />
            <a href="http://linux.die.net/man/3/ftrylockfile">http://linux.die.net/man/3/ftrylockfile</a>
            <br />
            <a href="http://linux.die.net/man/3/funlockfile">http://linux.die.net/man/3/funlockfile</a>
          </p>
        </td>
      </tr>
      <tr>
        <td> </td>
        <td> </td>
      </tr>
    </tbody>
  </table>
  <p> </p>
</div>
<div class="section">
  <h1 id="Anchor_106358756_h1_2">現在実装されていない関数</h1>
  <table class="table">
    <tbody>
      <tr>
        <th>posix 形式の関数</th>
        <th>インターフェース関数</th>
        <th>説明/注意事項</th>
        <th> </th>
      </tr>
      <tr>
        <td>
          <p>
            <strong>int fsync(</strong>int<em>fd</em><strong>);</strong></p>
          <p>
            <strong>int fdatasync(</strong>int<em>fd</em><strong>);</strong></p>
        </td>
        <td>
          <strong>実装なし</strong>
        </td>
        <td>
          <p>マニュアルページ：<a href="http://linux.die.net/man/2/fsync">http://linux.die.net/man/2/fsync を参照</a></p>
          <p>NintendoSDK には同等の関数がありません。</p>
        </td>
        <td> </td>
      </tr>
      <tr>
        <td>
          <strong>int fdatasync(</strong>int<em>fd</em><strong>);</strong></td>
        <td>
          <strong>実装なし</strong>
        </td>
        <td>マニュアルページ： <a href="http://linux.die.net/man/2/fcntl">http://linux.die.net/man/2/fcntl を参照</a></td>
        <td> </td>
      </tr>
      <tr>
        <td>
          <strong>intfcntl</strong>(int filedes, int cmd, &hellip;)</td>
        <td>
          <strong>実装なし</strong>
        </td>
        <td>マニュアルページ：<a href="http://linux.die.net/man/2/fcntl">http://linux.die.net/man/2/fcntl を参照</a></td>
        <td> </td>
      </tr>
    </tbody>
  </table>
  <h1 id="Anchor_106358756_h1_3">NintendoSDK FS API への低レベルインターフェース</h1>
  <p>fstat() 関数では、NintendoSDK のファイル情報を以下のように posix stat 構造体に変換する必要があります。</p>
  <table class="table">
    <tbody>
      <tr>
        <th>フィールド</th>
        <th>NintendoSDK での情報</th>
        <th>注意事項</th>
      </tr>
      <tr>
        <td>dev_t <strong>st_dev</strong></td>
        <td>0</td>
        <td> </td>
      </tr>
      <tr>
        <td>ino_t <strong>st_ino</strong></td>
        <td>0</td>
        <td> </td>
      </tr>
      <tr>
        <td>mode_t <strong>st_mode</strong></td>
        <td>0666</td>
        <td> </td>
      </tr>
      <tr>
        <td>nlink_t <strong>st_nlink</strong></td>
        <td>1</td>
        <td>ファイルには 1 つ以上のリンクがあります。</td>
      </tr>
      <tr>
        <td>uid_t <strong>st_uid</strong></td>
        <td>99</td>
        <td>
          <p>（my mac では 99 は __unknown を示します）</p>
          <p>0 を 0 == root として使用しないようにします。</p>
        </td>
      </tr>
      <tr>
        <td>gid_t <strong>st_gid</strong></td>
        <td>-1</td>
        <td>（my mac では -1 はグループがないことを示します）</td>
      </tr>
      <tr>
        <td>dev_t <strong>st_rdev</strong></td>
        <td>0</td>
        <td>該当なし</td>
      </tr>
      <tr>
        <td>off_t <strong>st_size</strong></td>
        <td>
          <strong>GetFileSize()</strong>
        </td>
        <td>NintendoSDK API を使用してファイルサイズを取得します。</td>
      </tr>
      <tr>
        <td>blksize_t <strong>st_blksize</strong></td>
        <td>未定義</td>
        <td> </td>
      </tr>
      <tr>
        <td>blkcnt_t <strong>st_blocks</strong></td>
        <td>未定義</td>
        <td> </td>
      </tr>
      <tr>
        <td>time_t <strong>st_atime</strong></td>
        <td>0</td>
        <td>サポートされていません。</td>
      </tr>
      <tr>
        <td>time_t <strong>st_mtime</strong></td>
        <td>0</td>
        <td>サポートされていません。</td>
      </tr>
      <tr>
        <td>time_t <strong>st_ctime</strong></td>
        <td>0</td>
        <td>サポートされていません。</td>
      </tr>
    </tbody>
  </table>
  <p> </p>
  <p>readdir 関数および readdir_r 関数では、NintendoSDK の <strong>DirectoryEntry</strong> を以下のように POSIX <strong>dirent</strong> に変換する必要があります。</p>
  <table class="table">
    <tbody>
      <tr>
        <th>dirent</th>
        <th>DirectoryEntry</th>
        <th>注意事項</th>
      </tr>
      <tr>
        <td>ino_t <strong>d_ino</strong></td>
        <td>0</td>
        <td>ディスクカタログにあるファイル情報のインデックスは、現在のところ、必ず 0 になります。</td>
      </tr>
      <tr>
        <td>off_t <strong>d_off</strong></td>
        <td>現在のディレクトリインデックス * sizeof(<strong>dirent</strong>) に設定</td>
        <td>NintendoSDK ではインデックスを使用し、POSIX では可変サイズのオフセットを使用します。</td>
      </tr>
      <tr>
        <td>unsigned int <strong>d_reclen</strong></td>
        <td>sizeof(<strong>dirent</strong>)</td>
        <td>現時点では、レコードサイズが必ず sizeof(<strong>dirent</strong>) と同じであるものとして扱います。</td>
      </tr>
      <tr>
        <td>unsigned char <strong>d_type</strong></td>
        <td>int8_t <strong>directoryEntryType</strong></td>
        <td>NintendoSDK の <strong>directoryEntryType</strong> を、<strong>DT_DIR</strong> または <strong>DT_REG</strong> のいずれかに変換します。</td>
      </tr>
      <tr>
        <td>char <strong>d_name</strong>[256]</td>
        <td>char <strong>name</strong>[EntryNameLengthMax + 1]</td>
        <td>
          <div class="warn_new">
            <div class="warn_new_left">警告：</div>
            <div class="warn_new_right">
              <p>(<strong>d_name</strong>) &gt;= sizeof(<strong>name</strong>) であることを確認する必要があります。</p>
            </div>
          </div>
        </td>
      </tr>
    </tbody>
  </table>
  <p> </p>
</div>
<p> </p>
</div>
<div class="breadcrumb_bottom"></div>
<div class="page_navigation">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
<tr><td colspan="2" class="page_navi_bottom"></td></tr>
</table>
</div>
</div>
</div>
<!--AddLink-->
<script>
var NintendoSdkApiRefernce = {
    idMap: {},
    linkRewrite: function ()
    {
        var idMap = NintendoSdkApiRefernce.idMap;
        function rewrite(el)
        {
            var e = idMap[el.className];
            if (e === undefined)
            {
                return;
            }
            var html = '';
            html += '<a href=';
            html += e.url;
            html += ' target="_blank">';
            html += el.innerHTML;
            html += '</a>';
            el.innerHTML = html;
        }
        var apiLinkElems = document.querySelectorAll('span[class*="ApiLink_"]');
        for (var i = 0, n = apiLinkElems.length; i< n; ++i) {
            rewrite(apiLinkElems[i]);
        }
    }
};
function SetUrl( id, url )
{
    NintendoSdkApiRefernce.idMap[id] = { url: url };
}
SetUrl( 'ApiLink_nn__fs__WriteFile', '../../../Api/HtmlNX/namespacenn_1_1fs.html#ab4351ff3a319e9a63093324a669492ab' )
SetUrl( 'ApiLink_nn__fs__WriteOptionFlag_Flush', '../../../Api/HtmlNX/namespacenn_1_1fs.html#afb4fdd50e0892400c07232f714caa14da2956e16dac576b2b7eff3142e18ac2c0' )

NintendoSdkApiRefernce.linkRewrite();
</script>
<!--AddLink-->
</body>
</html>
