<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<script type="text/javascript" src="../template/js/jquery/jquery.js"></script>
<script type="text/javascript" src="../template/js/common/manualLib.js"></script>
<script type="text/javascript" src="../tocData.js"></script>
<link rel="stylesheet" type="text/css" href="../template/css/template.css" />
<title>スケーラブルフォント</title>
</head>
<body data-reassemble="autoindex=no,forceNoLabel=yes">
<div id="autoindex_content">
<div class="body_content">
<noscript>
<div style="border: 4px double black; margin: 4px; padding: 2px; font-weight: bold; background-color: #FFFFCC;">
<p>お使いのブラウザは JavaScript が使用できないため、本ドキュメントの一部機能が無効になっています。</p><p>JavaScript が無効の環境では目次を使用することができません。<br />JavaScriptの実行が許可された状態で閲覧してください。<br /><br /></p>
</div>
</noscript>
<div class="page_navigation_top">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
</table>
</div>
<div class="breadcrumb"></div>

<!-- スケーラブルフォント -->
<div class="pagetitle" id="PageId_83956048">スケーラブルフォント</div>
<div class="text_separate">
<h1 id="Anchor_83956048_h1_1">スケーラブルフォント</h1>
<h2 id="Anchor_83956048_h2_1">はじめに</h2>
<p>本ドキュメントではスケーラブルフォントについて説明します。</p>
<h3 id="Anchor_83956048_h3_1">概要</h3>
<p>スケーラブルフォントは、本体内蔵のスケーラブルフォントデータや任意のTTF(OTF)を使用してフォント描画を行うためのライブラリです。</p>
<p>スケーラブルフォントには以下の内容が含まれています。</p>
<ul>
  <li>
    <strong>ScalableFontクラス</strong> ... <span class="ApiLink_nn__font__Font">nn::font::Font</span>クラスの派生で、スケーラブルフォントの描画を行うことができるようにしたクラスです。ビットマップ フォントであるResFontクラスと同様に、TextWriterクラスで文字を描画したり、ArcResourceAccessorクラスに登録して レイアウトの描画に使用したりすることができます。</li>
  <li>
    <strong>TextureCacheクラス</strong> ... フォントは実際にはテクスチャデータとして描画されますが、そのテクスチャデータを管理するためのクラスです。ScalableFontクラスにセットし て使います。複数のScalableFontクラスで一つのTextureCacheクラスを共有することもできます。</li>
</ul>
<h2 id="Anchor_83956048_h2_2">機能的な特徴</h2>
<h3 id="Anchor_83956048_h3_2">スケーラブルフォントをランタイムで扱うことができる</h3>
<p>ビットマップフォントは描画が高速で、ランタイムの扱いが簡単ですが、表示されうる全ての文字のテクスチャデータを保持しなければならないため、HD 環境ではリソースサイズと消費メモリが大きくなります。この問題は、特に文字数の多い中国・台湾フォントを扱わなければならない場合に顕著です。</p>
<p>スケーラブルフォントは、リソースとしてTTF(OTF)のパス情報を用いるため、<strong>ビットマップフォントと比較してリソースサイズが小さくて済みます</strong>。 また、ランタイムの消費メモリサイズも、一度に表示される文字数にもよりますが、ビットマップフォントより小 さいメモリ消費で使うことができます。</p>
<p>ただし、常にスケーラブルフォントがビットマップフォントより優れているわけではありません。<strong>スケーラブルフォントは、ビットマップフォントのようにリソースデータを直接描画することができず、描画の前に準備が必要です</strong>。 この準備には処理コストがかかりますし、プログラムの実装も複雑になります。また、表示するメッセージが予め決まっているのであれば、ビットマップフォン トは表示する文字のみ抽出しておくことができるため、リソースサイズに関するスケーラブルフォントの優位性は小さくなります。</p>
<p>まとめると、ビットマップフォントではなくスケーラブルフォントを使用した方がよいのは、以下のようなときであると言えます。</p>
<ul>
  <li>どのような文字を表示するかリソースコンバートの時点でわからないとき(例えばMiiの名前を表示するときなど)</li>
  <li>フォントを様々な大きさで描画するとき(ビットマップフォントで大きいテクスチャを縮小して表示するより綺麗に表示できる)</li>
  <li>標準フォントを使用するとき</li>
</ul>
<h3 id="Anchor_83956048_h3_3">フォントライブラリとの親和性</h3>
<p>スケーラブルフォントライブラリは、ビットマップフォントを表示するために作られたフォントライブラリとできるだけ同じように使えるように設計・実装されています。</p>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_83955990/83080090.png" class="embedded-image" />
  </span>
</p>
<p>上記の図は、スケーラブルフォントの各クラス(図中では赤で示されています)とそれに関係するクラスを示したものです。ScalableFontクラスは Fontクラスと同じインターフェースを持っているため、ビットマップフォントを扱うResFontクラスと同じようにレイアウトライブラリから扱うこと ができます。</p>
<p>文字に影を付けたり、斜体にしたりするレイアウトライブラリの機能も、ビットマップフォントと同じように利用することができます。</p>
<p>ただし、Fontクラスとインターフェースを合わせたことにより、逆に本来スケーラブルフォントが受ける必要のない制約を受けているという面もあります。例えば以下のような点です。</p>
<ul>
  <li>Fontクラスは、一つのインスタンスで一種類のサイズの文字しか扱うことができません。このため、<strong>ScalableFontクラスも一つのインスタンスで一種類のサイズの文字しか扱うことができません</strong>。複数のサイズを扱いたい場合、ScalableFontクラスのインスタンスを複数作成する必要があります。(TextureCacheクラスは共有できます。)</li>
  <li>ResFontクラスによるビットマップフォントの描画とできるだけ似た表示にするため、文字の表示位置等を本来のTrueTypeフォントの描画から少し変えています。通常は大きな違いはありませんが、特殊なケースで意図しない見え方になってしまうかもしれません。</li>
</ul>
<h3 id="Anchor_83956048_h3_4">テクスチャキャッシュによる文字の再利用</h3>
<p>スケーラブルフォントのリソースはそのままでは描画に使用することができないため、一度テクスチャデータとしてメモリ上に展開する必要があります。<strong>スケーラブルフォントライブラリは、この展開されたテクスチャデータをキャッシュして、同じ文字を描画するときになるべく再度展開しなくてよいような仕組みを持っています</strong>。この機能を担うのがTextureCacheクラスです。</p>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_83955990/83080089.png" class="embedded-image" />
  </span>
</p>
<p>一つのTextureCacheクラスのインスタンスは、2Dテクスチャ1枚をテクスチャキャッシュの領域として使用できます。サイズは初期化時に設定できますが、最大サイズはハードウェアの仕様に依存しますのでご注意ください。縦横のサイズは2の累乗の大きさでなければいけません。縦横が同じサイズである必要はありません。例えば横 が1024、縦が512という設定も大丈夫です。ハードウェアごとの最大テクスチャサイズについては「<a href="../Pages/Page_95696747.html">プラットフォーム固有の情報</a>」を参照してください。</p>
<p>
  <strong>TextureCacheクラスは、テクスチャ内に「ライン」と呼ばれる決まった高さの領域を設定し、文字を高さ別にラインに振り分けて管理します</strong>。 ラインの高さは2の累乗と決まっていて、例えば高さが16～31の文字は32のラインに、32～63の文字は64のラインに入ります。ラインがどこに作ら れるのかは最初から決まっているわけではなく、必要となったタイミングでその都度作られます。例えばキャッシュ内に64のラインしかなかったときは、32 のラインに入る文字が来たそのタイミングで32のラインが作られます。また、64のラインに入る文字が来たときに64のラインがすべて埋まっていたら、新 しく64のラインが作られます。</p>
<p>このようにラインは上から順番にどんどん作られていきます。スペースがある限り、一度展開された文字が消えることはありません。テクスチャキャッシュ内に 空きがなくなったときに、はじめてキャッシュ内の使われていない文字を消して新しい文字を配置するという処理が行われます。</p>
<p>このような仕組みになっているのは、できるだけテクスチャキャッシュ内に文字を残しておくためです。文字を展開するのには時間がかかるため、一度使われなくなった文字でも、残しておいて、必要になったタイミングで使えるようにしています。</p>
<h3 id="Anchor_83956048_h3_5">ボールド・縁取り等の文字効果</h3>
<p>これはスケーラブルフォントライブラリの機能というより内部で使用しているScalableFontEngineライブラリの機能なのですが、<strong>文字にボールド効果を付けたり、縁取りを行ったりすることができます</strong>。ビットマップフォントでは、このような効果を付けたフォントを予め用意しておかなければいけませんが、スケーラブルフォントでは一つのフォントでいろいろな用途をカバーできます。</p>
<h2 id="Anchor_83956048_h2_3">レイアウトエディタでデータを作る方法</h2>
<p>レイアウトエディタ上でスケーラブルフォントを使用するには「<a href="../Pages/Page_83955958.html">LayoutEditor でのスケーラブルフォントの使い方</a>」を参照してください。</p>
<p>&nbsp;</p>
<h2 id="Anchor_83956048_h2_4">プログラムの実装</h2>
<p>スケーラブルフォントを使用する場合、レイアウトライブラリを介して使用することがほとんどだと思いますので、その前提で解説を行います。 サンプルデモも併せてご参照ください。</p>
<h3 id="Anchor_83956048_h3_6">初期化</h3>
<h4 id="Anchor_83956048_h4_1">フォントデータのロード</h4>
<p>まず最初に行う必要があるのは、テクスチャデータをロードすることです。スケーラブルフォントが扱うことのできるデータの種類は下記の通りです。</p>
<ul>
  <li>
    <strong>TTF形式</strong> ... Windows等でシステムにインストールして使用することのできる、通常のTrueTypeフォント形式のファイルです。</li>
  <li>
    <strong>OTF形式</strong> ... Windows等でシステムにインストールして使用することのできる、通常のOpenTypeフォント形式のファイルです。</li>
  <li>
    <strong>BFTTF形式</strong> ... TTF形式のフォントを、Windowsでインストールして使用できないように難読化した形式のファイルです。標準フォントはこの形式で配布されます。</li>
  <li>
    <strong>BFOTF形式</strong> ... OTF形式のフォントを、Windowsでインストールして使用できないように難読化した形式のファイルです。</li>
</ul>
<h4 id="Anchor_83956048_h4_2">TextureCacheの初期化</h4>
<p>次にTextureCacheクラスを初期化します。TextureCacheクラスの初期化はInitializeメソッドで行います。このメソッドはパラメータがたくさんありますので、関数リファレンスに描かれている説明をよく読んで設定を行ってください。</p>
<p>特に注意が必要なのは、<strong>textureCacheWidth</strong>、<strong>textureCacheHeight</strong>、<strong>glyphNodeNumMax</strong>です。この3つをどのように指定すればよいかは、そのアプリケーションでどのように文字を表示したいかによります。</p>
<p>文字はテクスチャキャッシュに配置した状態でしか表示できませんので、例えば50ポイントの文字を400文字一度に表示したいのであれば、仮に横幅を 1024にしたとすると、1ラインに約20文字入りますので、64のラインが20必要となります。64&times;20=1280となりますので、縦は1024では 足りず、2048必要となります。つまりこの場合、textureCacheWidthに1024、textureCacheHeightに2048を指定すればよいことになります。</p>
<p>次にglyphNodeNumMaxですが、テクスチャキャッシュは、文字に関するデータを内部的に平衡二分木で管理しており、この数値は平衡二分木の ノード数を最大で幾つにするかを指定します。この場合は、テクスチャサイズが1024&times;2048ですので、全てが64のラインになったとすると、文字は最 大で20&times;32=640個入ることになります。ただ、実際にはアルファベット等の文字は50ポイントの文字でも横幅が50以下になりますので、1ラインに 20より多く入ることがあり、これより大きい数値が必要です。目安としては、この倍の数値を指定しておくとよいです。つまり、この場合は1280となりま す。</p>
<p>TextureCacheのInitializeメソッドはメモリアロケータを渡す形式となっていますが、レイアウトライブラリと異なり、<strong>メモリが確保されるのはこのInitializeメソッドの中だけです</strong>。その後は、いかなる場合でも、スケーラブルフォントライブラリはメモリ確保を行いません。</p>
<h4 id="Anchor_83956048_h4_3">ScalableFontの初期化</h4>
<p>次に、ScalableFontクラスのインスタンスを初期化します。TextureCacheほどではありませんが、ScalableFontクラスも注意を要する初期化パラメータがあります。</p>
<p>まず、<strong>textureCache</strong>には、先ほど初期化したTextureCacheクラスのインスタンスを指定してください。次に<strong>fontSize</strong>には、レイアウトエディタでデザイナがデータを作るときに使用したbffntのフォントサイズを指定してください。<strong>fontFace</strong>には、TextureCacheの初期化時に指定したフォントの種類を指定します。fontDatas等に配列を指定したと思うのですが、その配列内の対応するフォントのインデックスを指定してください。</p>
<p>
  <strong>isAlternateCharSpaceWithOriginalWidth</strong>は、表示しようとした文字がまだ準備で きていなかった場合にどのような処理を行うかを指定します。false(デフォルトの設定です)を指定すると、準備できていない文字の代わりに代替文字が 表示されます。デフォルトでは?になっています。trueを指定すると、準備できていない文字は単に空白になり、しかも文字幅はスペースではなく本来そこ に入る文字の幅が使われます。つまり、このオプションをtrueにすると、<strong>まだ表示できない文字は空白にしておき、準備が終わったら空白だった部分に文字が表示される</strong>という挙動を実現できます。状況に合った挙動を選んでください。</p>
<h4 id="Anchor_83956048_h4_4">ArcResourceAccessorへの登録</h4>
<p>次に、レイアウトの構築を行う前に、構築に使用するArcResourceAccessorに作成したScalableFontクラスのインスタンスを登 録します。このときの登録名は、レイアウトでデータを作成した時のビットマップフォント名と同じ名前にしてください。これにより、その名前のビットマップ フォントの代わりにスケーラブルフォントが使われることになります。</p>
<h3 id="Anchor_83956048_h3_7">文字の準備</h3>
<p>スケーラブルフォントで文字を描画するには、事前に準備が必要です。以下ではその手順について解説します。</p>
<h4 id="Anchor_83956048_h4_5">文字の登録</h4>
<p>まず最初に、描画する文字の登録が必要です。登録を行うには、ScalableFontクラスの<strong>RegisterGlyph</strong>、<strong>RegisterGlyphs</strong>、<strong>RegisterGlyphsWithLength</strong>を利用します。これらの関数は、登録する文字(または文字列)と、ロックを行う際のグループ番号を指定します。</p>
<p>ロックというのは、TextureCacheで特定の文字が消されないようにするための仕組みです。これについては後程詳しく解説します。</p>
<p>文字を自分で指定して登録する代わりに、<strong>RegisterGlyphFromTextBoxRecursive</strong>メソッ ドを利用して、指定したペイン以下のフォントとしてScalableFontを利用しているテキストボックスの文字列を全て登録することもできます。 TextBoxの文字列を動的に入れ替えないのであれば、レイアウトのBuildを行った直後にこのメソッドを呼んでおく、というのは確実かつ簡単な方法 です。</p>
<h4 id="Anchor_83956048_h4_6">テクスチャキャッシュの更新</h4>
<p>描画したい文字の登録が終わったら、次にその内容に応じてテクスチャキャッシュの更新を行います。この処理を行うのが、TextureCacheクラスの<strong>UpdateTextureCache</strong>メソッドです。</p>
<p>この処理は、TTF(OTF)のパス情報からビットマップ情報への変換や、テクスチャへのコピーなどを含みますので、かなり重い処理です。目安ですが、標準フォント で40ポイントの文字を10文字程度処理するためには4ミリ秒程度の時間がかかります。数十文字を処理しようとすると、それだけで1フレームの処理をオー バーしてしまいます。</p>
<p>テクスチャキャッシュの更新をシーン切り替えのときしか呼ばないのであれば、この処理時間は問題になりませんが、もしプレイヤーが操作している途中に更新 を行いたいのであれば、UpdateTextureCacheをメインスレッドより低い優先度のスレッドで呼び出し、複数フレームかけて更新することを検 討してください。UpdateTextureCacheは、他のメソッドと異なるスレッドで並行して呼ぶことができるように実装されています。このため、 メインスレッドでフォント描画を行っているのと並行して呼びだしても問題なく動作します。</p>
<p>UpdateTextureCacheが終わったら、<strong>CompleteTextureCache</strong>を呼びだしてください。この関数は、UpdateTextureCacheと異なり、他のメソッドと並行して呼びだすことができないということに注意が必要です。</p>
<p>CompleteTextureCacheが終わると、登録した文字を描画することができるようになります。ただこのとき、既に描画しているレイアウトの 文字を入れ替えた場合は、TextBoxのSetDirtyFlagメソッドを使用してDirtyFlagを立てを立ててください。DirtyFlagを 立てないと、TextBoxで描画される文字列が更新されません。</p>
<h3 id="Anchor_83956048_h3_8">テクスチャキャッシュから文字が消える条件に付いて</h3>
<p>テクスチャキャッシュは、領域が足りなくなると、使っていないと判断した文字を消去し、新しい文字をその領域に描きます。ここでは、「使っていない」と判断される条件に付いて解説します。</p>
<p>文字が使っていないと判断されるのは、以下の条件を<strong>すべて満たす場合</strong>です。</p>
<ul>
  <li>文字がどのロックグループでもロックされていない</li>
  <li>文字が前回のCompleteTextureCacheの後に一度も登録されていない</li>
  <li>文字が前回のCompleteTextureCacheの後に一度も描画されていない(ScalableFontのGetGlyphで取得されていない)</li>
</ul>
<p>これらの条件を一つも満たさなかった文字は、「消える可能性がある文字」としてマークされ、表示を行うことができなくなります。結果として、 TextBoxでその文字を表示したときは、代替文字が表示されることになります。逆に言うと、文字が消されないようにするためには、この中の一つだけで も満たすようにすればよいことになります。三つの条件の中でコントロールしやすいのは、最初の二つです。</p>
<p>まずロックについてですが、文字をロックするには、文字を登録する際に0～31の任意のロックグループを指定します。文字は、複数のロックグループに属することができます。例えば「あ」という文字が、グループ0と2の両方に属することがあり得ます。<strong>ロックはグループごとに解除することができますが、文字は全てのロックグループで解除されないと「使われていない」判定にはなりません。</strong></p>
<p>文字はロックしておけば消えることはないのですが、ロックされた文字でテクスチャキャッシュが埋まってしまうと新しい文字を描画できなくなってしまうた め、ある程度テクスチャキャッシュにスペースが残るくらいの文字数にしておき、使わなくなったらロック解除するようにしてください。</p>
<p>二つ目の条件を満たすには、例えば「レイアウトに存在するテキストボックスの文字は毎回登録する」というポリシーにするという方法があります。<strong>既にテクスチャキャッシュの中にある文字を登録しても特にペナルティはなく、「この文字は使われるので、消してはいけない」というフラグを立てる処理が行われます</strong>。</p>
<p>RegisterGlyphFromTextBoxRecursiveでテキストボックスの文字を全て登録する、UpdateTextureCacheす る、CompleteTextureCacheするという流れにしておけば、レイアウトで表示している文字が消えることはありません。</p>
<h3 id="Anchor_83956048_h3_9">利用ケース</h3>
<p>スケーラブルフォントの利用ケースは、単純なものから複雑なものまで、様々な場合が考えられます。ここでは代表的な使い型について説明します。</p>
<h4 id="Anchor_83956048_h4_7">最初にまとめて登録し、準備しておくケース</h4>
<p>一番簡単なケースです。シーンが切り替わった後に、表示される文字列が変わることがなければ、この方法で十分です。</p>
<ul>
  <li>レイアウトを構築した後に、RegisterGlyphFromTextBoxRecursiveを使用する等の方法で、表示されうるすべての文 字を登録します。その後、UpdateTextureCacheとCompleteTextureCacheを呼びだします。(シーンの切り替わりなの で、UpdateTextureCacheに時間がかかっても問題ないはずです。)</li>
  <li>完了すれば、表示されうる文字は全て描画できる状態になっています。あとは新たなシーンに入るまで、キャッシュの更新を行う必要はありません。</li>
</ul>
<p>ほとんどの文字は変わらないが、ごく一部（例えばスコアを示すための数値）は変わりうる、ということであれば、最初の段階で数値の表示に使用する文字を登 録してロックしておくことで対応可能です。ただ、変わりうる文字数が非常に多い場合はテクスチャキャッシュの領域が足りなくなる可能性がありますので、次 の方法を検討してください。</p>
<h4 id="Anchor_83956048_h4_8">描画を行いながら新しい文字を準備するケース</h4>
<p>シーンに入ってから変わりうる文字が多い場合は、シーン内で動的にテクスチャキャッシュの更新を行わなければいけません。このような場合は、以下のような手順にします。</p>
<ul>
  <li>シーンに入る前に、初期状態の文字を登録して、UpdateTextureCacheとCompleteTextureCacheを実行しておきます。これらの文字は、消えないようにロックしておきます。</li>
  <li>シーン内で新しい文字を表示する必要が出てきたら、その文字をRegisterGlyphsで登録します。RegisterGlyphsは、その 時点でテクスチャキャッシュになかった文字(つまり、テクスチャキャッシュに新たに展開しなければいけない文字)が何文字あるかを返します。もしこれが0 であれば、既に全てテクスチャキャッシュ内にあるということですので、以下の処理は必要ありません。</li>
  <li>新しい文字を登録したら、UpdateTextureCacheを呼びだします。ただ、この処理は長い時間がかかる可能性があります。処理落ちが目立つようであれば、優先度の低いサブスレッドで実行するようにしてください。</li>
  <li>UpdateTextureCacheが終わったら、CompleteTextureCacheを呼びだします。これは描画と同じスレッドで実行してください。</li>
  <li>その後、新しい文字が含まれるTextBoxのDirtyFlagを立ててください。これにより再描画が行われ、次のCalculateMtxとDrawで新しい文字が描画されます。</li>
</ul>
<h2 id="Anchor_83956048_h2_5">FAQ</h2>
<h3 id="Anchor_83956048_h3_10">テクスチャキャッシュに消すことのできる文字が十分あるにも関わらず、文字を展開できないことがある</h3>
<p>テクスチャキャッシュが文字で埋まっているが、消すことのできる文字は十分にあるという状況で、UpdateTextureCacheの中で以下のようなメッセージが表示され、新しい文字を展開することができない場合があります。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>nn::font::TextureCache: no erasable glyph. charCode = 0xe7 lineHeight = 64</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>この場合、新しい文字を配置するためのラインを作ることができなかったことによってエラーが発生しています。現状の仕組みでは、テクスチャキャッシュが空 いている限り、どんどんラインを作っていきます。一度作ったラインが消えることはありません。このため、例えば32のラインに収まる文字ばかりを描画して いて、テクスチャキャッシュが32のラインで埋まった後に、64のラインを必要とする文字が登録されても、64のラインを作ることができず、その文字は描 画できません。</p>
<p>また、さらに悪いことに、例えば25ポイントで文字を描画していても、縦に長い文字は32のラインに収まらず、64のラインが必要になることがあります。これは、ラテン文字のCedilla付きの文字(例えば &Ccedil; )等で起こります。</p>
<p>この問題を避けるには、予め64のラインを一つ作っておいて、後で64のラインを必要とする文字が出てきてもそこに入るようにする、という方法があります。TextureCacheの<strong>CreateNewLine</strong>メソッドを使用することで、明示的に任意の高さのラインを作成することができます。</p>
<h3 id="Anchor_83956048_h3_11">文字を登録する際に、Node number max overというメッセージが表示され、登録することができない</h3>
<p>RegisterGlyphメソッド等で文字を登録する際に、</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>nn::font::TextureCache: Node number max over. Please increase InitializeArg::glyphNodeNumMax.</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>というメッセージが表示され、登録を行うことができない場合があります。これは、テクスチャキャッシュ内で文字を管理するために使用している平衡二分木の ノード数が足りなくなったときに起こるエラーです。ノードは1文字につき一つ必要で、使われていないがテクスチャキャッシュ内には残っている文字のぶんも 必要ですので、テクスチャキャッシュのサイズが大きい程必要なノード数も大きくなります。このエラーが表示されたときは、TextureCacheの初期 化時に指定するglyphNodeNumMaxの数値を増やすようにしてください。</p>
<p>glyphNodeNumMaxにどのような数値を指定すればよいかの求め方は、TextureCacheの初期化に解説があります。</p>
<p>現在どのくらいノード数を消費しているかは、TextureCacheクラスの<strong>DumpGlyphTreeMap</strong>メソッドを使用することで確認できます。このメソッドを呼ぶと、平衡二分木の状態が表示され、最後に<strong>dump 102 nodes.</strong>のように現在消費しているノード数が表示されます。</p>
</div>
<div class="breadcrumb_bottom"></div>
<div class="page_navigation">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
<tr><td colspan="2" class="page_navi_bottom"></td></tr>
</table>
</div>
</div>
</div>
<!--AddLink-->
<script>
var NintendoSdkApiRefernce = {
    idMap: {},
    linkRewrite: function ()
    {
        var idMap = NintendoSdkApiRefernce.idMap;
        function rewrite(el)
        {
            var e = idMap[el.className];
            if (e === undefined)
            {
                return;
            }
            var html = '';
            html += '<a href=';
            html += e.url;
            html += ' target="_blank">';
            html += el.innerHTML;
            html += '</a>';
            el.innerHTML = html;
        }
        var apiLinkElems = document.querySelectorAll('span[class*="ApiLink_"]');
        for (var i = 0, n = apiLinkElems.length; i< n; ++i) {
            rewrite(apiLinkElems[i]);
        }
    }
};
function SetUrl( id, url )
{
    NintendoSdkApiRefernce.idMap[id] = { url: url };
}
SetUrl( 'ApiLink_nn__font__Font', '../../../Api/HtmlNX/classnn_1_1font_1_1_font.html' )

NintendoSdkApiRefernce.linkRewrite();
</script>
<!--AddLink-->
</body>
</html>
