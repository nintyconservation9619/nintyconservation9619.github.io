<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<script type="text/javascript" src="../template/js/jquery/jquery.js"></script>
<script type="text/javascript" src="../template/js/common/manualLib.js"></script>
<script type="text/javascript" src="../tocData.js"></script>
<link rel="stylesheet" type="text/css" href="../template/css/template.css" />
<title>ConditionVariable クラス</title>
</head>
<body data-reassemble="autoindex=no,forceNoLabel=yes">
<div id="autoindex_content">
<div class="body_content">
<noscript>
<div style="border: 4px double black; margin: 4px; padding: 2px; font-weight: bold; background-color: #FFFFCC;">
<p>お使いのブラウザは JavaScript が使用できないため、本ドキュメントの一部機能が無効になっています。</p><p>JavaScript が無効の環境では目次を使用することができません。<br />JavaScriptの実行が許可された状態で閲覧してください。<br /><br /></p>
</div>
</noscript>
<div class="page_navigation_top">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
</table>
</div>
<div class="breadcrumb"></div>

<!-- ConditionVariable クラス -->
<div class="pagetitle" id="PageId_83955576">ConditionVariable クラス</div>
<div class="text_separate">
<p>
  <ul class="macro_toc">
    <li>
      <a href="#Anchor_83955576_h1_1">ConditionVariable クラス</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_83955576_h2_1">機能概要</a>
      </li>
      <li>
        <a href="#Anchor_83955576_h2_2">ConditionVariable クラスの使用例</a>
      </li>
      <li>
        <a href="#Anchor_83955576_h2_3">ConditionVariable クラス使用上の注意事項</a>
      </li>
      <ul>
        <li>
          <a href="#Anchor_83955576_h3_1">Spurious wakeup について</a>
        </li>
        <li>
          <a href="#Anchor_83955576_h3_2">タイムアウト判定について</a>
        </li>
      </ul>
    </ul>
  </ul>
</p>
<h1 id="Anchor_83955576_h1_1">ConditionVariable クラス</h1>
<h2 id="Anchor_83955576_h2_1">機能概要</h2>
<p>
  <a href="../../../Api/HtmlNX/classnn_1_1os_1_1_condition_variable.html">ConditionVariable</a> クラスは <a href="../../../Api/HtmlNX/classnn_1_1os_1_1_mutex.html">Mutex</a> クラスと併用することで、複数<a href="../Pages/Page_83955697.html">スレッド</a>間で共有するリソースが特定の条件を満たすまで待機させることができる同期機能です。</p>
<p>
  <a href="../../../Api/HtmlNX/classnn_1_1os_1_1_condition_variable.html">ConditionVariable</a> クラスは、<a href="../../../Api/HtmlNX/structnn_1_1os_1_1_condition_variable_type.html">nn::os::ConditionVariableType</a> オブジェクトを利用した <a href="../Pages/Page_83955531.html">条件変数機能</a> をラッピングしたもので以下のメンバ関数を持ちます。API リファレンスはリンク先を参照して下さい。</p>
<table class="table">
  <tbody>
    <tr>
      <th>名前</th>
      <th>説明</th>
      <th>備考</th>
    </tr>
    <tr>
      <td>
        <a href="../../../Api/HtmlNX/classnn_1_1os_1_1_condition_variable.html#abab48acd1e2acce074a84b19e47037e3">ConditionVariable</a>
      </td>
      <td>コンストラクタ</td>
      <td>
        <a href="../../../Api/HtmlNX/namespacenn_1_1os.html#a1ea1d7b36ec1844ed9e05729e832f6c3">InitializeConditionVariable()</a> 同等の初期化を実行</td>
    </tr>
    <tr>
      <td>
        <a href="../../../Api/HtmlNX/classnn_1_1os_1_1_condition_variable.html#a312f64a3f68462f802b879dc1b6be7ac">~ConditionVariable</a>
      </td>
      <td>デストラクタ</td>
      <td>
        <a href="../../../Api/HtmlNX/namespacenn_1_1os.html#a817379cd29b11b49b185d0dc6afdc5c6">FinalizeConditionVariable()</a> 同等の破棄を実行</td>
    </tr>
    <tr>
      <td>
        <a href="../../../Api/HtmlNX/classnn_1_1os_1_1_condition_variable.html#ad074d822b79e084ee6c608a5a418e470">Wait</a>
      </td>
      <td>条件変数を待機する</td>
      <td>
        <a href="../../../Api/HtmlNX/namespacenn_1_1os.html#a69a1e2e570d09ebd7cdbaa9da2d7b187">WaitConditionVariable()</a> 同等の条件変数待機を実行</td>
    </tr>
    <tr>
      <td>
        <a href="../../../Api/HtmlNX/classnn_1_1os_1_1_condition_variable.html#a30c6c31ac58cae287fdc8141805c4ef5">TimedWait</a>
      </td>
      <td>条件変数を待機する</td>
      <td>
        <a href="../../../Api/HtmlNX/namespacenn_1_1os.html#a2643c34ccfd738890fdd0c546b61c7a8">TimedWaitConditionVariable()</a> 同等のタイムアウト付き条件変数待機を試行</td>
    </tr>
    <tr>
      <td>
        <a href="../../../Api/HtmlNX/classnn_1_1os_1_1_condition_variable.html#a457ebc40b1741f551662c5ade6eb8e12">Signal</a>
      </td>
      <td>シグナル通知する</td>
      <td>
        <a href="../../../Api/HtmlNX/namespacenn_1_1os.html#ae609d8150763b000d77f75d27fd44ac2">SignalConditionVariable()</a> 同等のシグナル通知を実行</td>
    </tr>
    <tr>
      <td>
        <a href="../../../Api/HtmlNX/classnn_1_1os_1_1_condition_variable.html#a24712ab09c26c17dfc00962c9bee7088">Broadcast</a>
      </td>
      <td>ブロードキャスト通知する</td>
      <td>
        <a href="../../../Api/HtmlNX/namespacenn_1_1os.html#a1588e76fa05096006c0dcba27f9c95bf">BroadcastConditionVariable()</a> 同等のブロードキャスト通知を実行</td>
    </tr>
  </tbody>
</table>
<p>&nbsp;</p>
<h2 id="Anchor_83955576_h2_2">ConditionVariable クラスの使用例</h2>
<p>多くのケースでは、以下のように何かしらのクラスのメンバ変数として <a href="../../../Api/HtmlNX/classnn_1_1os_1_1_mutex.html">Mutex</a> クラスと <a href="../../../Api/HtmlNX/classnn_1_1os_1_1_condition_variable.html">ConditionVariable</a> クラスを使用します。ここでは例として、複数ビットの状態を待機条件にすることのできる MultiEvent クラスを実装します。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="cp">#include &lt;mutex&gt;
#include &lt;nn/os.h&gt;
</span>
<span class="k">class</span> <span class="nc">MultiEvent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="c1">// コンストラクタでメンバ変数を初期化する
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">MultiEvent</span><span class="p">()</span> <span class="o">:</span> <span class="n">m_CurrentBits</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">m_Mutex</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{}</span>

&nbsp;&nbsp;&nbsp;&nbsp;<span class="c1">// pattern で 1 になっているビットが全てセットされるまで待機する
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="kt">void</span> <span class="n">WaitAll</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">pattern</span><span class="p">)</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="nn">std::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="nn">nn::os::</span><span class="n">Mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_Mutex</span><span class="p">);</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">while</span> <span class="p">((</span><span class="n">m_CurrentBits</span> <span class="o">&amp;</span> <span class="n">pattern</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pattern</span><span class="p">)</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">m_Cond</span><span class="p">.</span><span class="n">Wait</span><span class="p">(</span><span class="n">m_Mutex</span><span class="p">);</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">}</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">}</span>

&nbsp;&nbsp;&nbsp;&nbsp;<span class="c1">// pattern で 1 になっているビットのいずれかがセットされるまで待機する
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="kt">void</span> <span class="n">WaitAny</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">pattern</span><span class="p">)</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="nn">std::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="nn">nn::os::</span><span class="n">Mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_Mutex</span><span class="p">);</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">while</span> <span class="p">((</span><span class="n">m_CurrentBits</span> <span class="o">&amp;</span> <span class="n">pattern</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">m_Cond</span><span class="p">.</span><span class="n">Wait</span><span class="p">(</span><span class="n">m_Mutex</span><span class="p">);</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">}</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">}</span>

&nbsp;&nbsp;&nbsp;&nbsp;<span class="c1">// pattern で 1 になっているビットを全てセットする
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="kt">void</span> <span class="n">SetBits</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">pattern</span><span class="p">)</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="nn">std::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="nn">nn::os::</span><span class="n">Mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_Mutex</span><span class="p">);</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">m_CurrentBits</span> <span class="o">|=</span> <span class="n">pattern</span><span class="p">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">m_Cond</span><span class="p">.</span><span class="n">Broadcast</span><span class="p">();</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">}</span>

&nbsp;&nbsp;&nbsp;&nbsp;<span class="c1">// 全てのビットを 0 にクリアする
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="kt">void</span> <span class="n">Clear</span><span class="p">()</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">{</span>
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="nn">std::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="nn">nn::os::</span><span class="n">Mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_Mutex</span><span class="p">);</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">m_CurrentBits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
&nbsp;&nbsp;&nbsp; <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kt">uint32_t</span>                    <span class="n">m_CurrentBits</span><span class="p">;</span>
 &nbsp; &nbsp;<span class="nn">nn::os::</span><span class="n">Mutex</span>               <span class="n">m_Mutex</span><span class="p">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="nn">nn::os::</span><span class="n">ConditionVariable</span>   <span class="n">m_Cond</span><span class="p">;</span>
<span class="p">};</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>&nbsp;</p>
<p>まず、MultiEvent クラスのコンストラクタで m_Mutex( false ) として、<a href="../../../Api/HtmlNX/classnn_1_1os_1_1_mutex.html">Mutex</a> クラスのインスタンスを再帰ロック不可で初期化しています。また、条件変数の対象変数である m_CurrentBits を 0 に初期化しています。なお、m_Cond は暗黙のうちにコンストラクタが呼ばれ初期化されます。</p>
<p>WaitAll() では m_Mutex でロックをとった後、m_CurrentBits の値が特定の条件を満たすまで while ループしながら m_Cond.Wait() で条件変数待機を行ないます。m_Cond.Wait() から返ってきたからと言って m_CurrentBits が所望の条件を満たしているとは限らないため、while ループで何度も条件判定を行ないます。WaitAny() も条件が異なるだけで同様です。</p>
<p>SetBits() では現在の m_CurrentBits に引数で指定されたビットパターンで論理和演算を行なうと共に、m_Cond.Wait() 中の全ての待機スレッドを m_Cond.Broadcast() を使って起床します。起床されたスレッドは m_CurrentBits の内容を見て再度待ちに入るか否かを判定することになります。Clear() は現在の m_CurrentBits を 0 にクリアします。</p>
<p>&nbsp;</p>
<h2 id="Anchor_83955576_h2_3">ConditionVariable クラス使用上の注意事項</h2>
<h3 id="Anchor_83955576_h3_1">Spurious wakeup について</h3>
<p>
  <a href="../../../Api/HtmlNX/classnn_1_1os_1_1_condition_variable.html#ad074d822b79e084ee6c608a5a418e470">nn::os::ConditionVariable::Wait()</a> や <a href="../../../Api/HtmlNX/classnn_1_1os_1_1_condition_variable.html#a30c6c31ac58cae287fdc8141805c4ef5">nn::os::ConditionVariable::TimedWait()</a> に関しても spurious wakeup が発生します。詳細は <a href="../Pages/Page_83955531.html">条件変数機能</a>における 「spurious wakeup について」 を参照して下さい。</p>
<h3 id="Anchor_83955576_h3_2">タイムアウト判定について</h3>
<p>
  <a href="../../../Api/HtmlNX/namespacenn_1_1os.html#a2643c34ccfd738890fdd0c546b61c7a8">nn::os::TimedWaitConditionVariable()</a> ではタイムアウトが成立しても返値からそれを判断することはできません。呼び出し元は spurious wakeup 対策も含め、<a href="../../../Api/HtmlNX/namespacenn_1_1os.html#a2643c34ccfd738890fdd0c546b61c7a8">nn::os::TimedWaitConditionVariable()</a> から返ってきた後に各種条件が満足しているかを調べる必要があり、その１つとしてタイムアウトの成立についても調べる必要があります。これは、<a href="../../../Api/HtmlNX/classnn_1_1os_1_1_condition_variable.html">nn::os::ConditionVariable</a> クラスの <a href="../../../Api/HtmlNX/classnn_1_1os_1_1_condition_variable.html#a30c6c31ac58cae287fdc8141805c4ef5">TimedWait()</a> メンバ関数についても同様です。</p>
<p>以下は <a href="../../../Api/HtmlNX/namespacenn_1_1os.html#a79e29821bfb2b0c3a5c222488e90cc89">nn::os::GetSystemTick()</a> を使ったタイムアウト判定の実装例です。前述の MultiEvent クラスの実装に、タイムアウト付きの TimedWaitAllBits() メンバ関数を追加する場合の実装例を示します。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>&nbsp;&nbsp;&nbsp;&nbsp;<span class="c1">// pattern で 1 になっているビットが全てセットされるまで待機する。
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="c1">// 条件が成立した場合は true、タイムアウトした場合は false を返す。
</span>&nbsp;&nbsp;&nbsp; <span class="kt">bool</span> <span class="nf">TimedWaitAllBits</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">pattern</span><span class="p">,</span> <span class="nn">nn::</span><span class="n">TimeSpan</span> <span class="n">timeout</span><span class="p">)</span>    <span class="p">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">auto</span> <span class="n">limitTick</span> <span class="o">=</span> <span class="nn">nn::os::</span><span class="n">GetSystemTick</span><span class="p">()</span> <span class="o">+</span> <span class="nn">nn::os::</span><span class="n">ConvertToTick</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>  <span class="c1">// ... (A)
</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="nn">std::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="nn">nn::os::</span><span class="n">Mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_Mutex</span><span class="p">);</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">while</span> <span class="p">((</span><span class="n">m_CurrentBits</span> <span class="o">&amp;</span> <span class="n">pattern</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">auto</span> <span class="n">timespan</span> <span class="o">=</span> <span class="p">(</span><span class="n">limitTick</span> <span class="o">-</span> <span class="nn">nn::os::</span><span class="n">GetSystemTick</span><span class="p">).</span><span class="n">ToTimeSpan</span><span class="p">();</span>       <span class="c1">// ... (B)
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">if</span> <span class="p">(</span><span class="n">timespan</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">}</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">m_Cond</span><span class="p">.</span><span class="n">TimedWait</span><span class="p">(</span><span class="n">m_Mutex</span><span class="p">,</span> <span class="n">timespan</span><span class="p">);</span>                                    <span class="c1">// ... (C)
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">}</span>
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
&nbsp;&nbsp;&nbsp; <span class="p">}</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>(A) でタイムアウトが成立する Tick カウントの絶対時間を求めて limitTick に代入しておきます。</p>
<p>(B) でタイムアウトが成立するまでの相対 Tick カウントを求め、 <a href="../../../Api/HtmlNX/classnn_1_1_time_span.html">nn::TimeSpan</a> 型に変換しています。この式が記載されている while() ループは何回ループすることになるか分からないため、このような形で都度、タイムアウトが成立する絶対時間までの相対 Tick カウント値を求めています。</p>
<p>(C) でタイムアウト付きの条件変数待ちを発行しています。この関数では、 Signal や Broadcast 通知を受理したり、タイムアウトが成立したり、Spurious Wakeup が発生したりのいずれかで関数から返ってきます。そのため、このプログラムのように spurious wakeup 対策とタイムアウト判定の両方を行なう必要があります。</p>
<p>&nbsp;</p>
</div>
<div class="breadcrumb_bottom"></div>
<div class="page_navigation">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
<tr><td colspan="2" class="page_navi_bottom"></td></tr>
</table>
</div>
</div>
</div>
</body>
</html>
