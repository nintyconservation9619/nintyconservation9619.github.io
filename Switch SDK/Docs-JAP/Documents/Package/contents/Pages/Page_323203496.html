<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<script type="text/javascript" src="../template/js/jquery/jquery.js"></script>
<script type="text/javascript" src="../template/js/common/manualLib.js"></script>
<script type="text/javascript" src="../tocData.js"></script>
<link rel="stylesheet" type="text/css" href="../template/css/template.css" />
<title>NX Addon 5.3.0</title>
</head>
<body data-reassemble="autoindex=no,forceNoLabel=yes">
<div id="autoindex_content">
<div class="body_content">
<noscript>
<div style="border: 4px double black; margin: 4px; padding: 2px; font-weight: bold; background-color: #FFFFCC;">
<p>お使いのブラウザは JavaScript が使用できないため、本ドキュメントの一部機能が無効になっています。</p><p>JavaScript が無効の環境では目次を使用することができません。<br />JavaScriptの実行が許可された状態で閲覧してください。<br /><br /></p>
</div>
</noscript>
<div class="page_navigation_top">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
</table>
</div>
<div class="breadcrumb"></div>

<!-- NX Addon 5.3.0 -->
<div class="pagetitle" id="PageId_323203496">NX Addon 5.3.0</div>
<div class="text_separate">
<!--Remove-->
<p>
  <div>
    <!--Remove-->
  </div>
</p>
<p>
  <ul class="macro_toc">
    <li>
      <a href="#Anchor_323203496_h1_1">DIAG</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_323203496_h2_1">Log Viewer で、一定以上のサイズのログファイルを開いたとき、後半部分のログが表示されない</a>
      </li>
      <li>
        <a href="#Anchor_323203496_h2_2">Log Viewer のその他の不具合</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_323203496_h1_2">FS</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_323203496_h2_3">多数のファイル・ディレクトリを同時にオープンできない</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_323203496_h1_3">Socket</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_323203496_h2_4">nn::socket::Connect() に与える sockaddr が NULL だとエラーになる</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_323203496_h1_4">LDN</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_323203496_h2_5">特定の開発機で通信が不安定になる</a>
      </li>
      <li>
        <a href="#Anchor_323203496_h2_6">スリープからの起床後、ローカル通信を開始できなくなることがある</a>
      </li>
      <li>
        <a href="#Anchor_323203496_h2_7">稀に FATAL ERROR 2162-0002 が発生することがある</a>
      </li>
      <li>
        <a href="#Anchor_323203496_h2_8">稀にスキャンでアクセスポイントを発見できなくなる</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_323203496_h1_5">NFP</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_323203496_h2_9">Mount / Format / Restore で ResultInvalidTag が返ることがある</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_323203496_h1_6">本体機能</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_323203496_h2_10">HOMEメニューをインストールした状態でアプリをVSIやRunOnTargetで起動できる場面の制限</a>
      </li>
      <li>
        <a href="#Anchor_323203496_h2_11">VSIやRunOnTargetで起動中のアプリのオプションが開けない</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_323203496_h1_7">TOOL</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_323203496_h2_12">開発機本体更新ツールで PROD MODE への更新ができない。</a>
      </li>
      <li>
        <a href="#Anchor_323203496_h2_13">HlslCrossCompiler でハルシェーダの入出力変数にロケーションがアサインされない事がある</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_323203496_h1_8">VSI</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_323203496_h2_14">最適化されたコードを正しくデバッグすることができないことがある</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_323203496_h1_9">Graphics</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_323203496_h2_15">GPU処理のブロックが解除されないうちにテクスチャをディスプレイに提出すると、システムが不正な状態になる場合がある</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_323203496_h1_10">NVN</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_323203496_h2_16">異なる RAW フォーマットを持つテクスチャ間で物理メモリを共有するとレンダリング結果にノイズが生じる可能性がある（旧：特定の条件でカラーバッファと深度バッファが物理メモリを共有する場合にレンダリング結果にノイズが生じることがある）</a>
      </li>
      <li>
        <a href="#Anchor_323203496_h2_17">デバッグレイヤを有効にした NVNdevice を作成後に、NULL を引数として nvnDeviceGetProcAddress 等のAPIを呼び出すとデバッグレイヤが機能しなくなる</a>
      </li>
      <li>
        <a href="#Anchor_323203496_h2_18">GLSLC 関連</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_323203496_h1_11">atk</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_323203496_h2_19">シーケンスサウンドの再生時、 fseq で指定したテンポと比較して発音などのタイミングが遅れる</a>
      </li>
    </ul>
  </ul>
</p>
<h1 id="Anchor_323203496_h1_1">DIAG</h1>
<h2 id="Anchor_323203496_h2_1">Log Viewer で、一定以上のサイズのログファイルを開いたとき、後半部分のログが表示されない</h2>
<!--Remove-->
<h6 id="Anchor_323203496_h6_1">症状</h6>
<p>数十 MB 以上のサイズの NX Binaly Log (.nxbinlog) 形式のファイルを開いたとき、後半部分のログが省略されて、表示されません。</p>
<h6 id="Anchor_323203496_h6_2">回避策</h6>
<p>Log Viewer の Menu &gt; Convert NX Binary Log より、NX Binary Log をテキスト形式に変換して出力することで、すべてのログを確認することができます。</p>
<p>1GB を超えるような巨大なログを変換するときは、数分かかることがあります。</p>
<h6 id="Anchor_323203496_h6_3">修正予定</h6>
<p>次回以降のリリースで修正予定です。</p>
<h2 id="Anchor_323203496_h2_2">Log Viewer のその他の不具合</h2>
<!--Remove-->
<h6 id="Anchor_323203496_h6_4">症状</h6>
<ul>
  <li>ログを範囲選択するとき、任意の範囲より広くログが選択されることがある。</li>
  <li>Windows 7 で、ツールチップに表示されるログのメタデータのインデントが崩れる。</li>
</ul>
<h6 id="Anchor_323203496_h6_5">回避策</h6>
<p>回避策はありません。</p>
<h6 id="Anchor_323203496_h6_6">修正予定</h6>
<p>次回以降のリリースで修正予定です。</p>
<h1 id="Anchor_323203496_h1_2">FS</h1>
<h2 id="Anchor_323203496_h2_3">多数のファイル・ディレクトリを同時にオープンできない</h2>
<!--Remove-->
<h6 id="Anchor_323203496_h6_7">症状</h6>
<p>以下のファイルシステムで、同時にオープンできるファイル数・ディレクトリ数に制限があります。</p>
<table class="wrapped" style="margin-left: 20.0px;">
  <colgroup>
    <col />
    <col />
  </colgroup>
  <tbody>
    <tr>
      <th>ファイルシステム</th>
      <th>同時オープン可能数</th>
    </tr>
    <tr>
      <td>ホスト PC 上のファイルシステム( <span class="ApiLink_nn__fs__MountHost">nn::fs::MountHost</span>(), <span class="ApiLink_nn__fs__MountHostRoot">nn::fs::MountHostRoot</span>() )</td>
      <td>
        <p>202</p>
      </td>
    </tr>
    <tr>
      <td>アプリケーションプログラムフォーマット＝Raw で起動した場合のリソースデータ ( <span class="ApiLink_nn__fs__MountRom">nn::fs::MountRom</span>() )&nbsp;</td>
      <td>
        <p>202</p>
      </td>
    </tr>
  </tbody>
</table>
<h6 id="Anchor_323203496_h6_8">回避策</h6>
<p>回避策はありません。</p>
<h6 id="Anchor_323203496_h6_9">修正予定</h6>
<p>次回以降のリリースで修正を検討しています。</p>
<h1 id="Anchor_323203496_h1_3">Socket</h1>
<h2 id="Anchor_323203496_h2_4">nn::socket::Connect() に与える sockaddr が NULL だとエラーになる</h2>
<!--Remove-->
<h6 id="Anchor_323203496_h6_10">症状</h6>
<p>
  <span class="ApiLink_nn__socket__Connect">nn::socket::Connect</span>() に与える sockaddr が NULL だとエラーになります。</p>
<h6 id="Anchor_323203496_h6_11">回避策</h6>
<p>回避策はありません。</p>
<h6 id="Anchor_323203496_h6_12">修正予定</h6>
<p>次回以降のリリースで修正予定です。</p>
<h1 id="Anchor_323203496_h1_4">LDN</h1>
<h2 id="Anchor_323203496_h2_5">特定の開発機で通信が不安定になる</h2>
<!--Remove-->
<h6 id="Anchor_323203496_h6_13">症状</h6>
<p>特定の開発機で以下のような症状が発生する可能性があります。</p>
<ul>
  <li>スキャンでネットワークを見つけられない</li>
  <li>ネットワークへの接続に失敗する</li>
  <li>パケット損失率が高い</li>
</ul>
<p>さらに、本件の症状が発生する開発機が 2 台存在する場合、その 2 台間の通信がさらに不安定になります。</p>
<h6 id="Anchor_323203496_h6_14">回避策</h6>
<p>周囲の電波環境が悪い場合にも同じ問題が発生します。通信機器の少ない環境に移動する、他の開発機に交換するなどして症状が改善するか確認してください。本件の症状が顕著な場合、任天堂のサポート窓口まで問い合わせてください。</p>
<h6 id="Anchor_323203496_h6_15">修正予定</h6>
<p>今後の対応を検討中です。</p>
<h2 id="Anchor_323203496_h2_6">スリープからの起床後、ローカル通信を開始できなくなることがある</h2>
<!--Remove-->
<h6 id="Anchor_323203496_h6_16">症状</h6>
<p>スリープからの起床をきっかけとして、機内モードの設定に依らず <span class="ApiLink_nn__ldn__OpenAccessPoint">nn::ldn::OpenAccessPoint</span>() や <span class="ApiLink_nn__ldn__OpenStation">nn::ldn::OpenStation</span>() が <span class="ApiLink_nn__ldn__ResultWifiOff">nn::ldn::ResultWifiOff</span> を返し続ける状態になることがあります。一度この状態に陥ると、開発機を再起動するまで回復しません。</p>
<h6 id="Anchor_323203496_h6_17">回避策</h6>
<p>ありません。</p>
<h6 id="Anchor_323203496_h6_18">修正予定</h6>
<p>次回以降のリリースで修正予定です。</p>
<h2 id="Anchor_323203496_h2_7">稀に FATAL ERROR 2162-0002 が発生することがある</h2>
<!--Remove-->
<h6 id="Anchor_323203496_h6_19">症状</h6>
<p>以下のタイミングで FATAL ERROR 2162-0002 が発生することがあります。</p>
<ul>
  <li>ネットワークの構築、破棄</li>
  <li>AdvertiseData や StationAcceptPolicy の変更</li>
  <li>ステーションの追加、離脱</li>
</ul>
<h6 id="Anchor_323203496_h6_20">回避策</h6>
<p>ありません</p>
<h6 id="Anchor_323203496_h6_21">修正予定</h6>
<p>次回以降のリリースで修正予定です。</p>
<h2 id="Anchor_323203496_h2_8">稀にスキャンでアクセスポイントを発見できなくなる</h2>
<!--Remove-->
<h6 id="Anchor_323203496_h6_22">症状</h6>
<p>稀に以下のいずれかの症状が発生することがあります。</p>
<ul>
  <li>アクセスポイントがスキャンで発見できないネットワークを構築してしまうことがある</li>
  <li>特定のステーションにおいて、スキャンでネットワークを発見できなくなることがある</li>
</ul>
<h6 id="Anchor_323203496_h6_23">回避策</h6>
<p>アクセスポイント側で前者の問題が発生した場合、ネットワークを一旦破棄してから再度ネットワークを構築しなおすことで症状が回復します。</p>
<p>ステーション側で後者の問題が発生した場合、一旦 <span class="ApiLink_nn__ldn__CloseStation">nn::ldn::CloseStation</span>() あるいは <span class="ApiLink_nn__ldn__Finalize">nn::ldn::Finalize</span>() でステーションとしての動作を終了してから、再度ステーションになることで症状が回復します。</p>
<h6 id="Anchor_323203496_h6_24">修正予定</h6>
<p>次回以降のリリースで修正予定です。</p>
<h1 id="Anchor_323203496_h1_5">NFP</h1>
<h2 id="Anchor_323203496_h2_9">Mount / Format / Restore で&nbsp;ResultInvalidTag が返ることがある</h2>
<!--Remove-->
<h6 id="Anchor_323203496_h6_25">症状</h6>
<p>タグ側に問題がなく、正しくかざされている状態で稀に ResultInvalidTag が返ることがあります。</p>
<h6 id="Anchor_323203496_h6_26">回避策</h6>
<p>再度タグをかざしてください。</p>
<h6 id="Anchor_323203496_h6_27">修正予定</h6>
<p>未定です。</p>
<h1 id="Anchor_323203496_h1_6">本体機能</h1>
<h2 id="Anchor_323203496_h2_10">HOMEメニューをインストールした状態でアプリをVSIやRunOnTargetで起動できる場面の制限</h2>
<!--Remove-->
<h6 id="Anchor_323203496_h6_28">症状</h6>
<p>HOMEメニューをインストールしてHOMEメニューが起動した状態から、VSIやRunOnTargetでアプリを起動すると特殊な状態になってアプリを起動しますが、一部の画面ではこの機能を使うことができず、止まります。止まることが分かっている画面は以下のとおりです。</p>
<ul>
  <li>アプリ起動前にアカウント選択をする画面</li>
  <li>アプリ起動前にダイアログが出ている画面</li>
</ul>
<h6 id="Anchor_323203496_h6_29">回避策</h6>
<p>上記画面でアプリを起動しないようにしてください。</p>
<p>なお、VSIやRunOnTargetによる起動では細かな挙動が製品と異なる可能性がありますので、最終的なアプリとHOMEメニューの行き来の挙動を確認する際はnspを作成してインストールするかゲームカードに焼いて確認をすることをおすすめします。</p>
<h6 id="Anchor_323203496_h6_30">修正予定</h6>
<p>未定です。</p>
<h2 id="Anchor_323203496_h2_11">VSIやRunOnTargetで起動中のアプリのオプションが開けない</h2>
<!--Remove-->
<h6 id="Anchor_323203496_h6_31">症状</h6>
<p>HOMEメニューをインストールしてHOMEメニューが起動した状態から、VSIやRunOnTargetでアプリを起動すると特殊な状態になってアプリを起動しますが、それに対応した「オプション」を開くことはできません。</p>
<h6 id="Anchor_323203496_h6_32">回避策</h6>
<p>インストールするかゲームカードに焼いて「オプション」を開いてください。</p>
<h6 id="Anchor_323203496_h6_33">修正予定</h6>
<p>未定です。</p>
<h1 id="Anchor_323203496_h1_7">TOOL</h1>
<h2 id="Anchor_323203496_h2_12">開発機本体更新ツールで PROD MODE への更新ができない。</h2>
<!--Remove-->
<h6 id="Anchor_323203496_h6_34">症状</h6>
<p>EDEV を InitializeEdev もしくは InitializeEdevWin で初期化しようとすると、&quot;Parse GetSerialNumber output failed.&quot; と表示されエラーになることがあります。<br />なお発生頻度は低いです。</p>
<p>
  <br />
</p>
<h6 id="Anchor_323203496_h6_35">回避策</h6>
<p>初期化を再実行して下さい。</p>
<h6 id="Anchor_323203496_h6_36">修正予定</h6>
<p>次回リリースにて修正予定です。</p>
<h2 id="Anchor_323203496_h2_13">HlslCrossCompiler でハルシェーダの入出力変数にロケーションがアサインされない事がある</h2>
<!--Remove-->
<h6 id="Anchor_323203496_h6_37">症状</h6>
<p>DXBC に hs_control_point_phase が含まれるハルシェーダをコンバートした時に入出力変数にロケーションがアサインされない場合があります。</p>
<h6 id="Anchor_323203496_h6_38">回避策</h6>
<p>ありません。</p>
<h6 id="Anchor_323203496_h6_39">修正予定</h6>
<p>対応を検討しています。</p>
<h1 id="Anchor_323203496_h1_8">VSI</h1>
<h2 id="Anchor_323203496_h2_14">最適化されたコードを正しくデバッグすることができないことがある</h2>
<!--Remove-->
<p>インライン展開された関数内に置いたブレークポイントで停止することがないなど、最適化されたコードを正しくデバッグできないことがあります。&nbsp;<br />将来的には改善予定です。&nbsp;</p>
<h1 id="Anchor_323203496_h1_9">Graphics</h1>
<h2 id="Anchor_323203496_h2_15">GPU処理のブロックが解除されないうちにテクスチャをディスプレイに提出すると、システムが不正な状態になる場合がある</h2>
<!--Remove-->
<h6 id="Anchor_323203496_h6_40">症状</h6>
<p>以下の手順を行うと、システムが不正な状態になる場合があります。</p>
<p>アプリが GPU 処理をブロックした状態で、テクスチャをディスプレイに提出する<br />提出後、GPU 処理をブロックした状態が解除されないうちに、HOME メニュー遷移、本体スリープ等のアプリの実行を停止させる操作が行われる<br />「システムが不正な状態」とは、具体的には以下のような状態になります。</p>
<p>HOME メニュー遷移が正しく行われない<br />本体スリープに正しく入ることができない<br />本症状は、現在リリース中のすべてのバージョンで発生する可能性があります。</p>
<p>一例として以下のような実装にした場合に発生することがあります。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>nvnCommandBufferBeginRecording(&amp;m_CommandBuffer);
{
&nbsp;&nbsp;&nbsp;&nbsp;・・省略・・
&nbsp;&nbsp;&nbsp;&nbsp;// イベント待ちを行う
&nbsp;&nbsp;&nbsp;&nbsp;nvnCommandBufferWaitEvent(&amp;m_CommandBuffer, &amp;m_Event, NVN_EVENT_WAIT_MODE_GEQUAL_WRAP, nvnEventGetValue(&amp;m_Event) + 1);
&nbsp;&nbsp;&nbsp;&nbsp;・・省略・・
}
m_CommandHandle = nvnCommandBufferEndRecording(&amp;m_CommandBuffer);
// コマンドを提出する
nvnQueueSubmitCommands(&amp;m_Queue, 1, &amp;m_CommandHandle);
// 提出したコマンドをフラッシュし、GPU での実行が開始される
nvnQueueFlush();
// テクスチャを提出する
nvnQueuePresentTexture(&amp;m_Queue, m_pWindow, index);
// コマンドバッファにて待っているイベントをシグナルする
nvnEventSignal(&amp;m_Event, NVN_EVENT_SIGNAL_MODE_WRITE, nvnEventGetValue(&amp;m_Event) + 1);</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>
  <br />
</p>
<p>この例では、nvnQueuePresentTexture の呼び出し後に nvnEventSignal によって GPU のブロックを解除しています。</p>
<p>そのため、もし nvnQueuePresentTexture 呼び出し直後に HOME メニュー遷移、本体スリープ等が発生すると不正な状態になる可能性があります。</p>
<p>これ以外にも NVNsync を用いて複数の NVNqueue 間でGPU 処理をブロックしている場合等に同様の状況を作り出す可能性があります。</p>
<p>
  <br />
</p>
<h6 id="Anchor_323203496_h6_41">回避策</h6>
<p>GPU 処理をブロックした状態が解除されないうちに、テクスチャをディスプレイに提出するような実装にはしないでください。</p>
<p>以下のような実装を行うことで回避することができます。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>nvnCommandBufferBeginRecording(&amp;m_CommandBuffer);
{
&nbsp;&nbsp;&nbsp;&nbsp;・・省略・・
&nbsp;&nbsp;&nbsp;&nbsp;// イベント待ちを行う
&nbsp;&nbsp;&nbsp;&nbsp;nvnCommandBufferWaitEvent(&amp;m_CommandBuffer, &amp;m_Event, NVN_EVENT_WAIT_MODE_GEQUAL_WRAP, nvnEventGetValue(&amp;m_Event) + 1);
&nbsp;&nbsp;&nbsp;&nbsp;・・省略・・
}
m_CommandHandle = nvnCommandBufferEndRecording(&amp;m_CommandBuffer);
// コマンドを提出する
nvnQueueSubmitCommands(&amp;m_Queue, 1, &amp;m_CommandHandle);
// 提出したコマンドをフラッシュし、GPU での実行開始を保証する
nvnQueueFlush();
// テクスチャを提出する前に、コマンドバッファにて待っているイベントをシグナルし、GPU のブロックを解除する
nvnEventSignal(&amp;m_Event, NVN_EVENT_SIGNAL_MODE_WRITE, nvnEventGetValue(&amp;m_Event) + 1);
// テクスチャを提出する
nvnQueuePresentTexture(&amp;m_Queue, m_pWindow, index);</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>
  <br />
</p>
<p>nvnEventSignal を nvnQueuePresentTexture の呼び出し前に持ってくることにより、GPU 処理のブロックが確実に解除された状態で、テクスチャが提出されます。</p>
<p>「GPU 処理をブロックした状態」を作り出す API としては、NVN では以下の 3 種類があります。</p>
<ul>
  <li>nvnCommandBufferWaitSync</li>
  <li>nvnCommandBufferWaitEvent</li>
  <li>nvnQueueWaitSync</li>
</ul>
<p>NVN 以外のグラフィックス API を利用する場合も同様に GPU 処理をブロックした状態が解除されないうちに、テクスチャをディスプレイに提出するような実装にはしないでください。</p>
<h6 id="Anchor_323203496_h6_42">修正予定</h6>
<p>本症状は仕様となりますので、修正予定はありません。</p>
<h1 id="Anchor_323203496_h1_10">NVN</h1>
<h2 id="Anchor_323203496_h2_16">異なる RAW フォーマットを持つテクスチャ間で物理メモリを共有するとレンダリング結果にノイズが生じる可能性がある（旧：特定の条件でカラーバッファと深度バッファが物理メモリを共有する場合にレンダリング結果にノイズが生じることがある）</h2>
<!--Remove-->
<h6 id="Anchor_323203496_h6_43">症状</h6>
<p>異なる RAW フォーマットを持つテクスチャ間で物理メモリを共有するとレンダリング結果にノイズが生じる可能性があります。</p>
<p>NX では、テクスチャは 5 つの異なる RAW フォーマットを持ちます。（注：これは、テクスチャのストレージクラスとは異なる要素です）<br />以下に、RAW フォーマットの種類と各テクスチャフォーマットとの対応関係を示します。</p>
<table class="wrapped">
  <colgroup>
    <col />
    <col />
  </colgroup>
  <tbody>
    <tr>
      <th>RAW フォーマット</th>
      <th>テクスチャフォーマット</th>
    </tr>
    <tr>
      <td>Pitch</td>
      <td>
        <ul>
          <li>すべてのリニアフォーマット</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>Geberic 16Bx2</td>
      <td>
        <ul>
          <li>すべてのカラーフォーマット</li>
          <li>nvn::Format::DEPTH32F</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>Z16</td>
      <td>
        <ul>
          <li>
            <span style="color: rgb(51,51,51);">nvn::Format::DEPTH16</span>
          </li>
          <li>
            <span style="color: rgb(51,51,51);">nvn::Format::STENCIL8</span>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>Z24</td>
      <td>
        <ul>
          <li>
            <span style="color: rgb(51,51,51);">nvn::Format::DEPTH24</span>
          </li>
          <li>
            <span style="color: rgb(51,51,51);">nvn::Format::DEPTH24_STENCIL8</span>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>ZF32</td>
      <td>
        <ul>
          <li>
            <span style="color: rgb(51,51,51);">nvn::Format::DEPTH32F_STENCIL8</span>
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<p>この異なる RAW フォーマットを持つテクスチャ間で物理メモリを共有し、それぞれのテクスチャで書き込みを行っていると、L2 キャッシュの状態に不整合が生じ、その結果としてレンダリング結果にノイズが生じる可能性があります。</p>
<h6 id="Anchor_323203496_h6_44">回避策</h6>
<p>異なる RAW フォーマットを持つテクスチャ間で同じ物理メモリを共有しない（同じ物理メモリプールに仮想メモリプールをエイリアスしない）ようにすることで、この問題を回避できます。</p>
<h6 id="Anchor_323203496_h6_45">修正予定</h6>
<p>NXAddon 6.x.x にて、L2 キャッシュの無効化を行うバリアとして nvn::BarrierBits::INVALIDATE_L2_CACHE を提供予定です。<br />異なる RAW フォーマットを持つテクスチャを用いて同じ物理メモリへの書き込みを行う前に、このバリアを挿入することによって問題を回避できるようになります。</p>
<h2 id="Anchor_323203496_h2_17">デバッグレイヤを有効にした NVNdevice を作成後に、NULL を引数として nvnDeviceGetProcAddress 等のAPIを呼び出すとデバッグレイヤが機能しなくなる</h2>
<!--Remove-->
<h6 id="Anchor_323203496_h6_46">症状</h6>
<p>デバッグレイヤを有効にした NVNdevice を作成後に、nvnDeviceGetProcAddress 等の関数エントリポイント取得APIに nullptr を指定して呼び出すと、デバッグレイヤが機能しなくなります。</p>
<p>症状が発生する実装例</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre>extern &quot;C&quot; PFNNVNGENERICFUNCPTRPROC NVNAPIENTRY nvnBootstrapLoader(const char* name);
{
&nbsp;&nbsp;&nbsp;&nbsp;pfnc_nvnDeviceGetProcAddress = (PFNNVNDEVICEGETPROCADDRESSPROC)(nvnBootstrapLoader(&quot;nvnDeviceGetProcAddress&quot;));
&nbsp;&nbsp;&nbsp;&nbsp;pfnc_nvnDeviceInitialize = reinterpret_cast&lt;PFNNVNDEVICEINITIALIZEPROC&gt;(pfnc_nvnDeviceGetProcAddress(nullptr, &quot;nvnDeviceInitialize&quot;));
&nbsp;&nbsp;&nbsp;&nbsp;pfnc_nvnDeviceBuilderSetDefaults = reinterpret_cast&lt;PFNNVNDEVICEBUILDERSETDEFAULTSPROC&gt;(pfnc_nvnDeviceGetProcAddress(nullptr, &quot;nvnDeviceBuilderSetDefaults&quot;));
&nbsp;&nbsp;&nbsp;&nbsp;pfnc_nvnDeviceBuilderSetFlags = reinterpret_cast&lt;PFNNVNDEVICEBUILDERSETFLAGSPROC&gt;(pfnc_nvnDeviceGetProcAddress(nullptr, &quot;nvnDeviceBuilderSetFlags&quot;));
&nbsp;&nbsp;&nbsp;&nbsp;NVNdeviceBuilder deviceBuilder;
&nbsp;&nbsp;&nbsp;&nbsp;pfnc_nvnDeviceBuilderSetDefaults(&amp;deviceBuilder);
&nbsp;&nbsp;&nbsp;&nbsp;// デバッグレイヤを有効にするフラグを立てる。
&nbsp;&nbsp;&nbsp;&nbsp;pfnc_nvnDeviceBuilderSetFlags(&amp;deviceBuilder, NVN_DEVICE_FLAG_DEBUG_ENABLE_LEVEL_4_BIT);
&nbsp;&nbsp;&nbsp;&nbsp;NVNdevice device;
&nbsp;&nbsp;&nbsp;&nbsp;if (pfnc_nvnDeviceInitialize(&amp;device, &amp;deviceBuilder) == false)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NN_ASSERT(0, &quot;nvnDeviceInitialize&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// デバッグレイヤを有効にした NVNdevice を指定して呼び出す必要がある。
&nbsp;&nbsp;&nbsp;&nbsp;nvnLoadCProcs(&amp;device, pfnc_nvnDeviceGetProcAddress);
&nbsp;&nbsp;&nbsp;&nbsp;// NVNdevice を渡す引数に nullptr を指定して nvnDeviceGetProcAddress() を呼び出すと、副作用としてデバッグレイヤが機能しなくなる。
&nbsp;&nbsp;&nbsp;&nbsp;pfnc_nvnDeviceGetProcAddress(nullptr, &quot;nvnDeviceInitialize&quot;);
}</pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>
  <br />
</p>
<p>上記のように、nvnDeviceGetProcAddress(nullptr) を呼び出すとデバッグレイヤが機能しなくなります。</p>
<p>また、アプリケーションがリンクするライブラリ内部にて同様の操作が行われても、デバッグレイヤが機能しなくなります。</p>
<p>現状では、リリースしているすべてのバージョンで、movie ライブラリの NativeTexture モードを利用していると、本件の現象に遭遇することを確認しています。</p>
<h6 id="Anchor_323203496_h6_47">回避策</h6>
<p>NVNdevice 作成後に関数エントリポイント取得関数を利用する場合には、必ず NVNdevice を引数に渡してください。</p>
<p>対象となる関数エントリポイント取得関数は以下の通りです。</p>
<ul>
  <li>nvnDeviceGetProcAddress</li>
  <li>nvnLoadCProcs</li>
  <li>nvnLoadCPPProcs</li>
  <li>nvnBootstrapLoader</li>
</ul>
<p>この関数は NVNdevice を引数に取りませんが、内部的には nvnDeviceGetProcAddress(nullptr, ...) に相当します。このため、NVNdevice 作成後に nvnBootstrapLoader() を呼び出してはいけません。<br />ライブラリ内部での関数エントリポイント取得APIの呼び出しによって発生する本件の問題については、回避方法はありません。</p>
<h6 id="Anchor_323203496_h6_48">修正予定</h6>
<p>将来的にリリースされるバージョンで修正予定です。</p>
<h2 id="Anchor_323203496_h2_18">GLSLC 関連</h2>
<!--Remove-->
<ul>
  <li>The TX1 versions of the GLSLC library may produce slightly different machine code than the Windows version, including potential performance differences. The code produced on both platforms should be functionally correct though, and convergence of the two will happen in future changes.</li>
  <li>16-bit floating point values are supported in GLSL using mediump/lowp precision qualifiers with the extension __GL_NV_desktop_mediump_lowp, or by using explicit float16 types with the NV_gpu_shader5 extension.&nbsp; When using the extension GL_NV_desktop_mediump_lowp with mediump and lowp qualifiers, there are a few known issues:<ul><li>Mixing interface attribute types between shader stages with explicit NV_gpu_shader5 float16 types on one side of the interface and mediump/lowp types on the other side of the interface could produce linker errors.</li><li>Using explicit NV_gpu_shader5 float16 types as the types for interface attributes between two shader stages will produce a linker error.</li><li>ints/uints can not be implicitly converted to floats qualified with mediump/lowp qualifiers.&nbsp; This can be worked around by explicit constructing float types from the int/uint variables (similar to explicit casting in C/C++).&nbsp; This issue currently affects GLSL shaders using GL_NV_desktop_mediump_lowp _as well as_ ES shaders regardless of whether the extension GL_EXT_shader_implicit_conversions is used.</li><li>FP16 math when used with imageStore may cause corruption in certain cases. This issue is being investigated and will be fixed in an upcoming release.</li></ul></li>
</ul>
<h1 id="Anchor_323203496_h1_11">atk</h1>
<h2 id="Anchor_323203496_h2_19">シーケンスサウンドの再生時、 fseq で指定したテンポと比較して発音などのタイミングが遅れる</h2>
<!--Remove-->
<h6 id="Anchor_323203496_h6_49">症状</h6>
<p>シーケンスサウンドの再生時、 fseq で指定したテンポと比較して発音などのタイミングが遅れます。<br />遅れる幅は、再生時間に応じて大きくなります。</p>
<h6 id="Anchor_323203496_h6_50">回避策</h6>
<p>
  <span class="ApiLink_nn__atk__EffectAux">nn::atk::EffectAux</span> をいずれかの Aux バスに追加したのち、 <span class="ApiLink_nn__atk__EffectAux">nn::atk::EffectAux</span> の処理時に取得できるサンプル数に応じて、<br />シーケンスサウンドのテンポを <span class="ApiLink_nn__atk__SequenceSoundHandle__SetTempoRatio">nn::atk::SequenceSoundHandle::SetTempoRatio</span>() により変化させることで回避が可能です。</p>
<h6 id="Anchor_323203496_h6_51">修正予定</h6>
<p>将来的にリリースされるバージョンで修正予定です。</p>
<p>
  <br />
</p>
</div>
<div class="breadcrumb_bottom"></div>
<div class="page_navigation">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
<tr><td colspan="2" class="page_navi_bottom"></td></tr>
</table>
</div>
</div>
</div>
<!--AddLink-->
<script>
var NintendoSdkApiRefernce = {
    idMap: {},
    linkRewrite: function ()
    {
        var idMap = NintendoSdkApiRefernce.idMap;
        function rewrite(el)
        {
            var e = idMap[el.className];
            if (e === undefined)
            {
                return;
            }
            var html = '';
            html += '<a href=';
            html += e.url;
            html += ' target="_blank">';
            html += el.innerHTML;
            html += '</a>';
            el.innerHTML = html;
        }
        var apiLinkElems = document.querySelectorAll('span[class*="ApiLink_"]');
        for (var i = 0, n = apiLinkElems.length; i< n; ++i) {
            rewrite(apiLinkElems[i]);
        }
    }
};
function SetUrl( id, url )
{
    NintendoSdkApiRefernce.idMap[id] = { url: url };
}
SetUrl( 'ApiLink_nn__fs__MountHost', '../../../Api/HtmlNX/namespacenn_1_1fs.html#a1b85bf3f3cf038cb67a991a3e3304751' )
SetUrl( 'ApiLink_nn__fs__MountHostRoot', '../../../Api/HtmlNX/namespacenn_1_1fs.html#a2ea39d2487ac28bc767cd699eeeebe11' )
SetUrl( 'ApiLink_nn__fs__MountRom', '../../../Api/HtmlNX/namespacenn_1_1fs.html#a2e453fe1fbf8f818dc45bbd2897105cd' )
SetUrl( 'ApiLink_nn__socket__Connect', '../../../Api/HtmlNX/namespacenn_1_1socket.html#a3aded7f0c8c072c7beb68a670d03d36f' )
SetUrl( 'ApiLink_nn__ldn__OpenAccessPoint', '../../../Api/HtmlNX/namespacenn_1_1ldn.html#abd2dc6aa5708bb991b291fbe2342dd0b' )
SetUrl( 'ApiLink_nn__ldn__OpenStation', '../../../Api/HtmlNX/namespacenn_1_1ldn.html#ad296900d9a6018c664dc29de81bfcbae' )
SetUrl( 'ApiLink_nn__ldn__ResultWifiOff', '../../../Api/HtmlNX/classnn_1_1ldn_1_1_result_wifi_off.html' )
SetUrl( 'ApiLink_nn__ldn__CloseStation', '../../../Api/HtmlNX/namespacenn_1_1ldn.html#af3173a1e4c8f4ddbefec092efb59f1b2' )
SetUrl( 'ApiLink_nn__ldn__Finalize', '../../../Api/HtmlNX/namespacenn_1_1ldn.html#a7334cac55eb557b03289cbac37089355' )
SetUrl( 'ApiLink_nn__atk__EffectAux', '../../../Api/HtmlNX/classnn_1_1atk_1_1_effect_aux.html' )
SetUrl( 'ApiLink_nn__atk__SequenceSoundHandle__SetTempoRatio', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sequence_sound_handle.html#a56732c6687c0e7fa54979d1a421280b1' )

NintendoSdkApiRefernce.linkRewrite();
</script>
<!--AddLink-->
</body>
</html>
