<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<script type="text/javascript" src="../template/js/jquery/jquery.js"></script>
<script type="text/javascript" src="../template/js/common/manualLib.js"></script>
<script type="text/javascript" src="../tocData.js"></script>
<link rel="stylesheet" type="text/css" href="../template/css/template.css" />
<title>pthread APIs</title>
</head>
<body data-reassemble="autoindex=no,forceNoLabel=yes">
<div id="autoindex_content">
<div class="body_content">
<noscript>
<div style="border: 4px double black; margin: 4px; padding: 2px; font-weight: bold; background-color: #FFFFCC;">
<p>お使いのブラウザは JavaScript が使用できないため、本ドキュメントの一部機能が無効になっています。</p><p>JavaScript が無効の環境では目次を使用することができません。<br />JavaScriptの実行が許可された状態で閲覧してください。<br /><br /></p>
</div>
</noscript>
<div class="page_navigation_top">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
</table>
</div>
<div class="breadcrumb"></div>

<!-- pthread APIs -->
<div class="pagetitle" id="PageId_126570133">pthread APIs</div>
<div class="text_separate">
<p>
  <ul class="macro_toc">
    <li>
      <a href="#Anchor_126570133_h1_1">posix 関数インターフェース</a>
    </li>
    <ul>
      <ul>
        <ul>
          <li>
            <a href="#Anchor_126570133_h4_1">pthread_setschedparam()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_2">pthread_getschedparam()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_3">pthread_setschedprio()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_4">pthread_once()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_5">pthread_mutexattr_gettype() および pthread_mutexattr_settype()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_6">pthread_cond_broadcast()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_7">pthread_cond_signal()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_8">pthread_attr_getstack() および pthread_attr_setstack()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_9">pthread_create()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_10">pthread_attr_getscope() および pthread_attr_setscope()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_11">pthread_attr_getstacksize() および pthread_attr_setstacksize()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_12">pthread_getname_np() および pthread_setname_np()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_13">pthread_attr_getschedparam() および pthread_attr_setschedparam()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_14">pthread_condattr_getpshared() および pthread_condattr_setpshared()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_15">pthread_attr_getinheritsched() および pthread_attr_setinheritsched()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_16">pthread_equal()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_17">pthread_exit()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_18">pthread_condattr_init() および pthread_condattr_destroy()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_19">pthread_join()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_20">pthread_self()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_21">pthread_mutex_init()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_22">pthread_mutex_destroy()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_23">pthread_mutex_lock() および pthread_mutex_unlock()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_24">pthread_mutex_trylock()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_25">pthread_cond_init()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_26">pthread_cond_destroy()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_27">pthread_cond_wait()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_28">pthread_cond_timedwait()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_29">pthread_key_create()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_30">pthread_key_delete()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_31">pthread_getspecific() および pthread_setspecific()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_32">pthread_attr_getschedpolicy() および pthread_attr_setschedpolicy()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_33">pthread_attr_init() および pthread_attr_destroy()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_34">pthread_mutexattr_init() および pthread_mutexattr_destroy()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_35">pthread_barrier_init() および pthread_barrier_destroy()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_36">pthread_barrier_wait()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_37">pthread_barrierattr_getpshared() および pthread_barrierattr_setpshared()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_38">pthread_getaffinity_np() and pthread_setaffinity_np()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_39">pthread_rwlock_init() and pthread_rwlock_destroy()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_40">pthread_rwlock_unlock()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_41">pthread_rwlock_rdlock() and pthread_rwlock_wrlock()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_42">pthread_rwlock_tryrdlock() and pthread_rwlock_trywrlock()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_43">sched_yield()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_44">sched_get_priority_min() および sched_get_priority_max()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_45">sem_init() および sem_destroy()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_46">sem_getvalue()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_47">sem_post()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_48">sem_timedwait()</a>
          </li>
          <li>
            <a href="#Anchor_126570133_h4_49">sem_wait() and sem_trywait()</a>
          </li>
        </ul>
      </ul>
    </ul>
  </ul>
</p>
<div class="section">
  <h1 id="Anchor_126570133_h1_1">posix 関数インターフェース</h1>
</div>
<div class="section">
  <p>
    <br />
  </p>
  <div class="warn_new">
    <div class="warn_new_left">警告：</div>
    <div class="warn_new_right">
      <p>
        <span style="color: rgb(153,153,153);">
          <strong>グレー</strong>
        </span>の文字で表記されている errno 返り値は、NX 上のこの実装では返されません。</p>
    </div>
  </div>
  <p>
    <br />
  </p>
  <p>
    <br />
  </p>
  <table class="wrapped">
    <colgroup>
      <col />
      <col />
    </colgroup>
    <tbody>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_1">pthread_setschedparam()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_setschedparam</strong> (pthread_t thread, int policy, const struct sched_param *param)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <div class="section">
              <strong>
                <u>説明</u>
              </strong>
            </div>
            <div class="section">pthread_setschedparam() 関数は、渡されたスレッドのスケジューリングに関するポリシーとパラメータを設定します。</div>
            <div class="section">
              <br />
            </div>
            <div class="section">
              <u>
                <strong>NX 固有の扱い</strong>
              </u>
            </div>
            <div class="section">
              <ul>
                <li>NX では 'SCHED_FIFO' と 'SCHED_OTHER' のみをサポートしています。</li>
                <li>NX では、優先度として -16（最高）～ 15（最低）の範囲で 32 段階をサポートし、デフォルトは 0 です。</li>
              </ul>
            </div>
            <div class="section">
              <p>
                <br />
              </p>
              <div class="note_new">
                <div class="note_new_left">注意：</div>
                <div class="note_new_right">
                  <p>NX でサポートしていないスケジューリングモード：<br />- SCHED_RR<br />- SCHED_BATCH<br />- SCHED_IDLE<br />- SCHED_DEADLINE<br />- SCHED_RESET_ON_FORK</p>
                </div>
              </div>
              <p>
                <br />
              </p>
            </div>
            <div class="section">
              <p>
                <u>
                  <strong>インターフェース関数</strong>
                </u>
              </p>
              <p>int <strong>__nnmusl_pthread_setschedparam </strong>(pthread_t t, int policy, const struct sched_param *param)</p>
              <p>
                <br />
              </p>
            </div>
            <div class="section">
              <u>
                <strong>Errno</strong>
              </u>
            </div>
            <div class="section">
              <p>
                <strong>ENOTSUP</strong>：渡された <em>policy</em> が無効な値です。</p>
              <p>
                <strong>ESRCH</strong>：ID が <em>thread</em> であるスレッドが見つかりませんでした。</p>
              <p>
                <span style="color: rgb(153,153,153);">
                  <strong>EPERM</strong>：指定されたスケジューリングのポリシーとパラメータを設定するための適切な権限が呼び出し元にありません。</span>
              </p>
              <p>
                <span style="color: rgb(153,153,153);">
                  <strong>EINVAL</strong>：<em>policy</em> が認識されていないポリシーであるか、<em>param</em> がこのポリシーでは意味のないパラメータです。</span>
              </p>
            </div>
            <div class="section">
              <div>
                <span style="color: rgb(153,153,153);">
                  <br />
                </span>
              </div>
            </div>
            <div class="section">
              <u>
                <strong>Errno (NX 固有)</strong>
              </u>
            </div>
            <div class="section">
              <p>
                <strong>ERANGE</strong>：渡された <em>param</em>-&gt;<em>sched_priority</em> が、優先度の有効な範囲にありません。</p>
              <p style="margin-left: 90.0px;">（この関数で想定されている範囲は、最高優先度が -16、最低優先度が 15、デフォルト値が 0 です）</p>
            </div>
            <div class="section">
              <u>
                <strong>
                  <br />
                </strong>
              </u>
            </div>
            <div class="section">
              <u>
                <strong>詳細情報</strong>
              </u>
            </div>
            <div class="section">
              <a href="http://linux.die.net/man/3/pthread_setschedparam">http://linux.die.net/man/3/pthread_setschedparam</a>
            </div>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_2">pthread_getschedparam()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_getschedparam </strong>(pthread_t thread, int *policy, struct sched_param *param)</p>
          <p>
            <br />
          </p>
        </td>
        <td>
          <div class="content-wrapper">
            <div class="section">
              <strong>
                <u>説明</u>
              </strong>
            </div>
            <div class="section">
              <strong>pthread_getschedparam</strong>() 関数は、スレッド <em>thread</em> のスケジューリングポリシーを <em>policy</em> が指すバッファに返し、スケジューリングパラメータを <em>param</em> が指すバッファに返します。</div>
            <div class="section">
              <br />
            </div>
            <div class="section">
              <u>
                <strong>NX 固有の扱い</strong>
              </u>
            </div>
            <div class="section">
              <ul>
                <li>NX<span style="color: rgb(51,51,51);"> では、優先度として -16（最高）～ 15（最低）の範囲で 32 段階をサポートし、デフォルトは 0 です。</span><br /><span style="color: rgb(51,51,51);">したがって、この関数では、<em>param</em>-&gt;<em>sched_priority</em> をこの範囲内で設定します。</span></li>
              </ul>
              <p> </p>
              <p>
                <u>
                  <strong>Interface Function</strong>
                </u>
                <br />int <strong>__nnmusl_pthread_getschedparam </strong>(pthread_t t, int * policy, struct sched_param * param)</p>
              <p>
                <br />
              </p>
              <p> </p>
              <div class="section">
                <u>
                  <strong>Errno</strong>
                </u>
              </div>
              <div class="section">
                <p>
                  <strong>ESRCH</strong>：ID が <em>thread</em> であるスレッドが見つかりませんでした。</p>
                <p>
                  <span style="color: rgb(153,153,153);">
                    <strong>EPERM</strong>：指定されたスケジューリングのポリシーとパラメータを設定するための適切な権限が呼び出し元にありません。</span>
                </p>
                <p>
                  <span style="color: rgb(153,153,153);">
                    <strong>EINVAL</strong>：<em>policy</em> が認識されていないポリシーであるか、<em>param</em> がこのポリシーでは意味のないパラメータです。</span>
                </p>
                <p>
                  <span style="color: rgb(153,153,153);">
                    <strong>ENOTSUP</strong>：渡された <em>policy</em> が無効な値です。<br /></span>
                </p>
                <div class="section">
                  <u>
                    <strong>
                      <br />
                    </strong>
                  </u>
                </div>
                <div class="section">
                  <u>
                    <strong>Errno (NX 固有)</strong>
                  </u>
                </div>
                <div class="section">
                  <p>
                    <strong>ERANGE</strong>：渡された <em>param</em>-&gt;<em>sched_priority</em> が、優先度の有効な範囲にありません。</p>
                  <p style="margin-left: 90.0px;">（この関数で想定されている範囲は、 最高優先度が -16、最低優先度が 15、デフォルト値が 0 です）</p>
                </div>
                <p>
                  <span style="color: rgb(153,153,153);"> </span>
                </p>
              </div>
              <div class="section">
                <u>
                  <strong>詳細情報</strong>
                </u>
              </div>
              <div class="section">
                <a href="http://linux.die.net/man/3/pthread_getschedparam">http://linux.die.net/man/3/pthread_getschedparam</a>
              </div>
            </div>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_3">pthread_setschedprio()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_setschedprio </strong>(pthread_t thread, int prio)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_setschedprio</strong>() 関数は、スレッド <em>thread</em> のスケジューリングポリシーを、<em>prio</em> で指定された値に設定します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <u>
                <strong>NX 固有の扱い</strong>
              </u>
            </div>
            <div class="section">
              <ul>
                <li>NX では 'SCHED_FIFO' と 'SCHED_OTHER' のみをサポートしています。</li>
                <li>errno を 'ERANGE' に設定できます（以下の '<strong><u>Errno</u></strong>' のセクションを参照）。</li>
                <li>NX では、優先度として -16（最高）～ 15（最低）の範囲で 32 段階をサポートし、デフォルトは 0 です。</li>
              </ul>
            </div>
            <div class="note_new">
              <div class="note_new_left">注意：</div>
              <div class="note_new_right">
                <p>
                  <em>NX でサポートしていないスケジューリングモード：</em>
                </p>
                <p>- SCHED_RR<br />- SCHED_BATCH<br />- SCHED_IDLE<br />- SCHED_DEADLINE<br />- SCHED_RESET_ON_FORK</p>
              </div>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_pthread_setschedprio </strong>(pthread_t t, int prio)</p>
            <p>
              <u>
                <strong>
                  <br />
                </strong>
              </u>
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <div class="section">
              <p>
                <strong>ENOTSUP</strong>：渡された <em>policy</em> が無効な値です。</p>
              <p>
                <strong>ESRCH</strong>：ID が <em>thread</em> であるスレッドが見つかりませんでした。</p>
              <p>
                <em> </em>
              </p>
              <p>
                <span style="color: rgb(153,153,153);">
                  <strong>EPERM</strong>：指定されたスケジューリングのポリシーとパラメータを設定するための適切な権限が呼び出し元にありません。</span>
              </p>
              <p>
                <span style="color: rgb(153,153,153);">
                  <strong>EINVAL</strong>：<em>policy</em> が認識されていないポリシーであるか、<em>param</em> がこのポリシーでは意味のないパラメータです。<br /><br /></span>
              </p>
              <div class="section">
                <u>
                  <strong>Errno (NX 固有)</strong>
                </u>
              </div>
              <div class="section">
                <p>
                  <strong>ERANGE</strong>：渡された <em>param</em>-&gt;<em>sched_priority</em> が、優先度の有効な範囲にありません。</p>
                <p style="margin-left: 90.0px;">（この関数で想定されている範囲は、 最高優先度が -16、最低優先度が 15、デフォルト値が 0 です）</p>
              </div>
              <p>
                <span style="color: rgb(153,153,153);"> </span>
              </p>
            </div>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_setschedprio">http://linux.die.net/man/3/pthread_setschedprio</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_4">pthread_once()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_once </strong>(pthread_once_t *once_control, void (*init_routine)(void))</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>どのスレッドからであってもプロセスで最初の <strong>pthread_once</strong>() の呼び出しでは、引数を指定せずに <em>init_routine</em> を呼び出す必要があります。</p>
            <p>同じ <em>once_control</em> を指定した以降の <strong>pthread_once</strong>() の呼び出しでは、<em>init_routine</em> を呼び出さないようにします。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <u>
                <strong>NX 固有の扱い</strong>
              </u>
            </div>
            <div class="section">
              <ul>
                <li>'pthread_once_t' パラメータは静的に PTHREAD_ONCE_INIT に初期化する必要があります。</li>
                <li>'pthread_once_t' は 'int' として定義されます。</li>
              </ul>
            </div>
            <div class="note_new">
              <div class="note_new_left">注意：</div>
              <div class="note_new_right">
                <p>'pthread_once_t' パラメータは静的に PTHREAD_ONCE_INIT に初期化する必要があります。</p>
                <p>（その理由は、このパラメータが 'PTHREAD_ONCE_INIT' であれば、<em>init_routine</em> が未実行であることを意味するからです）</p>
              </div>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_pthread_once </strong>(pthread_once_t *control, void (*init)(void))</p>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <div class="section">
              <p>
                <span style="color: rgb(153,153,153);">
                  <strong>EINVAL</strong>：<em>init_routine</em> が無効な値です。</span>
              </p>
            </div>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_once">http://linux.die.net/man/3/pthread_once</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_5">pthread_mutexattr_gettype() および pthread_mutexattr_settype()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_mutexattr_settype </strong>(pthread_mutexattr_t *attr, int type);</p>
          <p>int <strong>pthread_mutexattr_gettype </strong>(const pthread_mutexattr_t *restrict attr, int *restrict type);</p>
          <p>
            <br />
          </p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_mutexattr_gettype</strong>() 関数はミューテックスの <em>type</em> 属性を取得し、<strong>pthread_mutexattr_settype</strong>() 関数は同様の属性を設定します。</p>
            <p>
              <em>type</em> 属性のデフォルト値は PTHREAD_MUTEX_DEFAULT です。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <u>
                <strong>NX 固有の扱い</strong>
              </u>
            </div>
            <div class="section">
              <ul>
                <li>この関数では、<em>type</em> パラメータとして PTHREAD_MUTEX_DEFAULT、PTHREAD_MUTEX_NORMAL、PTHREAD_MUTEX_RECURSIVE のみをサポートします。<br />（なお、PTHREAD_MUTEX_DEFAULT は PTHREAD_MUTEX_NORMAL と同値です）（</li>
                <li>サポート対象外：PTHREAD_MUTEX_ERRORCHECK、PTHREAD_MUTEX_STALLED、PTHREAD_MUTEX_ROBUST</li>
              </ul>
            </div>
            <div class="note_new">
              <div class="note_new_left">注意：</div>
              <div class="note_new_right">
                <p>次の値は <em>type</em> に指定できません。</p>
                <p>- PTHREAD_MUTEX_ERRORCHECK</p>
                <p>- PTHREAD_MUTEX_STALLED</p>
                <p>- PTHREAD_MUTEX_ROBUST</p>
              </div>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_pthread_mutexattr_settype </strong>(pthread_mutexattr_t *a, int type)</p>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <em>以下の条件下では pthread_mutexattr_settype() 関数が必ず失敗します。</em>
            </p>
            <p>
              <strong>EINVAL</strong>：<em>type</em> パラメータが無効な値である場合。</p>
            <p>
              <br />
            </p>
            <p>
              <em>以下の条件下では pthread_mutexattr_gettype() 関数および pthread_mutexattr_settype() 関数が失敗する可能性があります。</em>
            </p>
            <div class="section">
              <p>
                <span style="color: rgb(153,153,153);">
                  <strong>EINVAL</strong>：<em>attr</em> パラメータが無効な値である場合。</span>
              </p>
            </div>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_mutexattr_settype">http://linux.die.net/man/3/pthread_mutexattr_settype</a>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_mutexattr_gettype">http://linux.die.net/man/3/pthread_mutexattr_gettype</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_6">pthread_cond_broadcast()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_cond_broadcast </strong>(pthread_cond_t *cond)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_cond_broadcast</strong>() 関数は、指定された条件変数 <em>cond</em> に対して現在ブロックされているスレッドをすべてブロック解除します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <u>
                <strong>NX 固有の扱い</strong>
              </u>
            </div>
            <div class="section">
              <p>なし</p>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_BroadcastConditionVariable </strong>(pthread_cond_t *c)</p>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <div class="section">
              <p>
                <span style="color: rgb(153,153,153);">
                  <strong>EINVAL</strong>：<em>cond</em> パラメータが無効な値である場合。</span>
              </p>
            </div>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_cond_broadcast">http://linux.die.net/man/3/pthread_cond_broadcast</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_7">pthread_cond_signal()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_cond_signal </strong>(pthread_cond_t *cond)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_cond_broadcast</strong>() 関数は、指定された条件変数 <em>cond</em> に対して現在ブロックされているスレッドをすべてブロック解除します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <u>
                <strong>NX 固有の扱い</strong>
              </u>
            </div>
            <div class="section">
              <p>なし</p>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_SignalConditionVariable </strong>(pthread_cond_t *c)</p>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <div class="section">
              <p>
                <span style="color: rgb(153,153,153);">
                  <strong>EINVAL</strong>：<em>cond</em> パラメータが無効な値である場合。</span>
              </p>
            </div>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_cond_signal">http://linux.die.net/man/3/pthread_cond_signal</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_8">pthread_attr_getstack() および pthread_attr_setstack()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_attr_getstack </strong>(pthread_attr_t *attr, void **stackaddr, size_t *stacksize)</p>
          <p>int <strong>pthread_attr_setstack </strong>(pthread_attr_t *attr, void *stackaddr, size_t stacksize)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_attr_getstack</strong>() 関数はスレッドのスタックアドレスとスタックサイズの属性を取得し、<strong>pthread_attr_setstack</strong>() 関数は同様の属性を設定します。</p>
            <p>
              <br />
            </p>
            <p>pthread_attr_setstack() を使用する場合、pthread_create() に pthread_attr_t を渡すと、pthread_create() ではスタックが割り当てられません。</p>
            <p>これは、開発者側でスタックを用意していて、スタックのアドレスとサイズを pthread_attr_setstack に渡すことが想定されているからです。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <u>
                <strong>NX 固有の扱い</strong>
              </u>
            </div>
            <div class="section">
              <ul>
                <li>
                  <p>pthread_attr_setstack() では、スタックのアドレスを 4096 にアライメントし、スタックのサイズを 4096 Byte の倍数とする必要があります。</p>
                </li>
                <li>アドレスもサイズもゼロにすることはできません。</li>
              </ul>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_pthread_attr_getstack</strong> (const pthread_attr_t *a, void **addr, size_t *size)</p>
            <p>int <strong>__nnmusl_pthread_attr_setstack </strong>(pthread_attr_t *a, void *addr, size_t size)</p>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <em>以下の条件下では pthread_attr_getstack() が失敗する可能性があります。</em>
            </p>
            <div class="section">
              <p>
                <span style="color: rgb(153,153,153);">
                  <strong>EINVAL</strong>：<em>cond</em> パラメータが無効な値である場合。</span>
              </p>
            </div>
            <p>
              <em>
                <br />
              </em>
            </p>
            <p>
              <em>以下の条件下では pthread_attr_setstack() が失敗する可能性があります。</em>
            </p>
            <p>
              <strong>EINVAL</strong>：<em>stacksize</em> が PTHREAD_STACK_MIN 未満である場合。</p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EACCES</strong>：<em>stackaddr</em> と <em>stacksize</em> で指定されたスタック領域に対して、呼び出し元から読み取りも書き込みもできない場合。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>Errno (NX 固有)</strong>
              </u>
            </p>
            <p>
              <strong>EINVAL</strong>：<em>attr-&gt;</em>_<em>a_stackaddr</em> パラメータが NULL です。</p>
            <p>
              <strong>PTHREAD_ASSERT</strong>：スタックのサイズまたはアドレスが NX に合わせたアライメント（4096 アライメント）になっていないとアサートがトリガされます。</p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_attr_getstack">http://linux.die.net/man/3/pthread_attr_getstack</a>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_attr_setstack">http://linux.die.net/man/3/pthread_attr_setstack</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_9">pthread_create()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_create </strong>(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_create</strong>() 関数は、<em>start_routine()</em> パラメータを呼び出すことにより、呼び出し元プロセスで新たなスレッドを開始します。</p>
            <p>
              <br />
            </p>
            <p>
              <em>attr._a_sched</em> を 'PTHREAD_EXPLICIT_SCHED' に設定すると、作成したスレッドの優先度が <em>attr._a_prio</em> に設定されます。</p>
            <p>
              <em>attr._a_sched</em> を 'PTHREAD_INHERIT_SCHED' に設定すると、作成したスレッドの優先度は親スレッドの優先度に設定されます。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <u>
                <strong>NX 固有の扱い</strong>
              </u>
            </div>
            <div class="section">
              <ul>
                <li>
                  <p>attr パラメータを __ATTRP_C11_THREAD に設定すると（この値は &quot;(void*)(uintptr_t)-1&quot; です）、attr パラメータは無視され、</p>
                  <p>スタックはデフォルトのサイズである 81920 に設定されます。</p>
                </li>
                <li>
                  <p>この関数は、malloc() を使用して 90,632 Byte を割り当てます。</p>
                </li>
                <li>
                  <p>スレッドが作成されるたびに追加で 1,072 Byte が割り当てられ、nninitStartup() が呼び出された後、nnMain() が呼び出される前に 2.5 KByte が割り当てられます。<br /><span class="ApiLink_nn__os__SetMemoryAllocatorForThreadLocal">nn::os::SetMemoryAllocatorForThreadLocal</span>() を呼び出さないカスタムの nninitStartup() を作成すると、追加の割り当ては無効になります。<br /><br /></p>
                  <div class="note_new">
                    <div class="note_new_left">注意：</div>
                    <div class="note_new_right">
                      <p>TLS が有効であれば、スレッドが作成されるたびに追加で 1,072 Byte が割り当てられます。</p>
                      <p>TLS では、nninitStartup() が呼び出された後、nnMain() が呼び出される前に 2.5 KByte のメモリも割り当てられます。</p>
                      <p>TLS を無効にするには、nn::os::SetMemoryAllocatorForThreadLocal() を呼び出さないカスタムの nninitStartup() を作成します。</p>
                    </div>
                  </div>
                  <p>
                    <br />
                  </p>
                  <p>十分なメモリがないと、プログラムは強制終了します。</p>
                </li>
              </ul>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_CreateThread </strong>(pthread_t *res, const pthread_attr_t *attrp, void *(*entry)(void *), void *arg)</p>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <strong>EAGAIN</strong>：スレッドの作成に失敗しました。問題があることを説明するために、強制終了またはアサートがトリガされる可能性があります。</p>
            <div class="section">
              <p>
                <span style="color: rgb(153,153,153);">
                  <strong>EINVAL</strong>：<em>attr</em> の設定が無効です。</span>
              </p>
              <p>
                <span style="color: rgb(153,153,153);">
                  <strong>EPERM</strong>：<em>attr</em> で指定されたスケジューリングのポリシーとパラメータを設定するためのアクセス権がありません。</span>
              </p>
            </div>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_create">http://linux.die.net/man/3/pthread_create</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_10">pthread_attr_getscope() および pthread_attr_setscope()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_attr_getscope</strong>(pthread_attr_t *attr, int *scope)</p>
          <p>int <strong>pthread_attr_setscope</strong>(pthread_attr_t *attr, int scope)</p>
          <p>
            <br />
          </p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_attr_getscope</strong>() 関数はスレッドの属性にある競合範囲の属性を取得し、<strong>pthread_attr_setscope</strong>() 関数は同様の属性を設定します。</p>
            <p>
              <br />
            </p>
            <p>注意：'PTHREAD_SCOPE_PROCESS' は Linux ではサポートされていませんが、NX ではサポートされています。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <u>
                <strong>NX 固有の扱い</strong>
              </u>
            </div>
            <div class="section">
              <ul>
                <li>
                  <p>pthread_attr_getscope() は <em>scope</em> を必ず 'PTHREAD_SCOPE_PROCESS' に設定し、0 を返します。</p>
                </li>
                <li>
                  <p>pthread_attr_setscope() は、<em>scope</em> が 'PTHREAD_SCOPE_PROCESS' として渡された場合にのみ 0（成功）を返します。</p>
                </li>
                <li>pthread_attr_setscope() は、<em>scope</em> が 'PTHREAD_SCOPE_SYSTEM'として渡された場合に ENOTSUP を返します。</li>
                <li>pthread_attr_setscope() は、<em>scope</em> が上記以外の値として渡された場合に EINVAL を返します。</li>
              </ul>
            </div>
            <div class="note_new">
              <div class="note_new_left">注意：</div>
              <div class="note_new_right">
                <p>pthread_attr_setscope() は、<em>scope</em> パラメータとして 'PTHREAD_SCOPE_PROCESS' のみをサポートしています。</p>
              </div>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_pthread_attr_getscope </strong>(const pthread_attr_t *a, int *scope)</p>
            <p>int <strong>__nnmusl_pthread_attr_setscope </strong>(pthread_attr_t *a, int scope)</p>
            <p>
              <u>
                <strong>
                  <br />
                </strong>
              </u>
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <em>以下の条件下では pthread_attr_setscope() が失敗する可能性があります。</em>
            </p>
            <p>
              <strong>ENOTSUP</strong>：<em>scope</em> が 'PTHREAD_SCOPE_SYSTEM' として渡された場合。</p>
            <p>
              <strong>EINVAL</strong>：<em>scope</em> が 'PTHREAD_SCOPE_SYSTEM' でも 'PTHREAD_SCOPE_PROCESS' でもない値として渡された場合。</p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_attr_setscope">http://linux.die.net/man/3/pthread_attr_setscope</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_11">pthread_attr_getstacksize() および pthread_attr_setstacksize()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_attr_getstacksize </strong>(pthread_attr_t *attr, size_t * stacksize)</p>
          <p>int <strong>pthread_attr_setstacksize </strong>(pthread_attr_t *attr, size_t stacksize)<br /><br /></p>
          <p>
            <br />
          </p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_attr_getstacksize</strong>() 関数はスレッドのスタックサイズ属性を取得し、<strong>pthread_attr_setstacksize</strong>() 関数は同様の属性を設定します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <u>
                <strong>NX 固有の扱い</strong>
              </u>
            </div>
            <div class="section">
              <ul>
                <li>
                  <p>pthread_attr_setstacksize() は、呼び出されるたびに <em>attr-&gt;_a_stackaddr</em> を 0 に設定します。</p>
                </li>
              </ul>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_pthread_attr_getstacksize </strong>(const pthread_attr_t *restrict a, size_t *restrict size)</p>
            <p>int <strong>__nnmusl_pthread_attr_setstacksize </strong>(pthread_attr_t *a, size_t size)</p>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <em>以下の条件下では pthread_attr_setstacksize() が失敗する可能性があります。</em>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：<em>stacksize</em> が PTHREAD_STACK_MIN（16384）未満である場合。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>Errno (NX 固有)</strong>
              </u>
            </p>
            <p>
              <strong>PTHREAD_ASSERT</strong>：<em>stacksize</em> を 4096 にアライメントしていないと、アサートがトリガされます。</p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_attr_setstacksize">http://linux.die.net/man/3/pthread_attr_setstacksize</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_12">pthread_getname_np() および pthread_setname_np()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_setname_np </strong>(pthread_t *thread, const char *name)<br />int <strong>pthread_getname_np </strong>(pthread_t *thread, char *name, size_t len)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_setname_np</strong>() 関数を使用して、スレッドに一意の名前を設定できます。</p>
            <p>
              <strong>pthread_getname_np</strong>() はスレッドの名前を取得します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <u>
                <strong>NX 固有の扱い</strong>
              </u>
            </div>
            <div class="section">
              <ul>
                <li>
                  <p>この実装では、スレッド名に最大で 32 文字（null 終端文字を含めた文字数）を使用できます。</p>
                </li>
              </ul>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_GetThreadNamePointer </strong>(pthread_t thread, char *name, size_t len)</p>
            <p>int <strong>__nnmusl_SetThreadName </strong>(pthread_t thread, const char *name)</p>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>ERANGE</strong>：pthread_getname_np() の <em>name</em> パラメータと <em>len</em> パラメータの値がスレッドの名前を収めるには小さすぎます。</span>
            </p>
            <p>
              <strong>
                <span style="color: rgb(153,153,153);">ERANGE</span>
              </strong>
              <span style="color: rgb(153,153,153);">：pthread_setname_np() の <em>name</em> パラメータが長すぎます。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_getname_np">http://linux.die.net/man/3/pthread_getname_np</a>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_setname_np">http://linux.die.net/man/3/pthread_setname_np</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_13">pthread_attr_getschedparam() および pthread_attr_setschedparam()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_attr_getschedparam </strong>(pthread_attr_t *attr, struct sched_param *param)<br />int <strong>pthread_attr_setschedparam </strong>(pthread_attr_t *attr, const struct sched_param *param)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_attr_getschedparam</strong>() 関数はスレッドのスケジューリングパラメータ属性を取得し、 <strong>pthread_attr_setschedparam</strong>() 関数は同様の属性を設定します。</p>
            <p>
              <br />
            </p>
            <p>pthread_attr_setinheritsched() に 'PTHREAD_EXPLICIT_SCHED' を渡すと、pthread_create() で作成したスレッドでは</p>
            <p>pthread_attr_setschedparam() に渡した優先度が使用されます。それ以外の場合は、現在のスレッドの優先度が pthread_create() で使用されます。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <u>
                <strong>NX 固有の扱い</strong>
              </u>
            </div>
            <div class="section">
              <p>なし</p>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_pthread_attr_setschedparam </strong>(pthread_attr_t *a, const struct sched_param *param)</p>
            <p>（pthread_attr_getschedparam() には用意されていません）</p>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：<em>attr</em> または <em>param</em> の値が何らかの形で無効です。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>Errno (NX 固有)</strong>
              </u>
            </p>
            <p>
              <strong>ERANGE</strong>：渡された <em>param</em>-&gt;<em>sched_priority</em> が、優先度の有効な範囲にありません。</p>
            <p style="margin-left: 90.0px;">  （この関数で想定されている範囲は、 最高優先度が -16、最低優先度が 15、デフォルト値が 0 です）</p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_attr_getschedparam">http://linux.die.net/man/3/pthread_attr_getschedparam</a>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_attr_setschedparam">http://linux.die.net/man/3/pthread_attr_setschedparam</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_14">pthread_condattr_getpshared() および pthread_condattr_setpshared()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_condattr_getpshared </strong>(const pthread_condattr_t *restrict attr, int *restrict pshared)<br />int <strong>pthread_condattr_setpshared </strong>(pthread_condattr_t *attr, int pshared)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_condattr_getpshared</strong>() 関数はプロセスで共有する条件変数属性を取得し、<strong>pthread_condattr_setpshared</strong>() 関数は同様の属性を設定します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <u>
                <strong>NX 固有の扱い</strong>
              </u>
            </div>
            <div class="section">
              <ul>
                <li>
                  <p>NX では、'PTHREAD_PROCESS_SHARED' をサポートしていません。<br /></p>
                </li>
              </ul>
            </div>
            <div class="note_new">
              <div class="note_new_left">注意：</div>
              <div class="note_new_right">
                <p>NX では、複数のプロセス間でのスレッド共有をサポートしていません。'PTHREAD_PROCESS_PRIVATE' のみを指定できます。</p>
              </div>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_pthread_condattr_setpshared </strong>(pthread_condattr_t *a, int pshared)</p>
            <p>（pthread_condattr_getpshared() には用意されていません）</p>
            <p>
              <u>
                <strong>
                  <br />
                </strong>
              </u>
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <em>以下の条件下では pthread_condattr_setpshared() が失敗する可能性があります。</em>
            </p>
            <p>
              <strong>EINVAL</strong>：<em>pshared</em> パラメータの値が許容範囲外である場合（NX で '1U' を超える値）。<br /></p>
            <p>
              <u>
                <strong>
                  <br />
                </strong>
              </u>
            </p>
            <p>
              <u>
                <strong>Errno (NX 固有)</strong>
              </u>
            </p>
            <p>
              <strong>ENOTSUP</strong>：<em>pshared</em> パラメータが 'PTHREAD_PROCESS_SHARED' として渡されました。</p>
            <p>
              <strong>PTHREAD_ASSERT</strong>：<em>pshared</em> を 'PTHREAD_PROCESS_PRIVATE' 以外の値として渡すとアサートがトリガされます。</p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_condattr_getpshared">http://linux.die.net/man/3/pthread_condattr_getpshared</a>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_condattr_setpshared">http://linux.die.net/man/3/pthread_condattr_setpshared</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_15">pthread_attr_getinheritsched() および pthread_attr_setinheritsched()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_attr_getinheritsched </strong>(pthread_attr_t *attr, int *inheritsched)<br />int <strong>pthread_attr_setinheritsched </strong>(pthread_attr_t *attr, int inheritsched)</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>pthread_attr_getinheritsched</strong>() 関数はスレッドの継承スケジューリング属性を取得し、<strong>pthread_attr_setinheritsched</strong>() 関数は同様の属性を設定します。</p>
          <p>
            <br />
          </p>
          <p>pthread_attr_setinheritsched() に 'PTHREAD_EXPLICIT_SCHED' を渡すと、pthread_create() で作成したスレッドでは</p>
          <p>pthread_attr_setschedparam() に渡した優先度が使用されます。それ以外の場合は、現在のスレッドの優先度が pthread_create() で使用されます。これは、</p>
          <p>'PTHREAD_INHERIT_SCHED' がデフォルトの値であるからです。</p>
          <p>
            <br />
          </p>
          <div class="section">
            <u>
              <strong>NX 固有の扱い</strong>
            </u>
          </div>
          <p>該当なし</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>インターフェース関数</strong>
            </u>
          </p>
          <p>該当なし</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <em>以下の条件下では pthread_attr_setinheritsched() が失敗する可能性があります。</em>
          </p>
          <p>
            <strong>EINVAL</strong>：<em>inheritsched</em> パラメータの値が許容範囲外である場合（NX で '1U' を超える値）。</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/pthread_attr_getinheritsched">http://linux.die.net/man/3/pthread_attr_getinheritsched</a>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/pthread_attr_setinheritsched">http://linux.die.net/man/3/pthread_attr_setinheritsched</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_16">pthread_equal()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_equal </strong>(pthread_t t1, pthread_t t2)</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>pthread_equal</strong>() 関数は、2 つのスレッド識別子を比較します。</p>
          <p>
            <br />
          </p>
          <div class="section">
            <u>
              <strong>NX 固有の扱い</strong>
            </u>
          </div>
          <div class="section">
            <ul>
              <li>この実装は、&quot;#ifndef __cplusplus&quot; でカプセル化したマクロとして定義されています。したがって、C++ ではこの関数は実装されません。<br />C++ での同等関数は &quot;threads.h&quot; に記述されている thrd_equal() です。</li>
            </ul>
          </div>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>インターフェース関数</strong>
            </u>
          </p>
          <p>該当なし</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>該当なし</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/pthread_equal">http://linux.die.net/man/3/pthread_equal</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_17">pthread_exit()</h4>
          <p>
            <br />
          </p>
          <p>void <strong>pthread_exit </strong>(void *retval)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_exit</strong>() 関数は呼び出し元スレッドを終了します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
            </div>
            <div class="note_new">
              <div class="note_new_left">注意：</div>
              <div class="note_new_right">
                <p>pthread_exit() 関数は、スレッドがキャンセルされた時点で完了していなかったタスクを正常にクリーンアップします。</p>
                <p>この実装では、スレッドのキャンセルをサポートしていません。</p>
              </div>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>void <strong>__nnmusl_ExitThread </strong>(void *result)</p>
            <p>
              <u>
                <strong>
                  <br />
                </strong>
              </u>
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>該当なし</p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_exit">http://linux.die.net/man/3/pthread_exit</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_18">pthread_condattr_init() および pthread_condattr_destroy()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_condattr_init </strong>(pthread_condattr_t *attr)</p>
          <p>int <strong>pthread_condattr_destroy </strong>(pthread_condattr_t *attr<em>)</em></p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>pthread_condattr_init</strong>() 関数は、渡された条件変数属性オブジェクト <em>attr</em> を、</p>
          <p>現在の実装で定義されているすべての属性のデフォルト値で初期化します。</p>
          <p>
            <strong>pthread_condattr_destroy</strong>() 関数は条件変数属性オブジェクトを破棄します。</p>
          <p>
            <br />
          </p>
          <div class="section">
            <div class="section">
              <u>
                <strong>NX 固有の扱い</strong>
              </u>
            </div>
            <div class="section">
              <ul>
                <li>NX では、pthread_condattr_init() で <em>attr</em> に設定されるデフォルト値はすべて 0 です。</li>
                <li>pthread_condattr_destroy() は 0 を返すだけで、他には何も実行しません。</li>
              </ul>
            </div>
          </div>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>インターフェース関数</strong>
            </u>
          </p>
          <p>該当なし</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <em>以下の条件下では pthread_condattr_init() 関数が必ず失敗します。</em>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENOMEM</strong>：条件変数属性オブジェクトを初期化するにはメモリが不足している場合。</span>
          </p>
          <p>
            <em>以下の条件下では pthread_condattr_destroy() 関数が失敗する可能性があります。</em>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EINVAL</strong>：<em>attr</em> に指定された値が無効である場合。</span>
          </p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/pthread_condattr_init">http://linux.die.net/man/3/pthread_condattr_init</a>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/pthread_condattr_destroy">http://linux.die.net/man/3/pthread_condattr_destroy</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_19">pthread_join()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_join </strong>(pthread_t thread, void **retval)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_join</strong>() 関数は、<em>thread</em> で指定されたスレッドの終了を待機します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">なし</div>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_WaitThread </strong>(pthread_t t, void **res)</p>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EDEADLK</strong>：デッドロックが検出されました（例えば、2 つのスレッドが互いを結合しようとしています）。または、thread で呼び出し元のスレッドを指定しています。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：thread が結合可能なスレッドではありません。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：このスレッドとの結合を別のスレッドが既に待機しています。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>ESRCH</strong>：ID が thread であるスレッドが見つかりませんでした。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_join">http://linux.die.net/man/3/pthread_join</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_20">pthread_self()</h4>
          <p>
            <br />
          </p>
          <p>pthread_t <strong>pthread_self </strong>(void)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_self</strong>() 関数は呼び出し元スレッドの ID を返します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">なし</div>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>pthread_t <strong>__nnmusl_GetCurrentThread</strong>()</p>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>該当なし</p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>Errno (NX 固有)</strong>
              </u>
            </p>
            <p>
              <strong>ABORT</strong>：スレッド情報を収める TLS スロットもメモリも割り当てることができない場合は abort() がトリガされます。<strong><br /></strong></p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_self">http://linux.die.net/man/3/pthread_self</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_21">pthread_mutex_init()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_mutex_init </strong>(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_mutex_init</strong>() 関数は、<em>mutex</em> で参照しているミューテックスを、<em>attr</em> で指定された属性で初期化します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <ul>
                  <li>この実装では EPERM が返されません。その理由は、pthread_mutex_lock() の実行でアクセス権が設定され、pthread_unlock_mutex() の実行でそのアクセス権が確認されますが、NX の実装では、init() でも destroy() でもアクセス権を使用しないからです。<br /><br /></li>
                  <li>この実装では ENOMEM も EAGAIN も返されません。その理由は、どのようなアロケーションの失敗も、基礎となる NintendoSDK API で abort() を使用して処理されるからです。<br /></li>
                </ul>
              </div>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_MutexInit </strong>(pthread_mutex_t *m, const pthread_mutexattr_t *a)</p>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <em>以下の条件下では pthread_mutex_init() 関数が必ず失敗します。</em>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EAGAIN</strong>：別のミューテックスを初期化するために必要なリソース（メモリ以外のリソース）がシステムにない場合。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>ENOMEM</strong>：ミューテックスを初期化するにはメモリが不足している場合。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>EPERM</strong>：この操作を実行する権限が呼び出し元にない場合。</span>
            </p>
            <p>
              <em>以下の条件下では pthread_mutex_init() 関数が失敗する可能性があります。</em>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EBUSY</strong>：初期化済みで破棄されていないミューテックスである <em>mutex</em>, を実装側で再度初期化しようとした場合。</span>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：attr に指定された値が無効である場合。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_mutex_init">http://linux.die.net/man/3/pthread_mutex_init</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_22">pthread_mutex_destroy()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_mutex_destroy </strong>(pthread_mutex_t *mutex)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_mutex_destroy</strong>() 関数は、<em>mutex</em> で参照しているミューテックスオブジェクトを破棄し、未初期化状態にします。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <ul>
                  <li>
                    <p>pthread_mutex_destroy() の呼び出しですべてのミューテックスを破棄する必要があります。そのようにしないとメモリリークが発生します。</p>
                  </li>
                </ul>
              </div>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_MutexDestroy </strong>(pthread_mutex_t *m)</p>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EBUSY</strong>：ロックされているか別のスレッドで参照されている（例えば、pthread_cond_wait() で使用している） <em>mutex</em> を破棄しようとしました。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：<em>mutex</em> で指定されている値が無効です。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_mutex_destroy">http://linux.die.net/man/3/pthread_mutex_destroy</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_23">pthread_mutex_lock() および pthread_mutex_unlock()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_mutex_lock </strong>(pthread_mutex_t *mutex)</p>
          <p>int <strong>pthread_mutex_unlock </strong>(pthread_mutex_t *mutex)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_mutex_lock</strong>() 関数は、渡された <em>mutex</em> をロックします。</p>
            <p>
              <strong>pthread_mutex_unlock</strong>() 関数は、<em>mutex</em> で参照しているミューテックスオブジェクトを解放します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <p>
                  <br />
                </p>
                <div class="note_new">
                  <div class="note_new_left">注意：</div>
                  <div class="note_new_right">
                    <p>NX では、&quot;PTHREAD_PRIO_NONE&quot;、&quot;PTHREAD_PRIO_INHERIT&quot;、&quot;PTHREAD_PRIO_PROTECT&quot; をサポートしていません。</p>
                  </div>
                </div>
                <p>
                  <br />
                </p>
              </div>
            </div>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_MutexLock </strong>(pthread_mutex_t *m)</p>
            <p>int <strong>__nnmusl_MutexUnlock </strong>(pthread_mutex_t *m)</p>
            <p>
              <u>
                <strong>
                  <br />
                </strong>
              </u>
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：'PTHREAD_PRIO_PROTECT' を指定して <em>mutex</em> が作成され、呼び出し元スレッドの優先度が <em>mutex</em> の最高優先度よりも高くなっています。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：mutex で指定された値が、初期化済みのミューテックスオブジェクトを参照していません。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>EAGAIN</strong>：ミューテックスの再帰ロック数がその最大数を超えているので、目的のミューテックスを取得できませんでした。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>EDEADLK</strong>：現在のスレッドは既に目的のミューテックスを所有しています。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>EPERM</strong>：現在のスレッドは目的のミューテックスを所有していません。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_mutex_lock">http://linux.die.net/man/3/pthread_mutex_init</a>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_mutex_unlock">http://linux.die.net/man/3/pthread_mutex_unlock</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_24">pthread_mutex_trylock()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_mutex_trylock </strong>(pthread_mutex_t *mutex)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_mutex_trylock</strong>() 関数は pthread_mutex_lock() と同等ですが、ミューテックスが既に</p>
            <p>ロックされているとただちに返る点が異なります。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <p>
                  <br />
                </p>
                <div class="note_new">
                  <div class="note_new_left">注意：</div>
                  <div class="note_new_right">
                    <p>NX では、&quot;PTHREAD_PRIO_NONE&quot;、&quot;PTHREAD_PRIO_INHERIT&quot;、&quot;PTHREAD_PRIO_PROTECT&quot; をサポートしていません。</p>
                  </div>
                </div>
                <p>
                  <br />
                </p>
              </div>
            </div>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_MutexTryLock </strong>(pthread_mutex_t *m)</p>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <strong>EBUSY</strong>：ミューテックスを取得できませんでした。既にロックされている可能性があります。</p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：'PTHREAD_PRIO_PROTECT' を指定して <em>mutex</em> が作成され、呼び出し元スレッドの優先度が <em>mutex</em> の最高優先度よりも高くなっています。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>EBUSY</strong>：ミューテックスがロックされているので取得できませんでした。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：mutex で指定された値が、初期化済みのミューテックスオブジェクトを参照していません。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>EAGAIN</strong>：ミューテックスの再帰ロック数がその最大数を超えているので、目的のミューテックスを取得できませんでした。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>EDEADLK</strong>：現在のスレッドは既に目的のミューテックスを所有しています。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>EPERM</strong>：現在のスレッドは目的のミューテックスを所有していません。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>Errno (NX 固有)</strong>
              </u>
            </p>
            <p>
              <strong>ABORT</strong>：pthread_mutex_init() を実行せずにこの関数を呼び出すと（初期化していない <em>mutex</em> を渡す操作） abort() がトリガされます。</p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_mutex_trylock">http://linux.die.net/man/3/pthread_mutex_trylock</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_25">pthread_cond_init()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_cond_init </strong>(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_cond_init</strong>() 関数は、<em>cond</em> で参照している条件変数を、<em>attr</em> で参照している属性で初期化します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <ul>
                  <li>NX では共有属性とクロック属性を変更できません。</li>
                  <li>
                    <p>この実装では、どのようなアロケーションの失敗も、基礎となる NintendoSDK API で abort() を使用して処理されるので、</p>
                    <p>ENOMEM と EAGAIN は返されません。</p>
                  </li>
                </ul>
              </div>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_InitializeConditionVariable </strong>(pthread_cond_t *c, const pthread_condattr_t *a)</p>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <em>以下の条件下では pthread_cond_init() 関数が必ず失敗します。</em>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EAGAIN</strong>：別の条件変数を初期化するために必要なリソース（メモリ以外のリソース）がシステムにない場合。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>ENOMEM</strong>：条件変数を初期化するにはメモリが不足している場合。</span>
            </p>
            <p>
              <span style="color: rgb(153,153,153);"> </span>
              <em>以下の条件下では pthread_cond_init() 関数が失敗する可能性があります。</em>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>EBUSY</strong>：初期化済みで破棄されていない条件変数である <em>cond</em> を再度初期化しようとした場合。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：attr で指定されている値が無効である場合。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_cond_init">http://linux.die.net/man/3/pthread_cond_init</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_26">pthread_cond_destroy()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_cond_destroy </strong>(pthread_cond_t *cond)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_cond_destroy</strong>() 関数は、<em>cond</em> で参照している条件変数を破棄し、未初期化状態にします。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <ul>
                  <li>pthread_cond_destroy() の呼び出しですべての条件変数を破棄する必要があります。そのようにしないとメモリリークが発生します。</li>
                </ul>
              </div>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_FinalizeConditionVariable </strong>(pthread_cond_t *c)</p>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EBUSY</strong>：ロックされているか別のスレッドで参照されている（例えば、pthread_cond_wait() で使用している） <em>cond</em> を破棄しようとしました。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：<em>cond</em> で指定されている値が無効です。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_cond_destroy">http://linux.die.net/man/3/pthread_cond_destroy</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_27">pthread_cond_wait()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_cond_wait </strong>(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_cond_wait</strong>() 関数は条件変数に対してブロックします。</p>
            <p>この関数は、呼び出し元スレッド側でロックした <em>mutex</em> を指定して呼び出す必要があります。そのようにしないと、不定な動作となります。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <p>なし</p>
              </div>
            </div>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>インターフェース関数</strong>
              </u>
            </p>
            <p>int <strong>__nnmusl_WaitConditionVariable </strong>(pthread_cond_t *c, pthread_mutex_t *m)</p>
            <p>
              <br />
            </p>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：<em>cond</em> または <em>mutex</em> で指定された値が無効です。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：同じ条件変数に対して同時に実行した pthread_cond_wait() 操作にそれぞれ異なるミューテックスが指定されました。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>EPERM</strong>：呼び出しの時点で <em>mutex</em> が現在のスレッドで所有されていませんでした。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_cond_wait">http://linux.die.net/man/3/pthread_cond_wait</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_28">pthread_cond_timedwait()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_cond_timedwait </strong>(</p>
          <p style="margin-left: 60.0px;">pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex,</p>
          <p style="margin-left: 60.0px;">const struct timespec *restrict abstime)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_cond_timedwait</strong>() 関数は pthread_cond_wait() と同等ですが、</p>
            <p>条件 cond が通知されるかブロードキャストされる前に、</p>
            <p>
              <em>abstime</em> で指定された絶対時間が経過すると（システム時間が abstime 以上）エラーが返される点が異なります。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <ul>
                  <li>
                    <em>abstime</em> を NULL として渡すと、pthread_cond_timedwait() はデフォルト値である現在のシステム時間をとります。</li>
                </ul>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>int <strong>__nnmusl_TimedWaitConditionVariable </strong>(pthread_cond_t *c, pthread_mutex_t *m, const struct timespec *ts)</p>
                <p>
                  <br />
                </p>
              </div>
            </div>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <strong>ETIMEDOUT</strong>：pthread_cond_timedwait() に abstime で指定した時間が経過しました。</p>
            <p>
              <strong>EINVAL</strong>：pthread_cond_timedwait() が不明なエラーで失敗しました。</p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_cond_timedwait">http://linux.die.net/man/3/pthread_cond_timedwait</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_29">pthread_key_create()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_key_create </strong>(pthread_key_t *key, void (*destructor)(void*))</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_key_create</strong>() 関数は、プロセスのすべてのスレッドで認識できるスレッド固有のデータ key を作成します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <ul>
                  <li>
                    <p>現在のところ、NintendoSDK にはスロットが 16 個という制限があり、nnmusl の pthread 実装では、それらのスロットのいずれかを使用します。</p>
                  </li>
                </ul>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>int <strong>__nnmusl_AllocateTlsSlot </strong>(pthread_key_t *k, void (*dtor)(void *))</p>
                <p>
                  <br />
                </p>
              </div>
            </div>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EAGAIN</strong>：別の key を作成するために必要なリソースがシステムにないか、key の数が上限（PTHREAD_KEYS_MAX）を超えています。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>ENOMEM</strong>：key を作成するにはメモリが不足しています。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>Errno (NX 固有)</strong>
              </u>
            </p>
            <p>
              <strong>EAGAIN</strong>：TLS スロットを割り当てることができませんでした。</p>
            <p>
              <strong>ABORT</strong>：アロケーションに失敗すると、'NN_OS_PANIC' による abort() がトリガされます。</p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_key_create">http://linux.die.net/man/3/pthread_key_create</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_30">pthread_key_delete()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_key_delete </strong>(pthread_key_t key)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_key_delete</strong>() 関数は、pthread_key_create() で以前に返されたスレッド固有のデータ key を削除します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <p>なし</p>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>int <strong>__nnmusl_FreeTlsSlot </strong>(pthread_key_t k)</p>
                <p>
                  <br />
                </p>
              </div>
            </div>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：key の値が無効です。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_key_delete">http://linux.die.net/man/3/pthread_key_delete</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_31">pthread_getspecific() および pthread_setspecific()</h4>
          <p>
            <br />
          </p>
          <p>void *<strong>pthread_getspecific </strong>(pthread_key_t key)<br />int <strong>pthread_setspecific </strong>(pthread_key_t key, const void *value)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_getspecific</strong>() 関数は、指定された <em>key</em> に現在バインドされている値を、呼び出し元スレッドに代わって返します。</p>
            <p>
              <strong>pthread_setspecific</strong>() 関数は、pthread_key_create() の以前の呼び出しで取得した <em>key</em> にスレッド固有の <em>value</em> を関連付けます。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <ul>
                  <li>この実装では ENOMEM が返されません。その理由は、どのようなアロケーションの失敗も、基礎となる NintendoSDK API で abort() を使用して処理されるからです。</li>
                </ul>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>void *<strong>__nnmusl_GetTlsValue </strong>(pthread_key_t k)</p>
                <p>int <strong>__nnmusl_SetTlsValue </strong>(pthread_key_t k, const void *x)</p>
                <p>
                  <br />
                </p>
              </div>
            </div>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <em>以下の条件下では pthread_setspecific() 関数が必ず失敗します。</em>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>ENOMEM</strong>：value を key に関連付けるにはメモリが不足している場合。</span>
            </p>
            <p>
              <em>以下の条件下では pthread_setspecific() 関数が失敗する可能性があります。</em>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：key の値が無効である場合。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>Errno (NX 固有)</strong>
              </u>
            </p>
            <p>
              <strong>ASSERT</strong>：<em>key</em> が &quot;TlsSlotCountMax&quot;(16 として定義されています）を超えると、pthread_setspecific でアサートがトリガされます。</p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_getspecific">http://linux.die.net/man/3/pthread_getspecific</a>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_setspecific">http://linux.die.net/man/3/pthread_setspecific</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_32">pthread_attr_getschedpolicy() および pthread_attr_setschedpolicy()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_attr_getschedpolicy </strong>(pthread_attr_t *attr, int *policy)</p>
          <p>int <strong>pthread_attr_setschedpolicy </strong>(pthread_attr_t *attr, int policy)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_attr_getschedpolicy</strong>() 関数はスレッドのスケジューリングポリシー属性を取得し、<strong>pthread_attr_setschedpolicy</strong>() 関数は同様の属性を設定します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <ul>
                  <li>NX では、スケジューリングポリシーを扱うことはできません。なお、NX のデフォルトの動作は、SCHED_FIFO または SCHED_OTHER.を指定した場合と同様です。<br />これ以外のどのようなポリシーを pthread_attr_setschedpolicy() に渡しても ENOTSUP が返されます。</li>
                </ul>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>int <strong>__nnmusl_pthread_attr_setschedpolicy</strong>(pthread_attr_t *a, int policy)</p>
                <p>（pthread_attr_getschedpolicy() には用意されていません）</p>
                <p>
                  <br />
                </p>
              </div>
            </div>
            <p>
              <u>
                <strong>Errno<br /></strong>
              </u>
              <em>以下の条件下では pthread_attr_setschedpolicy() 関数が失敗する可能性があります。</em>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：<em>policy</em> パラメータが無効な値である場合。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>Errno (NX 固有)</strong>
              </u>
            </p>
            <p>
              <strong>ENOTSUP</strong>：<em>policy</em> パラメータが、SCHED_FIFO でも SCHED_OTHER でもない値として渡されています。</p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_attr_getschedpolicy">http://linux.die.net/man/3/pthread_attr_getschedpolicy</a>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_attr_setschedpolicy">http://linux.die.net/man/3/pthread_attr_setschedpolicy</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_33">pthread_attr_init() および pthread_attr_destroy()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_attr_init </strong>(pthread_attr_t *attr)</p>
          <p>int <strong>pthread_attr_destroy </strong>(pthread_attr_t *attr)</p>
          <p>
            <br />
          </p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>pthread_attr_init</strong>attr が指すスレッド属性オブジェクトを初期化し、</p>
          <p>pthread_attr_destroy() 関数は同様のオブジェクトを破棄します。</p>
          <p>
            <br />
          </p>
          <div class="section">
            <div class="section">
              <u>
                <strong>NX 固有の扱い</strong>
              </u>
            </div>
            <div class="section">
              <ul>
                <li>NX での pthread_attr_init() では、<em>attr</em> に設定されるデフォルト値はすべて 0 です。</li>
                <li>pthread_attr_destroy() は 0 を返すだけで、他には何も実行しません。</li>
              </ul>
              <p>
                <br />
              </p>
            </div>
          </div>
          <p>
            <u>
              <strong>インターフェース関数</strong>
            </u>
          </p>
          <p>なし</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno<br /></strong>
            </u> なし</p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>詳細情報</strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/pthread_attr_init">http://linux.die.net/man/3/pthread_attr_init</a>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/pthread_attr_destroy">http://linux.die.net/man/3/pthread_attr_destroy</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_34">pthread_mutexattr_init() および pthread_mutexattr_destroy()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_mutexattr_init </strong>(pthread_mutexattr_t *attr)</p>
          <p>int <strong>pthread_mutexattr_destroy </strong>(pthread_mutexattr_t *<em>attr</em>)</p>
        </td>
        <td>
          <p>
            <u>
              <strong>説明</strong>
            </u>
          </p>
          <p>
            <strong>pthread_mutexattr_init</strong>() 関数は、ミューテックス属性オブジェクト <em>attr</em> をデフォルト値で初期化します。</p>
          <p>
            <strong>pthread_mutexattr_destroy</strong>() 関数は、ミューテックス属性オブジェクトを破棄します。</p>
          <p>
            <br />
          </p>
          <div class="section">
            <div class="section">
              <u>
                <strong>NX 固有の扱い</strong>
              </u>
            </div>
            <div class="section">
              <p>なし</p>
              <p>
                <br />
              </p>
            </div>
          </div>
          <p>
            <u>
              <strong>インターフェース関数</strong>
            </u>
          </p>
          <p>なし</p>
          <p>
            <br />
          </p>
          <p>
            <u>
              <strong>Errno</strong>
            </u>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <em>以下の条件下では pthread_mutexattr_init() 関数が必ず失敗します。</em>
              <strong>
                <br />
              </strong>
            </span>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>ENOMEM</strong>：ミューテックス属性オブジェクトを初期化するにはメモリが不足している場合。</span>
          </p>
          <p>
            <em>以下の条件下では pthread_mutexattr_init() 関数が失敗する可能性があります。</em>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EINVAL</strong>：<em>attr</em> に指定された値が無効である場合。</span>
          </p>
          <p>
            <em>
              <span style="color: rgb(153,153,153);">以下の条件下では pthread_mutexattr_destroy() 関数が失敗する可能性があります。</span>
            </em>
          </p>
          <p>
            <span style="color: rgb(153,153,153);">
              <strong>EINVAL</strong>：<em>attr</em> に指定された値が無効である場合。</span>
          </p>
          <p>
            <strong>
              <br />
            </strong>
          </p>
          <p>
            <u>
              <strong>詳細情報<br /></strong>
            </u>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/pthread_mutexattr_init">http://linux.die.net/man/3/pthread_mutexattr_init</a>
          </p>
          <p>
            <a href="http://linux.die.net/man/3/pthread_mutexattr_destroy">http://linux.die.net/man/3/pthread_mutexattr_destroy</a>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_35">pthread_barrier_init() および pthread_barrier_destroy()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_barrier_init </strong>(pthread_barrier_t *restrict barrier,</p>
          <p style="margin-left: 90.0px;">const pthread_barrierattr_t *restrict attr, unsigned count)</p>
          <p>int <strong>pthread_barrier_destroy </strong>(pthread_barrier_t *barrier)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <u>
              <strong>説明</strong>
            </u>
            <p>
              <strong>pthread_barrier_init</strong>() 関数は、<em>barrier</em> が参照するバリアーを使用するうえで必要なすべてのリソースを割り当て、</p>
            <p>
              <em>attr</em> が参照する属性でこのバリアーを初期化します。</p>
            <p>
              <br />
            </p>
            <p>
              <strong>pthread_barrier_destroy</strong>() 関数は、<em>barrier</em> が参照するバリアーを破棄し、そのバリアーで使用されていたリソースを</p>
            <p>すべて解放します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <ul>
                  <li>この実装での pthread_barrier_init() では、errno として EAGAIN と ENOMEM は返されません。その理由は、どのようなアロケーションの失敗も、基礎となる NintendoSDK API で abort() を使用して処理されるからです。<br /></li>
                </ul>
                <div class="note_new">
                  <div class="note_new_left">注意：</div>
                  <div class="note_new_right">
                    <p>NX ではバリアー属性が使用されないので、pthread_barrier_init() で指定した 'pthread_barrierattr_t' パラメータは無視されます。</p>
                    <p>その結果、pthread_barrierattr_init() 関数と pthread_barrierattr_destroy() 関数は実際には何も実行しません。</p>
                  </div>
                </div>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>int <strong>__nnmusl_pthread_barrier_init </strong>(pthread_barrier_t *b)</p>
                <p>int <strong>__nnmusl_pthread_barrier_destroy </strong>(pthread_barrier_t *b)</p>
                <p>
                  <br />
                </p>
              </div>
            </div>
            <p>
              <u>
                <strong>Errno<br /></strong>
              </u>
            </p>
            <p>
              <em>以下の条件下では pthread_barrier_init() 関数が必ず失敗します。</em>
            </p>
            <p>
              <strong>EINVAL</strong>：<em>count</em> に指定された値が 0 である場合。</p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EAGAIN</strong>：別のバリアーを初期化するために必要なリソースがシステムにない場合。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>ENOMEM</strong>：バリアーを初期化するにはメモリが不足している場合。</span>
            </p>
            <p>
              <em>以下の条件下では pthread_barrier_init() 関数が失敗する可能性があります。</em>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <span style="color: rgb(153,153,153);">
                  <strong>EBUSY</strong>：使用中のバリアーを実装側で再初期化しようとした場合。</span>
                <br />
                <span style="color: rgb(153,153,153);">
                  <strong>EINVAL</strong>：<em>attr</em> で指定された値が無効である場合。</span>
                <br />
              </span>
            </p>
            <p>
              <em>以下の条件下では pthread_barrier_destroy() 関数が失敗する可能性があります。</em>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EBUSY</strong>：使用中のバリアーを実装側で破棄しようとした場合。</span>
              <br />
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：<em>barrier</em> で指定された値が無効である場合。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_barrier_init">http://linux.die.net/man/3/pthread_barrier_init</a>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_barrier_destroy">http://linux.die.net/man/3/pthread_barrier_destroy</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_36">pthread_barrier_wait()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_barrier_wait </strong>(pthread_barrier_t *barrier);</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>pthread_barrier_wait</strong>() 関数は、<em>barrier</em> で参照しているバリアーの位置で、稼動している複数のスレッドを同期化します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <p>
                  <br />
                </p>
                <div class="note_new">
                  <div class="note_new_left">注意：</div>
                  <div class="note_new_right">
                    <p>NX での pthread_barrier_wait() 関数は、その実行結果が成功であるか失敗であるかに関係なく、必ず 'PTHREAD_BARRIER_SERIAL_THREAD' を返します。<br />実行に失敗した場合は内部アサートまたは強制終了がトリガされます。</p>
                  </div>
                </div>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>int <strong>__nnmusl_pthread_barrier_wait </strong>(pthread_barrier_t *b)</p>
                <p>
                  <br />
                </p>
              </div>
            </div>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <strong>EINVAL </strong>
              <span style="color: rgb(153,153,153);">：</span>
              <em>barrier</em>
              <span style="color: rgb(153,153,153);"> で指定されている値が、初期化済みのバリアーオブジェクトを参照していません。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>Errno (NX 固有)</strong>
              </u>
            </p>
            <p>
              <strong>ABORT</strong>：pthread_barrier_init() を実行せずに pthread_barrier_wait() を呼び出すと（初期化していないバリアーを使用する操作） abort() がトリガされます。</p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/pthread_barrier_wait">http://linux.die.net/man/3/pthread_barrier_wait</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_37">pthread_barrierattr_getpshared() および pthread_barrierattr_setpshared()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_barrierattr_getpshared </strong>(const pthread_barrierattr_t *restrict attr, int *restrict pshared)<br />int <strong>pthread_barrierattr_setpshared </strong>(pthread_barrierattr_t *attr, int pshared)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <u>
              <strong>説明</strong>
            </u>
            <p>該当なし（「NX 固有の扱い」を参照）</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <p>
                  <br />
                </p>
                <div class="warn_new">
                  <div class="warn_new_left">警告：</div>
                  <div class="warn_new_right">
                    <p>現時点の NX では pthread_barrierattr_getpshared() 関数および pthread_barrierattr_setpshared() 関数の機能をサポートしていないので、これらの関数は実装されていません。<br /></p>
                  </div>
                </div>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>該当なし</p>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>Errno<br /></strong>
                  </u>
                </p>
                <p>該当なし</p>
                <p>
                  <strong>
                    <br />
                  </strong>
                </p>
                <p>
                  <u>
                    <strong>詳細情報</strong>
                  </u>
                </p>
                <p>
                  <a href="http://linux.die.net/man/3/pthread_barrierattr_getpshared">http://linux.die.net/man/3/pthread_barrierattr_getpshared</a>
                </p>
                <p>
                  <a href="http://linux.die.net/man/3/pthread_barrierattr_setpshared">http://linux.die.net/man/3/pthread_barrierattr_setpshared</a>
                </p>
              </div>
            </div>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_38">pthread_getaffinity_np() and pthread_setaffinity_np()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_getaffinity_np</strong>(pthread_t thread, size_t cpusetsize, cpu_set_t *cpuset)</p>
          <p>int <strong>pthread_setaffinity_np</strong>(pthread_t thread, size_t cpusetsize, const cpu_set_t *cpuset)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <u>
              <strong>説明</strong>
            </u>
            <p>
              <strong>pthread_getaffinity_np</strong>() 関数は、<em>cpuset</em> が指すバッファにあるスレッド <em>thread</em> の CPU アフィニティマスクを返します。</p>
            <p>
              <strong>pthread_setaffinity_np</strong>() 関数は、<em>cpuset</em> が指す CPU セットに対して、スレッド <em>thread</em> の CPU アフィニティマスクを設定します。</p>
            <p>
              <br />
            </p>
            <p>「pthread.h」でインクルードする「sched.h」に記述されたさまざまな「CPU_*」マクロ（CPU_SET や CPU_ISSET など）もサポートされています。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <ul>
                  <li>NX の実装では、アフィニティマスクとして 'cpu_set_t' 配列ではなく、単独の '<span class="ApiLink_nn__Bit64">nn::Bit64</span>' (uint64_t) を使用します。その結果、この<br />マスクは、アプリケーションを 64 bit でビルドしている場合は cpuset.__bits[0] に格納され、<br />32 bit でビルドしている場合は '<span class="ApiLink_nn__Bit64">nn::Bit64</span>' の下位ビットである cpuset.__bits[0] と上位ビットである cpuset.__bits[1] に格納されます。<br />つまり、__bits[0] または __bits[1] のみ（またはその両方のみ）が使用され、1 つのマスクで sizeof(<span class="ApiLink_nn__Bit64">nn::Bit64</span>)*8 個のコアのみがサポートされます。</li>
                  <li>pthread_setaffinity_np()<span style="color: rgb(51,51,51);"> では、引数 '</span>cpusetsize'<span style="color: rgb(51,51,51);"> を使用して「理想的なコア」の値を渡すことができます。</span><br /><span style="color: rgb(51,51,51);">NX の内部実装では、この &quot;理想的なコア&quot; の値が問題なく使用されます。 標準の pthread 関数の宣言では、この方法が直接はサポートされていません。</span><br /><span style="color: rgb(51,51,51);">なお、'cpusetsize' を使用することで、NX に用意されているこの拡張機能を使用できます。 サポートされている 'ccpusetsize' の値は、以下のとおりです。</span></li>
                </ul>
                <table class="wrapped">
                  <tbody>
                    <tr>
                      <th>cpusetsize の値</th>
                      <th>意味</th>
                    </tr>
                    <tr>
                      <td>'cpuset' マスクで指定されているいずれかのコアの値</td>
                      <td>'cpuset' マスクに複数のコアが存在する場合、優先するコアをユーザ側で指定できます。</td>
                    </tr>
                    <tr>
                      <td>IdealCoreDontCare (&quot;-1&quot;)</td>
                      <td>システム側での判断に従って、アフィニティマスクで指定されているいずれかのコアでスレッドが実行されるようにします。</td>
                    </tr>
                    <tr>
                      <td>IdealCoreUseDefaultValue (&quot;-2&quot;)</td>
                      <td>スレッドの作成元プロセスを実行していたコアで、そのスレッドが実行されるようにします。</td>
                    </tr>
                    <tr>
                      <td>IdealCoreNoUpdate (&quot;-3&quot;)</td>
                      <td>アフィニティマスクを更新しますが、内部スケジューラでコアの変更を要求していない限り、別のコアにはスレッドを移動できません。</td>
                    </tr>
                    <tr>
                      <td>sizeof(cpu_set_t)</td>
                      <td>引数は無視され、「IdealCoreUseDefaultValue (-2)」が「理想的なコア」の値として使用されます。</td>
                    </tr>
                    <tr>
                      <td>上記の値のいずれでもなく、'cpuset' にも指定されていない値</td>
                      <td>アサートがトリガされます。</td>
                    </tr>
                  </tbody>
                </table>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>int <strong>__nnmusl_pthread_getaffinity_np</strong>(pthread_t td, size_t size, cpu_set_t *set)<br />int <strong>__nnmusl_pthread_setaffinity_np</strong>(pthread_t td, size_t ignored_size_or_ideal_core, const cpu_set_t *set)</p>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>Errno</strong>
                  </u>
                </p>
                <p>
                  <em>次の条件下では、pthread_getaffinity_np() 関数が失敗する可能性があります。</em>
                </p>
                <p>
                  <strong>EINVAL</strong>：'thread' パラメータが無効か、適切に初期化されていません。<br /><strong>ESRCH</strong>：'thread' で指定されているスレッドが見つからなかったか、適切に初期化されていません。</p>
                <p>
                  <em>次の条件下では、pthread_setaffinity_np() 関数が失敗する可能性があります。</em>
                </p>
                <p>
                  <strong>EINVAL</strong>：'thread' パラメータが無効であるか、適切に初期化されていません。</p>
                <p>
                  <strong>ESRCH</strong>：'thread' で指定されたスレッドが見つからないか、そのスレッドが適切に初期化されていません。</p>
                <p>
                  <span style="color: rgb(153,153,153);">
                    <strong>EFAULT</strong>：指定されたメモリアドレスが無効です。</span>
                  <br />
                  <span style="color: rgb(153,153,153);">
                    <strong>EINVAL</strong> (pthread_setaffinity_np())：現在物理的にシステムに配置されているプロセッサがアフィニティのビットマスクで指定されていません。</span>
                  <br />
                  <span style="color: rgb(153,153,153);">
                    <strong>EINVAL</strong> (pthread_setaffinity_np())：カーネルでサポートされているセットの範囲にない CPU が cpuset で指定されています。</span>
                </p>
                <p>
                  <strong>
                    <br />
                  </strong>
                </p>
                <p>
                  <strong>
                    <u>Errno（NX 固有）</u>
                  </strong>
                </p>
                <p>
                  <em>次の条件下では、pthread_getaffinity_np() 関数が失敗します。</em>
                </p>
                <p>
                  <strong>EOVERFLOW</strong>：nn::Bit64 を格納するには、'cpuset' パラメータで指定されているサイズが不適切です。</p>
                <p>
                  <em>次の条件下では、pthread_setaffinity_np() 関数が失敗します。</em>
                  <strong>
                    <br />
                  </strong>
                </p>
                <p>
                  <strong>EOVERFLOW</strong>：nn::Bit64 を格納するには、'cpuset' パラメータで指定されているサイズが不適切です。</p>
                <p>
                  <strong>ASSERT</strong>：'cpuset' パラメータが無効の場合、アサートが発生します。これは、このパラメータが空である場合、</p>
                <p>または cpusetsize' パラメータを使用して渡した理想的なコアがマスクで指定されていない場合です。</p>
                <p>
                  <strong>ASSERT</strong>：'cpusetsize' を使用して、&quot;sizeof(cpu_set_t)&quot; だけを渡すのではなく、理想的なコアの値も渡した場合に、</p>
                <p>そのコアの値が 'cpuset' マスクで指定されていないと、アサートがトリガされます。</p>
                <p>
                  <strong>
                    <br />
                  </strong>
                </p>
                <p>
                  <u>
                    <strong>詳細情報</strong>
                  </u>
                </p>
                <p>
                  <a href="http://linux.die.net/man/3/pthread_getaffinity_np">http://linux.die.net/man/3/pthread_getaffinity_np</a>
                </p>
                <p>
                  <a href="http://linux.die.net/man/3/pthread_setaffinity_np">http://linux.die.net/man/3/pthread_setaffinity_np</a>
                </p>
                <p>
                  <a href="http://linux.die.net/man/3/cpu_set">http://linux.die.net/man/3/cpu_set</a>
                </p>
              </div>
            </div>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_39">pthread_rwlock_init() and pthread_rwlock_destroy()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_rwlock_init</strong>(pthread_rwlock_t *rw, const pthread_rwlockattr_t *a)<br />int <strong>pthread_rwlock_destroy</strong>(pthread_rwlock_t *rw)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <u>
              <strong>説明</strong>
            </u>
            <p>
              <strong>pthread_rwlock_destroy</strong>() 関数は、rwlock により参照される読み書きロックオブジェクトを破棄して、ロックで使用されているあらゆるリソースを解放します。<br /><strong>pthread_rwlock_init</strong>() 関数は、rwlock により参照される読み書きロックを使用するために必要なあらゆるリソースを割り当てます。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <ul>
                  <li>pthread_rwlock_init() に渡される <em>pthread_rwlockattr_t* </em>引数は、NX では使用されません。デフォルトの属性値のみが使用されます。</li>
                </ul>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>int <strong>__nnmusl_pthread_rwlock_init</strong>(pthread_rwlock_t *rw, const pthread_rwlockattr_t *a)</p>
                <p>int <strong>__nnmusl_pthread_rwlock_destroy</strong>(pthread_rwlock_t *rw)</p>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>Errno</strong>
                  </u>
                </p>
                <p>
                  <em>以下の条件下では、pthread_rwlock_init() が必ず失敗します。</em>
                  <br />
                  <strong>EINVAL</strong>：渡された 'rwlock' パラメータが NULL である。<br /><span style="color: rgb(128,128,128);"><strong>EAGAIN</strong>：別の読み書きロックを初期化するために必要な（メモリ以外の）リソースがシステムに存在しない。</span><br /><span style="color: rgb(128,128,128);"><strong>ENOMEM</strong>：読み書きロックを初期化するために必要なメモリが不足している。</span><br /><span style="color: rgb(128,128,128);"><strong>EPERM</strong>：処理の実行に必要な権限が呼び出し元にない。</span><br /><span style="color: rgb(128,128,128);"><strong>EBUSY</strong>：既に初期化されていてもまだ破棄されていない読み書きロックを初期化しようとしている。</span><br /><em>以下の条件下では、pthread_rwlock_destroy() が必ず失敗します。</em><br /><strong>EINVAL</strong>：渡された 'rwlock' パラメータが NULL である。<br /><span style="color: rgb(128,128,128);"><strong>EBUSY</strong>： rwlock により参照されているオブジェクトがロックされているときに破棄されようとしたことが実装で検出された。</span></p>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>Errno (NX 固有)</strong>
                  </u>
                </p>
                <p>
                  <strong>ASSERT</strong>：pthread_rwlock_init() により初期化されていないロック上で pthread_rwlock_destroy() が呼び出されると、アサートがトリガされます。</p>
                <p>
                  <strong>ASSERT</strong>： 'rw' で未処理の読み取りロックまたは書き込みロックが保持されているときに pthread_rwlock_destroy() が呼び出されると、アサートがトリガされます。</p>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>詳細情報</strong>
                  </u>
                </p>
                <p>
                  <a href="https://linux.die.net/man/3/pthread_rwlock_init">https://linux.die.net/man/3/pthread_rwlock_init</a>
                </p>
                <p>
                  <a href="https://linux.die.net/man/3/pthread_rwlock_destroy">https://linux.die.net/man/3/pthread_rwlock_destroy</a>
                </p>
              </div>
            </div>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_40">pthread_rwlock_unlock()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_rwlock_unlock</strong>(pthread_rwlock_t *rw)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <u>
              <strong>説明</strong>
            </u>
            <p>
              <strong>pthread_rwlock_unlock</strong>() 関数は、rwlock により参照される読み書きロックオブジェクト上で保持されているロックを解放します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <p>該当なし</p>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>int <strong>__nnmusl_pthread_rwlock_unlock</strong>(pthread_rwlock_t *rw)</p>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>Errno</strong>
                  </u>
                </p>
                <p>
                  <em>以下の条件下では、pthread_rwlock_unlock() が必ず失敗します。</em>
                  <br />
                  <strong>EINVAL </strong>：<em>rwlock</em> で指定された値が初期化済みの読み書きロックオブジェクトを参照していない。</p>
                <p>
                  <span style="color: rgb(128,128,128);">
                    <strong>EPERM</strong>：現在のスレッドが読み書きロック上でロックを保持していない。</span>
                </p>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>Errno (NX 固有)</strong>
                  </u>
                </p>
                <p>
                  <strong>ASSERT</strong>：'rw' が pthread_rwlock_init() で初期化されていないと、アサートがトリガされます。</p>
                <p>
                  <strong>ASSERT</strong>：未処理の読み書きロックが 'rw' で保持されていると、アサートがトリガされます。</p>
                <p>
                  <strong>ASSERT</strong>：書き込みロックが 'rw' で保持されていて、呼び出し元のスレッドがそのロックの所有者でないと、アサートがトリガされます。</p>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>詳細情報</strong>
                  </u>
                </p>
                <p>
                  <a href="https://linux.die.net/man/3/pthread_rwlock_unlock">https://linux.die.net/man/3/pthread_rwlock_unlock</a>
                </p>
              </div>
            </div>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_41">pthread_rwlock_rdlock() and pthread_rwlock_wrlock()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_rwlock_rdlock</strong>(pthread_rwlock_t *rw)</p>
          <p>int <strong>pthread_rwlock_wrlock</strong>(pthread_rwlock_t *rw)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <u>
              <strong>説明</strong>
            </u>
            <p>ライターがロックを保持しておらず、ロックによりブロックされているライターが存在しない場合、<strong>pthread_rwlock_rdlock</strong>() 関数は読み取りロックを獲得します。</p>
            <p>他に rwlock ロックを保持しているスレッド（リーダーまたはライター）が存在しない場合には、<strong>pthread_rwlock_wrlock</strong>() 関数が書き込みロックを獲得します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <ul>
                  <li>保持可能な読み取り/書き込みロックの最大数は &quot;<span class="ApiLink_nn__os__ReaderWriterLockCountMax">nn::os::ReaderWriterLockCountMax</span>&quot; で定義されており、65535 に設定されています。</li>
                </ul>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>int <strong>__nnmusl_pthread_rwlock_rdlock</strong>(pthread_rwlock_t *rw)</p>
                <p>int <strong>__nnmusl_pthread_rwlock_wrlock</strong>(pthread_rwlock_t *rw)</p>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>Errno</strong>
                  </u>
                </p>
                <p>
                  <em>以下の条件下では、pthread_rwlock_rdlock() 関数が失敗する可能性があります。</em>
                  <br />
                  <strong>EINVAL</strong>：パラメータ 'rwlock' が NULL である。<br /><strong>EAGAIN</strong>：rwlock に対する読み取りロックが最大数を超えているため、読み取りロックを獲得できない。<br /><span style="color: rgb(128,128,128);"><strong>EDEADLK</strong>：現在のスレッドが既に書き込みに対する読み書きロックを有している。</span><br /><em>以下の条件下では、pthread_rwlock_wrlock() 関数が失敗する可能性があります。</em><br /><strong>EINVAL</strong>：パラメータ 'rwlock' が NULL である。<br /><span style="color: rgb(128,128,128);"><strong>EDEADLK</strong>：現在のスレッドが既に書き込みまたは読み取りに対する読み書きロックを有している。</span></p>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>Errno (NX 固有)</strong>
                  </u>
                </p>
                <p>
                  <strong>ASSERT</strong>：'rw' が pthread_rwlock_init() で初期化されていないと、アサートがトリガされます。</p>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>詳細情報</strong>
                  </u>
                </p>
                <p>
                  <a href="https://linux.die.net/man/3/pthread_rwlock_rdlock">https://linux.die.net/man/3/pthread_rwlock_rdlock</a>
                </p>
                <p>
                  <a href="https://linux.die.net/man/3/pthread_rwlock_wrlock">https://linux.die.net/man/3/pthread_rwlock_wrlock</a>
                </p>
              </div>
            </div>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_42">pthread_rwlock_tryrdlock() and pthread_rwlock_trywrlock()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>pthread_rwlock_tryrdlock</strong>(pthread_rwlock_t *rw)</p>
          <p>int <strong>pthread_rwlock_trywrlock</strong>(pthread_rwlock_t *rw)</p>
          <p>
            <br />
          </p>
        </td>
        <td>
          <div class="content-wrapper">
            <u>
              <strong>説明</strong>
            </u>
            <p>ライターがロックを保持しておらず、ロックによりブロックされているライターが存在しない場合、<strong>pthread_rwlock_rdlock</strong>() 関数は読み取りロックを獲得します。</p>
            <p>他に rwlock ロックを保持しているスレッド（リーダーまたはライター）が存在しない場合には、<strong>pthread_rwlock_wrlock</strong>() 関数が書き込みロックを獲得します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <ul>
                  <li>保持可能な読み取り/書き込みロックの最大数は &quot;<span class="ApiLink_nn__os__ReaderWriterLockCountMax">nn::os::ReaderWriterLockCountMax</span>&quot; で定義されており、65535 に設定されています。</li>
                </ul>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>int <strong>__nnmusl_pthread_rwlock_tryrdlock</strong>(pthread_rwlock_t *rw)</p>
                <p>int <strong>__nnmusl_pthread_rwlock_trywrlock</strong>(pthread_rwlock_t *rw)</p>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>Errno</strong>
                  </u>
                </p>
                <p>
                  <em>以下の条件下では、pthread_rwlock_tryrdlock() 関数が必ず失敗します。</em>
                  <br />
                  <strong>EBUSY</strong>：今回はロックを獲得できなかった。<br /><strong>EINVAL</strong>：パラメータ 'rwlock' が NULL である。<br /><strong>EAGAIN</strong>：rwlock に対する読み取りロックが最大数を超えているため、読み取りロックを獲得できない。<br /><em>以下の条件下では、pthread_rwlock_trywrlock() 関数が必ず失敗します。</em><br /><strong>EBUSY</strong>：今回はロックを獲得できなかった。<br /><strong>EINVAL</strong>：パラメータ 'rwlock' が NULL である。<br /><span style="color: rgb(128,128,128);"><strong>EDEADLK</strong>：現在のスレッドが既に書き込みまたは読み取りに対する読み書きロックを既に有している。</span></p>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>Errno (NX 固有)</strong>
                  </u>
                </p>
                <p>
                  <strong>ASSERT</strong>：'rw' が pthread_rwlock_init() で初期化されていないと、アサートがトリガされます。</p>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>詳細情報</strong>
                  </u>
                </p>
                <p>
                  <a href="https://linux.die.net/man/3/pthread_rwlock_tryrdlock">https://linux.die.net/man/3/pthread_rwlock_tryrdlock</a>
                </p>
                <p>
                  <a href="https://linux.die.net/man/3/pthread_rwlock_trywrlock">https://linux.die.net/man/3/pthread_rwlock_trywrlock</a>
                </p>
              </div>
            </div>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_43">sched_yield()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>sched_yield</strong>(void);</p>
        </td>
        <td>
          <div class="content-wrapper">
            <u>
              <strong>説明</strong>
            </u>
            <p>
              <strong>sched_yield</strong>() 関数は、実行中のスレッドに対して、再びスレッドリストの筆頭に置かれるまでプロセッサの利用を放棄することを指示します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <p>なし</p>
                <p>
                  <u>
                    <strong>
                      <br />
                    </strong>
                  </u>
                </p>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>int <strong>__nnmusl_YieldThread</strong>()</p>
                <p>
                  <u>
                    <strong>
                      <br />
                    </strong>
                  </u>
                </p>
                <p>
                  <u>
                    <strong>Errno</strong>
                  </u>
                </p>
                <p>該当なし</p>
                <p>
                  <strong>
                    <br />
                  </strong>
                </p>
                <p>
                  <u>
                    <strong>詳細情報</strong>
                  </u>
                </p>
                <p>
                  <a href="http://linux.die.net/man/3/sched_yield">http://linux.die.net/man/3/sched_yield</a>
                </p>
              </div>
            </div>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_44">sched_get_priority_min() および sched_get_priority_max()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>sched_get_priority_min</strong>(int policy)</p>
          <p>int <strong>sched_get_priority_max</strong>(int policy)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>これらの関数は、policy で指定されたスケジューリングポリシーに定義されている優先順位の最小値と最大値を返します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <ul>
                  <li>NX では、スケジューリングポリシーを扱うことはできません。NX のデフォルトの動作は、SCHED_FIFO または SCHED_OTHER.を指定した場合と同様です。<br />これ以外のどのようなポリシーをこれらの関数に渡してもアサートがトリガされます。</li>
                </ul>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>int <strong>__nnmusl_sched_get_priority_min</strong>(int policy)</p>
                <p>int <strong>__nnmusl_sched_get_priority_max</strong>(int policy)</p>
                <p>
                  <br />
                </p>
              </div>
            </div>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <span style="color: rgb(153,153,153);">
                <strong>EINVAL</strong>：<em>policy</em> パラメータが無効な値である場合。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>Errno (NX 固有)</strong>
              </u>
            </p>
            <p>
              <strong>ASSERT</strong>：SCHED_FIFO でも SCHED_OTHER でもないポリシーが渡されてアサートがトリガされた場合。</p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/sched_get_priority_max">http://linux.die.net/man/3/sched_get_priority_max</a>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/sched_get_priority_min">http://linux.die.net/man/3/sched_get_priority_min</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_45">sem_init() および sem_destroy()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>sem_init</strong>(sem_t *sem, int pshared, unsigned int value);</p>
          <p>int <strong>sem_destroy</strong>(sem_t *sem);</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>これらの関数は、名前のないセマフォを初期化または破棄します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <ul>
                  <li>
                    <p>この実装では、セマフォに対して sem_init と sem_destroy を呼び出す必要があります。</p>
                  </li>
                  <li>
                    <p>
                      <em>pshared</em> 引数として 0 を渡すことができるのはこの実装のみです。</p>
                  </li>
                  <li>sem_destroy() で破棄していないセマフォがあるとメモリリークの原因になります。</li>
                </ul>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>int <strong>__nnmusl_InitalizeSemaphore</strong>(sem_t *sem, int pshared, unsigned value)</p>
                <p>int <strong>__nnmusl_FinalizeSemaphore</strong>(sem_t *sem)</p>
                <p>
                  <br />
                </p>
              </div>
            </div>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <em>次の条件下では sem_init() が必ず失敗します。</em>
            </p>
            <p>
              <strong>EINVAL</strong>：SEM_VALUE_MAX より大きい値を <em>value</em> で渡した場合。</p>
            <p>
              <strong>ENOSYS </strong>：<em>pshared</em> がゼロではない場合。</p>
            <p>
              <em>次の条件下では sem_destroy() が必ず失敗します。</em>
            </p>
            <p>
              <strong>EINVAL</strong>：<em>sem</em> が有効なセマフォではない場合。</p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/sem_init">http://linux.die.net/man/3/sem_init</a>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/sem_destroy">http://linux.die.net/man/3/sem_destroy</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_46">sem_getvalue()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>sem_getvalue</strong>(sem_t *sem, int *sval);</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>sem_getvalue</strong>() は、<em>sem</em> でポイントされているセマフォの現在の値を、<em>sval</em> でポイントされている整数に代入します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <ul>
                  <li>
                    <p>なし</p>
                  </li>
                </ul>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>int <strong>__nnmusl_GetCurrentSemaphoreCount</strong>(sem_t *sem, int *valp);</p>
                <p>
                  <br />
                </p>
              </div>
            </div>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <span style="color: rgb(128,128,128);">
                <strong>EINVAL</strong>：<em>sem</em> が有効なセマフォではない場合。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/sem_getvalue">http://linux.die.net/man/3/sem_getvalue</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_47">sem_post()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>sem_post</strong>(sem_t *sem)</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>
              <strong>sem_post</strong>() は、<em>sem</em> でポイントされているセマフォをインクリメント（ロック解除）します。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <ul>
                  <li>
                    <p>なし</p>
                  </li>
                </ul>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>int <strong>__nnmusl_ReleaseSemaphore</strong>(sem_t *sem)</p>
                <p>
                  <br />
                </p>
              </div>
            </div>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <span style="color: rgb(128,128,128);">
                <strong>EINVAL</strong>：<em>sem</em> が有効なセマフォではない場合。</span>
            </p>
            <p>
              <span style="color: rgb(128,128,128);">
                <strong>EOVERFLOW</strong>：セマフォに指定できる最大値を超える場合。</span>
            </p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/sem_post">http://linux.die.net/man/3/sem_post</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_48">sem_timedwait()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>sem_timedwait</strong>(sem_t *sem, const struct timespec *abs_timeout);</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>この関数は、<em>sem</em> でポイントされているセマフォをデクリメント（ロック）します。ただし、デクリメントをただちに実行できない場合にこの関数呼び出しをブロックする時間の上限値が <em>abs_timeout</em> で</p>
            <p>指定されている場合はデクリメントしません。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <ul>
                  <li>
                    <p>NX では絶対時間をサポートしていません。clock_gettime() または gettimeofday() を使用すると、<br />ボードを起動した時点からの経過時間をそれぞれナノ秒またはマイクロ秒の単位で取得できます。<br />これらの呼び出しを使用して「現在の時間」を取得し、その時間に目的のタイムアウト<br />時間を加算します。</p>
                  </li>
                </ul>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>int <strong>__nnmusl_TimedAcquireSemaphore</strong>(sem_t *sem, const struct timespec *ts)</p>
                <p>
                  <br />
                </p>
              </div>
            </div>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <strong>EINVAL</strong>：struct timespec ポインタが NULL であるか、tv_sec &lt; 0 または tv_nsec &gt;= 1000000000 です。</p>
            <p>
              <strong>ETIMEDOUT</strong>：タイムアウトが発生しました。</p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/sem_timedwait">http://linux.die.net/man/3/sem_timedwait</a>
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <h4 id="Anchor_126570133_h4_49">sem_wait() and sem_trywait()</h4>
          <p>
            <br />
          </p>
          <p>int <strong>sem_wait</strong>(sem_t *sem);</p>
          <p>int <strong>sem_trywait</strong>(sem_t *sem);</p>
        </td>
        <td>
          <div class="content-wrapper">
            <p>
              <u>
                <strong>説明</strong>
              </u>
            </p>
            <p>これらの関数は、<em>sem</em> でポイントされたセマフォをデクリメント（ロック）します。</p>
            <p>
              <em>sem_trywait()</em> では、デクリメントをただちに実行できない場合、</p>
            <p>ブロックせずにエラーが返されます。</p>
            <p>
              <br />
            </p>
            <div class="section">
              <div class="section">
                <u>
                  <strong>NX 固有の扱い</strong>
                </u>
              </div>
              <div class="section">
                <ul>
                  <li>
                    <p>なし</p>
                  </li>
                </ul>
                <p>
                  <br />
                </p>
                <p>
                  <u>
                    <strong>インターフェース関数</strong>
                  </u>
                </p>
                <p>int <strong>__nnmusl_AcquireSemaphore</strong>(sem_t *sem)</p>
                <p>int <strong>__nnmusl_TryAcquireSemaphore</strong>(sem_t *sem)</p>
                <p>
                  <br />
                </p>
              </div>
            </div>
            <p>
              <u>
                <strong>Errno</strong>
              </u>
            </p>
            <p>
              <em>次の条件下では sem_trywait() が必ず失敗します。</em>
              <u>
                <strong>
                  <br />
                </strong>
              </u>
            </p>
            <p>
              <strong>EAGAIN</strong>：目的のセマフォを取得できなかった場合。</p>
            <p>
              <strong>
                <br />
              </strong>
            </p>
            <p>
              <u>
                <strong>詳細情報</strong>
              </u>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/sem_wait">http://linux.die.net/man/3/sem_wait</a>
            </p>
            <p>
              <a href="http://linux.die.net/man/3/sem_trywait">http://linux.die.net/man/3/sem_trywait</a>
            </p>
          </div>
        </td>
      </tr>
    </tbody>
  </table>
</div>
</div>
<div class="breadcrumb_bottom"></div>
<div class="page_navigation">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
<tr><td colspan="2" class="page_navi_bottom"></td></tr>
</table>
</div>
</div>
</div>
<!--AddLink-->
<script>
var NintendoSdkApiRefernce = {
    idMap: {},
    linkRewrite: function ()
    {
        var idMap = NintendoSdkApiRefernce.idMap;
        function rewrite(el)
        {
            var e = idMap[el.className];
            if (e === undefined)
            {
                return;
            }
            var html = '';
            html += '<a href=';
            html += e.url;
            html += ' target="_blank">';
            html += el.innerHTML;
            html += '</a>';
            el.innerHTML = html;
        }
        var apiLinkElems = document.querySelectorAll('span[class*="ApiLink_"]');
        for (var i = 0, n = apiLinkElems.length; i< n; ++i) {
            rewrite(apiLinkElems[i]);
        }
    }
};
function SetUrl( id, url )
{
    NintendoSdkApiRefernce.idMap[id] = { url: url };
}
SetUrl( 'ApiLink_nn__os__SetMemoryAllocatorForThreadLocal', '../../../Api/HtmlNX/namespacenn_1_1os.html#a347a69381452967e4a51b3c18aae7807' )
// ApiLink_nn__Bit64
SetUrl( 'ApiLink_nn__os__ReaderWriterLockCountMax', '../../../Api/HtmlNX/namespacenn_1_1os.html#a3cb4af12ad2e9b3e32f1e72d3a313f32' )

NintendoSdkApiRefernce.linkRewrite();
</script>
<!--AddLink-->
</body>
</html>
