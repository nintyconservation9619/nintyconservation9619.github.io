<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<script type="text/javascript" src="../template/js/jquery/jquery.js"></script>
<script type="text/javascript" src="../template/js/common/manualLib.js"></script>
<script type="text/javascript" src="../tocData.js"></script>
<link rel="stylesheet" type="text/css" href="../template/css/template.css" />
<title>各機能の利用方法</title>
</head>
<body data-reassemble="autoindex=no,forceNoLabel=yes">
<div id="autoindex_content">
<div class="body_content">
<noscript>
<div style="border: 4px double black; margin: 4px; padding: 2px; font-weight: bold; background-color: #FFFFCC;">
<p>お使いのブラウザは JavaScript が使用できないため、本ドキュメントの一部機能が無効になっています。</p><p>JavaScript が無効の環境では目次を使用することができません。<br />JavaScriptの実行が許可された状態で閲覧してください。<br /><br /></p>
</div>
</noscript>
<div class="page_navigation_top">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
</table>
</div>
<div class="breadcrumb"></div>

<!-- 各機能の利用方法 -->
<div class="pagetitle" id="PageId_114739604">各機能の利用方法</div>
<div class="text_separate">
<p>
  <ul class="macro_toc">
    <li>
      <a href="#Anchor_114739604_h1_1">はじめに</a>
    </li>
    <li>
      <a href="#Anchor_114739604_h1_2">NFP ライブラリ利用の流れ</a>
    </li>
    <li>
      <a href="#Anchor_114739604_h1_3">初期化処理</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_114739604_h2_1">NFP ライブラリを初期化</a>
      </li>
      <li>
        <a href="#Anchor_114739604_h2_2">タグ検知イベントの登録</a>
      </li>
      <li>
        <a href="#Anchor_114739604_h2_3">タグ検知イベントの破棄</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_114739604_h1_4">タグ検知の開始</a>
    </li>
    <li>
      <a href="#Anchor_114739604_h1_5">タグ情報の取得</a>
    </li>
    <li>
      <a href="#Anchor_114739604_h1_6">タグのマウント</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_114739604_h2_4">壊れたタグのデータが修復可能な場合</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_114739604_h1_7">NFP タグ領域へのアクセス</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_114739604_h2_5">キャラクターID の取得</a>
      </li>
      <li>
        <a href="#Anchor_114739604_h2_6">オーナー、ニックネームの取得</a>
      </li>
      <li>
        <a href="#Anchor_114739604_h2_7">アプリ専用領域へのアクセス</a>
      </li>
      <ul>
        <li>
          <a href="#Anchor_114739604_h3_1">アプリ専用領域の読み込み</a>
        </li>
        <li>
          <a href="#Anchor_114739604_h3_2">アプリ専用領域の作成</a>
        </li>
        <li>
          <a href="#Anchor_114739604_h3_3">アプリ専用領域への書き込み</a>
        </li>
        <li>
          <a href="#Anchor_114739604_h3_4">アクセス ID の異なる amiibo のゲームデータを引き継いで書き換える場合</a>
        </li>
      </ul>
    </ul>
    <li>
      <a href="#Anchor_114739604_h1_8">タグ喪失通知の待ち受け</a>
    </li>
    <li>
      <a href="#Anchor_114739604_h1_9">終了</a>
    </li>
    <li>
      <a href="#Anchor_114739604_h1_10">共通エラーハンドリング</a>
    </li>
    <li>
      <a href="#Anchor_114739604_h1_11">エラービューアによるメッセージの表示</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_114739604_h2_8">アプリケーションによるエラービューア表示</a>
      </li>
      <li>
        <a href="#Anchor_114739604_h2_9">NFP ライブラリによるエラービューア表示</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_114739604_h1_12">amiibo 設定</a>
    </li>
    <ul>
      <li>
        <a href="#Anchor_114739604_h2_10">オーナー登録、ニックネーム登録</a>
      </li>
      <li>
        <a href="#Anchor_114739604_h2_11">データの復旧</a>
      </li>
      <li>
        <a href="#Anchor_114739604_h2_12">ゲームデータ消去</a>
      </li>
    </ul>
    <li>
      <a href="#Anchor_114739604_h1_13">複数の NFC デバイス同時利用</a>
    </li>
  </ul>
</p>
<h1 id="Anchor_114739604_h1_1">はじめに</h1>
<p>ここでは、NFP ライブラリの各機能の利用方法についてまとめます。</p>
<h1 id="Anchor_114739604_h1_2">NFP ライブラリ利用の流れ</h1>
<p>NFP ライブラリを利用する際の基本的な流れは下図のようになります。</p>
<!--figure001-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure001"></a>図 3. NFP ライブラリ利用の基本的な流れ</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/161422401.png" width="500" class="embedded-image" />
  </span>
</p>
<h1 id="Anchor_114739604_h1_3">初期化処理</h1>
<h2 id="Anchor_114739604_h2_1">NFP ライブラリを初期化</h2>
<p>NFP ライブラリの初期化は <span class="ApiLink_nn__nfp__Initialize">nn::nfp::Initialize</span>() を呼び出します。</p>
<p>NFP ライブラリ使用中、ユーザーの操作によってアプリケーションが意図しないタイミングで NFC デバイスが使用不能になることがあります。そのような状況に備えるには、あらかじめ NFP ライブラリの初期化後に <span class="ApiLink_nn__nfp__AttachAvailabilityChangeEvent">nn::nfp::AttachAvailabilityChangeEvent</span>() を呼び出し、NFC デバイスの使用可否の変化を通知するイベントを設定しておきます。</p>
<p>このイベントを設定すると次のような変化があったときに通知を受け取ることができます。</p>
<ul>
  <li>NFC デバイスが切断された</li>
  <li>NFC デバイスが接続された</li>
  <li>フォーカスのあるアプリケーションが変わった</li>
  <li>本体がスリープから復帰した</li>
  <li>NFC 機能が無効になった</li>
  <li>NFC 機能が有効になった&nbsp;</li>
</ul>
<div class="note_new">
  <div class="note_new_left">注意：</div>
  <div class="note_new_right">
    <p>このイベントは、NFC デバイスが接続されていない状態で NFC 機能の有効・無効を切り替えても発生します。</p>
  </div>
</div>
<p>
  <span class="ApiLink_nn__nfp__AttachAvailabilityChangeEvent">nn::nfp::AttachAvailabilityChangeEvent</span>() に未初期化の <span class="ApiLink_nn__os__SystemEventType">nn::os::SystemEventType</span> 構造体を渡すと、イベントが初期化されて通知を受け取れるようになります。初期化以外のイベント制御は、OS ライブラリの「システムイベント」の章を参照してください。</p>
<p>この通知を受け取った時は必要に応じて <span class="ApiLink_nn__nfp__GetDeviceState">nn::nfp::GetDeviceState</span>() で NFP ライブラリのステートを確認します。</p>
<!--figure002-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure002"></a>図 4. 初期化処理</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/159287999.png" width="200" class="embedded-image" />
  </span>
</p>
<h2 id="Anchor_114739604_h2_2">タグ検知イベントの登録</h2>
<p>タグの操作を行う前に、タグ検知に関連する NFP ライブラリからの通知をアプリケーションで受け取るイベントを設定する必要があります。</p>
<p>NFP ライブラリからアプリケーションへは、以下のタイミングでタグ検知に関連する通知が行われます。</p>
<ol>
  <li>タグ発見通知<ul><li>NFC デバイスが NFC タグを発見した</li></ul></li>
  <li>タグ喪失通知<ul><li>発見していた NFC タグが NFC デバイスから離れた</li><li>タグを検知している状態で <span class="ApiLink_nn__nfp__StopDetection">nn::nfp::StopDetection</span>() または <span class="ApiLink_nn__nfp__Finalize">nn::nfp::Finalize</span>() を呼び出した</li></ul></li>
</ol>
<p>まず、タグの操作を行う NFC デバイスの情報を取得します。</p>
<p>NFP ライブラリの初期化後、NFC デバイスのハンドルリストを取得します。NFC デバイスのハンドルの取得は <span class="ApiLink_nn__nfp__ListDevices">nn::nfp::ListDevices</span>() で行います。</p>
<p>次に操作対象のコントローラーを特定するために、<span class="ApiLink_nn__nfp__GetNpadId">nn::nfp::GetNpadId</span>() を呼び出して NpadId を取得します。<span class="ApiLink_nn__nfp__GetNpadId">nn::nfp::GetNpadId</span>() の引数には <span class="ApiLink_nn__nfp__ListDevices">nn::nfp::ListDevices</span>() で取得したデバイスハンドルを指定します。デバイスハンドルごとに NpadId を取得し、操作対象のコントローラーのデバイスハンドルを特定します。NpadId については hid ライブラリを参照してください。</p>
<p>次に操作対象の NFC デバイスごとにタグ発見通知、タグ喪失通知のイベント登録設定を行います。タグ発見通知のイベント登録には<span class="ApiLink_nn__nfp__AttachActivateEvent">nn::nfp::AttachActivateEvent</span>()、タグ喪失通知のイベント登録には <span class="ApiLink_nn__nfp__AttachDeactivateEvent">nn::nfp::AttachDeactivateEvent</span>() を呼びだします。それぞれの関数に未初期化の <span class="ApiLink_nn__os__SystemEventType">nn::os::SystemEventType</span> 構造体を渡すと、イベントが初期化されて通知を受け取れるようになります。初期化以外のイベント制御は、OS ライブラリの「システムイベント」の章を参照してください。</p>
<p>
  <span class="ApiLink_nn__nfp__AttachActivateEvent">nn::nfp::AttachActivateEvent</span>() で設定したイベントがシグナル状態になることでタグの発見がアプリケーションに通知されます。</p>
<p>
  <span class="ApiLink_nn__nfp__AttachDeactivateEvent">nn::nfp::AttachDeactivateEvent</span>() で設定したイベントがシグナル状態になることでタグの喪失がアプリケーションに通知されます。</p>
<p>次のフロー図は NFC デバイスハンドルの取得からイベント登録を行うまでの例です。</p>
<!--figure050-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure050"></a>図 5. NFC デバイスハンドルリストの取得とイベントの登録</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/161438121.png" width="500" class="embedded-image" />
  </span>
</p>
<h2 id="Anchor_114739604_h2_3">タグ検知イベントの破棄</h2>
<p>
  <span class="ApiLink_nn__nfp__AttachActivateEvent">nn::nfp::AttachActivateEvent</span>() と <span class="ApiLink_nn__nfp__AttachDeactivateEvent">nn::nfp::AttachDeactivateEvent</span>() で初期化したイベントは使用後は必ず破棄を行う必要があります。エラーの発生などでイベントの再登録を行う場合も、NFC デバイスのハンドルに登録していたイベントを破棄してください。イベントの破棄は <span class="ApiLink_nn__os__DestroySystemEvent">nn::os::DestroySystemEvent</span>() を呼び出します。</p>
<h1 id="Anchor_114739604_h1_4">タグ検知の開始</h1>
<p>タグ検知の開始は <span class="ApiLink_nn__nfp__StartDetection">nn::nfp::StartDetection</span>() で行います。引数に対象の NFC デバイスのハンドルを指定します。タグ検知を開始する前に、すでにタグが検知済みか検知中の状態の場合は <span class="ApiLink_nn__nfp__StopDetection">nn::nfp::StopDetection</span>() を実行する必要があります。</p>
<p>タグ検知を行っている間、NFP ライブラリはタグを発見したか、発見していたタグと通信可能であるかを定期的に判定します。タグ検知の状態が変化する要因が発生してから、タグ発見がアプリケーションに通知されるまでには、 1 秒程度のタイムラグがあります。タグ喪失がアプリケーションに通知されるまでには 1 ～ 3 秒程度のタイムラグがあります。そのため、タグがタッチされたり、タグが離されたりしたタイミングをシビアに判定するような実装を行わないでください。</p>
<p>検知開始後、タグの発見は <span class="ApiLink_nn__nfp__AttachActivateEvent">nn::nfp::AttachActivateEvent</span>() で設定したイベントがシグナル状態になることでアプリケーションに通知されます。タグが発見された段階で、以下の処理が可能になります。</p>
<ul>
  <li>タグ情報の取得</li>
  <li>タグのマウント</li>
</ul>
<div class="note_new">
  <div class="note_new_left">注意：</div>
  <div class="note_new_right">
    <p>タグの発見通知を待ち受ける間に、HOMEメニューやスリープに遷移すると検知に失敗します。タグ発見通知を受け取る前に NFC デバイスの利用可/不可の変化通知イベントを受け取った場合に <span class="ApiLink_nn__nfp__GetDeviceState">nn::nfp::GetDeviceState</span>() を呼び出してステートを調べ、検知に失敗していないかどうかを確認する必要があります。</p>
  </div>
</div>
<p>次のフロー図はタグ検知時の例です。</p>
<!--figure003-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure003"></a>図 6. タグ検知の開始</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/159288387.png" width="500" class="embedded-image" />
  </span>
</p>
<p>タグの検知後、NFC デバイスからタグが離れると NFP ライブラリはタグを見失います。この時、<span class="ApiLink_nn__nfp__AttachDeactivateEvent">nn::nfp::AttachDeactivateEvent</span>() で設定したイベントがシグナル状態になり、タグの喪失がアプリケーションに通知されます。タグ喪失状態ではタグへの読み書きができません。タグへのアクセスを継続する場合は <span class="ApiLink_nn__nfp__StartDetection">nn::nfp::StartDetection</span>() を再度呼び出す必要があります。</p>
<h1 id="Anchor_114739604_h1_5">タグ情報の取得</h1>
<p>タグ情報の取得は <span class="ApiLink_nn__nfp__GetTagInfo">nn::nfp::GetTagInfo</span>() を呼び出します。タグが検出された状態、またはマウントされた状態で実行してください。</p>
<p>タグ情報は <span class="ApiLink_nn__nfp__TagInfo">nn::nfp::TagInfo</span> 構造体で定義されています。<span class="ApiLink_nn__nfp__GetTagInfo">nn::nfp::GetTagInfo</span>() は引数で渡された <span class="ApiLink_nn__nfp__TagInfo">nn::nfp::TagInfo</span> 構造体に値を設定します。</p>
<div class="info_new">
  <div class="info_new_left">参考：</div>
  <div class="info_new_right">
    <p>NFP ライブラリでは、NFC タグの UID が取得できるのはタグ情報からだけです。</p>
    <p>タグ情報は NFP ライブラリでアクセス可能な種類のタグであれば取得できる情報のみが記録されているため、発見されたタグが NFP タグであるかどうかまでは分かりません。</p>
  </div>
</div>
<p>次のフロー図の例ではタグ情報を取得して目的に合った UID のタグがタッチされたかどうかを確認しています。</p>
<!--figure015-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure015"></a>図 7. タグ情報の取得</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/161422712.png" width="500" class="embedded-image" />
  </span>
</p>
<p>
  <a name="Anchor_114739604_a_Mount"></a>
</p>
<h1 id="Anchor_114739604_h1_6">タグのマウント</h1>
<p>NFP タグの情報にアクセスする前に、まず <span class="ApiLink_nn__nfp__Mount">nn::nfp::Mount</span>() を呼び出して検知されたタグをマウントする必要があります。</p>
<p>
  <span class="ApiLink_nn__nfp__Mount">nn::nfp::Mount</span>() には、アクセスできる領域を指定しないものと指定するものの二種類があります。</p>
<div class="code">
  <a name="AutoAnchor_114739604_code001"></a>コード 1.  タグのマウント</div>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="nn">nn::</span><span class="n">Result</span> <span class="nn">nn::nfp::</span><span class="n">Mount</span> <span class="p">(</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">const</span> <span class="nn">nn::nfp::</span><span class="n">DeviceHandle</span> <span class="o">&amp;</span>     <span class="n">deviceHandle</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="nn">nn::nfp::</span><span class="n">ModelType</span>                <span class="n">modelType</span> 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">);</span>

<span class="nn">nn::</span><span class="n">Result</span> <span class="nn">nn::nfp::</span><span class="n">Mount</span> <span class="p">(</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">const</span> <span class="nn">nn::nfp::</span><span class="n">DeviceHandle</span> <span class="o">&amp;</span>     <span class="n">deviceHandle</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="nn">nn::nfp::</span><span class="n">ModelType</span>                <span class="n">modelType</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="nn">nn::nfp::</span><span class="n">MountTarget</span>              <span class="n">mountTarget</span> 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>マウントする領域を指定する場合は引数に&nbsp;<span class="ApiLink_nn__nfp__MountTarget">nn::nfp::MountTarget</span> 型の値を指定します。領域指定しない関数は、領域指定する関数において MountTarget_All（全ての領域）を指定した場合と同じ動作になります。</p>
<p>指定したマウント対象領域によって、マウント時の挙動が異なります。マウント対象領域 に MountTarget_Rom 以外を指定した場合、マウントに成功するとバックアップデータの更新が行われます。</p>
<!--table002-->
<div class="table">
  <a name="AutoAnchor_114739604_table002"></a>表 5.  マウント対象の指定と成功時の挙動</div>
<table class="wrapped">
  <colgroup>
    <col />
    <col />
    <col />
  </colgroup>
  <tbody>
    <tr>
      <th>指定する引数</th>
      <th>マウント対象領域</th>
      <th>マウントに成功した時のバックアップデータの更新</th>
    </tr>
    <tr>
      <td>MountTarget_Rom</td>
      <td>読み取り専用領域</td>
      <td>更新しない</td>
    </tr>
    <tr>
      <td>MountTarget_Ram</td>
      <td>読み書き可能領域</td>
      <td>更新する</td>
    </tr>
    <tr>
      <td>MountTarget_All<br />または指定なし</td>
      <td>全ての領域</td>
      <td>更新する</td>
    </tr>
  </tbody>
</table>
<p>発見されたタグが NFP タグでない場合は <span class="ApiLink_nn__nfp__ResultNotSupported">nn::nfp::ResultNotSupported</span> が返されます。</p>
<p>発見されたタグが NFP タグであっても、未知のフォーマットバージョンでありマウントできない場合には <span class="ApiLink_nn__nfp__ResultInvalidFormatVersion">nn::nfp::ResultInvalidFormatVersion</span> が返されます。</p>
<p>発見されたタグが NFP タグであり、タグのマウントに成功した場合は <span class="ApiLink_nn__ResultSuccess">nn::ResultSuccess</span> が返されます。</p>
<p>
  <span class="ApiLink_nn__nfp__ResultNeedRetry">nn::nfp::ResultNeedRetry</span> が返された場合は、再度 <span class="ApiLink_nn__nfp__Mount">nn::nfp::Mount</span>() を呼び出すことでマウントに成功する可能性があります。</p>
<p>タグのデータが壊れている場合は <span class="ApiLink_nn__nfp__ResultNeedRestore">nn::nfp::ResultNeedRestore</span> もしくは <span class="ApiLink_nn__nfp__ResultNeedFormat">nn::nfp::ResultNeedFormat</span> が返されます。ただし、タグが壊れていてもマウント実行時マウント領域に MountTarget_Rom を指定していた場合は ResultSuccess が返されます。<span class="ApiLink_nn__nfp__ResultNeedRestore">nn::nfp::ResultNeedRestore</span> が返されたときは、タグのデータを復旧することができます（参照：<a href="#Anchor_114739604_whenRepairable">壊れたタグのデータが修復可能な場合</a>）。<span class="ApiLink_nn__nfp__ResultNeedFormat">nn::nfp::ResultNeedFormat</span> が返されたときは、そのタグを使ったことのあるほかのゲーム機本体であれば復旧することができます。そのようなゲーム機本体がない場合は復旧できません。HOMEメニューから起動したamiibo設定で初期化を行ってください。</p>
<p>マウント対象のタグが見つからなかった場合、<span class="ApiLink_nn__nfp__ResultNeedRestart">nn::nfp::ResultNeedRestart</span> が返されます。タグのマウントを継続する場合は <span class="ApiLink_nn__nfp__StartDetection">nn::nfp::StartDetection</span>() を再度呼び出す必要があります。</p>
<p>タグ喪失の通知を受信した場合も同様に <span class="ApiLink_nn__nfp__StartDetection">nn::nfp::StartDetection</span>() を再度呼び出す必要があります。タグ喪失の通知を受信した状態でマウントを実行した場合、 <span class="ApiLink_nn__nfp__Mount">nn::nfp::Mount</span>() の返り値は <span class="ApiLink_nn__nfp__ResultNfcDeviceNotFound">nn::nfp::ResultNfcDeviceNotFound</span> となります。</p>
<div class="info_new">
  <div class="info_new_left">参考：</div>
  <div class="info_new_right">
    <p>タグのマウントには 1 秒程度を必要とします。</p>
  </div>
</div>
<p>次のフロー図はタグマウントの例です。</p>
<!--figure004-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure004"></a>図 8. タグのマウント</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/125178230.png" width="500" class="embedded-image" />
  </span>
</p>
<p>処理でエラーが発生してもリトライが可能な場合の再試行数はフロー図で示した回数でなくてもかまいません。</p>
<p>
  <a name="Anchor_114739604_whenRepairable"></a>
</p>
<h2 id="Anchor_114739604_h2_4">壊れたタグのデータが修復可能な場合</h2>
<p>
  <span class="ApiLink_nn__nfp__Mount">nn::nfp::Mount</span>() が <span class="ApiLink_nn__nfp__ResultNeedRestore">nn::nfp::ResultNeedRestore</span> を返した場合は、アプリケーションで NFP タグの修復を行うことができます。次いずれかの方法で修復を行います。</p>
<ul>
  <li>アプリケーション内で <span class="ApiLink_nn__nfp__Restore">nn::nfp::Restore</span>() を呼び出す</li>
  <li>「amiibo 設定」<span class="ApiLink_nn__nfp__StartRestorer">nn::nfp::StartRestorer</span>() を呼び出す</li>
</ul>
<p>
  <span class="ApiLink_nn__nfp__Restore">nn::nfp::Restore</span>() の呼び出しは、タグが検知済みでマウントも喪失もされていない状態で行ってください。</p>
<p>返り値に <span class="ApiLink_nn__nfp__ResultNeedRetry">nn::nfp::ResultNeedRetry</span> が返された場合は再度 <span class="ApiLink_nn__nfp__Restore">nn::nfp::Restore</span>() を呼び出すことでタグの修復に成功する可能性があります。</p>
<div class="info_new">
  <div class="info_new_left">参考：</div>
  <div class="info_new_right">
    <p>タグの修復には１～２秒程度かかります。</p>
  </div>
</div>
<p>修復されるデータは、タグのマウント時およびタグへの書き込みを行う直前に NFP ライブラリがバックアップしたデータです。そのため、NFP タグへの書き込みに失敗したあとに修復した場合は、書き込み前のデータではなく、書き込もうとしたデータで修復されることになります。</p>
<p>次のフロー図はタグ復旧の例です。フロー図では違うタグがタッチされた場合に備えて、タグの検知の開始から再開しています。</p>
<!--figure005-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure005"></a>図 9.  タグの復旧</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/125178233.png" width="500" class="embedded-image" />
  </span>
</p>
<p>処理でエラーが発生してもリトライが可能な場合の再試行数はフロー図で示した回数でなくてもかまいません。</p>
<h1 id="Anchor_114739604_h1_7">NFP タグ領域へのアクセス</h1>
<p>タグのマウントが成功すると、NFP タグ領域にアクセスできるようになります。NFP タグ領域には以下のものがあります。</p>
<!--table003-->
<div class="table">
  <a name="AutoAnchor_114739604_table003"></a>表 6. NFP タグ領域</div>
<table class="wrapped">
  <tbody>
    <tr>
      <th>NFP タグ領域</th>
      <th>概要</th>
    </tr>
    <tr>
      <td>共用領域</td>
      <td>オーナー登録情報やキャラクターID など、NFP タグが持つ情報が保存される領域。アプリケーションからは書き換え不可、参照のみ。</td>
    </tr>
    <tr>
      <td>アプリ専用領域</td>
      <td>アプリケーション向けに用意されている読み書き可能な領域。最大 216 Byte のデータを格納することが可能。</td>
    </tr>
  </tbody>
</table>
<p>共用領域、アプリ専用領域について詳しくは「NFP ガイド」を参照してください。</p>
<h2 id="Anchor_114739604_h2_5">キャラクターID の取得</h2>
<p>マウントされた NFP タグの情報をアプリケーションで使用する前に、キャラクターID を取得します。アプリケーションは取得したキャラクターID が自身のアプリケーションで利用できるか確認してください。アプリケーションが利用できるキャラクターID については「NFP ガイド」を参照してください。</p>
<p>キャラクターID の取得には <span class="ApiLink_nn__nfp__GetModelInfo">nn::nfp::GetModelInfo</span>() を呼び出します。タグのマウント時、マウント領域に MountTarget_Rom または MountTarget_All を指定しておく必要があります。<span class="ApiLink_nn__nfp__GetModelInfo">nn::nfp::GetModelInfo</span>() で取得する共用領域の情報は <span class="ApiLink_nn__nfp__ModelInfo">nn::nfp::ModelInfo</span> 構造体で定義されています。<span class="ApiLink_nn__nfp__GetModelInfo">nn::nfp::GetModelInfo</span>() は引数で渡された <span class="ApiLink_nn__nfp__ModelInfo">nn::nfp::ModelInfo</span> 構造体に値を設定します。</p>
<p>次のフロー図はキャラクターID取得の例です。</p>
<!--figure006-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure006"></a>図 10. キャラクターID の取得</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/158500237.png" width="500" class="embedded-image" />
  </span>
</p>
<p>
  <a name="Anchor_114739604_a_GetRegisterInfo"></a>
</p>
<h2 id="Anchor_114739604_h2_6">オーナー、ニックネームの取得</h2>
<p>NFP タグに記録されているオーナーやニックネームの取得は <span class="ApiLink_nn__nfp__GetRegisterInfo">nn::nfp::GetRegisterInfo</span>() を呼び出します。タグのマウント時、マウント領域に MountTarget_Ram または MountTarget_All を指定しておく必要があります。</p>
<p>オーナーやニックネームは <span class="ApiLink_nn__nfp__RegisterInfo">nn::nfp::RegisterInfo</span> 構造体で定義されています。<span class="ApiLink_nn__nfp__GetRegisterInfo">nn::nfp::GetRegisterInfo</span>() は引数で渡された <span class="ApiLink_nn__nfp__RegisterInfo">nn::nfp::RegisterInfo</span> 構造体に値を設定します。<span class="ApiLink_nn__nfp__RegisterInfo">nn::nfp::RegisterInfo</span> 構造体にはニックネームを表示する際のフォントのリージョン情報が含まれます。</p>
<p>返り値に <span class="ApiLink_nn__nfp__ResultNeedRegister">nn::nfp::ResultNeedRegister</span> が返された場合、マウントされた NFP タグは「amiibo設定」によるオーナー登録が行われていません。NFP タグのオーナー、ニックネームを必須とするアプリケーションは「amiibo設定」を起動してください。</p>
<div class="info_new">
  <div class="info_new_left">参考：</div>
  <div class="info_new_right">
    <p>ニックネームを表示するアプリケーションは、amiibo のニックネームとオーナーの Mii のニックネームの扱いに注意してください。特に、ニックネームがオーナーの Mii の名前であるかのような表示にならないようにしてください。また、「（オーナーの名前）の amiibo」や「（amiibo のキャラクター名）」、「amiibo」、「アミーボ」のように、ニックネームが設定されていない場合でも代替となる文字列が表示されるようにしてください。</p>
  </div>
</div>
<p>オーナー登録がされていれば、Mii のデータは必ず設定されていますが、ニックネームは設定されていない（空文字列である）場合があります。ニックネームの登録を必須とするアプリケーションは <span class="ApiLink_nn__nfp__ResultNeedRegister">nn::nfp::ResultNeedRegister</span> と同じ手順で「amiibo設定」を起動してください。</p>
<p>ニックネームは UTF-8 で格納されています。終端文字は NULL（0x00）です。ニックネームはフォントリージョンの異なるアプリケーションが対応していない文字が含まれている場合があります。その場合でも、フォントリージョンで指定された内蔵フォントで表示するか、アプリケーションで使用しているフォントにない文字を代替文字で表示するなどの対応を行い、画面表示が崩れたりアプリケーションの進行に支障が出たりしないようにしてください。</p>
<div class="info_new">
  <div class="info_new_left">参考：</div>
  <div class="info_new_right">
    <p>代替文字としては&quot;□&quot;（U+25A1）を推奨します。NX の本体機能が採用している代替文字が&quot;□&quot;（U+25A1）であり、挙動が統一できるためです。</p>
    <p>アプリケーションで使用しているフォントにない文字の代替として空白や非表示にすることは推奨しません。文字が抜けることでニックネームがNGワードに見える場合があるからです。</p>
  </div>
</div>
<p>次のフロー図はオーナー、ニックネームの取得時の例です。</p>
<!--figure007-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure007"></a>図 11. オーナー、ニックネームの取得</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/158500238.png" width="500" class="embedded-image" />
  </span>
</p>
<p>
  <a name="Anchor_114739604_a_OpenApplicationArea"></a>
</p>
<h2 id="Anchor_114739604_h2_7">アプリ専用領域へのアクセス</h2>
<p>アプリ専用領域はその amiibo に対応したアプリケーションがデータを自由に読み書きできる領域です。</p>
<p>アプリ専用領域はアクセスID によってアクセス権限の制御が行われており、アプリ専用領域へのアクセスを開始するには、最初にアプリケーションにアクセス権限があるかを確認する必要があります。NFP タグのアプリ専用領域の状態を確認するには、<span class="ApiLink_nn__nfp__OpenApplicationArea">nn::nfp::OpenApplicationArea</span>() を呼び出します。</p>
<p>アクセスID が一致しない場合、<span class="ApiLink_nn__nfp__OpenApplicationArea">nn::nfp::OpenApplicationArea</span>() は <span class="ApiLink_nn__nfp__ResultAccessIdMisMatch">nn::nfp::ResultAccessIdMisMatch</span> を返します。この場合、読み込みおよび書き込みの両方が制限されます。このアプリケーション用にアプリ専用領域を利用したい場合は「amiibo設定」で保存されているアプリ専用領域のデータを削除する必要があります。</p>
<p>アプリ専用領域がない場合、<span class="ApiLink_nn__nfp__OpenApplicationArea">nn::nfp::OpenApplicationArea</span>() は <span class="ApiLink_nn__nfp__ResultNeedCreate">nn::nfp::ResultNeedCreate</span> を返します。その場合はアプリケーションでアプリ専用領域を作成してください。</p>
<p>アプリ専用領域に書き込むデータを CAFE でも読み込む場合は、CAFE と NX ではエンディアンが違うため、どちらかに統一することを推奨します。</p>
<p>次のフロー図はアプリ専用領域アクセス開始時の例です。</p>
<!--figure008-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure008"></a>図 12. アプリ専用領域へのアクセス</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/158501175.png" width="500" class="embedded-image" />
  </span>
</p>
<p>
  <br />
</p>
<h3 id="Anchor_114739604_h3_1">アプリ専用領域の読み込み</h3>
<p>アプリ専用領域に書き込まれているデータを読み込むには <span class="ApiLink_nn__nfp__GetApplicationArea">nn::nfp::GetApplicationArea</span>() を呼び出します。</p>
<p>アプリ専用領域の先頭から指定されたバイト数の内容をバッファに読み込むことができます。アプリ専用領域から読み込み可能なデータの最大サイズは <span class="ApiLink_nn__nfp__GetCommonInfo">nn::nfp::GetCommonInfo</span>() で取得した <span class="ApiLink_nn__nfp__CommonInfo">nn::nfp::CommonInfo</span> 構造体の applicationAreaSize メンバから取得することができます。</p>
<p>次のフロー図はアプリ専用領域読み込み時の例です。</p>
<!--figure010-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure010"></a>図 13. アプリ専用領域の読み込み</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/159287704.png" width="450" class="embedded-image" />
  </span>
</p>
<p>
  <br />
</p>
<h3 id="Anchor_114739604_h3_2">アプリ専用領域の作成</h3>
<p>アプリ専用領域の作成は <span class="ApiLink_nn__nfp__CreateApplicationArea">nn::nfp::CreateApplicationArea</span>() を呼び出します。</p>
<div class="info_new">
  <div class="info_new_left">参考：</div>
  <div class="info_new_right">
    <p>アプリ専用領域の作成には１～２秒程度かかります。関数内で <span class="ApiLink_nn__nfp__Flush">nn::nfp::Flush</span>() と同じ動作を行っているため、<span class="ApiLink_nn__nfp__CreateApplication">nn::nfp::CreateApplication</span>() に続けて <span class="ApiLink_nn__nfp__Flush">nn::nfp::Flush</span>() を呼び出す必要はありません。</p>
  </div>
</div>
<p>次のフロー図はアプリ専用領域作成の例です。</p>
<!--figure009-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure009"></a>図 14. アプリ専用領域の作成</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/158503143.png" width="500" class="embedded-image" />
  </span>
</p>
<p>処理でエラーが発生してもリトライが可能な場合の再試行数はフロー図で示した回数でなくてもかまいません。</p>
<p>
  <br />
</p>
<h3 id="Anchor_114739604_h3_3">アプリ専用領域への書き込み</h3>
<p>アプリ専用領域への書き込みは <span class="ApiLink_nn__nfp__SetApplicationArea">nn::nfp::SetApplicationArea</span>() と <span class="ApiLink_nn__nfp__Flush">nn::nfp::Flush</span>() を呼び出します。</p>
<p>
  <span class="ApiLink_nn__nfp__SetApplicationArea">nn::nfp::SetApplicationArea</span>() の実行が完了した時点では、まだ NFP タグのアプリ専用領域への書き込みは行われず、NFP ライブラリ内でキャッシュされている状態になっています。NFP タグのアプリ専用領域への書き込みは <span class="ApiLink_nn__nfp__Flush">nn::nfp::Flush</span>() で行われます。</p>
<div class="info_new">
  <div class="info_new_left">参考：</div>
  <div class="info_new_right">
    <p>NFP タグのアプリ専用領域への書き込みには１～２秒程度かかります。</p>
  </div>
</div>
<p>次のフロー図はアプリ専用領域への書き込み例です。</p>
<!--figure011-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure011"></a>図 15. アプリ専用領域への書き込み</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/159287705.png" width="500" class="embedded-image" />
  </span>
</p>
<p>処理でエラーが発生してもリトライが可能な場合の再試行数はフロー図で示した回数でなくてもかまいません。</p>
<p>
  <a name="Anchor_114739604_a_RecreateApplicationArea"></a>
</p>
<h3 id="Anchor_114739604_h3_4">アクセス ID の異なる amiibo のゲームデータを引き継いで書き換える場合</h3>
<p>アクセス ID の異なる amiibo のゲームデータを引き継いで書き換える場合は、<span class="ApiLink_nn__nfp__RecreateApplicationArea">nn::nfp::RecreateApplicationArea</span>() で amiibo のアクセス ID およびデータ形式の書き換えを行います。書き換えを行うには、amiibo にゲームデータを書き込んだアプリのアクセス ID の情報が必要です。</p>
<p>例えば、次のような流れでこのAPIを使用します。（ここでの説明では、実行中アプリのアクセス ID を『A』、実行中のアプリが知っているほかのアプリのアクセス ID を『B』とします。）</p>
<ol>
  <li>まず、タッチされた amiibo の記録しているゲームデータが実行中のアプリのものかどうかを確認します。<span class="ApiLink_nn__nfp__OpenApplicationArea">nn::nfp::OpenApplicationArea</span>（） をアクセス ID『A』を使って実行します。<ol><li>成功した場合は通常通りデータの読み込み、書き込み処理を行います。</li><li><span class="ApiLink_nn__nfp__ResultAccessIdMisMatch">nn::nfp::ResultAccessIdMisMatch</span> を返した場合、2. へ進みます。</li></ol></li>
  <li>今度はアクセス ID『B』で <span class="ApiLink_nn__nfp__OpenApplicationArea">nn::nfp::OpenApplicationArea</span>() を実行します。<ol><li>アクセス ID『B』で成功した場合は、<span class="ApiLink_nn__nfp__RecreateApplicationArea">nn::nfp::RecreateApplicationArea</span>() を使用することができます。amiibo に記録されたゲームデータを書き換えるかどうかユーザーに確認し、ゲームデータの引き継ぎを行います。</li><li>アクセス ID『B』でも <span class="ApiLink_nn__nfp__ResultAccessIdMisMatch">nn::nfp::ResultAccessIdMisMatch</span> を返した場合、実行中のアプリでは amiibo のゲームデータにアクセスすることはできません。amiibo に記録されたゲームデータを引き継ぎできないことをユーザーに通知します。</li></ol></li>
</ol>
<div class="note_new">
  <div class="note_new_left">注意：</div>
  <div class="note_new_right">
    <p>
      <span class="ApiLink_nn__nfp__RecreateApplicationArea">nn::nfp::RecreateApplicationArea</span>() はアクセス ID を書き換えますので、実行後の amiibo は元のアプリではアクセスできなくなります。引き継ぎを行うと元のアプリではアクセスできなくなることをユーザーに通知するようにしてください。</p>
  </div>
</div>
<p>次のフロー図は、ユーザーの確認が終わったあと、データの引き継ぎを行う場合を想定した例です。</p>
<!--figure021-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure021"></a>図 16. アプリ専用領域データをほかのアプリに引き継ぐ</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/235860931.png" width="500" class="embedded-image" />
  </span>
</p>
<p>処理でエラーが発生してもリトライが可能な場合の再試行数はフロー図で示した回数でなくてもかまいません。</p>
<h1 id="Anchor_114739604_h1_8">タグ喪失通知の待ち受け</h1>
<p>タグへのアクセスが終了したあとや異なるタグでタッチされたあとに、タグの検知を引き続き行う場合は、NFP ライブラリにマウントされているタグの情報を一旦解除し、再度検知可能な状態に戻します。</p>
<p>マウント状態を解除するときは <span class="ApiLink_nn__nfp__Unmount">nn::nfp::Unmount</span>() を呼び出します。</p>
<p>ユーザーにはタグを離すように通知します。タグが NFP デバイスから離されるとタグ喪失がアプリケーションに通知されます。</p>
<p>タグ検知の終了は <span class="ApiLink_nn__nfp__StopDetection">nn::nfp::StopDetection</span>() を呼び出します。</p>
<p>次のフロー図はタグ喪失待ち受け時の例です。</p>
<!--figure012-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure012"></a>図 17. タグ喪失通知の待ち受け</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/159287706.png" width="350" class="embedded-image" />
  </span>
</p>
<h1 id="Anchor_114739604_h1_9">終了</h1>
<p>NFP ライブラリの終了処理は <span class="ApiLink_nn__nfp__Finalize">nn::nfp::Finalize</span>() を呼び出します。関数内でタグのマウント解除やタグ検知の終了が行われ、タグを検知していた場合はタグ喪失の通知も行われます。NFP ライブラリ終了のタイミングでは、下記イベントの破棄も忘れず実行してください。</p>
<ul>
  <li>NFC デバイスの利用可/不可の変化通知</li>
  <li>タグ発見通知</li>
  <li>タグ喪失通知</li>
</ul>
<!--figure013-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure013"></a>図 18. NFP ライブラリの終了</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/161421069.png" class="embedded-image" />
  </span>
</p>
<h1 id="Anchor_114739604_h1_10">共通エラーハンドリング</h1>
<p>次の図は NFP ライブラリの関数を呼び出した際に、共通して返されるエラーをハンドリングするシーケンスの例です。このシーケンス例でハンドリングしているエラーは、基本的にタグの検知開始からやり直す必要のあるエラーです。また、通信が完了するまで同じタグでタッチし続け、別のタグに入れ替わったときにはエラーが発生することを前提にしています。</p>
<p>エラーの原因をユーザーの手で取り除く方法がある場合は、ユーザーにその方法を通知してください。たとえば NFC 機能無効状態のためにエラーとなった場合は NFC 機能を有効にすることで問題が回避できることを通知します。</p>
<!--figure014-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure014"></a>図 19. 共通エラーハンドリング</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/161420892.png" width="500" class="embedded-image" />
  </span>
</p>
<p>
  <br />
</p>
<h1 id="Anchor_114739604_h1_11">エラービューアによるメッセージの表示</h1>
<h2 id="Anchor_114739604_h2_8">アプリケーションによるエラービューア表示</h2>
<p>NFP ライブラリから返されるエラーに対し、エラービューアを使用してメッセージを表示させることができます。</p>
<p>ほとんどのエラーはエラービューアでメッセージを表示することができます。エラーごとに表示されるエラービューアのメッセージについてはオンラインドキュメントのエラーコードリストを参照してください。</p>
<p>例外として、次のエラーはエラービューアが対応していません。アプリケーション側でエラーへの対応を行ってください。</p>
<!--table005-->
<div class="table">
  <a name="AutoAnchor_114739604_table005"></a>表 7. エラービューアでメッセージが用意されていないエラー</div>
<table class="wrapped relative-table" style="width: 96.6599%;">
  <colgroup>
    <col style="width: 24.9458%;" />
    <col style="width: 19.8498%;" />
    <col style="width: 20.4106%;" />
    <col style="width: 34.7938%;" />
  </colgroup>
  <tbody>
    <tr>
      <th>返り値</th>
      <th>エラー内容</th>
      <th>メッセージ例</th>
      <th>関連する項</th>
    </tr>
    <tr>
      <td>
        <p>
          <span class="ApiLink_nn__nfp__ResultNeedRegister">nn::nfp::ResultNeedRegister</span>
        </p>
        <p>
          <br />
        </p>
        <p>［出力する関数］</p>
        <p>
          <span class="ApiLink_nn__nfp__GetRegisterInfo">nn::nfp::GetRegisterInfo</span>()</p>
      </td>
      <td>
        <p>登録情報が設定されていません。amiibo 設定での設定が必要です。</p>
        <p>
          <br />
        </p>
      </td>
      <td>amiiboにオーナーとニックネームを登録してください｡</td>
      <td>
        <p>NFP タグ領域へのアクセス<a href="#Anchor_114739604_a_GetRegisterInfo">「オーナー、ニックネームの取得」 </a></p>
        <p>amiibo 設定<a href="#Anchor_114739604_a_OwnerSetings">「オーナー登録、ニックネーム登録」 </a></p>
      </td>
    </tr>
    <tr>
      <td>
        <p>
          <span class="ApiLink_nn__nfp__ResultNeedRestore">nn::nfp::ResultNeedRestore</span>
        </p>
        <p>
          <br />
        </p>
        <p>［出力する関数］</p>
        <p>
          <span class="ApiLink_nn__nfp__Mount">nn::nfp::Mount</span>()</p>
      </td>
      <td>
        <p>タグのデータが壊れています。</p>
        <p>Restore() によるタグの復旧を行う必要があります。</p>
        <p>
          <br />
        </p>
      </td>
      <td>
        <p>amiiboのデータが壊れています。</p>
        <p>この本体に保存されているデータで復旧しますか？</p>
      </td>
      <td>
        <p>
          <a href="#Anchor_114739604_a_Mount">タグのマウント</a>
          <a href="#Anchor_114739604_whenRepairable">「壊れたタグのデータが修復可能な場合」</a>
          <br />amiibo 設定<a href="#Anchor_114739604_a_StartRestorer">「データの復旧」</a></p>
      </td>
    </tr>
    <tr>
      <td>
        <p>
          <span class="ApiLink_nn__nfp__ResultAccessIdMisMatch">nn::nfp::ResultAccessIdMisMatch</span>
        </p>
        <p>
          <br />
        </p>
        <p>［出力する関数］</p>
        <p>
          <span class="ApiLink_nn__nfp__OpenApplicationArea">nn::nfp::OpenApplicationArea</span>()</p>
      </td>
      <td>
        <p>アクセス ID が一致しないため、アプリケーション専用領域へのアクセスができません。</p>
        <p>
          <br />
        </p>
      </td>
      <td>
        <p>別のゲームのデータが記録されているため、このゲームのデータを書き込むことができません。amiibo に記録されている別のゲームのデータを消去して書き込めるようにしますか？</p>
      </td>
      <td>NFP タグ領域へのアクセス<a href="#Anchor_114739604_a_OpenApplicationArea">「アプリ専用領域へのアクセス」</a><br /><a href="#Anchor_114739604_a_RecreateApplicationArea">「アクセス ID の異なる amiibo のゲームデータを引き継いで書き換える場合」</a></td>
    </tr>
  </tbody>
</table>
<p>アプリケーションの判断でエラー処理するときなどユーザーへの通知を特に必要としない場合はメッセージ表示させなくても構いません。</p>
<h2 id="Anchor_114739604_h2_9">NFP ライブラリによるエラービューア表示</h2>
<p>システム上致命的なエラーが発生したり、コントローラが壊れたりした場合には NFP ライブラリがエラービューアを表示することがあります。</p>
<div class="note_new">
  <div class="note_new_left">注意：</div>
  <div class="note_new_right">
    <p>NFP ライブラリがエラービューアを表示した場合は、処理がアプリケーションに返ってくるのに時間を要することがありますのでご注意ください。タイミングによってはアプリケーションが NFC の使用をキャンセルした後にエラービューアが表示されることがあります。</p>
  </div>
</div>
<h1 id="Anchor_114739604_h1_12">amiibo 設定</h1>
<p>オーナー登録やゲームデータの削除など、NFP タグに対する特殊な操作は「amiibo 設定」から行います。アプリケーションからは次の機能の「amiibo 設定」を呼び出すことができます。</p>
<ul>
  <li>オーナー登録、ニックネーム登録</li>
  <li>データの復旧</li>
  <li>ゲームデータ消去</li>
</ul>
<p>「amiibo 設定」起動中は設定が完了するまで、処理がアプリケーションには返りません。</p>
<p>
  <a name="Anchor_114739604_a_OwnerSetings"></a>
</p>
<h2 id="Anchor_114739604_h2_10">オーナー登録、ニックネーム登録</h2>
<p>「amiibo 設定」のオーナー登録、ニックネーム登録は <span class="ApiLink_nn__nfp__StartNicknameAndOwnerSettings">nn::nfp::StartNicknameAndOwnerSettings</span>() を呼び出します。<span class="ApiLink_nn__nfp__StartNicknameAndOwnerSettings">nn::nfp::StartNicknameAndOwnerSettings</span>() は引数にRegisterInfo を指定するものと指定しないものの2種類があります。</p>
<!--code101-->
<div class="code">
  <a name="AutoAnchor_114739604_code101"></a>コード 2. オーナー登録、ニックネーム登録</div>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="nn">nn::</span><span class="n">Result</span> <span class="nn">nn::nfp::</span><span class="n">StartNicknameAndOwnerSettings</span>     <span class="p">(</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">DeviceHandle</span> <span class="o">*</span>                        <span class="n">pOutDeviceHandle</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kt">bool</span> <span class="o">*</span>                                <span class="n">pOutIsRegistered</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">RegisterInfo</span> <span class="o">*</span>                        <span class="n">pOutRegisterInfo</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">const</span> <span class="n">AmiiboSettingsStartParam</span> <span class="o">&amp;</span>      <span class="n">startParam</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">const</span> <span class="n">TagInfo</span> <span class="o">&amp;</span>                       <span class="n">tagInfo</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">const</span> <span class="n">RegisterInfo</span> <span class="o">&amp;</span>                  <span class="n">registerInfo</span> 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">)</span>

<span class="nn">nn::</span><span class="n">Result</span> <span class="nn">nn::nfp::</span><span class="n">StartNicknameAndOwnerSettings</span>     <span class="p">(</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">DeviceHandle</span> <span class="o">*</span>                        <span class="n">pOutDeviceHandle</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kt">bool</span> <span class="o">*</span>                                <span class="n">pOutIsRegistered</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">RegisterInfo</span> <span class="o">*</span>                        <span class="n">pOutRegisterInfo</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">const</span> <span class="n">AmiiboSettingsStartParam</span> <span class="o">&amp;</span>      <span class="n">startParam</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">const</span> <span class="n">TagInfo</span> <span class="o">&amp;</span>                       <span class="n">tagInfo</span> 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">)</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>次のフロー図は amiibo 設定でオーナー登録、ニックネーム登録を行う例です。</p>
<!--figure101-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure101"></a>図 20. amiibo 設定 オーナー登録、ニックネーム登録</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/163758476.png" width="500" class="embedded-image" />
  </span>
</p>
<p>
  <a name="Anchor_114739604_a_StartRestorer"></a>
</p>
<h2 id="Anchor_114739604_h2_11">データの復旧</h2>
<p>「amiibo 設定」のデータの復旧は <span class="ApiLink_nn__nfp__StartRestorer">nn::nfp::StartRestorer</span>() を呼び出します。</p>
<p>次のフロー図は amiibo 設定でデータ復旧を行う例です。</p>
<!--figure102-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure102"></a>図 21. amiibo 設定 データの復旧</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/163758477.png" class="embedded-image" />
  </span>
</p>
<h2 id="Anchor_114739604_h2_12">ゲームデータ消去</h2>
<p>「amiibo 設定」のゲームデータ消去は <span class="ApiLink_nn__nfp__StartGameDataEraser">nn::nfp::StartGameDataEraser</span>() を呼び出します。</p>
<p>次のフロー図は amiibo 設定でゲームデータ消去を行う例です。</p>
<!--figure103-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure103"></a>図 22. amiibo 設定 ゲームデータ消去</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/163758478.png" class="embedded-image" />
  </span>
</p>
<h1 id="Anchor_114739604_h1_13">複数の NFC デバイス同時利用</h1>
<p>複数の NFC デバイスを同時利用する場合、NFC デバイスごとにスレッドで操作することができます。</p>
<!--figure201-->
<div class="figure">
  <a name="AutoAnchor_114739604_figure201"></a>図 23. 複数の NFC デバイスの管理をスレッドごとに行う例</div>
<p>
  <span class="embedded-file-wrapper ">
    <img src="../Attachments/Attach_114739604/199795117.png" width="500" class="embedded-image" />
  </span>
</p>
<p>図の例では、最初に NFP ライブラリの初期化と NFC デバイスハンドルの取得を行います。取得した NFCデバイスのハンドルごとにスレッドで管理し、マルチスレッドで API を呼び出すことができます。</p>
<p>複数の NFC デバイスを同時利用する場合は次の点に注意してください。</p>
<ul>
  <li>
    <span class="ApiLink_nn__nfp__Finalize">nn::nfp::Finalize</span>() はすべてのタグ操作を終えた後に行ってください。</li>
  <li>amiibo 設定（<span class="ApiLink_nn__nfp__StartNicknameAndOwnerSettings">nn::nfp::StartNicknameAndOwnerSettings</span>()、<span class="ApiLink_nn__nfp__StartRestorer">nn::nfp::StartRestorer</span>()、<span class="ApiLink_nn__nfp__StartGameDataEraser">nn::nfp::StartGameDataEraser</span>()）は複数スレッドで同時に呼び出しても、一つずつしか行われません。実行中の amiibo 設定が終了するまで、そのほかのスレッドの amiibo 設定はブロックされます。</li>
  <li>NFC デバイスの最大接続台数は4台までです。コントローラーが5台以上接続されている状態では NFC 機能は1台までしか使用することができません。<br /><p><br /></p></li>
</ul>
<p>
  <br />
</p>
<p>
  <br />
</p>
</div>
<div class="breadcrumb_bottom"></div>
<div class="page_navigation">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
<tr><td colspan="2" class="page_navi_bottom"></td></tr>
</table>
</div>
</div>
</div>
<!--AddLink-->
<script>
var NintendoSdkApiRefernce = {
    idMap: {},
    linkRewrite: function ()
    {
        var idMap = NintendoSdkApiRefernce.idMap;
        function rewrite(el)
        {
            var e = idMap[el.className];
            if (e === undefined)
            {
                return;
            }
            var html = '';
            html += '<a href=';
            html += e.url;
            html += ' target="_blank">';
            html += el.innerHTML;
            html += '</a>';
            el.innerHTML = html;
        }
        var apiLinkElems = document.querySelectorAll('span[class*="ApiLink_"]');
        for (var i = 0, n = apiLinkElems.length; i< n; ++i) {
            rewrite(apiLinkElems[i]);
        }
    }
};
function SetUrl( id, url )
{
    NintendoSdkApiRefernce.idMap[id] = { url: url };
}
SetUrl( 'ApiLink_nn__nfp__Initialize', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#afa344c4dc54ca2a562b3ddfee0742f99' )
SetUrl( 'ApiLink_nn__nfp__AttachAvailabilityChangeEvent', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a0e70bf61d3d0f6c7c3c9dd63a6e7db04' )
SetUrl( 'ApiLink_nn__os__SystemEventType', '../../../Api/HtmlNX/structnn_1_1os_1_1_system_event_type.html' )
SetUrl( 'ApiLink_nn__nfp__GetDeviceState', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#aeb240b6269510ef739fb4a820ee3601a' )
SetUrl( 'ApiLink_nn__nfp__StopDetection', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#aa8bd12f4e1b4b206463047e3142a261a' )
SetUrl( 'ApiLink_nn__nfp__Finalize', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a217aa0ade4696c4f68c5574e6e2ed3e0' )
SetUrl( 'ApiLink_nn__nfp__ListDevices', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a8e7488fa2c37e3b7b3c8624699c8ce7e' )
SetUrl( 'ApiLink_nn__nfp__GetNpadId', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#ab15d52a3089002edbf40e1ecebf2b490' )
SetUrl( 'ApiLink_nn__nfp__AttachActivateEvent', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a2a08ccb321632168ac7c0d9003336f11' )
SetUrl( 'ApiLink_nn__nfp__AttachDeactivateEvent', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a898bfa0687f44dc0f4220f989563c6a8' )
SetUrl( 'ApiLink_nn__os__DestroySystemEvent', '../../../Api/HtmlNX/namespacenn_1_1os.html#a3d924bc362ec80648323428be5182338' )
SetUrl( 'ApiLink_nn__nfp__StartDetection', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#afd22b7158c9c5ef8ab0a59db89e7d351' )
SetUrl( 'ApiLink_nn__nfp__GetTagInfo', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a45e88ea137a0212dad4a44de072c5abc' )
SetUrl( 'ApiLink_nn__nfp__TagInfo', '../../../Api/HtmlNX/structnn_1_1nfp_1_1_tag_info.html' )
SetUrl( 'ApiLink_nn__nfp__Mount', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#abdc7133c665e6a2414af658d4aed6b9a' )
SetUrl( 'ApiLink_nn__nfp__MountTarget', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a9f52385485f17ebfad924d6e72ab4356' )
SetUrl( 'ApiLink_nn__nfp__ResultNotSupported', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_not_supported.html' )
SetUrl( 'ApiLink_nn__nfp__ResultInvalidFormatVersion', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_invalid_format_version.html' )
SetUrl( 'ApiLink_nn__ResultSuccess', '../../../Api/HtmlNX/classnn_1_1_result_success.html' )
SetUrl( 'ApiLink_nn__nfp__ResultNeedRetry', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_need_retry.html' )
SetUrl( 'ApiLink_nn__nfp__ResultNeedRestore', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_need_restore.html' )
SetUrl( 'ApiLink_nn__nfp__ResultNeedFormat', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_need_format.html' )
SetUrl( 'ApiLink_nn__nfp__ResultNeedRestart', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_need_restart.html' )
SetUrl( 'ApiLink_nn__nfp__ResultNfcDeviceNotFound', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_nfc_device_not_found.html' )
SetUrl( 'ApiLink_nn__nfp__Restore', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a7292375a9a80f936d505ddb20cb74d5e' )
SetUrl( 'ApiLink_nn__nfp__StartRestorer', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a909114bcc708d55de460c9b35a314695' )
SetUrl( 'ApiLink_nn__nfp__GetModelInfo', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a6795ef429b2d1effe1039a6f02c403b3' )
SetUrl( 'ApiLink_nn__nfp__ModelInfo', '../../../Api/HtmlNX/structnn_1_1nfp_1_1_model_info.html' )
SetUrl( 'ApiLink_nn__nfp__GetRegisterInfo', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#aa2b8e18324f250c48eba82378f4002e5' )
SetUrl( 'ApiLink_nn__nfp__RegisterInfo', '../../../Api/HtmlNX/structnn_1_1nfp_1_1_register_info.html' )
SetUrl( 'ApiLink_nn__nfp__ResultNeedRegister', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_need_register.html' )
SetUrl( 'ApiLink_nn__nfp__OpenApplicationArea', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#ae031efebb24d01f253819e7051ee5b8b' )
SetUrl( 'ApiLink_nn__nfp__ResultAccessIdMisMatch', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_access_id_mis_match.html' )
SetUrl( 'ApiLink_nn__nfp__ResultNeedCreate', '../../../Api/HtmlNX/classnn_1_1nfp_1_1_result_need_create.html' )
SetUrl( 'ApiLink_nn__nfp__GetApplicationArea', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a4627e180bdb0dc997d904ac57f8cab04' )
SetUrl( 'ApiLink_nn__nfp__GetCommonInfo', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#aed274413977d6c21166fa434315a6ff9' )
SetUrl( 'ApiLink_nn__nfp__CommonInfo', '../../../Api/HtmlNX/structnn_1_1nfp_1_1_common_info.html' )
SetUrl( 'ApiLink_nn__nfp__CreateApplicationArea', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#adf02884c6bcd5dc0b8cc7d55309f2903' )
SetUrl( 'ApiLink_nn__nfp__Flush', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#ade408175b18f37cc322c863e0d3c2129' )
// ApiLink_nn__nfp__CreateApplication
SetUrl( 'ApiLink_nn__nfp__SetApplicationArea', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a33928ed61aa99decae7127c1d6a65e2a' )
SetUrl( 'ApiLink_nn__nfp__RecreateApplicationArea', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a6cd074db4990e0ec7d2caf4f939ec808' )
SetUrl( 'ApiLink_nn__nfp__Unmount', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a8d45eed0a3f22de6c244e629609287ba' )
SetUrl( 'ApiLink_nn__nfp__StartNicknameAndOwnerSettings', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#ab79eee0c523079873ea6a3ee737cdefd' )
SetUrl( 'ApiLink_nn__nfp__StartGameDataEraser', '../../../Api/HtmlNX/namespacenn_1_1nfp.html#a37ae933f9548417263e1002d032a34c6' )

NintendoSdkApiRefernce.linkRewrite();
</script>
<!--AddLink-->
</body>
</html>
