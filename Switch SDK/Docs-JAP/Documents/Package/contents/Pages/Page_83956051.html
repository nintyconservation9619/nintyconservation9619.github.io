<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<script type="text/javascript" src="../template/js/jquery/jquery.js"></script>
<script type="text/javascript" src="../template/js/common/manualLib.js"></script>
<script type="text/javascript" src="../tocData.js"></script>
<link rel="stylesheet" type="text/css" href="../template/css/template.css" />
<title>クイックスタート</title>
</head>
<body data-reassemble="autoindex=no,forceNoLabel=yes">
<div id="autoindex_content">
<div class="body_content">
<noscript>
<div style="border: 4px double black; margin: 4px; padding: 2px; font-weight: bold; background-color: #FFFFCC;">
<p>お使いのブラウザは JavaScript が使用できないため、本ドキュメントの一部機能が無効になっています。</p><p>JavaScript が無効の環境では目次を使用することができません。<br />JavaScriptの実行が許可された状態で閲覧してください。<br /><br /></p>
</div>
</noscript>
<div class="page_navigation_top">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
</table>
</div>
<div class="breadcrumb"></div>

<!-- クイックスタート -->
<div class="pagetitle" id="PageId_83956051">クイックスタート</div>
<div class="text_separate">
<h1 id="Anchor_83956051_h1_1">目次</h1>
<p>
  <ul class="macro_toc">
    <li>
      <a href="#Anchor_83956051_h2_1">開発環境の構築</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_2">サンプルプログラムのビルドと実行</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_3">サンプルプログラムのソースコード</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_4">初期化処理</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_5">サウンドデータのロード</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_6">フレーム処理</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_7">サウンドの再生と停止</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_8">サウンドハンドル</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_9">ホールド再生</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_10">サウンドのプリペア ( 再生準備 )</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_11">文字列を使った再生</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_12">サウンドの種類</a>
    </li>
    <li>
      <a href="#Anchor_83956051_h2_13">レンダリング結果の取得</a>
    </li>
  </ul>
</p>
<h1 id="Anchor_83956051_h1_2">クイックスタート</h1>
<p>ここでは、まず開発環境の構築方法を説明し、その後サンプルプログラムを参考にしながら単純なオーディオプログラムの組み方を説明します。</p>
<p>サンプルのビルドや実行を行った後、サンプルのソースコードを見ながら、サウンドプログラムの組み方の説明を行います。</p>
<h2 id="Anchor_83956051_h2_1">開発環境の構築</h2>
<p>ここでは、オーディオプログラム開発環境の構築方法を説明します。</p>
<h3 id="Anchor_83956051_h3_1">NintendoWare Audio ToolKit ライブラリ</h3>
<p>オーディオプログラムを組むためには、Atk ライブラリを利用します。<br />Atk ライブラリは、NintendoWare&nbsp;パッケージに含まれる&nbsp;<span class="ApiLink_nn__atk">nn::atk</span> 名前空間の&nbsp;API&nbsp;が該当します。</p>
<h3 id="Anchor_83956051_h3_2">ディレクトリ構成</h3>
<p>Atk ライブラリに関連があるディレクトリ構成は、以下の通りです。<br />なお、NintendoWare&nbsp;のインストールディレクトリ&nbsp;NintendoSDK&nbsp;ディレクトリを、%NINTENDO_SDK_ROOT%&nbsp;と表記しています。</p>
<p>図&nbsp;1&nbsp;ディレクトリ構成</p>
<table class="table">
  <tbody>
    <tr>
      <td>
        <div class="container" title="Hint: double-click to select code">
          <div class="line number1 index0 alt2">
            <code class="plain plain">%NINTENDO_SDK_ROOT%</code>
          </div>
          <div class="line number2 index1 alt1">
            <code class="plain plain">　　|</code>
          </div>
          <div class="line number3 index2 alt2">
            <code class="plain plain">　　+-- Libraries\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ライブラリファイル</code>
          </div>
          <div class="line number4 index3 alt1">
            <code class="plain plain">　　+-- Sources\Libraries\atk\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Atk ライブラリのソースコード</code>
          </div>
          <div class="line number5 index4 alt2">
            <code class="plain plain">　　+-- Samples\Sources\Applications\AtkSimple\ など // Atk のサンプルプログラム</code>
          </div>
          <div class="line number6 index5 alt1">
            <code class="plain plain">　　+-- Documents\Package\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 開発環境のドキュメント</code>
          </div>
          <div class="line number7 index6 alt2">
            <code class="plain plain">　　+-- Tools\Audio\SoundMaker\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // SoundMaker ツール</code>
          </div>
        </div>
      </td>
    </tr>
  </tbody>
</table>
<h3 id="Anchor_83956051_h3_3">Atk ライブラリを使った開発環境</h3>
<p>Atk ライブラリを使った開発を行うためには、大きく分けて 4 つの事前準備が必要です。</p>
<ul>
  <li>ライブラリファイルのリンク設定</li>
  <li>インクルードパスの設定</li>
  <li>サウンドデータの配置</li>
  <li>サウンド&nbsp;ID&nbsp;ファイルの参照</li>
</ul>
<h4 id="Anchor_83956051_h4_1">ライブラリファイルのリンク設定</h4>
<p>Atk ライブラリを利用するには、Atk ライブラリおよび、Atk ライブラリに依存するライブラリファイルをリンクする必要があります。</p>
<p>%NINTENDO_SDK_ROOT%\Libraries\ 以下に含まれる&nbsp;libnn_atk.lib, libnn_audio.lib をリンクするようにしてください。<br />(圧縮オーディオを使用する場合は libnn_codec.lib もリンクしてください)&nbsp;</p>
<h4 id="Anchor_83956051_h4_2">インクルードパスの設定</h4>
<p>%NINTENDO_SDK_ROOT%\Include&nbsp;をインクルードパスに追加してください。</p>
<h4 id="Anchor_83956051_h4_3">サウンドデータの配置</h4>
<p>サウンドデザイナーが作成したサウンドデータは、サウンドアーカイブ&nbsp;(*.bfsar)&nbsp;と複数のストリームデータ&nbsp;(*.bfstm)&nbsp;が格納されたフォルダとしてプログラマーに渡されます。サウンドアーカイブは、ストリームデータ以外の複数のサウンドデータが&nbsp;1&nbsp;つにまとめられたファイルです。</p>
<p>プログラマーは、これらのサウンドデータをストレージ上に配置して使用します。各アプリケーションで設定したコンテンツディレクトリに、各ファイルを配置してください。</p>
<h4 id="Anchor_83956051_h4_4">サウンド&nbsp;ID&nbsp;ファイルのインクルード</h4>
<p>サウンド&nbsp;ID&nbsp;ファイル&nbsp;(*.fsid)&nbsp;は、サウンドアーカイブを使用するためのラベルが定義されたファイルで、サウンドアーカイブ作成時に、同時に出力されます。プログラマーは、このファイルをヘッダファイルと同じようにインクルードして、ソースファイル中で参照します。</p>
<p>AtkSimple&nbsp;デモでは&nbsp;%NINTENDO_SDK_ROOT%\Samples\Sources\Applications\AtkSimple\Common.fsid&nbsp;が該当します。</p>
<h2 id="Anchor_83956051_h2_2">サンプルプログラムのビルドと実行</h2>
<p>サンプルプログラムのビルド・実行方法については <a href="../Pages/Page_95692646.html">Atkスタートガイド</a> のサンプルプログラムのビルドの項目を参照ください。</p>
<h2 id="Anchor_83956051_h2_3">サンプルプログラムのソースコード</h2>
<p>この章では、ソースコードの内容を見ながらサウンドプログラムを説明します。</p>
<p>以下の説明で使用するソースコードは、<a href="../../../Api/HtmlNX/_page_sample_atk_simple.html">こちら</a>&nbsp;の AtkSimple.cpp からの引用になります。<br />このサンプルプログラムの引用を使って、基本的なサウンドプログラムについて説明を行います。</p>
<p>&nbsp;</p>
<div>
  <h3 id="Anchor_83956051_h3_4">参照ヘッダファイル</h3>
</div>
<p>AtkSimple.cpp&nbsp;では、下記のヘッダファイルを参照しています。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="cp">#include &quot;Common.fsid&quot;
#include &lt;nn/atk.h&gt;
</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>nn/atk.h&nbsp;は Atk ライブラリのヘッダファイルです。Atk ライブラリを使うためには、必ずこのファイルを参照する必要があります。</p>
<p>また、Common.fsid&nbsp;は、サウンド&nbsp;ID&nbsp;ファイルです。このファイルで定義されているラベルを使うことで、サウンドアーカイブ中の特定のサウンドデータを使用することができます。</p>
<h3 id="Anchor_83956051_h3_5">名前空間</h3>
<p>Atk ライブラリは、名前空間 <span class="ApiLink_nn__atk">nn::atk</span> で定義されています。</p>
<p>&nbsp;</p>
<!--Remove-->
<p>&nbsp;</p>
<h2 id="Anchor_83956051_h2_4">初期化処理</h2>
<p>基本的な初期化処理の流れは、次のようになります。</p>
<ol>
  <li>サウンドシステムの初期化</li>
  <li>サウンドアーカイブの初期化</li>
  <li>サウンドデータマネージャーの初期化</li>
  <li>サウンドアーカイブプレイヤーの初期化</li>
  <li>サウンドヒープの構築</li>
</ol>
<p>&nbsp;</p>
<div>
  <h3 id="Anchor_83956051_h3_7">サウンドシステムの初期化</h3>
</div>
<p>サウンドシステムの初期化のため、次のように&nbsp;<span class="ApiLink_nn__atk__SoundSystem">nn::atk::SoundSystem</span>&nbsp;クラスの&nbsp;API&nbsp;を呼び出します。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="c1">// SoundSystem の初期化
</span><span class="nn">nn::atk::SoundSystem::</span><span class="n">SoundSystemParam</span> <span class="n">param</span><span class="p">;</span>
<span class="nn">std::</span><span class="kt">size_t</span> <span class="n">memSizeForSoundSystem</span> <span class="o">=</span> <span class="nn">nn::atk::SoundSystem::</span><span class="n">GetRequiredMemSize</span><span class="p">(</span> <span class="n">param</span> <span class="p">);</span>
<span class="n">g_pMemoryForSoundSystem</span> <span class="o">=</span> <span class="nn">nns::atk::</span><span class="n">Allocate</span><span class="p">(</span> <span class="n">memSizeForSoundSystem</span><span class="p">,</span> <span class="nn">nn::atk::SoundSystem::</span><span class="n">WorkMemoryAlignSize</span> <span class="p">);</span>
<span class="n">isSuccess</span> <span class="o">=</span> <span class="nn">nn::atk::SoundSystem::</span><span class="n">Initialize</span><span class="p">(</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">param</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">g_pMemoryForSoundSystem</span> <span class="p">),</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">memSizeForSoundSystem</span> <span class="p">);</span>
<span class="n">NN_ABORT_UNLESS</span><span class="p">(</span> <span class="n">isSuccess</span><span class="p">,</span> <span class="s">&quot;cannot initialize SoundSystem&quot;</span> <span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>
  <span class="ApiLink_nn__atk__SoundSystem__Initialize">nn::atk::SoundSystem::Initialize</span>&nbsp;関数で、サウンドシステムの初期化を行います。<br />サウンドシステムを初期化すると、Atk ライブラリ内部で動作するサウンドスレッドとタスクスレッドが起動します。</p>
<p>引数には、サウンドスレッドとタスクスレッドのプライオリティ、またそれぞれのスレッドのスタックサイズなどを格納する&nbsp;<span class="ApiLink_nn__atk__SoundSystem__SoundSystemParam">nn::atk::SoundSystem::SoundSystemParam</span>&nbsp;構造体を渡します。<br />サウンドスレッドは、サウンドの再生処理を行います。再生を遅延無く行うために、サウンドスレッドの優先度を高くしておく必要があります。</p>
<p>タスクスレッドは、ストリームデータの読み込みやプレイヤーヒープへのデータロードを行います。ストリームデータの読み込みに遅延が発生すると、音が途切れますので、タスクスレッドの優先度も高くしておく必要があります。</p>
<div class="info_new">
  <div class="info_new_left">参考：</div>
  <div class="info_new_right">
    <p>音が途切れるのを防ぐために、タスクスレッドはサウンドスレッドよりも優先度を高くすることを推奨します。</p>
  </div>
</div>
<h3 id="Anchor_83956051_h3_8">サウンドアーカイブの初期化</h3>
<p>次にサウンドアーカイブの初期化を行います。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="nn">nn::atk::</span><span class="n">FsSoundArchive</span>    <span class="n">g_SoundArchive</span><span class="p">;</span>

<span class="c1">// SoundArchive の初期化
</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">archiveAbsolutePath</span> <span class="o">=</span> <span class="nn">nns::atk::</span><span class="n">GetAbsolutePath</span><span class="p">(</span><span class="n">ArchiveRelativePath</span><span class="p">);</span>
<span class="n">isSuccess</span> <span class="o">=</span> <span class="n">g_SoundArchive</span><span class="p">.</span><span class="n">Open</span><span class="p">(</span><span class="n">archiveAbsolutePath</span><span class="p">);</span>
<span class="n">NN_ABORT_UNLESS</span><span class="p">(</span> <span class="n">isSuccess</span><span class="p">,</span> <span class="s">&quot;cannot open SoundArchive(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">archiveAbsolutePath</span> <span class="p">);</span>

<span class="c1">// SoundArchive のパラメータ情報をメモリにロード
</span><span class="nn">std::</span><span class="kt">size_t</span> <span class="n">infoBlockSize</span> <span class="o">=</span> <span class="n">g_SoundArchive</span><span class="p">.</span><span class="n">GetHeaderSize</span><span class="p">();</span>
<span class="n">g_pMemoryForInfoBlock</span> <span class="o">=</span> <span class="nn">nns::atk::</span><span class="n">Allocate</span><span class="p">(</span>  <span class="n">infoBlockSize</span><span class="p">,</span> <span class="nn">nn::atk::FsSoundArchive::</span><span class="n">BufferAlignSize</span> <span class="p">);</span>
<span class="n">isSuccess</span> <span class="o">=</span> <span class="n">g_SoundArchive</span><span class="p">.</span><span class="n">LoadHeader</span><span class="p">(</span> <span class="n">g_pMemoryForInfoBlock</span><span class="p">,</span> <span class="n">infoBlockSize</span> <span class="p">);</span>
<span class="n">NN_ABORT_UNLESS</span><span class="p">(</span> <span class="n">isSuccess</span><span class="p">,</span> <span class="s">&quot;cannot load InfoBlock&quot;</span> <span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>あらかじめ、<span class="ApiLink_nn__atk__FsSoundArchive">nn::atk::FsSoundArchive</span>&nbsp;クラスのインスタンス&nbsp;s_SoundArchive&nbsp;&nbsp;を確保しておきます。</p>
<p>
  <span class="ApiLink_nn__atk__FsSoundArchive__Open">nn::atk::FsSoundArchive::Open</span>&nbsp;関数で、サウンドアーカイブを開きます。引数には FS&nbsp;ファイルシステムに配置されたパスを指定します。</p>
<p>次に、必要最低限の情報を読み込むために、<span class="ApiLink_nn__atk__FsSoundArchive__LoadHeader">nn::atk::FsSoundArchive::LoadHeader</span>&nbsp;関数を呼び出します。<br />関数の引数には、読み込みに必要なメモリー領域を渡します。読み込みに必要なメモリー領域のサイズは、<span class="ApiLink_nn__atk__FsSoundArchive__GetHeaderSize">nn::atk::FsSoundArchive::GetHeaderSize</span>&nbsp;関数で取得することができます。</p>
<h3 id="Anchor_83956051_h3_9">サウンドデータマネージャーの初期化</h3>
<p>次は、サウンドデータマネージャーの初期化です。サウンドデータマネージャーは、サウンドアーカイブ内のデータをロード・管理するためのクラスです。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="nn">nn::atk::</span><span class="n">SoundDataManager</span>   <span class="n">g_SoundDataManager</span><span class="p">;</span>

<span class="c1">// SoundDataManager の初期化
</span><span class="nn">std::</span><span class="kt">size_t</span> <span class="n">memSizeForSoundDataManager</span> <span class="o">=</span> <span class="n">g_SoundDataManager</span><span class="p">.</span><span class="n">GetRequiredMemSize</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">g_SoundArchive</span> <span class="p">);</span>
<span class="n">g_pMemoryForSoundDataManager</span> <span class="o">=</span> <span class="nn">nns::atk::</span><span class="n">Allocate</span><span class="p">(</span> <span class="n">memSizeForSoundDataManager</span><span class="p">,</span> <span class="nn">nn::atk::SoundDataManager::</span><span class="n">BufferAlignSize</span> <span class="p">);</span>
<span class="n">isSuccess</span> <span class="o">=</span> <span class="n">g_SoundDataManager</span><span class="p">.</span><span class="n">Initialize</span><span class="p">(</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="o">&amp;</span><span class="n">g_SoundArchive</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">g_pMemoryForSoundDataManager</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">memSizeForSoundDataManager</span> <span class="p">);</span>
<span class="n">NN_ABORT_UNLESS</span><span class="p">(</span> <span class="n">isSuccess</span><span class="p">,</span> <span class="s">&quot;cannot initialize SoundDataManager&quot;</span> <span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>あらかじめ、nn:atk::SoundDataManager&nbsp;クラスのインスタンス&nbsp;s_SoundDataManager&nbsp;を確保しておきます。</p>
<p>
  <span class="ApiLink_nn__atk__SoundDataManager__Initialize">nn::atk::SoundDataManager::Initialize</span>&nbsp;関数で、サウンドデータマネージャーを初期化することができます。</p>
<p>関数の引数には、サウンドアーカイブへのポインタ&nbsp;&amp;s_SoundArchive&nbsp;と、サウンドデータマネージャーの初期化に必要なメモリー領域を渡します。<br />初期化に必要なメモリー領域は、<span class="ApiLink_nn__atk__SoundDataManager__GetRequiredMemSize">nn::atk::SoundDataManager::GetRequiredMemSize</span>&nbsp;関数で取得することができます。</p>
<h3 id="Anchor_83956051_h3_10">サウンドアーカイブプレイヤーの初期化</h3>
<p>次は、サウンドアーカイブプレイヤーの初期化です。サウンドアーカイブプレイヤーは、サウンドアーカイブを使ってサウンドを再生するためのクラスです。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="nn">nn::atk::</span><span class="n">SoundArchivePlayer</span> <span class="n">g_SoundArchivePlayer</span><span class="p">;</span>

<span class="c1">// SoundArchivePlayer の初期化
</span><span class="nn">std::</span><span class="kt">size_t</span> <span class="n">memSizeForSoundArchivePlayer</span> <span class="o">=</span> <span class="n">g_SoundArchivePlayer</span><span class="p">.</span><span class="n">GetRequiredMemSize</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">g_SoundArchive</span> <span class="p">);</span>
<span class="n">g_pMemoryForSoundArchivePlayer</span> <span class="o">=</span> <span class="nn">nns::atk::</span><span class="n">Allocate</span><span class="p">(</span> <span class="n">memSizeForSoundArchivePlayer</span><span class="p">,</span> <span class="nn">nn::atk::SoundArchivePlayer::</span><span class="n">BufferAlignSize</span><span class="p">);</span>
<span class="nn">std::</span><span class="kt">size_t</span> <span class="n">memSizeForStreamBuffer</span> <span class="o">=</span> <span class="n">g_SoundArchivePlayer</span><span class="p">.</span><span class="n">GetRequiredStreamBufferSize</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">g_SoundArchive</span> <span class="p">);</span>
<span class="n">g_pMemoryForStreamBuffer</span> <span class="o">=</span> <span class="nn">nns::atk::</span><span class="n">Allocate</span><span class="p">(</span> <span class="n">memSizeForStreamBuffer</span><span class="p">,</span> <span class="nn">nn::audio::</span><span class="n">BufferAlignSize</span> <span class="p">);</span>
<span class="n">isSuccess</span> <span class="o">=</span> <span class="n">g_SoundArchivePlayer</span><span class="p">.</span><span class="n">Initialize</span><span class="p">(</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="o">&amp;</span><span class="n">g_SoundArchive</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="o">&amp;</span><span class="n">g_SoundDataManager</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">g_pMemoryForSoundArchivePlayer</span><span class="p">,</span> <span class="n">memSizeForSoundArchivePlayer</span><span class="p">,</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">g_pMemoryForStreamBuffer</span><span class="p">,</span> <span class="n">memSizeForStreamBuffer</span> <span class="p">);</span>
<span class="n">NN_ABORT_UNLESS</span><span class="p">(</span> <span class="n">isSuccess</span><span class="p">,</span> <span class="s">&quot;cannot initialize SoundArchivePlayer&quot;</span> <span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>あらかじめ、<span class="ApiLink_nn__atk__SoundArchivePlayer">nn::atk::SoundArchivePlayer</span>&nbsp;クラスのインスタンス g_SoundArchivePlayer&nbsp;を確保しておきます。</p>
<p>
  <span class="ApiLink_nn__atk__SoundArchivePlayer__Initialize">nn::atk::SoundArchivePlayer::Initialize</span>&nbsp;関数で、サウンドアーカイブプレイヤーの初期化を行います。<br />引数には、使用するサウンドアーカイブのポインタ&nbsp;&amp;g_SoundArchive&nbsp;とサウンドデータマネージャーのポインタ&nbsp;&amp;g_SoundDataManager、さらに初期化に必要なメモリー領域を&nbsp;2&nbsp;つ渡します。<br />1&nbsp;つは、サウンドアーカイブプレイヤー内で確保される各サウンドのインスタンスやワーク領域として使用し、もう&nbsp;1&nbsp;つはストリームサウンド再生用のバッファに使用します。<br />ストリームバッファは <span class="ApiLink_nn__audio__BufferAlignSize">nn::audio::BufferAlignSize</span> でアラインされている必要があるためご注意ください。&nbsp;</p>
<p>これらのメモリー領域のサイズは、<span class="ApiLink_nn__atk__SoundArchivePlayer__GetRequiredMemSize">nn::atk::SoundArchivePlayer::GetRequiredMemSize</span>&nbsp;関数及び、<span class="ApiLink_nn__atk__SoundArchivePlayer__GetRequiredStreamBufferSize">nn::atk::SoundArchivePlayer::GetRequiredStreamBufferSize</span>&nbsp;関数で取得することができます。</p>
<h3 id="Anchor_83956051_h3_11">サウンドヒープの構築</h3>
<p>最後にサウンドヒープの構築を行います。サウンドヒープは、サウンドデータをロードするためのメモリー領域を管理するクラスです。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="nn">nn::atk::</span><span class="n">SoundHeap</span>          <span class="n">g_SoundHeap</span><span class="p">;</span>

<span class="c1">// SoundHeap の初期化
</span><span class="n">g_pMemoryForSoundHeap</span> <span class="o">=</span> <span class="nn">nns::atk::</span><span class="n">Allocate</span><span class="p">(</span> <span class="n">SoundHeapSize</span> <span class="p">);</span>
<span class="n">isSuccess</span> <span class="o">=</span> <span class="n">g_SoundHeap</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span> <span class="n">g_pMemoryForSoundHeap</span><span class="p">,</span> <span class="n">SoundHeapSize</span> <span class="p">);</span>
<span class="n">NN_ABORT_UNLESS</span><span class="p">(</span> <span class="n">isSuccess</span><span class="p">,</span> <span class="s">&quot;cannot create SoundHeap&quot;</span> <span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>あらかじめ、<span class="ApiLink_nn__atk__SoundHeap">nn::atk::SoundHeap</span>&nbsp;クラスのインスタンス g_SoundHeap&nbsp;を確保しておきます。</p>
<p>
  <span class="ApiLink_nn__atk__SoundHeap__Create">nn::atk::SoundHeap::Create</span>&nbsp;関数でサウンドヒープの構築を行います。引数には、サウンドヒープに割り当てるメモリー領域を渡します。</p>
<h2 id="Anchor_83956051_h2_5">サウンドデータのロード</h2>
<p>ウェーブサウンドやシーケンスサウンドを再生するには、再生に必要なサウンドデータをあらかじめロードしておく必要があります。<br />サウンドデータは「グループ」というサウンドデータの固まり単位でロードするほか、「シーケンスデータ」や「ウェーブサウンドデータ」、「バンクデータ」、「波形アーカイブデータ」単位でもロードが可能です。</p>
<p>グループにどのデータを含めるかは&nbsp;SoundMaker&nbsp;上で設定することができます。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="kt">bool</span> <span class="n">isSuccess</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="n">isSuccess</span> <span class="o">=</span> <span class="n">g_SoundDataManager</span><span class="p">.</span><span class="n">LoadData</span><span class="p">(</span> <span class="n">SEQ_MARIOKART</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_SoundHeap</span> <span class="p">);</span>
<span class="n">NN_ABORT_UNLESS</span><span class="p">(</span> <span class="n">isSuccess</span><span class="p">,</span> <span class="s">&quot;LoadData(SEQ_MARIOKART) failed.&quot;</span> <span class="p">);</span>

<span class="n">isSuccess</span> <span class="o">=</span> <span class="n">g_SoundDataManager</span><span class="p">.</span><span class="n">LoadData</span><span class="p">(</span> <span class="n">SE_YOSHI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g_SoundHeap</span> <span class="p">);</span>
<span class="n">NN_ABORT_UNLESS</span><span class="p">(</span> <span class="n">isSuccess</span><span class="p">,</span> <span class="s">&quot;LoadData(SE_YOSHI) failed.&quot;</span> <span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>
  <span class="ApiLink_nn__atk__SoundDataManager__LoadData">nn::atk::SoundDataManager::LoadData</span>&nbsp;関数で、サウンドデータをロードすることができます。</p>
<p>引数には、ロードしたいサウンドデータやグループなどのラベルと、ロードしたデータを格納するためのサウンドヒープを渡します。</p>
<p>データラベル&nbsp;SEQ_MARIOKART&nbsp;および&nbsp;SE_YOSHI&nbsp;は、サウンド&nbsp;ID&nbsp;ファイル &quot;Common.fsid&quot;&nbsp;で定義されています。ロードすべきデータやロードすべきタイミングは、サウンドデザイナーに確認しておく必要があります。</p>
<p>AtkSimple サンプルでは、シーケンスサウンド&nbsp;SEQ_MARIOKART&nbsp;に関するすべてのデータ&nbsp;(シーケンスデータ、バンクデータ、波形アーカイブデータ)&nbsp;および、ウェーブサウンド&nbsp;SE_YOSHI&nbsp;に関するすべてのデータ&nbsp;(ウェーブサウンドデータ、波形アーカイブデータ)&nbsp;をロードしています。</p>
<p>&nbsp;</p>
<div class="info_new">
  <div class="info_new_left">参考：</div>
  <div class="info_new_right">
    <p>注意：<br /><span class="ApiLink_nn__atk__SoundDataManager__LoadData">nn::atk::SoundDataManager::LoadData</span>&nbsp;関数は、同期読み込みを行います。非同期版の関数は用意されていません。<br />非同期読み込みを行いたい場合は、別スレッドでこの関数を呼びだしてください。<span class="ApiLink_nn__atk__SoundDataManager__LoadData">nn::atk::SoundDataManager::LoadData</span>&nbsp;関数を別スレッドで呼びだす際の注意点は、リファレンスマニュアルを参照してください。</p>
  </div>
</div>
<h2 id="Anchor_83956051_h2_6">フレーム処理</h2>
<p>毎フレーム、サウンドアーカイブプレイヤーの更新処理が必要です。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="n">g_SoundArchivePlayer</span><span class="p">.</span><span class="n">Update</span><span class="p">();</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>通常、メインループから呼び出します。ビデオフレームごとに呼び出す必要はありません。</p>
<p>音量のフェード処理などは、本関数の呼び出しを&nbsp;1&nbsp;フレームと換算します。</p>
<h2 id="Anchor_83956051_h2_7">サウンドの再生と停止</h2>
<p>&nbsp;</p>
<div>
  <h3 id="Anchor_83956051_h3_12">サウンドの再生</h3>
</div>
<p>サウンドの再生は次のように行います。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">g_SoundArchivePlayer</span><span class="p">.</span><span class="n">StartSound</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">g_SoundHandle</span><span class="p">,</span> <span class="n">soundId</span> <span class="p">).</span><span class="n">IsSuccess</span><span class="p">();</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>
  <span class="ApiLink_nn__atk__SoundArchivePlayer__StartSound">nn::atk::SoundArchivePlayer::StartSound</span>&nbsp;関数で、サウンドの再生を行います。<br />引数には、サウンドハンドルと、再生するサウンドのラベルを渡します。</p>
<p>サウンドハンドルとして、<span class="ApiLink_nn__atk__SoundHandle">nn::atk::SoundHandle</span>&nbsp;クラスのインスタンスのポインタ&nbsp;&amp;g_SoundHandle&nbsp;を渡しています。</p>
<p>サウンドハンドルについては、後で説明します。</p>
<p>再生するサウンドのラベルは、サウンド&nbsp;ID&nbsp;ファイル&nbsp;&quot;Common.fsid&quot;&nbsp;で定義されています。どのラベルがどのようなサウンドなのかは、サウンドデザイナーに確認しておく必要があります。</p>
<h3 id="Anchor_83956051_h3_13">サウンドの停止</h3>
<p>サウンドの停止は、サウンドハンドルを使って行います。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="n">g_SoundHandle</span><span class="p">.</span><span class="n">Stop</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>
  <span class="ApiLink_nn__atk__SoundHandle__Stop">nn::atk::SoundHandle::Stop</span>&nbsp;関数で、サウンドを停止させることができます。<br />引数にはフェードアウトフレーム数を渡します。フェードアウトフレーム数の時間をかけて徐々に音量を落とした後に、サウンドは停止します。 <br />フェードアウトフレーム数は<span class="ApiLink_nn__atk__SoundArchivePlayer__Update">nn::atk::SoundArchivePlayer::Update</span>&nbsp;の呼び出し回数に該当します。</p>
<p>前述のとおり、<span class="ApiLink_nn__atk__SoundHandle__Stop">nn::atk::SoundHandle::Stop</span>&nbsp;関数を呼び出す時点で、すでにサウンドが停止していたとしても問題ありません。その場合は、関数は何もせずに返ります。</p>
<h2 id="Anchor_83956051_h2_8">サウンドハンドル</h2>
<h3 id="Anchor_83956051_h3_14">サウンドハンドルとは？</h3>
<p>サウンドハンドルは、再生したサウンドを止めたり、音量を変えたりするためのオブジェクトです。<br />1&nbsp;つのサウンドハンドルで、1&nbsp;つのサウンドの制御ができます。サウンドの再生に成功すると、サウンドとサウンドハンドルが紐付けられます。</p>
<p>以降この紐付けが切断されるまで、サウンドハンドルを使って再生したサウンドのコントロールが可能になります。</p>
<p>図&nbsp;2&nbsp;サウンドの再生に成功すると、サウンドとサウンドハンドルが紐付けられる</p>
<p>
  <strong>
    <span class="embedded-file-wrapper ">
      <img src="../Attachments/Attach_83956051/83080907.png" class="embedded-image" />
    </span>
  </strong>
</p>
<p>つまり、プログラマーは「再生したサウンド」が本当にまだ再生中なのかを意識しなくて済むことを意味します。<br />再生中の時と、すでに停止していた時とで同じ処理を行っても、誤って別のサウンドの操作を行ってしまうという問題が発生しません。</p>
<h3 id="Anchor_83956051_h3_15">サウンドハンドル生成のヒント</h3>
<p>ワンショットの効果音など、再生だけして停止などは行わない場合には、サウンドハンドルを&nbsp;1&nbsp;つだけ用意して、使い回して次々に再生することができます。<br />また、再生直後だけなら、それぞれ再生したサウンドに対して、ボリュームなどのパラメータを変更することができます。</p>
<p>BGM&nbsp;やエンジン音などの持続系の効果音では、少なくとも停止する必要がありますので、それぞれのサウンドに対して、サウンドハンドルが必要になります。</p>
<h2 id="Anchor_83956051_h2_9">ホールド再生</h2>
<p>
  <span style="background-color: rgb(255,255,255);">サウンドの再生・停止を行うためには通常、StartSound&nbsp;関数と&nbsp;Stop&nbsp;関数を使いますが、プログラムの実装上、停止するタイミングで、Stop&nbsp;関数を呼び出すことが面倒な場合があります。</span>
</p>
<p>
  <span style="background-color: rgb(255,255,255);">このようなときは、StartSound&nbsp;関数の代わりに&nbsp;HoldSound&nbsp;関数を使うことができます。</span>
</p>
<h3 id="Anchor_83956051_h3_16">HoldSound 関数の使い方</h3>
<p>HoldSound&nbsp;関数を使う場合は、鳴らし続けたい間、毎フレームコールします。毎フレーム続けて呼び出すと、はじめの １ 回だけ再生開始処理が行われ、2&nbsp;回目以降は何も処理しません。</p>
<p>このような再生方式を&nbsp;NintendoWare サウンドライブラリでは「ホールド再生」と呼びます。</p>
<p>HoldSound&nbsp;関数を呼び出し続けている間はサウンドは再生し続けますが、呼び出しをやめると、<span class="ApiLink_nn__atk__SoundArchivePlayer__Update">nn::atk::SoundArchivePlayer::Update</span>&nbsp;関数内で、自動的に停止します。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">g_SoundArchivePlayer</span><span class="p">.</span><span class="n">HoldSound</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">g_SoundHandleHold</span><span class="p">,</span> <span class="n">soundId</span> <span class="p">).</span><span class="n">IsSuccess</span><span class="p">();</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>HoldSound&nbsp;関数は、上記のように&nbsp;StartSound&nbsp;関数の代わりに呼び出すだけです。</p>
<h3 id="Anchor_83956051_h3_17">プレイヤープライオリティ負け後の再生再開</h3>
<p>StartSound&nbsp;関数と&nbsp;Stop&nbsp;関数を使用した再生の場合、プレイヤープライオリティ負けでサウンドの再生が強制的に停止させられると、明示的に&nbsp;StartSound&nbsp;を呼び出さない限り、再び鳴り始めることはありません。</p>
<p>HoldSound&nbsp;を使った場合は、毎フレーム呼び出すため、プレイヤープライオリティ負けで停止しても、次のフレームで再度再生を試みることになります。そのため、他の優先度の高いサウンドの再生が終了した時点で、自動的に再生が再開されます。</p>
<p>ただし、再生の再開は、サウンドデータの途中ではなく先頭から行われますので、サウンドデータによっては不自然な再生になる場合がありますので注意してください。</p>
<h3 id="Anchor_83956051_h3_18">HoldSound&nbsp;関数でのプレイヤープライオリティ処理</h3>
<p>HoldSound&nbsp;関数を使った場合、サウンド再生のプレイヤープライオリティ処理が、通常と異なります。仮にプレイヤープライオリティ設定値が&nbsp;64&nbsp;だったとすると、鳴らし始めの時はプライオリティが、64&nbsp;より １ 小さい&nbsp;63&nbsp;として処理されます。もし再生に成功した場合は、プレイヤープライオリティは設定値通り&nbsp;64&nbsp;になります。</p>
<p>このため、通常は、同じプレイヤープライオリティでは後着優先ですが、HoldSound&nbsp;関数を使った場合は先着優先となります。</p>
<h2 id="Anchor_83956051_h2_10">
  <a name="Anchor_83956051_SND_PREPARE"></a>サウンドのプリペア ( 再生準備 )</h2>
<p>サウンドデータの種類によっては、StartSound&nbsp;関数を呼び出してもすぐに再生が開始されない場合があります。具体的には、ストリームサウンドを再生する場合、ある程度のデータを先読みしておく必要があるため、先読みが完了するまで、再生が開始されません。</p>
<p>また、プレイヤーヒープを使ってウェーブサウンドやシーケンスサウンドを再生する場合も、必要なデータがプレイヤーヒープへロードし終わるまで再生が開始されません&nbsp;(プレイヤーヒープについては、「<a href="../Pages/Page_83956038.html#Anchor_83956038_PLAYER_HEAP">メモリー管理 - プレイヤーヒープ</a>」をご参照ください)。</p>
<p>通常、このことが大きな問題になることはありませんが、絵と音を同期させたい時など、再生開始するタイミングが不定だと困る場合があります。このようなときは、StartSound&nbsp;関数の代わりに&nbsp;PrepareSound&nbsp;関数を使うことができます。</p>
<h3 id="Anchor_83956051_h3_19">PrepareSound&nbsp;関数の使い方</h3>
<p>PrepareSound&nbsp;関数は、サウンド再生開始の準備のみ行います。そのため、PrepareSound&nbsp;関数を呼び出しただけではサウンドは再生されません。</p>
<p>サウンドの再生開始準備は非同期で行われます。準備が完了したかどうかを確認するには、<span class="ApiLink_nn__atk__SoundHandle__IsPrepared">nn::atk::SoundHandle::IsPrepared</span>&nbsp;関数を利用することができます。準備完了を確認したら、<span class="ApiLink_nn__atk__SoundHandle__StartPrepared">nn::atk::SoundHandle::StartPrepared</span>&nbsp;関数を呼び出すことで、サウンドを再生させることができます。</p>
<p>準備が完了していれば、StartPrepared&nbsp;関数を呼び出すと、すぐにサウンドの再生が開始されます。準備が完了していない状態で&nbsp;StartPrepared&nbsp;関数を呼び出した場合は、準備の完了を待ってから、自動的にサウンドの再生が行われます。</p>
<h2 id="Anchor_83956051_h2_11">文字列を使った再生</h2>
<p>前述のサンプルコードでは、次のように再生関数に再生するサウンドのサウンド&nbsp;ID&nbsp;を渡していました。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">g_SoundArchivePlayer</span><span class="p">.</span><span class="n">StartSound</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">g_SoundHandle</span><span class="p">,</span> <span class="n">SEQ_MARIOKART</span> <span class="p">).</span><span class="n">IsSuccess</span><span class="p">();</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>サウンド&nbsp;ID&nbsp;は、サウンド&nbsp;ID&nbsp;ファイル&nbsp;(*.fsid)&nbsp;で定義されていますので、あらかじめサウンド&nbsp;ID&nbsp;ファイルをインクルードしておく必要があります。そのため、サウンド&nbsp;ID&nbsp;ファイルが更新されるたびに、再コンパイルが必要になってしまうデメリットがあります。</p>
<p>これとは別に、次のような文字列で再生する方法も用意されています。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">g_SoundArchivePlayer</span><span class="p">.</span><span class="n">StartSound</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">g_SoundHandle</span><span class="p">,</span> <span class="s">&quot;SEQ_MARIOKART&quot;</span> <span class="p">).</span><span class="n">IsSuccess</span><span class="p">();</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>この方法では文字列を使いますので、サウンド&nbsp;ID&nbsp;ファイルをインクルードする必要がありません。ただし、次のような初期化処理を追加する必要があります。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="c1">// SoundArchive のラベル文字列情報をメモリにロード
</span><span class="nn">std::</span><span class="kt">size_t</span> <span class="n">memSizeForLabelString</span> <span class="o">=</span> <span class="n">g_SoundArchive</span><span class="p">.</span><span class="n">GetLabelStringDataSize</span><span class="p">();</span>
<span class="n">g_pMemoryForLabelData</span> <span class="o">=</span> <span class="nn">nns::atk::</span><span class="n">Allocate</span><span class="p">(</span> <span class="n">memSizeForLabelString</span><span class="p">,</span> <span class="nn">nn::atk::FsSoundArchive::</span><span class="n">BufferAlignSize</span> <span class="p">);</span>
<span class="n">g_SoundArchive</span><span class="p">.</span><span class="n">LoadLabelStringData</span><span class="p">(</span> <span class="n">g_pMemoryForLabelData</span><span class="p">,</span> <span class="n">memSizeForLabelString</span> <span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>文字列再生は、サウンド&nbsp;ID&nbsp;再生に比べて次のような特徴がありますので、必要に応じて使い分けてください。</p>
<ul>
  <li>サウンド&nbsp;ID&nbsp;ファイルをインクルードしないので、サウンドデータを更新してもプログラムの再コンパイルは不要。</li>
  <li>ラベル文字列データのロードが必要。</li>
  <li>文字列をサウンド&nbsp;ID&nbsp;に変換するための実行コストがかかる。</li>
  <li>サウンド指定のスペルミスを、コンパイル時に検出できない。</li>
</ul>
<h2 id="Anchor_83956051_h2_12">サウンドの種類</h2>
<p>Atk ライブラリで再生できるサウンドは、次の&nbsp;3&nbsp;種類あります。</p>
<ul>
  <li>ストリームサウンド</li>
  <li>ウェーブサウンド</li>
  <li>シーケンスサウンド</li>
</ul>
<p>これらはすべて、<span class="ApiLink_nn__atk__SoundArchivePlayer__StartSound">nn::atk::SoundArchivePlayer::StartSound</span>&nbsp;関数で再生することができます。そのため、サウンドデザイナーがどの種類のサウンドで作成したのかを、プログラマーは意識しなくて済むようになっています。</p>
<p>また、サウンドハンドルには、一時停止や再生停止、ボリューム変更、音程変更などの基本的な関数が用意されていますので、再生のコントロールも、共通の操作が可能となっています。</p>
<p>もし、テンポ変更のように、シーケンスサウンドのみ可能な操作を行いたい場合は、シーケンスサウンドハンドルというものを使用します。</p>
<p>シーケンスサウンドハンドルはサウンドハンドルと同様の扱いができるもので、なおかつシーケンス特有の操作関数が追加されています。</p>
<p>シーケンスサウンドハンドルを使うためには、再生したサウンドハンドルを引数に渡して、<span class="ApiLink_nn__atk__SequenceSoundHandle">nn::atk::SequenceSoundHandle</span>&nbsp;クラスのコンストラクタを呼びだします。その後で、シーケンス特有の操作関数を呼びだします。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="k">if</span> <span class="p">(</span> <span class="n">g_SoundArchivePlayer</span><span class="p">.</span><span class="n">StartSound</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">g_SoundHandle</span><span class="p">,</span> <span class="n">SEQ_MARIOKART</span> <span class="p">).</span><span class="n">IsSuccess</span><span class="p">()</span> <span class="p">)</span>
<span class="p">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="nn">nn::atk::</span><span class="n">SequenceSoundHandle</span> <span class="n">seqHandle</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">g_SoundHandle</span> <span class="p">);</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="n">seqHandle</span><span class="p">.</span><span class="n">SetTempoRatio</span><span class="p">(</span> <span class="mf">2.0f</span> <span class="p">);</span>
<span class="p">}</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<p>なお、シーケンスサウンド以外のサウンドと紐付けられたハンドルを&nbsp;<span class="ApiLink_nn__atk__SequenceSoundHandle">nn::atk::SequenceSoundHandle</span>&nbsp;クラスのコンストラクタに渡すと、そのシーケンスサウンドハンドルは無効になります。無効なシーケンスサウンドハンドルに対する関数呼び出しは無視されます。</p>
<h2 id="Anchor_83956051_h2_13">レンダリング結果の取得</h2>
<p>サウンドの再生処理を行った後、オーディオレンダラによってレンダリングされた結果は&nbsp;CircularBufferSink の機能を使って取得することができます。</p>
<h3 id="Anchor_83956051_h3_20">CircularBufferSink の有効化</h3>
<p>CircularBufferSink を使用するには、サウンドシステムの初期化時に CircularBufferSink を有効化する必要があります。</p>
<p>CircularBufferSink を有効化するには <span class="ApiLink_nn__atk__SoundSystem__SoundSystemParam">nn::atk::SoundSystem::SoundSystemParam</span> で以下２点の設定が必要です。</p>
<ul>
  <li>CircularBufferSink の有効化フラグ</li>
  <li>レンダリング結果の保持に使用するバッファの大きさ</li>
</ul>
<p>バッファの大きさはオーディオフレーム数で指定し、大きくするとサウンドシステムの初期化に必要なバッファサイズや、<span class="ApiLink_nn__atk__SoundSystem__GetCircularBufferSinkBufferSize">nn::atk::SoundSystem::GetCircularBufferSinkBufferSize</span>() での返り値が大きくなります。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="c1">// CircularBufferSink の有効化
</span><span class="nn">nn::atk::SoundSystem::</span><span class="n">SoundSystemParam</span> <span class="n">param</span><span class="p">;</span>
<span class="n">param</span><span class="p">.</span><span class="n">enableCircularBufferSink</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">param</span><span class="p">.</span><span class="n">recordingAudioFrameCount</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
<span class="p">...</span>
<span class="nn">nn::atk::SoundSystem::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="p">...);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<h3 id="Anchor_83956051_h3_21">CircularBufferSink の読み込み</h3>
<p>CircularBufferSink を有効化すると、毎オーディオフレームのレンダリング結果が CircularBufferSink に保持されていきます。</p>
<p>保持されたサンプルデータは <span class="ApiLink_nn__atk__SoundSystem__ReadCircularBufferSink">nn::atk::SoundSystem::ReadCircularBufferSink</span>() で読み込むことができます。<br />保持されたサンプルデータは適宜読み込む必要があり、サウンドシステム初期化時に指定したオーディオフレーム数を越えて未読のデータが貯まると、古いデータから破棄されていきます。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="c1">// CircularBufferSink の読み込み
</span><span class="kt">size_t</span> <span class="n">bufferSize</span> <span class="o">=</span> <span class="nn">nn::atk::SoundSystem::</span><span class="n">GetCircularBufferSinkBufferSize</span><span class="p">();</span>
<span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">Allocate</span><span class="p">(</span><span class="n">bufferSize</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="n">readSize</span> <span class="o">=</span> <span class="nn">nn::atk::SoundSystem::</span><span class="n">ReadCircularBufferSink</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">bufferSize</span><span class="p">);</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
<h3 id="Anchor_83956051_h3_22">CircularBufferSink から取得したサンプルデータの利用</h3>
<p>読み込んだサンプルデータの詳細については&nbsp;<span class="ApiLink_nn__audio__ReadCircularBufferSink">nn::audio::ReadCircularBufferSink</span>() に記載がありますが、<br />１オーディオフレームあたり (レンダリングするサンプル数) * (チャンネル数) * (2 byte) のサイズのサンプルデータで構成されており、<br /><span class="ApiLink_nn__atk__SoundSystem__ReadCircularBufferSink">nn::atk::SoundSystem::ReadCircularBufferSink</span>() を１回呼び出すと、この整数倍のサイズのサンプルデータを読み込めます。</p>
<p>取得されたサンプルデータはブロックインタリーブされているため、サンプルデータの処理には以下の API をご利用ください。</p>
<ul>
  <li>
    <span class="ApiLink_nn__atk__SoundSystem__GetRendererSampleCount">nn::atk::SoundSystem::GetRendererSampleCount</span>() :&nbsp;レンダラが１オーディオフレームあたりにレンダリングするサンプル数を取得します</li>
  <li>
    <span class="ApiLink_nn__atk__SoundSystem__GetRendererChannelCountMax">nn::atk::SoundSystem::GetRendererChannelCountMax</span>() : レンダラがレンダリングするチャンネル数を取得します</li>
</ul>
<p>以下に取得したサンプルデータをチャンネル毎に処理するコード例を示します。</p>
<table class="codeblock">
  <tbody>
    <tr>
      <td class="code">
        <div class="codeblock"><pre><span class="c1">// CircularBufferSink から取得したサンプルデータの利用
</span><span class="kt">uint32_t</span> <span class="n">rendererSampleCount</span> <span class="o">=</span> <span class="nn">nn::atk::SoundSystem::</span><span class="n">GetRendererSampleCount</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">channelCountMax</span> <span class="o">=</span> <span class="nn">nn::atk::SoundSystem::</span><span class="n">GetRendererChannelCountMax</span><span class="p">();</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">BytesPerSample</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// レンダリング結果は PCM16 のため 1 サンプルあたり 2 byte;
</span>
<span class="kt">int</span> <span class="n">readSizePerAudioFrame</span> <span class="o">=</span> <span class="n">rendererSampleCount</span> <span class="o">*</span> <span class="n">channelCountMax</span> <span class="o">*</span> <span class="n">BytesPerSample</span><span class="p">;</span>
<span class="n">NN_ABORT_UNLESS</span><span class="p">(</span><span class="n">readSize</span> <span class="o">%</span> <span class="n">readSizePerAudioFrame</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">readAudioFrameCount</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">readSize</span><span class="p">)</span> <span class="o">/</span> <span class="n">readSizePerAudioFrame</span><span class="p">;</span> <span class="c1">// 何オーディオフレーム分のサンプルデータを読み込んだか
</span><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">frame</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">frame</span> <span class="o">&lt;</span> <span class="n">readAudioFrameCount</span><span class="p">;</span> <span class="o">++</span><span class="n">frame</span><span class="p">)</span>
<span class="p">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kt">int16_t</span><span class="o">*</span> <span class="n">audioFrameBase</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">int16_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">+</span> <span class="n">frame</span> <span class="o">*</span> <span class="n">rendererSampleCount</span> <span class="o">*</span> <span class="n">channelCountMax</span><span class="p">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">channel</span> <span class="o">&lt;</span> <span class="n">channelCountMax</span><span class="p">;</span> <span class="o">++</span><span class="n">channel</span><span class="p">)</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">{</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kt">int16_t</span><span class="o">*</span> <span class="n">channelBase</span> <span class="o">=</span> <span class="n">audioFrameBase</span> <span class="o">+</span> <span class="n">channel</span> <span class="o">*</span> <span class="n">rendererSampleCount</span><span class="p">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c1">// チャンネル毎に処理を行う
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">...</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="p">}</span>
<span class="p">}</span></pre></div>
      </td>
    </tr>
  </tbody>
</table>
</div>
<div class="breadcrumb_bottom"></div>
<div class="page_navigation">
<table class="page_navi_root">
<tr>
<td class="page_navi_left"></td>
<td class="page_navi_right"></td>
</tr>
<tr><td colspan="2" class="page_navi_bottom"></td></tr>
</table>
</div>
</div>
</div>
<!--AddLink-->
<script>
var NintendoSdkApiRefernce = {
    idMap: {},
    linkRewrite: function ()
    {
        var idMap = NintendoSdkApiRefernce.idMap;
        function rewrite(el)
        {
            var e = idMap[el.className];
            if (e === undefined)
            {
                return;
            }
            var html = '';
            html += '<a href=';
            html += e.url;
            html += ' target="_blank">';
            html += el.innerHTML;
            html += '</a>';
            el.innerHTML = html;
        }
        var apiLinkElems = document.querySelectorAll('span[class*="ApiLink_"]');
        for (var i = 0, n = apiLinkElems.length; i< n; ++i) {
            rewrite(apiLinkElems[i]);
        }
    }
};
function SetUrl( id, url )
{
    NintendoSdkApiRefernce.idMap[id] = { url: url };
}
SetUrl( 'ApiLink_nn__atk', '../../../Api/HtmlNX/namespacenn_1_1atk.html' )
SetUrl( 'ApiLink_nn__atk__SoundSystem', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_system.html' )
SetUrl( 'ApiLink_nn__atk__SoundSystem__Initialize', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_system.html#a90af35a47a6cba54503302105cebd49a' )
SetUrl( 'ApiLink_nn__atk__SoundSystem__SoundSystemParam', '../../../Api/HtmlNX/structnn_1_1atk_1_1_sound_system_1_1_sound_system_param.html' )
SetUrl( 'ApiLink_nn__atk__FsSoundArchive', '../../../Api/HtmlNX/classnn_1_1atk_1_1_fs_sound_archive.html' )
SetUrl( 'ApiLink_nn__atk__FsSoundArchive__Open', '../../../Api/HtmlNX/classnn_1_1atk_1_1_fs_sound_archive.html#abc5844f76700bf574fd380c63994bada' )
SetUrl( 'ApiLink_nn__atk__FsSoundArchive__LoadHeader', '../../../Api/HtmlNX/classnn_1_1atk_1_1_fs_sound_archive.html#ae35a81cb38094a2f2a9ae12d179b9622' )
SetUrl( 'ApiLink_nn__atk__FsSoundArchive__GetHeaderSize', '../../../Api/HtmlNX/classnn_1_1atk_1_1_fs_sound_archive.html#ad09c1b9648843e5e650350faffcf9e2b' )
SetUrl( 'ApiLink_nn__atk__SoundDataManager__Initialize', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_data_manager.html#a671e6256ee7b9f5bbd6871b7672475a5' )
SetUrl( 'ApiLink_nn__atk__SoundDataManager__GetRequiredMemSize', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_data_manager.html#afb9bb6557c8bfa17f1ed8eb31bcbd0e8' )
SetUrl( 'ApiLink_nn__atk__SoundArchivePlayer', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_archive_player.html' )
SetUrl( 'ApiLink_nn__atk__SoundArchivePlayer__Initialize', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_archive_player.html#aa2de65567087f698294d36e91fd9b9f9' )
SetUrl( 'ApiLink_nn__audio__BufferAlignSize', '../../../Api/HtmlNX/namespacenn_1_1audio.html#af5777df6841245416b561fc93f1786b1' )
SetUrl( 'ApiLink_nn__atk__SoundArchivePlayer__GetRequiredMemSize', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_archive_player.html#a69ae9eba7e9ffd8b45b2714bb721f9aa' )
SetUrl( 'ApiLink_nn__atk__SoundArchivePlayer__GetRequiredStreamBufferSize', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_archive_player.html#a778f7f63b34d09e5241e7f18aef3f227' )
SetUrl( 'ApiLink_nn__atk__SoundHeap', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_heap.html' )
SetUrl( 'ApiLink_nn__atk__SoundHeap__Create', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_heap.html#ab63a16b64673cf18a429c41b21be1b2f' )
SetUrl( 'ApiLink_nn__atk__SoundDataManager__LoadData', '../../../Api/HtmlNX/classnn_1_1atk_1_1detail_1_1_sound_archive_loader.html#a3c8676a9807a4940a79a5c39546ab4f0' )
SetUrl( 'ApiLink_nn__atk__SoundArchivePlayer__StartSound', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_startable.html#af7259f5cb7f4c89ebae54d2c102e1a9e' )
SetUrl( 'ApiLink_nn__atk__SoundHandle', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_handle.html' )
SetUrl( 'ApiLink_nn__atk__SoundHandle__Stop', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_handle.html#a2ef2040a3bc7b007bc19a6efc26a88bb' )
SetUrl( 'ApiLink_nn__atk__SoundArchivePlayer__Update', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_archive_player.html#a22e4ef8d9785639f48343fd84aba6d3a' )
SetUrl( 'ApiLink_nn__atk__SoundHandle__IsPrepared', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_handle.html#a18fec84f97d735de838d09391be6d06c' )
SetUrl( 'ApiLink_nn__atk__SoundHandle__StartPrepared', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_handle.html#a89821c8c19d4faa515e5b61dba898b07' )
SetUrl( 'ApiLink_nn__atk__SequenceSoundHandle', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sequence_sound_handle.html' )
SetUrl( 'ApiLink_nn__atk__SoundSystem__GetCircularBufferSinkBufferSize', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_system.html#a3174c4b4141eb0d2be2e7419427a9a09' )
SetUrl( 'ApiLink_nn__atk__SoundSystem__ReadCircularBufferSink', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_system.html#af2699af79bd3461ec029afa019773fda' )
SetUrl( 'ApiLink_nn__audio__ReadCircularBufferSink', '../../../Api/HtmlNX/namespacenn_1_1audio.html#a3b5cb0cd36d72dce3c5cc039e9c48f85' )
SetUrl( 'ApiLink_nn__atk__SoundSystem__GetRendererSampleCount', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_system.html#a1f4a70a2753f463116e7c81dbfa7a0d1' )
SetUrl( 'ApiLink_nn__atk__SoundSystem__GetRendererChannelCountMax', '../../../Api/HtmlNX/classnn_1_1atk_1_1_sound_system.html#aa5374101036ad73f60ffea371a881eb7' )

NintendoSdkApiRefernce.linkRewrite();
</script>
<!--AddLink-->
</body>
</html>
