<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>IPA</title>
<link rel="StyleSheet" href="../style.css" type="text/css" title="general">
</head>
<body class="opcode">

<!-- ############################### -->
<!-- # Opcode                      # -->
<!-- ############################### -->
<h1>
    IPA : Interpolate Attribute<br>
    <!-- SUMMARY_TABLE_INFO { description => "Interpolate Attribute" } -->
</h1>


<!-- The following information is used to generate the text in the opcode table in ../opcodes.htm -->
<!-- SUMMARY_TABLE_INFO { section => "Floating Point Instructions" } -->
<!-- SUMMARY_TABLE_INFO { opcode => "IPA", subsection => 1 } -->

<!-- ############################### -->
<!-- # Format                      # -->
<!-- ############################### -->
<h2>Format:</h2>
<div class="Format">

<pre>
SPA 5.0:
<code>        <code>{@{!}Pg}</code>   <code><b>IPA</b>{.mode}{.msi}{.SAT}</code>           <code>Rd, a[ImmU10]{{, Rb{, Rc}}{,{!}Pmul}}</code>   <code><!-- OPEX_COUNT_4 --><!-- BEGIN &opex("MIO_RD_WR_SCBD") -->{&amp;req_6}</code>   <code>{&amp;rdN}</code>   <code>{&amp;wrN}</code>   <code>{?sched}<!-- END &opex("MIO_RD_WR_SCBD") --></code>   <code>;</code>   </code><!-- SUMMARY_TABLE_INFO { define_opcode => "IPA" } -->

<code>        <code>{@{!}Pg}</code>   <code><b>IPA</b>.IDX{.PASS}{.msi}{.SAT}</code>       <code>Rd, a[Ra]{, RZ, Rc}, {!}Puniform</code>        <code><!-- OPEX_COUNT_4 --><!-- BEGIN &opex("MIO_RD_WR_SCBD") -->{&amp;req_6}</code>   <code>{&amp;rdN}</code>   <code>{&amp;wrN}</code>   <code>{?sched}<!-- END &opex("MIO_RD_WR_SCBD") --></code>   <code>;</code>   </code><!-- SUMMARY_TABLE_INFO { define_opcode => "IPA" } -->
<code>        <code>{@{!}Pg}</code>   <code><b>IPA</b>.IDX{.MUL}{.msi}{.SAT}</code>        <code>Rd, a[Ra], Rb{, Rc}, {!}Puniform</code>        <code><!-- OPEX_COUNT_4 --><!-- BEGIN &opex("MIO_RD_WR_SCBD") -->{&amp;req_6}</code>   <code>{&amp;rdN}</code>   <code>{&amp;wrN}</code>   <code>{?sched}<!-- END &opex("MIO_RD_WR_SCBD") --></code>   <code>;</code>   </code><!-- SUMMARY_TABLE_INFO { define_opcode => "IPA" } -->
<code>        <code>{@{!}Pg}</code>   <code><b>IPA</b>.IDX{.CONSTANT}{.msi}{.SAT}</code>   <code>Rd, a[Ra]{, RZ, Rc}, {!}Puniform</code>        <code><!-- OPEX_COUNT_4 --><!-- BEGIN &opex("MIO_RD_WR_SCBD") -->{&amp;req_6}</code>   <code>{&amp;rdN}</code>   <code>{&amp;wrN}</code>   <code>{?sched}<!-- END &opex("MIO_RD_WR_SCBD") --></code>   <code>;</code>   <code>// Note: Rc useless</code>   </code><!-- SUMMARY_TABLE_INFO { define_opcode => "IPA" } -->
<code>        <code>{@{!}Pg}</code>   <code><b>IPA</b>.IDX{.SC}{.msi}{.SAT}</code>         <code>Rd, a[Ra], Rb{, Rc}, {!}Puniform</code>        <code><!-- OPEX_COUNT_4 --><!-- BEGIN &opex("MIO_RD_WR_SCBD") -->{&amp;req_6}</code>   <code>{&amp;rdN}</code>   <code>{&amp;wrN}</code>   <code>{?sched}<!-- END &opex("MIO_RD_WR_SCBD") --></code>   <code>;</code>   </code><!-- SUMMARY_TABLE_INFO { define_opcode => "IPA" } -->


 .mode:   { <b>.PASS, .MUL*, .CONSTANT, .SC</b> } 

 .msi:    { <b>.CENTER*, .CENTROID, .OFFSET, INVALID</b> } 

 .SAT:    Output saturate to (+0.0,1.0) that maps NaN to +0.0. 
          The saturation step will always interpret the IPA result as an fp32 value, and  apply a 
          denormal flush before saturation.  
          Because the IS_FRONT_FACE attribute returns a boolean result (0x0000_0000 or 0xFFFF_FFFF),
          the .SAT modifier is ignored for this attribute.
</pre>

</div>

<!-- ############################### -->
<!-- # Description                 # -->
<!-- ############################### -->
<h2>Description:</h2>
<div class="Description">

<p>
Evaluate an attribute for this fragment.
</p>
<p>
If .IDX modifier is not specified (immediate IPA),  the #immU10 ( <b>unsigned</b>
10b immediate) is treated as byte addressed logical attribute.<br>
If .IDX modifier is specified (indexed IPA), then Ra is treated a 32 bit
al2pResult_ps_t data structure containing physical attribute byte offset in TRAM. This structure is
usually generated by a previous <b>AL2P</b> instruction.


</p>

<p>
The triangle ram (TRAM) is accessed at the specified address, and the (A,B,C) plane 
equation is retrieved. Interpolation then returns Ax+By+C, where (x,y) is the pixel's
sample location.
</p>

<p>
.mode controls the interpolation mode:
</p>
<dl>
<dt>.PASS:</dt>
<dd>
              Interpolate Ax+By+C as fp32, no post fp32 multiply.<br>
              Flush output denorm to sign preserving 0.0.
</dd>
<dt>.MUL: // This is default.</dt>
<dd>
              Interpolate Ax+By+C as fp32,<br>
              Flush Rb denorm to sign-preserving 0.0.<br
              If Pmul is true, then fp32 multiply by Rb.<br> 
              Flush output denorm to sign preserving 0.0.<br>
</dd>
<dt>.CONSTANT:</dt>
<dd>
              If the attributes is declared Constant, it will Pass C as 32b bitfield (<b>NO</b> denorm flush)<br>
              If the attribute is not Constant in the ShaderProgramHeader, return 0<br>
</dd>
<dt>.SC:</dt>
<dd>
              State controls above selection.
</dd>
</p>

<p>
The Pmul predicate value should be set to false if the result of the
interpolation multiply would not change the interpolation result (i.e.
the multiplicand in Rb is 1.0). Pmul is ignored if <b>.SAT</b> is set.
</p>
<p>
Pmul is PT by default.
</p>

<p>
.msi controls the sampling mode:</p>

<dl>
<dt>.CENTER: // This is default.</dt>
<dd>
      Center (offset of 0/16,0/16 from center of pixel)
</dd>
<dt>.CENTROID:</dt>
<dd>
      Centroid (closest covered sample to center).
      If multisampling is not on, or if all or none of the samples are covered,
      then centroid is center.
      Else first covered sample in sample list.
</dd>
<dt>.OFFSET:</dt>
<dd>
      Offset (shader register provides offsets)
<pre>
        - Rc contains sample (dx,dy)
             dx[15:00], format is integer pixel[15:12].subpixel[11:00]
             dy[31:16], format is integer pixel[31:28].subpixel[27:16]
        - add the (dx,dy) pair of 4.12 signed offsets from the center of the pixel before the
          position is interpolated.
             1111.<b>1000</b>00000000 = -8/16
             1111.<b>1001</b>00000000 = -7/16
             1111.<b>1010</b>00000000 = -6/16
             1111.<b>1011</b>00000000 = -5/16
             1111.<b>1100</b>00000000 = -4/16
             1111.<b>1101</b>00000000 = -3/16
             1111.<b>1110</b>00000000 = -2/16
             1111.<b>1111</b>00000000 = -1/16
             0000.<b>0000</b>00000000 =  0/16    // center of pixel
             0000.<b>0001</b>00000000 =  1/16
             0000.<b>0010</b>00000000 =  2/16
             0000.<b>0011</b>00000000 =  3/16
             0000.<b>0100</b>00000000 =  4/16
             0000.<b>0101</b>00000000 =  5/16
             0000.<b>0110</b>00000000 =  6/16
	     0000.<b>0111</b>00000000 =  7/16
</pre>

	  <p><b>NOTE:</b> We only implement 0.4b offsets, so the upper 4b and lower 8b are
                currently ignored. This allows interpolation at all 16*16 sub-pixel locations.
		</p>
</dd>
</dl>

<p>
See the <b>PIXLD</b> instruction for retrieving dx,dy and coverage information for a sub-sample.
</p>

<p>
The Puniform predicate value indicates if the attribute to index is warp-uniform.
If Puniform has a value of true, the HW can optimize the interpolation writeback.
It is required that Puniform has the correct value, for this optimization to work.
If Puniform has a value of true, and the attribute
index is not warp-uniform, the behavior of this instruction is UNPREDICTABLE.
</p>

</div>


<!-- ############################### -->
<!-- # Examples                    # -->
<!-- ############################### -->
<h2>Examples:</h2>
<div class="Examples">

<pre>
<b>IPA</b>.PASS R4, a[0x7c];           # interpolate WPOS.w = 1/w 
<b>MUFU</b>.RCP R4, R4;                # w 
<b>IPA</b>.MUL  R0, a[0x300], R4;      # s: interpolate TEX0.s = s/w, multiply by w 
<b>IPA</b>.MUL  R1, a[0x304], R4;      # t: interpolate TEX0.t = t/w, multiply by w


<b>IPA</b>.PASS R1, a[ 0x7c];          # WPOS.w
<b>FCMP</b>.NE  P0, R1, 1.0;
<b>MUFU</b>.RCP R1, R1;
<b>IPA</b>.MUL  R0, a[0x300], R1, P0;  # TEX0.s
<b>IPA</b>.MUL  R1, a[0x304], R1, P0;  # TEX0.t


<b>AL2P</b>         P0, R5, R6,     0;
<b>IPA</b>.IDX.PASS R2,     a[R5], P0; # indexed IPA, with attribute pointed to by R6
</pre>
</div>

<!-- ############################### -->
<!-- # Tail                        # -->
<!-- ############################### -->
<div class="Tail">
<p><a href="../opcodes.htm">Back to Index of Instructions</a></p>
</div>
</body>
</html>
