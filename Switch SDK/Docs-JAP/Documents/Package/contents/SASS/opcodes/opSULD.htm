<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>SULD</title>
<link rel="StyleSheet" href="../style.css" type="text/css" title="general">
</head>
<body class="opcode">

<!-- ############################### -->
<!-- # Opcode                      # -->
<!-- ############################### -->
<h1>
    SULD : Surface Load <br>
    <!-- SUMMARY_TABLE_INFO { description => "Surface Load " } -->
</h1>


<!-- The following information is used to generate the text in the opcode table in ../opcodes.htm -->
<!-- SUMMARY_TABLE_INFO { section => "Compute Load/Store Instructions" } -->
<!-- SUMMARY_TABLE_INFO { opcode => "SULD", subsection => 9.1 } -->

<!-- ############################### -->
<!-- # Format                      # -->
<!-- ############################### -->
<h2>Format</h2>
<div class="Format">

<pre>
SPA 5.0:
<code>        <code>{@{!}Pg}</code>   <code><b>SULD</b>.D{.BA}.dim{.cop}{.sz}{.clamp}</code>   <code>Rd0, [Ra], #tsPtrIdxU13</code>         <code><!-- OPEX_COUNT_4 --><!-- BEGIN &opex("MIO_RD_WR_SCBD") -->{&amp;req_6}</code>   <code>{&amp;rdN}</code>   <code>{&amp;wrN}</code>   <code>{?sched}<!-- END &opex("MIO_RD_WR_SCBD") --></code>   <code>;</code>   </code><!-- SUMMARY_TABLE_INFO { define_opcode => "SULD" } -->
<code>        <code>{@{!}Pg}</code>   <code><b>SULD</b>.D{.BA}.dim{.cop}{.sz}{.clamp}</code>   <code>Rd0, [Ra], Rc</code>                   <code><!-- OPEX_COUNT_4 --><!-- BEGIN &opex("MIO_RD_WR_SCBD") -->{&amp;req_6}</code>   <code>{&amp;rdN}</code>   <code>{&amp;wrN}</code>   <code>{?sched}<!-- END &opex("MIO_RD_WR_SCBD") --></code>   <code>;</code>   </code><!-- SUMMARY_TABLE_INFO { define_opcode => "SULD" } -->
<code>        <code>{@{!}Pg}</code>   <code><b>SULD</b>.P.dim{.cop}{.rgba}{.clamp}</code>      <code>Rd0, [Ra], #tsPtrIdxU13</code>         <code><!-- OPEX_COUNT_4 --><!-- BEGIN &opex("MIO_RD_WR_SCBD") -->{&amp;req_6}</code>   <code>{&amp;rdN}</code>   <code>{&amp;wrN}</code>   <code>{?sched}<!-- END &opex("MIO_RD_WR_SCBD") --></code>   <code>;</code>   </code><!-- SUMMARY_TABLE_INFO { define_opcode => "SULD" } -->
<code>        <code>{@{!}Pg}</code>   <code><b>SULD</b>.P.dim{.cop}{.rgba}{.clamp}</code>      <code>Rd0, [Ra], Rc</code>                   <code><!-- OPEX_COUNT_4 --><!-- BEGIN &opex("MIO_RD_WR_SCBD") -->{&amp;req_6}</code>   <code>{&amp;rdN}</code>   <code>{&amp;wrN}</code>   <code>{?sched}<!-- END &opex("MIO_RD_WR_SCBD") --></code>   <code>;</code>   </code><!-- SUMMARY_TABLE_INFO { define_opcode => "SULD" } -->

 4 more variants support tiled resources (sparse status predicate). 
<code>        <code>{@{!}Pg}</code>   <code><b>SULD</b>.D{.BA}.dim{.cop}{.sz}{.clamp}</code>   <code>{Ps,} Rd0, [Ra], #tsPtrIdxU13</code>   <code><!-- OPEX_COUNT_4 --><!-- BEGIN &opex("MIO_RD_WR_SCBD") -->{&amp;req_6}</code>   <code>{&amp;rdN}</code>   <code>{&amp;wrN}</code>   <code>{?sched}<!-- END &opex("MIO_RD_WR_SCBD") --></code>   <code>;</code>   </code><!-- SUMMARY_TABLE_INFO { define_opcode => "SULD" } -->
<code>        <code>{@{!}Pg}</code>   <code><b>SULD</b>.D{.BA}.dim{.cop}{.sz}{.clamp}</code>   <code>{Ps,} Rd0, [Ra], Rc</code>             <code><!-- OPEX_COUNT_4 --><!-- BEGIN &opex("MIO_RD_WR_SCBD") -->{&amp;req_6}</code>   <code>{&amp;rdN}</code>   <code>{&amp;wrN}</code>   <code>{?sched}<!-- END &opex("MIO_RD_WR_SCBD") --></code>   <code>;</code>   </code><!-- SUMMARY_TABLE_INFO { define_opcode => "SULD" } -->
<code>        <code>{@{!}Pg}</code>   <code><b>SULD</b>.P.dim{.cop}{.rgba}{.clamp}</code>      <code>{Ps,} Rd0, [Ra], #tsPtrIdxU13</code>   <code><!-- OPEX_COUNT_4 --><!-- BEGIN &opex("MIO_RD_WR_SCBD") -->{&amp;req_6}</code>   <code>{&amp;rdN}</code>   <code>{&amp;wrN}</code>   <code>{?sched}<!-- END &opex("MIO_RD_WR_SCBD") --></code>   <code>;</code>   </code><!-- SUMMARY_TABLE_INFO { define_opcode => "SULD" } -->
<code>        <code>{@{!}Pg}</code>   <code><b>SULD</b>.P.dim{.cop}{.rgba}{.clamp}</code>      <code>{Ps,} Rd0, [Ra], Rc</code>             <code><!-- OPEX_COUNT_4 --><!-- BEGIN &opex("MIO_RD_WR_SCBD") -->{&amp;req_6}</code>   <code>{&amp;rdN}</code>   <code>{&amp;wrN}</code>   <code>{?sched}<!-- END &opex("MIO_RD_WR_SCBD") --></code>   <code>;</code>   </code><!-- SUMMARY_TABLE_INFO { define_opcode => "SULD" } -->


Modifiers:

        .dim    {<b>.1D, .1D_BUFFER, .1D_ARRAY, .2D, .2D_ARRAY, .3D</b>}

        .mode   {<b>.D, .P</b>}
            .D      This mode specifies load from surface as raw data of size .sz, without any format conversion.
                    In this mode, if .BA (ByteAddress) is specified, 
                         the x-coordinate is assumed to be in bytes, aligned on a .sz boundary. 
                         Otherwise, x-ordinate is treated as sample co-ordinate and scaled by .sz in hardware.
            .P      This mode specified a formatted pixel load from surface. 
                    The x value is a sample coordinate in the target surface.
                    In this mode .rgba specifies the number of components written by the load. 

        .cop:  { <b>.CA*, .CG, .CS, .LU, .CV , .CI</b>}    // Cache all*, global, streaming, last-use, volatile, inconsistent
          <b>.CA</b>*   cache at all levels, likely to be accessed again (default) // Except L1 cache (see description)
          <b>.CG</b>    cache at global level (cache in L2 and below, not L1, )
          <b>.CS</b>    maps to .CA
          <b>.LU</b>    maps to .CG 
          <b>.CV</b>    cache as volatile (consider cached system memory lines stale, fetch again)
          <b>.CI</b>    cache as inconsistent data. (expected to be used only with invariant data)

        .sz     {<b>.U8, .S8, .U16, .S16, .32*, .64, .128</b>}  // used in .D mode, specifes load size of raw data.
        .rgba   {<b>.R, .RG, .RGBA*</b>}                        // used in .P mode, specifies a scalar, vec2 or vec4 destination register.
        .BA     x-coordinate is specified as byte-address. (in .D mode)
        .clamp  {<b>.IGN, .NEAR*, .TRAP</b>}



    Operands
    ------------------------------------
    Ra             Coordinates  (Note: Ra cannot be RZ register).
    Rd0            Destination  data  register
    #tsPtrIdxU13   This immediate index (word address) is used to fetch the packed header+sampler pointer entry from constant cache.  The bank from which
                   it is fetched  is determined by bundle state. The constant bank entry is 32 bit structure of the form
                   "samplerPtr[31:20] | headerPtr[19:0]". (Surface instructions ignore sample pointers).
                   Any header pointer greater than one specified in SetTexHeaderPoolC.MaximumIndex  will be regarded as an "invalid" texture.
    Rc             In bindless mode, Rc register is used to pass the "samplerPtr[31:20] | headerPtr[19:0]". 
                   Note: Rc cannot be RZ register.

   Ps       Predicate returning sparse tile status. Indiate that the surface access is happening to a page marked as sparse (not valid).
                   <b>Note:</b> The encoding of Ps is bit inverted ie  0 => PT and  7 => P0.

</pre>
</div>

<!-- ############################### -->
<!-- # Description                 # -->
<!-- ############################### -->
<h2>Description</h2>
<div class="Description">

<p>
<b>SULD</b> loads the data from surface in global memory using pitch or blocklinear addressing. 
</p>
<p>
Register <B>Ra</B> specifies surface coordinates. The number of coordinates depends upon surface dimension. 
<B>Ra</B> must follow register alignment rules for given number of coordinates.
</p>
<TABLE border="1" cellpadding="10%">
<CAPTION><EM>Surface Coordinate packing in Ra</EM></CAPTION>
<TR>
    <th> .dim </th>
    <th> Ra </th>
    <th> Ra+1 </th>
    <th> Ra+2 </th>
</TR>
<TR>
    <TD> 1D </TD>
    <TD> S32 </TD>
    <TD>  </TD>
    <TD>  </TD>
</TR>
<TR>
    <TD> 1D_BUFFER </TD>
    <TD> S32/U32 </TD>
    <TD>  </TD>
    <TD>  </TD>
</TR>
<TR>
    <TD> 1D_ARRAY </TD>
    <TD> S32 </TD>
    <TD> U16 </TD>
    <TD>  </TD>
</TR>
<TR>
    <TD> 2D </TD>
    <TD> S32 </TD>
    <TD> S32 </TD>
    <TD>  </TD>
</TR>
<TR>
    <TD> 2D_ARRAY </TD>
    <TD> S32 </TD>
    <TD> S32 </TD>
    <TD> U16 </TD>
</TR>
<TR>
    <TD> 3D </TD>
    <TD> S32 </TD>
    <TD> S32 </TD>
    <TD> S32 </TD>
</TR>
</TABLE>           
<p>
For 1D_BUFFER, the coordinate is S32 if .clamp is .NEAR. Otherwise, the coordinate is interpreted as U32.  
The 1D_ARRAY and 2D_ARRAY array indices are treated as U16, meaning only the 16 LSBs of the register value are used.
</p>

<p>
The .clamp option specifies how to clamp out of bounds addresses (too high or low).
<ul>
        <li>.IGN indicates that zero data will be returned for an out-of-bounds address.</li>
        <li>.NEAR is similar to TLD.CL. An out-of-bounds address will be clamped to the surface boundary
            and the nearest data element will be returned.</li>
        <li>.TRAP indicates that an out-of-bounds address causes an execution trap. If coordinates exceed bounds, the memory access is treated like an .IGN.</li>
</ul>
</p>

<p>
<B>Sc</B> contains a pointer to texture header. The possible options for Sc are:
<ul>
   <li> Rc: stored in 32-bit register. (Rc cannot be RZ)</li>
 <li> Constant with Immediate address, #tsPtrIdxU13: { const[15:2], 2'b00 } </li>
</ul>
</p>
<p>
Size specifier for byte (.D.BA) and coordinate (.D) addressing.
<ul>
   <li>.sz is one of: .U8, .S8, .U16, .S16, .32, .64, .128. </li>
   <li>For surface data sizes smaller than 32 bits, </li>
   <ul> <li> the returned value is zero-extended for  (.U8. .U16) or </li>
        <li> sign-exented (.S8, .S16) into the 32-bit Rd0 register. </li>
   </ul>
   <li> For sizes larger than 32 bits, SULD writes 2 (.64) or 4 (.128) sequential registers, and Rd0 must be even or quad-aligned accordingly. </li>
</ul>
</p>

<p>
All surface loads are uncached at L1 level, regardless of .cop. 
Within the L1 cache, surface operations to the same coordinates as cached Texture operations will not invalidate cached data lines.
<p>
If the surface being accessed is disabled, an <B>SULD</B> will silently fail and return 0(s) as a result.
</p>
</div>

<p>
Surface dimensions have the following compatibility with texture dimensions:


<!-- ############################### -->
<!-- # Examples                    # -->
<!-- ############################### -->
<h2>Examples:</h2>
<div class="Examples">

<pre>
<b>SULD.D.2D</b> R2, [R4], R6;
<b>SULD.P.3D.R.IGN</b> R2, [R4], 0x100;  // surface header pointer is fetched from c[state_controlled_bank][0x400]
</pre>

</div>

<!-- ############################### -->
<!-- # Tail                        # -->
<!-- ############################### -->
<div class="Tail">
<p><a href="../opcodes.htm">Back to Index of Instructions</a></p>
</div>
</body>
</html>
