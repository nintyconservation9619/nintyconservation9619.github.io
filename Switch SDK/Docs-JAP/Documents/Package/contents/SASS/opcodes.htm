<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<link rel="StyleSheet" href="style.css" type="text/css" title="general">
<title>Maxwell Instruction Set Architecture</title></head>
<body class="optable">

<h1>Maxwell Instruction Set Architecture</h1>
<ul>
</ul>



<h1>Instruction Set</h1>

<h2>Quick Links</h2>

<p>
<a href="opcodes/opAL2P.htm">AL2P</a>
<a href="opcodes/opALD.htm">ALD</a>
<a href="opcodes/opAST.htm">AST</a>
<a href="opcodes/opATOM.htm">ATOM</a>
<a href="opcodes/opATOMS.htm">ATOMS</a>
<a href="opcodes/opB2R.htm">B2R</a>
<a href="opcodes/opBAR.htm">BAR</a>
<a href="opcodes/opBFE.htm">BFE</a>
<a href="opcodes/opBFI.htm">BFI</a>
<a href="opcodes/opBPT.htm">BPT</a>
<a href="opcodes/opBRA.htm">BRA</a>
<a href="opcodes/opBRK.htm">BRK</a>
<a href="opcodes/opBRA.htm">BRX</a>
<a href="opcodes/opCAL.htm">CAL</a>
<a href="opcodes/opCCTL.htm">CCTL</a>
<a href="opcodes/opCCTL.htm">CCTLL</a>
<a href="opcodes/opCCTLT.htm">CCTLT</a>
<a href="opcodes/opCONT.htm">CONT</a>
<a href="opcodes/opS2R.htm">CS2R</a>
<a href="opcodes/opCSET.htm">CSET</a>
<a href="opcodes/opCSETP.htm">CSETP</a>
<a href="opcodes/opDADD.htm">DADD</a>
<a href="opcodes/opDEPBAR.htm">DEPBAR</a>
<a href="opcodes/opDFMA.htm">DFMA</a>
<a href="opcodes/opDMNMX.htm">DMNMX</a>
<a href="opcodes/opDMUL.htm">DMUL</a>
<a href="opcodes/opDSET.htm">DSET</a>
<a href="opcodes/opDSETP.htm">DSETP</a>
<a href="opcodes/opEXIT.htm">EXIT</a>
<a href="opcodes/opF2F.htm">F2F</a>
<a href="opcodes/opF2I.htm">F2I</a>
<a href="opcodes/opFADD.htm">FADD</a>
<a href="opcodes/opFADD.htm">FADD32I</a>
<a href="opcodes/opFCHK.htm">FCHK</a>
<a href="opcodes/opFCMP.htm">FCMP</a>
<a href="opcodes/opFFMA.htm">FFMA</a>
<a href="opcodes/opFFMA.htm">FFMA32I</a>
<a href="opcodes/opFLO.htm">FLO</a>
<a href="opcodes/opFMNMX.htm">FMNMX</a>
<a href="opcodes/opFMUL.htm">FMUL</a>
<a href="opcodes/opFMUL.htm">FMUL32I</a>
<a href="opcodes/opFSET.htm">FSET</a>
<a href="opcodes/opFSETP.htm">FSETP</a>
<a href="opcodes/opFSWZADD.htm">FSWZADD</a>
<a href="opcodes/opGETCRSPTR.htm">GETCRSPTR</a>
<a href="opcodes/opGETLMEMBASE.htm">GETLMEMBASE</a>
<a href="opcodes/opHADD2.htm">HADD2</a>
<a href="opcodes/opHADD2.htm">HADD2_32I</a>
<a href="opcodes/opHFMA2.htm">HFMA2</a>
<a href="opcodes/opHFMA2.htm">HFMA2_32I</a>
<a href="opcodes/opHMUL2.htm">HMUL2</a>
<a href="opcodes/opHMUL2.htm">HMUL2_32I</a>
<a href="opcodes/opHSET2.htm">HSET2</a>
<a href="opcodes/opHSETP2.htm">HSETP2</a>
<a href="opcodes/opI2F.htm">I2F</a>
<a href="opcodes/opI2I.htm">I2I</a>
<a href="opcodes/opIADD.htm">IADD</a>
<a href="opcodes/opIADD3.htm">IADD3</a>
<a href="opcodes/opIADD.htm">IADD32I</a>
<a href="opcodes/opICMP.htm">ICMP</a>
<a href="opcodes/opIDE.htm">IDE</a>
<a href="opcodes/opIMAD.htm">IMAD</a>
<a href="opcodes/opIMAD.htm">IMAD32I</a>
<a href="opcodes/opIMADSP.htm">IMADSP</a>
<a href="opcodes/opIMNMX.htm">IMNMX</a>
<a href="opcodes/opIMUL.htm">IMUL</a>
<a href="opcodes/opIMUL.htm">IMUL32I</a>
<a href="opcodes/opIPA.htm">IPA</a>
<a href="opcodes/opISBERD.htm">ISBERD</a>
<a href="opcodes/opISCADD.htm">ISCADD</a>
<a href="opcodes/opISCADD.htm">ISCADD32I</a>
<a href="opcodes/opISET.htm">ISET</a>
<a href="opcodes/opISETP.htm">ISETP</a>
<a href="opcodes/opCAL.htm">JCAL</a>
<a href="opcodes/opBRA.htm">JMP</a>
<a href="opcodes/opBRA.htm">JMX</a>
<a href="opcodes/opKIL.htm">KIL</a>
<a href="opcodes/opLD.htm">LD</a>
<a href="opcodes/opLDC.htm">LDC</a>
<a href="opcodes/opLDG.htm">LDG</a>
<a href="opcodes/opLDW.htm">LDL</a>
<a href="opcodes/opLDW.htm">LDS</a>
<a href="opcodes/opLEA.htm">LEA</a>
<a href="opcodes/opLEPC.htm">LEPC</a>
<a href="opcodes/opLONGJMP.htm">LONGJMP</a>
<a href="opcodes/opLOP.htm">LOP</a>
<a href="opcodes/opLOP3.htm">LOP3</a>
<a href="opcodes/opLOP.htm">LOP32I</a>
<a href="opcodes/opMEMBAR.htm">MEMBAR</a>
<a href="opcodes/opMOV.htm">MOV</a>
<a href="opcodes/opMOV.htm">MOV32I</a>
<a href="opcodes/opMUFU.htm">MUFU</a>
<a href="opcodes/opNOP.htm">NOP</a>
<a href="opcodes/opOUT.htm">OUT</a>
<a href="opcodes/opP2R.htm">P2R</a>
<a href="opcodes/opBRK.htm">PBK</a>
<a href="opcodes/opCONT.htm">PCNT</a>
<a href="opcodes/opEXIT.htm">PEXIT</a>
<a href="opcodes/opPIXLD.htm">PIXLD</a>
<a href="opcodes/opLONGJMP.htm">PLONGJMP</a>
<a href="opcodes/opPOPC.htm">POPC</a>
<a href="opcodes/opRET.htm">PRET</a>
<a href="opcodes/opPRMT.htm">PRMT</a>
<a href="opcodes/opPSET.htm">PSET</a>
<a href="opcodes/opPSETP.htm">PSETP</a>
<a href="opcodes/opR2B.htm">R2B</a>
<a href="opcodes/opR2P.htm">R2P</a>
<a href="opcodes/opRAM.htm">RAM</a>
<a href="opcodes/opRED.htm">RED</a>
<a href="opcodes/opRET.htm">RET</a>
<a href="opcodes/opRRO.htm">RRO</a>
<a href="opcodes/opRTT.htm">RTT</a>
<a href="opcodes/opS2R.htm">S2R</a>
<a href="opcodes/opSAM.htm">SAM</a>
<a href="opcodes/opSEL.htm">SEL</a>
<a href="opcodes/opSETCRSPTR.htm">SETCRSPTR</a>
<a href="opcodes/opSETLMEMBASE.htm">SETLMEMBASE</a>
<a href="opcodes/opSHF.htm">SHF</a>
<a href="opcodes/opSHFL.htm">SHFL</a>
<a href="opcodes/opSHL.htm">SHL</a>
<a href="opcodes/opSHR.htm">SHR</a>
<a href="opcodes/opSSY.htm">SSY</a>
<a href="opcodes/opST.htm">ST</a>
<a href="opcodes/opSTG.htm">STG</a>
<a href="opcodes/opSTW.htm">STL</a>
<a href="opcodes/opSTP.htm">STP</a>
<a href="opcodes/opSTW.htm">STS</a>
<a href="opcodes/opSUATOM.htm">SUATOM</a>
<a href="opcodes/opSULD.htm">SULD</a>
<a href="opcodes/opSURED.htm">SURED</a>
<a href="opcodes/opSUST.htm">SUST</a>
<a href="opcodes/opSYNC.htm">SYNC</a>
<a href="opcodes/opTEX.htm">TEX</a>
<a href="opcodes/opTEXS.htm">TEXS</a>
<a href="opcodes/opTLD.htm">TLD</a>
<a href="opcodes/opTLD4.htm">TLD4</a>
<a href="opcodes/opTLD4S.htm">TLD4S</a>
<a href="opcodes/opTLDS.htm">TLDS</a>
<a href="opcodes/opTMML.htm">TMML</a>
<a href="opcodes/opTXA.htm">TXA</a>
<a href="opcodes/opTXD.htm">TXD</a>
<a href="opcodes/opTXQ.htm">TXQ</a>
<a href="opcodes/opVABSDIFF.htm">VABSDIFF</a>
<a href="opcodes/opVABSDIFF4.htm">VABSDIFF4</a>
<a href="opcodes/opVADD.htm">VADD</a>
<a href="opcodes/opVMAD.htm">VMAD</a>
<a href="opcodes/opVMNMX.htm">VMNMX</a>
<a href="opcodes/opVOTE.htm">VOTE</a>
<a href="opcodes/opVSET.htm">VSET</a>
<a href="opcodes/opVSETP.htm">VSETP</a>
<a href="opcodes/opVSHL.htm">VSHL</a>
<a href="opcodes/opVSHR.htm">VSHR</a>
<a href="opcodes/opXMAD.htm">XMAD</a>
</p>

<h2>Index of Instructions</h2>

<table>
<!-- section "Floating Point Instructions" -->
<tbody><tr><th colspan="3" class="header"><a name="FloatingPoint">Index of Floating Point Instructions</a></th></tr>
<tr><th>Opcode</th><th>Description</th></tr>
<!-- section "Floating Point Instructions", subsection 0 -->
<tr>
 <td class="op"><a href="opcodes/opFADD.htm">FADD</a></td>
 <td>FP32 Add</td>
</tr><tr>
 <td class="op"><a href="opcodes/opFADD.htm">FADD32I</a></td>
 <td>FP32 Add</td>
</tr><tr>
 <td class="op"><a href="opcodes/opFCHK.htm">FCHK</a></td>
 <td>Single Precision FP Divide Range Check</td>
</tr><tr>
 <td class="op"><a href="opcodes/opFCMP.htm">FCMP</a></td>
 <td>FP32 Compare to Zero and Select Source</td>
</tr><tr>
 <td class="op"><a href="opcodes/opFFMA.htm">FFMA</a></td>
 <td>FP32 Fused Multiply and Add</td>
</tr><tr>
 <td class="op"><a href="opcodes/opFFMA.htm">FFMA32I</a></td>
 <td>FP32 Fused Multiply and Add</td>
</tr><tr>
 <td class="op"><a href="opcodes/opFMNMX.htm">FMNMX</a></td>
 <td>FP32 Minimum/Maximum</td>
</tr><tr>
 <td class="op"><a href="opcodes/opFMUL.htm">FMUL</a></td>
 <td>FP32 Multiply</td>
</tr><tr>
 <td class="op"><a href="opcodes/opFMUL.htm">FMUL32I</a></td>
 <td>FP32 Multiply</td>
</tr><tr>
 <td class="op"><a href="opcodes/opFSET.htm">FSET</a></td>
 <td>FP32 Compare And Set</td>
</tr><tr>
 <td class="op"><a href="opcodes/opFSETP.htm">FSETP</a></td>
 <td>FP32 Compare And Set Predicate</td>
</tr><tr>
 <td class="op"><a href="opcodes/opFSWZADD.htm">FSWZADD</a></td>
 <td>FP32 Add used for FSWZ emulation</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Floating Point Instructions", subsection 1 -->
<tr>
 <td class="op"><a href="opcodes/opIPA.htm">IPA</a></td>
 <td>Interpolate Attribute</td>
</tr><tr>
 <td class="op"><a href="opcodes/opMUFU.htm">MUFU</a></td>
 <td>Multi Function Operation</td>
</tr><tr>
 <td class="op"><a href="opcodes/opRRO.htm">RRO</a></td>
 <td>Range Reduction Operator FP</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Floating Point Instructions", subsection 2 -->
<tr>
 <td class="op"><a href="opcodes/opDADD.htm">DADD</a></td>
 <td>FP64 Add</td>
</tr><tr>
 <td class="op"><a href="opcodes/opDFMA.htm">DFMA</a></td>
 <td>FP64 Fused Mutiply Add</td>
</tr><tr>
 <td class="op"><a href="opcodes/opDMNMX.htm">DMNMX</a></td>
 <td>FP64 Minimum/Maximum</td>
</tr><tr>
 <td class="op"><a href="opcodes/opDMUL.htm">DMUL</a></td>
 <td>FP64 Multiply</td>
</tr><tr>
 <td class="op"><a href="opcodes/opDSET.htm">DSET</a></td>
 <td>FP64 Compare And Set</td>
</tr><tr>
 <td class="op"><a href="opcodes/opDSETP.htm">DSETP</a></td>
 <td>FP64 Compare And Set Predicate</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Floating Point Instructions", subsection 3 -->
<tr>
 <td class="op"><a href="opcodes/opHADD2.htm">HADD2</a></td>
 <td>FP16 SIMD Addition</td>
</tr><tr>
 <td class="op"><a href="opcodes/opHADD2.htm">HADD2_32I</a></td>
 <td>FP16 SIMD Addition</td>
</tr><tr>
 <td class="op"><a href="opcodes/opHFMA2.htm">HFMA2</a></td>
 <td>FP16 SIMD Fused Multiply and Add</td>
</tr><tr>
 <td class="op"><a href="opcodes/opHFMA2.htm">HFMA2_32I</a></td>
 <td>FP16 SIMD Fused Multiply and Add</td>
</tr><tr>
 <td class="op"><a href="opcodes/opHMUL2.htm">HMUL2</a></td>
 <td>FP16 SIMD Multiply</td>
</tr><tr>
 <td class="op"><a href="opcodes/opHMUL2.htm">HMUL2_32I</a></td>
 <td>FP16 SIMD Multiply</td>
</tr><tr>
 <td class="op"><a href="opcodes/opHSET2.htm">HSET2</a></td>
 <td>FP16 SIMD Compare and Set</td>
</tr><tr>
 <td class="op"><a href="opcodes/opHSETP2.htm">HSETP2</a></td>
 <td>FP16 SIMD Compare and Set Predicate</td>
<!-- section "Integer Instructions" -->
</tr><tr><th colspan="3" class="header"><a name="Integer">Index of Integer Instructions</a></th></tr>
<tr><th>Opcode</th><th>Description</th></tr>
<!-- section "Integer Instructions", subsection 2 -->
<tr>
 <td class="op"><a href="opcodes/opBFE.htm">BFE</a></td>
 <td>Bit Field Extract</td>
</tr><tr>
 <td class="op"><a href="opcodes/opBFI.htm">BFI</a></td>
 <td>Bit Field Insert</td>
</tr><tr>
 <td class="op"><a href="opcodes/opFLO.htm">FLO</a></td>
 <td>Find Leading One</td>
</tr><tr>
 <td class="op"><a href="opcodes/opIADD.htm">IADD</a></td>
 <td>Integer Addition</td>
</tr><tr>
 <td class="op"><a href="opcodes/opIADD3.htm">IADD3</a></td>
 <td>3-input Integer Addition</td>
</tr><tr>
 <td class="op"><a href="opcodes/opIADD.htm">IADD32I</a></td>
 <td>Integer Addition</td>
</tr><tr>
 <td class="op"><a href="opcodes/opICMP.htm">ICMP</a></td>
 <td>Integer Compare to Zero and Select Source</td>
</tr><tr>
 <td class="op"><a href="opcodes/opIMAD.htm">IMAD</a></td>
 <td>Integer Multiply And Add</td>
</tr><tr>
 <td class="op"><a href="opcodes/opIMAD.htm">IMAD32I</a></td>
 <td>Integer Multiply And Add</td>
</tr><tr>
 <td class="op"><a href="opcodes/opIMADSP.htm">IMADSP</a></td>
 <td>Extracted Integer Multiply And Add.</td>
</tr><tr>
 <td class="op"><a href="opcodes/opIMNMX.htm">IMNMX</a></td>
 <td>Integer Minimum/Maximum</td>
</tr><tr>
 <td class="op"><a href="opcodes/opIMUL.htm">IMUL</a></td>
 <td>Integer Multiply</td>
</tr><tr>
 <td class="op"><a href="opcodes/opIMUL.htm">IMUL32I</a></td>
 <td>Integer Multiply</td>
</tr><tr>
 <td class="op"><a href="opcodes/opISCADD.htm">ISCADD</a></td>
 <td>Scaled Integer Addition</td>
</tr><tr>
 <td class="op"><a href="opcodes/opISCADD.htm">ISCADD32I</a></td>
 <td>Scaled Integer Addition</td>
</tr><tr>
 <td class="op"><a href="opcodes/opISET.htm">ISET</a></td>
 <td>Integer Compare And Set</td>
</tr><tr>
 <td class="op"><a href="opcodes/opISETP.htm">ISETP</a></td>
 <td>Integer Compare And Set Predicate</td>
</tr><tr>
 <td class="op"><a href="opcodes/opLEA.htm">LEA</a></td>
 <td>Compute Effective Address</td>
</tr><tr>
 <td class="op"><a href="opcodes/opLOP.htm">LOP</a></td>
 <td>Logic Operation</td>
</tr><tr>
 <td class="op"><a href="opcodes/opLOP3.htm">LOP3</a></td>
 <td>3-input Logic Operation</td>
</tr><tr>
 <td class="op"><a href="opcodes/opLOP.htm">LOP32I</a></td>
 <td>Logic Operation</td>
</tr><tr>
 <td class="op"><a href="opcodes/opPOPC.htm">POPC</a></td>
 <td>Population count</td>
</tr><tr>
 <td class="op"><a href="opcodes/opSHF.htm">SHF</a></td>
 <td>Funnel Shift</td>
</tr><tr>
 <td class="op"><a href="opcodes/opSHL.htm">SHL</a></td>
 <td>Shift Left</td>
</tr><tr>
 <td class="op"><a href="opcodes/opSHR.htm">SHR</a></td>
 <td>Shift Right</td>
</tr><tr>
 <td class="op"><a href="opcodes/opXMAD.htm">XMAD</a></td>
 <td>Integer Short Multiply Add</td>
<!-- section "Video Instructions" -->
</tr><tr><th colspan="3" class="header"><a name="Video">Index of Video Instructions</a></th></tr>
<tr><th>Opcode</th><th>Description</th></tr>
<!-- section "Video Instructions", subsection 2 -->
<tr>
 <td class="op"><a href="opcodes/opVABSDIFF.htm">VABSDIFF</a></td>
 <td>Integer Byte/Short Absolute Difference</td>
</tr><tr>
 <td class="op"><a href="opcodes/opVADD.htm">VADD</a></td>
 <td>Integer Byte/Short Addition</td>
</tr><tr>
 <td class="op"><a href="opcodes/opVMAD.htm">VMAD</a></td>
 <td>Integer Byte/Short Multiply Add</td>
</tr><tr>
 <td class="op"><a href="opcodes/opVMNMX.htm">VMNMX</a></td>
 <td>Integer Byte/Short Minimum/Maximum</td>
</tr><tr>
 <td class="op"><a href="opcodes/opVSET.htm">VSET</a></td>
 <td>Integer Byte/Short Set</td>
</tr><tr>
 <td class="op"><a href="opcodes/opVSETP.htm">VSETP</a></td>
 <td>Integer Byte/Short Compare And Set Predicate</td>
</tr><tr>
 <td class="op"><a href="opcodes/opVSHL.htm">VSHL</a></td>
 <td>Integer Byte/Short Shift Left</td>
</tr><tr>
 <td class="op"><a href="opcodes/opVSHR.htm">VSHR</a></td>
 <td>Integer Byte/Short Shift Right</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Video Instructions", subsection 4 -->
<tr>
 <td class="op"><a href="opcodes/opVABSDIFF4.htm">VABSDIFF4</a></td>
 <td>Integer SIMD Byte Absolute Difference</td>
<!-- section "Conversion Instructions" -->
</tr><tr><th colspan="3" class="header"><a name="Conversion">Index of Conversion Instructions</a></th></tr>
<tr><th>Opcode</th><th>Description</th></tr>
<!-- section "Conversion Instructions", subsection 4 -->
<tr>
 <td class="op"><a href="opcodes/opF2F.htm">F2F</a></td>
 <td>Floating Point To Floating Point Conversion</td>
</tr><tr>
 <td class="op"><a href="opcodes/opF2I.htm">F2I</a></td>
 <td>Floating Point To Integer Conversion</td>
</tr><tr>
 <td class="op"><a href="opcodes/opI2F.htm">I2F</a></td>
 <td>Integer To Floating Point Conversion</td>
</tr><tr>
 <td class="op"><a href="opcodes/opI2I.htm">I2I</a></td>
 <td>Integer To Integer Conversion</td>
<!-- section "Movement Instructions" -->
</tr><tr><th colspan="3" class="header"><a name="Movement">Index of Movement Instructions</a></th></tr>
<tr><th>Opcode</th><th>Description</th></tr>
<!-- section "Movement Instructions", subsection 4 -->
<tr>
 <td class="op"><a href="opcodes/opMOV.htm">MOV</a></td>
 <td>Move</td>
</tr><tr>
 <td class="op"><a href="opcodes/opMOV.htm">MOV32I</a></td>
 <td>Move</td>
</tr><tr>
 <td class="op"><a href="opcodes/opPRMT.htm">PRMT</a></td>
 <td>Permute Register Pair</td>
</tr><tr>
 <td class="op"><a href="opcodes/opSEL.htm">SEL</a></td>
 <td>Select Source with Predicate</td>
</tr><tr>
 <td class="op"><a href="opcodes/opSHFL.htm">SHFL</a></td>
 <td>Warp Wide Register Shuffle</td>
<!-- section "Predicate/CC Instructions" -->
</tr><tr><th colspan="3" class="header"><a name="Predicate_CC">Index of Predicate/CC Instructions</a></th></tr>
<tr><th>Opcode</th><th>Description</th></tr>
<!-- section "Predicate/CC Instructions", subsection 4 -->
<tr>
 <td class="op"><a href="opcodes/opCSET.htm">CSET</a></td>
 <td>Test Condition Code And Set</td>
</tr><tr>
 <td class="op"><a href="opcodes/opCSETP.htm">CSETP</a></td>
 <td>Test Condition Code and Set Predicate</td>
</tr><tr>
 <td class="op"><a href="opcodes/opPSET.htm">PSET</a></td>
 <td>Combine Predicates and Set</td>
</tr><tr>
 <td class="op"><a href="opcodes/opPSETP.htm">PSETP</a></td>
 <td>Combine Predicates and Set Predicate</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Predicate/CC Instructions", subsection 4.1 -->
<tr>
 <td class="op"><a href="opcodes/opP2R.htm">P2R</a></td>
 <td>Move Predicate Register To Register</td>
</tr><tr>
 <td class="op"><a href="opcodes/opR2P.htm">R2P</a></td>
 <td>Move Register To Predicate/CC Register</td>
<!-- section "Texture Instructions" -->
</tr><tr><th colspan="3" class="header"><a name="Texture">Index of Texture Instructions</a></th></tr>
<tr><th>Opcode</th><th>Description</th></tr>
<!-- section "Texture Instructions", subsection 4 -->
<tr>
 <td class="op"><a href="opcodes/opTEX.htm">TEX</a></td>
 <td>Texture Fetch</td>
</tr><tr>
 <td class="op"><a href="opcodes/opTLD.htm">TLD</a></td>
 <td>Texture Load</td>
</tr><tr>
 <td class="op"><a href="opcodes/opTLD4.htm">TLD4</a></td>
 <td>Texture Load 4</td>
</tr><tr>
 <td class="op"><a href="opcodes/opTMML.htm">TMML</a></td>
 <td>Texture MipMap Level</td>
</tr><tr>
 <td class="op"><a href="opcodes/opTXA.htm">TXA</a></td>
 <td>Texture Virtual AA</td>
</tr><tr>
 <td class="op"><a href="opcodes/opTXD.htm">TXD</a></td>
 <td>Texture Fetch With Derivatives </td>
</tr><tr>
 <td class="op"><a href="opcodes/opTXQ.htm">TXQ</a></td>
 <td>Texture Query</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Texture Instructions", subsection 4.5 -->
<tr>
 <td class="op"><a href="opcodes/opTEXS.htm">TEXS</a></td>
 <td>Texture Fetch with scalar/non-vec4 source/destinations</td>
</tr><tr>
 <td class="op"><a href="opcodes/opTLD4S.htm">TLD4S</a></td>
 <td>Texture Load 4 with scalar/non-vec4 source/destinations</td>
</tr><tr>
 <td class="op"><a href="opcodes/opTLDS.htm">TLDS</a></td>
 <td>Texture Load with scalar/non-vec4 source/destinations</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Texture Instructions", subsection 5 -->
<tr>
 <td class="op"><a href="opcodes/opSTP.htm">STP</a></td>
 <td>Set Texture Phase</td>
<!-- section "Graphics Load/Store Instructions" -->
</tr><tr><th colspan="3" class="header"><a name="GraphicsLoad_Store">Index of Graphics Load/Store Instructions</a></th></tr>
<tr><th>Opcode</th><th>Description</th></tr>
<!-- section "Graphics Load/Store Instructions", subsection 5 -->
<tr>
 <td class="op"><a href="opcodes/opAL2P.htm">AL2P</a></td>
 <td>Attribute Logical to physical (translate)</td>
</tr><tr>
 <td class="op"><a href="opcodes/opALD.htm">ALD</a></td>
 <td>Attribute Load</td>
</tr><tr>
 <td class="op"><a href="opcodes/opAST.htm">AST</a></td>
 <td>Attribute Store</td>
</tr><tr>
 <td class="op"><a href="opcodes/opISBERD.htm">ISBERD</a></td>
 <td>Read from ISBE structures used by VTG shaders</td>
</tr><tr>
 <td class="op"><a href="opcodes/opOUT.htm">OUT</a></td>
 <td>Output Token</td>
</tr><tr>
 <td class="op"><a href="opcodes/opPIXLD.htm">PIXLD</a></td>
 <td>Pixel Load</td>
<!-- section "Compute Load/Store Instructions" -->
</tr><tr><th colspan="3" class="header"><a name="ComputeLoad_Store">Index of Compute Load/Store Instructions</a></th></tr>
<tr><th>Opcode</th><th>Description</th></tr>
<!-- section "Compute Load/Store Instructions", subsection 5 -->
<tr>
 <td class="op"><a href="opcodes/opLD.htm">LD</a></td>
 <td>Load from generic Memory</td>
</tr><tr>
 <td class="op"><a href="opcodes/opLDC.htm">LDC</a></td>
 <td>Load Constant</td>
</tr><tr>
 <td class="op"><a href="opcodes/opLDG.htm">LDG</a></td>
 <td>Load from Global Memory</td>
</tr><tr>
 <td class="op"><a href="opcodes/opLDW.htm">LDL</a></td>
 <td>Load within Local Memory Window</td>
</tr><tr>
 <td class="op"><a href="opcodes/opLDW.htm">LDS</a></td>
 <td>Local within Shared Memory Window</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Compute Load/Store Instructions", subsection 6 -->
<tr>
 <td class="op"><a href="opcodes/opST.htm">ST</a></td>
 <td>Store to generic Memory</td>
</tr><tr>
 <td class="op"><a href="opcodes/opSTG.htm">STG</a></td>
 <td>Store to global Memory</td>
</tr><tr>
 <td class="op"><a href="opcodes/opSTW.htm">STL</a></td>
 <td>Store within Local or Shared Window</td>
</tr><tr>
 <td class="op"><a href="opcodes/opSTW.htm">STS</a></td>
 <td>Store within Local or Shared Window</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Compute Load/Store Instructions", subsection 7 -->
<tr>
 <td class="op"><a href="opcodes/opATOM.htm">ATOM</a></td>
 <td>Atomic Operation on generic Memory</td>
</tr><tr>
 <td class="op"><a href="opcodes/opATOMS.htm">ATOMS</a></td>
 <td>Atomic Operation on Shared Memory</td>
</tr><tr>
 <td class="op"><a href="opcodes/opRED.htm">RED</a></td>
 <td>Reduction Operation on generic Memory </td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Compute Load/Store Instructions", subsection 8 -->
<tr>
 <td class="op"><a href="opcodes/opCCTL.htm">CCTL</a></td>
 <td>Cache Control</td>
</tr><tr>
 <td class="op"><a href="opcodes/opCCTL.htm">CCTLL</a></td>
 <td>Cache Control</td>
</tr><tr>
 <td class="op"><a href="opcodes/opMEMBAR.htm">MEMBAR</a></td>
 <td>Memory Barrier</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Compute Load/Store Instructions", subsection 9.1 -->
<tr>
 <td class="op"><a href="opcodes/opCCTLT.htm">CCTLT</a></td>
 <td>Texture Cache Control</td>
</tr><tr>
 <td class="op"><a href="opcodes/opSUATOM.htm">SUATOM</a></td>
 <td>Surface Reduction</td>
</tr><tr>
 <td class="op"><a href="opcodes/opSULD.htm">SULD</a></td>
 <td>Surface Load </td>
</tr><tr>
 <td class="op"><a href="opcodes/opSURED.htm">SURED</a></td>
 <td>Atomic Reduction on surface memory</td>
</tr><tr>
 <td class="op"><a href="opcodes/opSUST.htm">SUST</a></td>
 <td>Surface Store </td>
<!-- section "Control Instructions" -->
</tr><tr><th colspan="3" class="header"><a name="Control">Index of Control Instructions</a></th></tr>
<tr><th>Opcode</th><th>Description</th></tr>
<!-- section "Control Instructions", subsection 9.1 -->
<tr>
 <td class="op"><a href="opcodes/opBRA.htm">BRA</a></td>
 <td>Relative Branch</td>
</tr><tr>
 <td class="op"><a href="opcodes/opBRA.htm">BRX</a></td>
 <td>Relative Branch Indirect</td>
</tr><tr>
 <td class="op"><a href="opcodes/opBRA.htm">JMP</a></td>
 <td>Absolute Jump</td>
</tr><tr>
 <td class="op"><a href="opcodes/opBRA.htm">JMX</a></td>
 <td>Absolute Jump Indirect</td>
</tr><tr>
 <td class="op"><a href="opcodes/opSSY.htm">SSY</a></td>
 <td>Set Synchronization Point</td>
</tr><tr>
 <td class="op"><a href="opcodes/opSYNC.htm">SYNC</a></td>
 <td>Converge threads after conditional branch</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Control Instructions", subsection 10 -->
<tr>
 <td class="op"><a href="opcodes/opCAL.htm">CAL</a></td>
 <td>Relative Call</td>
</tr><tr>
 <td class="op"><a href="opcodes/opCAL.htm">JCAL</a></td>
 <td>Absolute Call</td>
</tr><tr>
 <td class="op"><a href="opcodes/opRET.htm">PRET</a></td>
 <td>Pre-Return From Subroutine</td>
</tr><tr>
 <td class="op"><a href="opcodes/opRET.htm">RET</a></td>
 <td>Return From Subroutine</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Control Instructions", subsection 11.1 -->
<tr>
 <td class="op"><a href="opcodes/opBRK.htm">BRK</a></td>
 <td>Break</td>
</tr><tr>
 <td class="op"><a href="opcodes/opBRK.htm">PBK</a></td>
 <td>Pre-Break</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Control Instructions", subsection 11.2 -->
<tr>
 <td class="op"><a href="opcodes/opCONT.htm">CONT</a></td>
 <td>Continue</td>
</tr><tr>
 <td class="op"><a href="opcodes/opCONT.htm">PCNT</a></td>
 <td>Pre-continue</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Control Instructions", subsection 11.4 -->
<tr>
 <td class="op"><a href="opcodes/opEXIT.htm">EXIT</a></td>
 <td>Exit Program</td>
</tr><tr>
 <td class="op"><a href="opcodes/opEXIT.htm">PEXIT</a></td>
 <td>Pre-Exit</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Control Instructions", subsection 11.5 -->
<tr>
 <td class="op"><a href="opcodes/opLONGJMP.htm">LONGJMP</a></td>
 <td>Long-Jump</td>
</tr><tr>
 <td class="op"><a href="opcodes/opLONGJMP.htm">PLONGJMP</a></td>
 <td>Pre-Long-Jump</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Control Instructions", subsection 12 -->
<tr>
 <td class="op"><a href="opcodes/opKIL.htm">KIL</a></td>
 <td>Kill Thread</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Control Instructions", subsection 13 -->
<tr>
 <td class="op"><a href="opcodes/opBPT.htm">BPT</a></td>
 <td>BreakPoint/Trap</td>
</tr><tr>
 <td class="op"><a href="opcodes/opIDE.htm">IDE</a></td>
 <td>Interrupt disable/enable </td>
</tr><tr>
 <td class="op"><a href="opcodes/opRAM.htm">RAM</a></td>
 <td>Restore Active Mask</td>
</tr><tr>
 <td class="op"><a href="opcodes/opRTT.htm">RTT</a></td>
 <td>Return From Trap</td>
</tr><tr>
 <td class="op"><a href="opcodes/opSAM.htm">SAM</a></td>
 <td>Set Active Mask</td>
<!-- section "Miscellaneous Instructions" -->
</tr><tr><th colspan="3" class="header"><a name="Miscellaneous">Index of Miscellaneous Instructions</a></th></tr>
<tr><th>Opcode</th><th>Description</th></tr>
<!-- section "Miscellaneous Instructions", subsection 11 -->
<tr>
 <td class="op"><a href="opcodes/opNOP.htm">NOP</a></td>
 <td>No Operation</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Miscellaneous Instructions", subsection 12 -->
<tr>
 <td class="op"><a href="opcodes/opS2R.htm">CS2R</a></td>
 <td>Move Special Register to Register</td>
</tr><tr>
 <td class="op"><a href="opcodes/opS2R.htm">S2R</a></td>
 <td>Move Special Register to Register</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Miscellaneous Instructions", subsection 13 -->
<tr>
 <td class="op"><a href="opcodes/opLEPC.htm">LEPC</a></td>
 <td>Load Effective Program Counter</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Miscellaneous Instructions", subsection 13.1 -->
<tr>
 <td class="op"><a href="opcodes/opB2R.htm">B2R</a></td>
 <td>Move Barrier To Register</td>
</tr><tr>
 <td class="op"><a href="opcodes/opBAR.htm">BAR</a></td>
 <td>Barrier Synchronization</td>
</tr><tr>
 <td class="op"><a href="opcodes/opR2B.htm">R2B</a></td>
 <td>Move Register to Barrier </td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Miscellaneous Instructions", subsection 14 -->
<tr>
 <td class="op"><a href="opcodes/opVOTE.htm">VOTE</a></td>
 <td>Vote Across SIMD Thread Group</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Miscellaneous Instructions", subsection 14.9 -->
<tr>
 <td class="op"><a href="opcodes/opDEPBAR.htm">DEPBAR</a></td>
 <td>Dependency  Barrier</td>
</tr><tr><td colspan="3"></td></tr>
<!-- section "Miscellaneous Instructions", subsection 15 -->
<tr>
 <td class="op"><a href="opcodes/opGETCRSPTR.htm">GETCRSPTR</a></td>
 <td>Get Call Return Stack Pointer</td>
</tr><tr>
 <td class="op"><a href="opcodes/opGETLMEMBASE.htm">GETLMEMBASE</a></td>
 <td>Get Local Memory Base Pointer</td>
</tr><tr>
 <td class="op"><a href="opcodes/opSETCRSPTR.htm">SETCRSPTR</a></td>
 <td>Set Call Return Stack Pointer</td>
</tr><tr>
 <td class="op"><a href="opcodes/opSETLMEMBASE.htm">SETLMEMBASE</a></td>
 <td>Set Local Memory Base Pointer</td>
</tr></tbody></table>

<br>

<h1>NVN Constant Buffer Accesses</h1>

The following section will describe how to interpret constant buffer accesses,
such as uniform references, in the SASS dump.<br><br>

Assembly instructions may fetch
values from a bound constant buffer in arithmetic or general load instructions.
For example, the instruction:

<pre>
            MOV             R4, c[0xa][0x0];                              # [000128]
</pre>

moves data from a contant buffer into register R4.  References to constant
buffer memory in disassembled instructions are of the form "c[A][B]", where "c"
indicates a reference to a constant buffer in GPU hardware.  The first index
("[0xa]" in the above example) indicates which constant bank (buffer binding) the
instruction is reading from. The second index ("[0x0]" in the above example) is
the byte offset into the bank.  There are a total of 18 constant banks
available per shader stage.  4 banks are reserved by the compiler and NVN
implementation for various purposes: internal data, such as driver-managed
constants, shader constants, non-uniform buffer uniform data, or other non-user
data.  14 banks are reserved for backing user-defined uniform buffers in the
shaders, and these banks start with constant bank "c[0x3]".
<br><br>

The following table illustrates the constant bank layout:
<br><br>

<table>
<tbody>
<tr><th>HW Constant bank</th><th>Purpose</th></tr>
<tr><td>c[0x0]                </td> <td>Reserved for driver-managed constants                             </td></tr> 
<tr><td>c[0x1]                </td> <td>Immediate constants in shader code, extracted by the compiler     </td></tr>
<tr><td>c[0x2]                </td> <td>Bound resource uniforms (images and samplers) for the shader stage</td></tr>
<tr><td>c[0x3] through c[0x10]</td> <td>User uniform buffer bindings 0 through 13 for the shader stage    </td></tr>
<tr><td>c[0x11]               </td> <td>Reserved by the driver                                            </td></tr>
</tbody>
</table>
<br><br>

Note that the layout described in this section details binaries of GLSLC GPU code
major version 1.  If a new GPU code major version format is introduced, these
layouts might change, but that would indicate a backwards incompatible break.

<h2>Reserved Driver-Managed Constants</h2>

The NVN driver binds an internal constant buffer to hardware constant bank #0,
which holds driver-managed constant data.  The constant buffer holds API state
that needs to be fetched by compiler-generated shader code implementing various
NVN API features.  Among the data stored in this constant buffer are 16-byte descriptors
for shader storage blocks, which are programmed via
nvn::CommandBuffer::BindStorageBuffer.
<br><br>

For graphics shaders, this internal constant buffer is shared by all shader
stages.  The shader storage block bindings for each shader stage can be found
in the following locations:
<br><br>

<table>
<tbody>
<tr><th>SSBO bindings</th><th>c[0x0] entries</th></tr>
<tr><td>Vertex       SSBO bindings 0 through 15</td><td>c[0x0][0x110 through 0x20F]</td></tr>
<tr><td>Tess Control SSBO bindings 0 through 15</td><td>c[0x0][0x210 through 0x30F]</td></tr>
<tr><td>Tess Eval    SSBO bindings 0 through 15</td><td>c[0x0][0x310 through 0x40F]</td></tr>
<tr><td>Geometry     SSBO bindings 0 through 15</td><td>c[0x0][0x410 through 0x50F]</td></tr>
<tr><td>Fragment     SSBO bindings 0 through 15</td><td>c[0x0][0x510 through 0x60F]</td></tr>
</tbody>
</table>
<br><br>

A separate internal constant buffer is used for compute shaders.  In addition
to storing shader storage block bindings, this constant buffer also holds
16-byte descriptors for compute shader uniform buffer bindings. Tegra X1 compute
shader hardware only supports 8 total constant buffer bindings.  Uniform
buffer bindings #0 through #4 map directly to "c[0x3]" through "c[0x7]", while
buffer bindings #5 through #13 are fetched from the internal constant buffer
"c[0x0]" and emulated using global loads.  If an array of uniform buffer
bindings crosses the boundary between bindings #4 and #5 and an access to that
array uses a non-constant buffer index, that access will use the internal
constant buffer, regardless of the actual index.
<br><br>

<table>
<tbody>
<tr><th>Compute API bindings</th><th>Constant buffer locations</th></tr>
<tr><td>Uniform buffer bindings 0 through 4 (if non-emulated)               </td><td>c[0x3] through c[0x7]                      </td></tr>
<tr><td>Uniform buffer bindings 0 through 13 (if emulated with global loads)</td><td>c[0x0][0x210 through 0x2F0]; 16 bytes each </td></tr>
<tr><td>SSBO bindings 0 through 15                                          </td><td>c[0x0][0x310 through 0x40F]; 16 bytes each </td></tr>
</tbody>
</table>

<h2>Bound Resource Uniforms</h2>

GLSL shaders used by NVN can include sampler or image uniforms associated with API
binding points which are not stored in user-defined uniform blocks.  For example:

<pre>
            layout(binding=4) uniform sampler2D smp;
</pre>

declares a variable _smp_ that is associated with API binding point #4 for the
shader stage.  Unlike OpenGL, NVN has separate API binding points for each
shader stage.  The handles used by these binding points are stored in a
per-stage internal constant buffer bound to hardware constant bank #2
("c[0x2]") at a pre-defined fixed offset based on the assigned binding for each
uniform in the shader.  Samplers, separate textures/samplers, and images are represented
as 8 byte entries per binding.
<br><br>

The layout of bank c[0x2] is defined as follows:

<table>
<tbody>
<tr><th>Byte range in c[0x2]</th><th>Usage</th></tr>
<tr><td>c[0x2][<0x0   through 0x1F >]          </td><td> Reserved for internal use                                        </td></tr>
<tr><td>c[0x2][<0x20  through 0x11F>]          </td><td> API combined texture/sampler bindings 0 through 31; 8 bytes each </td></tr>
<tr><td>c[0x2][<0x120 through 0x15F>]          </td><td> API Image bindings 0 through 7; 8 bytes each                     </td></tr>
<tr><td>c[0x2][<0x160 through 0x167>]          </td><td> Reserved for internal use                                        </td></tr>
<tr><td>c[0x2][<0x168 through 0x567>]          </td><td> API texture-only bindings 0 through 127; 8 bytes each            </td></tr>
<tr><td>c[0x2][<0x568 through 0x667>]          </td><td> API sampler-only bindings 0 through 31; 8 bytes each             </td></tr>
<br><br>
</tbody>
</table>
<br><br>

Note that texture and image instructions using bound resource uniforms might show up in the
assembly as instructions referencing 4-byte immediate integer offsets
instead of making explicit references to "c[0x2]"; the hardware is already
programmed to reference constant bank #2 for pulling descriptors for these
types of instructions, and the compiler might choose to optimize out
intermediate loads from this constant bank.  For example, in the instruction

<pre>
	     TEXS.NODEP.P    R2, R0, R4, R4, 0xe, 2D, RGBA;                # [000010]
</pre>

the "0xe" (14) indicates that the hardware will fetch the texture or image
descriptor at an offset of 14*4 = 56 bytes from the beginning of the bound
resource uniform constant buffer.  That would refer to combined texture/sampler
binding #3.
<br><br>

Also note that while samplers and images are represented as 8-byte values, generated
shader code may fetch bindings using 4-byte loads.

<h2>Uniform Buffer Bindings</h2>

Each uniform buffer binding in a shader stage corresponds to a single constant
bank.  For example, "c[0xa][0x0]" maps to the first byte of the uniform buffer
binding #7 in the shader.  If the user had defined a uniform bank in a GLSL
shader with "layout(binding = 3)", then SASS instructions referencing that
uniform buffer would contain "c[0x6]".
<br><br>

In order to determine byte offsets of members of a uniform block, developers
will need to know the layout of the uniform block's data or use GLSLC reflection
information to query offsets.  Uniform buffers that use std140 or std430 layouts have an
explicit pre-defined format for the uniform block data.  Shaders that do not use
one of these fixed layouts for a uniform buffer have the compiler assign an implementation-dependent layout.
In the case std140 or std430 are not used, developers mapping uniform buffer
uniforms in the shader to the byte offsets within the constant bank will need
to use GLSLC's reflection section to get the
byte offsets for the desired uniforms.  Byte offsets in the reflection section
for uniform buffer uniforms map directly to the byte offsets into the corresponding
constant bank.
<br><br>

<h1> Vertex Attributes and Varyings</h1>

When passing inputs and outputs between graphics shader stages, instructions
refer to an attribute by a canonical "address" of the form "a[addr]", where
_addr_ is a byte offset into a logical structure containing all possible
attributes.  For example:

<pre>
            IPA             R5, a[0x80], R4;                              # [0001b8] ATTR0
            IPA             R6, a[0x84], R4;                              # [0001c8] GENERIC_ATTRIBUTE_00_Y
            IPA             R7, a[0x88], R4;                              # [0001d0] GENERIC_ATTRIBUTE_00_Z
            IPA             R8, a[0x8c], R4;                              # [0001d8] GENERIC_ATTRIBUTE_00_W
</pre>

interpolates (IPA) the four components of generic vector attribute 0, which
has byte offsets in the range [0x80, 0x8F].  In GLSL shaders, a layout
qualifier like:

<pre>
            layout(location=4) in vec4 value;
</pre>

will associate _value_ with generic vector attribute 4, which has an associated
offset of 0xC0.
<br><br>

The interface supports 32 generic vectors with offsets in the range [0x80,
0x27F].  The interface also supports various fixed-function attributes.  For
instructions using attributes, as in the example above, comments in the
disassembled instructions identify the attributes accessed.
<br><br>

Note that these "byte offsets" are not actually used as offsets in memory; they
are rather treated as canonical attribute numbers.  Tegra X1 hardware optimizes
attribute passing so that unused or "dead" attributes are not passed between
stages and do not consume storage or memory bandwidth.
<br><br>


<h2>Quick Links</h2>

<br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br>

</body></html>
